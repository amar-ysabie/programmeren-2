<!DOCTYPE html>

<html lang="ko" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="logging.config — Logging configuration" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/logging.config.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="소스 코드: Lib/logging/config.py Important: 이 페이지에는 레퍼런스 정보만 있습니다. 자습서는 다음을 참조하십시오 기초 자습서, 고급 자습서, 로깅 요리책. 이 절에서는 logging 모듈을 구성하기 위한 API에 관해 설명합니다. 구성 함수: 다음 함수는 logging 모듈을 구성합니다. logging.config 모듈에 ..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="소스 코드: Lib/logging/config.py Important: 이 페이지에는 레퍼런스 정보만 있습니다. 자습서는 다음을 참조하십시오 기초 자습서, 고급 자습서, 로깅 요리책. 이 절에서는 logging 모듈을 구성하기 위한 API에 관해 설명합니다. 구성 함수: 다음 함수는 logging 모듈을 구성합니다. logging.config 모듈에 ..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>logging.config — Logging configuration &#8212; Python 3.12.4 문서</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css%3Fv=80d5e7a1.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css%3Fv=bb723527.css" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css%3Fv=b20cc3f5.css" />
    
    <script src="../_static/documentation_options.js%3Fv=3050f571"></script>
    <script src="../_static/doctools.js%3Fv=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js%3Fv=dc90522c"></script>
    <script src="../_static/translations.js%3Fv=b5f768d8"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.12.4 문서에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="logging.handlers — Logging handlers" href="logging.handlers.html" />
    <link rel="prev" title="logging — Logging facility for Python" href="logging.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="../../../3/library/logging.config.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" />
                <input type="submit" value="이동"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="logging.config.html#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code> — Logging configuration</a><ul>
<li><a class="reference internal" href="logging.config.html#configuration-functions">구성 함수</a></li>
<li><a class="reference internal" href="logging.config.html#security-considerations">Security considerations</a></li>
<li><a class="reference internal" href="logging.config.html#configuration-dictionary-schema">구성 딕셔너리 스키마</a><ul>
<li><a class="reference internal" href="logging.config.html#dictionary-schema-details">딕셔너리 스키마 세부사항</a></li>
<li><a class="reference internal" href="logging.config.html#incremental-configuration">증분 구성</a></li>
<li><a class="reference internal" href="logging.config.html#object-connections">객체 연결</a></li>
<li><a class="reference internal" href="logging.config.html#user-defined-objects">사용자 정의 객체</a></li>
<li><a class="reference internal" href="logging.config.html#handler-configuration-order">Handler configuration order</a></li>
<li><a class="reference internal" href="logging.config.html#access-to-external-objects">외부 객체에 대한 액세스</a></li>
<li><a class="reference internal" href="logging.config.html#access-to-internal-objects">내부 객체에 대한 액세스</a></li>
<li><a class="reference internal" href="logging.config.html#import-resolution-and-custom-importers">임포트 결정과 사용자 정의 임포터</a></li>
<li><a class="reference internal" href="logging.config.html#configuring-queuehandler-and-queuelistener">Configuring QueueHandler and QueueListener</a></li>
</ul>
</li>
<li><a class="reference internal" href="logging.config.html#configuration-file-format">구성 파일 형식</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="logging.html"
                          title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code> — Logging facility for Python</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="logging.handlers.html"
                          title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code> — Logging handlers</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/logging.config.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="logging.handlers.html" title="logging.handlers — Logging handlers"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="logging.html" title="logging — Logging facility for Python"
             accesskey="P">이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">일반 운영 체제 서비스</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="logging.config.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code> — Logging configuration</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-logging.config">
<span id="logging-config-logging-configuration"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code> — Logging configuration<a class="headerlink" href="logging.config.html#module-logging.config" title="Link to this heading">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/logging/config.py">Lib/logging/config.py</a></p>
<aside class="sidebar">
<p class="sidebar-title">Important</p>
<p>이 페이지에는 레퍼런스 정보만 있습니다. 자습서는 다음을 참조하십시오</p>
<ul class="simple">
<li><p><a class="reference internal" href="../howto/logging.html#logging-basic-tutorial"><span class="std std-ref">기초 자습서</span></a></p></li>
<li><p><a class="reference internal" href="../howto/logging.html#logging-advanced-tutorial"><span class="std std-ref">고급 자습서</span></a></p></li>
<li><p><a class="reference internal" href="../howto/logging-cookbook.html#logging-cookbook"><span class="std std-ref">로깅 요리책</span></a></p></li>
</ul>
</aside>
<hr class="docutils" />
<p>이 절에서는 logging 모듈을 구성하기 위한 API에 관해 설명합니다.</p>
<section id="configuration-functions">
<span id="logging-config-api"></span><h2>구성 함수<a class="headerlink" href="logging.config.html#configuration-functions" title="Link to this heading">¶</a></h2>
<p>다음 함수는 logging 모듈을 구성합니다. <a class="reference internal" href="logging.config.html#module-logging.config" title="logging.config: Configuration of the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code></a> 모듈에 있습니다. 사용은 선택 사항입니다 — 이 함수들을 사용하거나 (<a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 자체에서 정의된) 주 API를 호출하고 <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a>이나 <a class="reference internal" href="logging.handlers.html#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a>에서 선언된 처리기를 정의해서 logging 모듈을 구성할 수 있습니다.</p>
<dl class="py function">
<dt class="sig sig-object py" id="logging.config.dictConfig">
<span class="sig-prename descclassname"><span class="pre">logging.config.</span></span><span class="sig-name descname"><span class="pre">dictConfig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="logging.config.html#logging.config.dictConfig" title="Link to this definition">¶</a></dt>
<dd><p>딕셔너리로 로깅 구성을 받습니다. 이 딕셔너리의 내용은 아래의 <a class="reference internal" href="logging.config.html#logging-config-dictschema"><span class="std std-ref">구성 딕셔너리 스키마</span></a>에 설명되어 있습니다.</p>
<p>구성 중에 에러를 만나면, 이 함수는 적절하게 설명하는 메시지와 함께 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>, <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 또는 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다. 다음은 에러를 발생시킬 수 있는 (불완전한) 조건 목록입니다:</p>
<ul class="simple">
<li><p>문자열이 아니거나 실제 로깅 수준과 일치하지 않는 문자열인 <code class="docutils literal notranslate"><span class="pre">level</span></code>.</p></li>
<li><p>불리언이 아닌 <code class="docutils literal notranslate"><span class="pre">propagate</span></code> 값.</p></li>
<li><p>해당 대상이 없는 id.</p></li>
<li><p>증분(incremental) 호출 중에 발견된 존재하지 않는 처리기 id.</p></li>
<li><p>잘못된 로거 이름.</p></li>
<li><p>결정할 수 없는 내부나 외부 객체.</p></li>
</ul>
<p>구문 분석은 <code class="xref py py-class docutils literal notranslate"><span class="pre">DictConfigurator</span></code> 클래스에 의해 수행되며, 생성자로는 구성에 사용되는 딕셔너리가 전달되고, 객체는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">configure()</span></code> 메서드를 가집니다. <a class="reference internal" href="logging.config.html#module-logging.config" title="logging.config: Configuration of the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code></a> 모듈에는 초기에 <code class="xref py py-class docutils literal notranslate"><span class="pre">DictConfigurator</span></code>로 설정된 콜러블 어트리뷰트 <code class="xref py py-attr docutils literal notranslate"><span class="pre">dictConfigClass</span></code>가 있습니다. 여러분 자신의 적절한 구현으로 <code class="xref py py-attr docutils literal notranslate"><span class="pre">dictConfigClass</span></code>의 값을 바꿀 수 있습니다.</p>
<p><a class="reference internal" href="logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictConfig()</span></code></a>는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">dictConfigClass</span></code>를 호출해서 지정된 딕셔너리를 전달한 다음, 반환된 객체의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">configure()</span></code> 메서드를 호출하여 구성을 적용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dictConfig</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
    <span class="n">dictConfigClass</span><span class="p">(</span><span class="n">config</span><span class="p">)</span><span class="o">.</span><span class="n">configure</span><span class="p">()</span>
</pre></div>
</div>
<p>예를 들어, <code class="xref py py-class docutils literal notranslate"><span class="pre">DictConfigurator</span></code>의 서브 클래스는 자체 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>에서 <code class="docutils literal notranslate"><span class="pre">DictConfigurator.__init__()</span></code>를 호출한 다음, 후속 <code class="xref py py-meth docutils literal notranslate"><span class="pre">configure()</span></code> 호출에서 사용할 수 있는 사용자 정의 접두사를 설정할 수 있습니다. <code class="xref py py-attr docutils literal notranslate"><span class="pre">dictConfigClass</span></code>는 이 새 서브 클래스에 연결되고, <a class="reference internal" href="logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictConfig()</span></code></a>는 기본, 사용자 정의되지 않은 상태에서와 똑같이 호출될 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.config.fileConfig">
<span class="sig-prename descclassname"><span class="pre">logging.config.</span></span><span class="sig-name descname"><span class="pre">fileConfig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">defaults</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disable_existing_loggers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="logging.config.html#logging.config.fileConfig" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="configparser.html#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a>-형식 파일에서 로깅 구성을 읽습니다. 파일 형식은 <a class="reference internal" href="logging.config.html#logging-config-fileformat"><span class="std std-ref">구성 파일 형식</span></a>에 설명된 것과 같아야 합니다. 이 함수는 응용 프로그램에서 여러 번 호출 할 수 있어서, 최종 사용자가 여러 가지 미리 준비된 구성 중에서 선택할 수 있도록 합니다 (개발자가 선택 사항을 표시하고 선택한 구성을 로드하는 메커니즘을 제공한다면).</p>
<p>It will raise <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a> if the file
doesn’t exist and <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> if the file is invalid or
empty.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> – A filename, or a file-like object, or an instance derived
from <a class="reference internal" href="configparser.html#configparser.RawConfigParser" title="configparser.RawConfigParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">RawConfigParser</span></code></a>. If a
<code class="xref py py-class docutils literal notranslate"><span class="pre">RawConfigParser</span></code>-derived instance is passed, it is used as
is. Otherwise, a <a class="reference internal" href="configparser.html#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConfigParser</span></code></a> is
instantiated, and the configuration read by it from the
object passed in <code class="docutils literal notranslate"><span class="pre">fname</span></code>. If that has a <a class="reference internal" href="readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a>
method, it is assumed to be a file-like object and read using
<a class="reference internal" href="configparser.html#configparser.ConfigParser.read_file" title="configparser.ConfigParser.read_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_file()</span></code></a>; otherwise,
it is assumed to be a filename and passed to
<a class="reference internal" href="configparser.html#configparser.ConfigParser.read" title="configparser.ConfigParser.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>.</p></li>
<li><p><strong>defaults</strong> – Defaults to be passed to the <code class="xref py py-class docutils literal notranslate"><span class="pre">ConfigParser</span></code> can be specified
in this argument.</p></li>
<li><p><strong>disable_existing_loggers</strong> – <code class="docutils literal notranslate"><span class="pre">False</span></code>로 지정되면, 이 호출이 이루어졌을 때 존재하는 로거는 활성화된 상태로 남습니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">True</span></code>이므로, 과거 호환성을 유지하도록 이전 동작을 활성화합니다. 이 동작은 이미 존재하는 비 루트 로거를 그들이나 그들의 조상이 로깅 구성에서 명시적으로 명명되지 않으면 비활성화하는 것입니다.</p></li>
<li><p><strong>encoding</strong> – The encoding used to open file when <em>fname</em> is filename.</p></li>
</ul>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>An instance of a subclass of <a class="reference internal" href="configparser.html#configparser.RawConfigParser" title="configparser.RawConfigParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">RawConfigParser</span></code></a> is
  now accepted as a value for <code class="docutils literal notranslate"><span class="pre">fname</span></code>. This facilitates:</p>
<blockquote>
<div><ul class="simple">
<li><p>로깅 구성이 전체 응용 프로그램 구성의 일부인 구성 파일의 사용.</p></li>
<li><p>파일에서 읽어 들인 다음 <code class="docutils literal notranslate"><span class="pre">fileConfig</span></code>로 전달되기 전에 사용하는 응용 프로그램이 (예를 들어, 명령 줄 매개 변수나 실행 시간 환경의 다른 측면에 기반하여) 수정하는 구성의 사용.</p></li>
</ul>
</div></blockquote>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.10에서 변경: </span>Added the <em>encoding</em> parameter.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span>An exception will be thrown if the provided file
doesn’t exist or is invalid or empty.</p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.config.listen">
<span class="sig-prename descclassname"><span class="pre">logging.config.</span></span><span class="sig-name descname"><span class="pre">listen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">DEFAULT_LOGGING_CONFIG_PORT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verify</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="logging.config.html#logging.config.listen" title="Link to this definition">¶</a></dt>
<dd><p>지정된 포트에서 소켓 서버를 시작하고, 새 구성을 수신 대기합니다. 포트를 지정하지 않으면, 모듈의 기본 <code class="xref py py-const docutils literal notranslate"><span class="pre">DEFAULT_LOGGING_CONFIG_PORT</span></code>가 사용됩니다. 로깅 구성은 <a class="reference internal" href="logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictConfig()</span></code></a>나 <a class="reference internal" href="logging.config.html#logging.config.fileConfig" title="logging.config.fileConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">fileConfig()</span></code></a>로 처리하기에 적합한 파일로 전송됩니다. 서버를 시작하기 위해 <a class="reference internal" href="threading.html#threading.Thread.start" title="threading.Thread.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>를 호출할 수 있는 <a class="reference internal" href="threading.html#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal notranslate"><span class="pre">Thread</span></code></a> 인스턴스를 반환하고, 적절할 때 <a class="reference internal" href="threading.html#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a>할 수 있습니다. 서버를 중지하려면, <a class="reference internal" href="logging.config.html#logging.config.stopListening" title="logging.config.stopListening"><code class="xref py py-func docutils literal notranslate"><span class="pre">stopListening()</span></code></a>을 호출하십시오.</p>
<p><code class="docutils literal notranslate"><span class="pre">verify</span></code> 인자가 지정되면, 소켓을 통해 수신된 바이트열이 유효하고 처리되어야 하는지를 확인하는 콜러블이어야 합니다. 소켓을 통해 전송되는 것을 암호화 및/또는 서명하고, <code class="docutils literal notranslate"><span class="pre">verify</span></code> 콜러블이 서명 확인 및/또는 암호 해독을 수행할 수 있습니다. <code class="docutils literal notranslate"><span class="pre">verify</span></code> 콜러블은 단일 인자(소켓을 통해 수신된 바이트열)로 호출되며, 처리할 바이트열이나 바이트열을 버려야 함을 나타내기 위해 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. 반환된 바이트열은 전달된 바이트열과 같을 수 있고 (예를 들어, 확인만 수행될 때), 또는 완전히 다를 수 있습니다 (아마도 암호 해독이 수행될 때).</p>
<p>소켓으로 구성을 보내려면, 구성 파일을 읽어서 소켓에 <code class="docutils literal notranslate"><span class="pre">struct.pack('&gt;L',</span> <span class="pre">n)</span></code>를 사용하여 바이너리로 만든 4바이트의 길이를 앞에 붙인 바이트 시퀀스를 보냅니다.</p>
<div class="admonition note" id="logging-eval-security">
<p class="admonition-title">참고</p>
<p>Because portions of the configuration are passed through
<a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>, use of this function may open its users to a security risk.
While the function only binds to a socket on <code class="docutils literal notranslate"><span class="pre">localhost</span></code>, and so does
not accept connections from remote machines, there are scenarios where
untrusted code could be run under the account of the process which calls
<a class="reference internal" href="logging.config.html#logging.config.listen" title="logging.config.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code></a>. Specifically, if the process calling <a class="reference internal" href="logging.config.html#logging.config.listen" title="logging.config.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code></a> runs
on a multi-user machine where users cannot trust each other, then a
malicious user could arrange to run essentially arbitrary code in a
victim user’s process, simply by connecting to the victim’s
<a class="reference internal" href="logging.config.html#logging.config.listen" title="logging.config.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code></a> socket and sending a configuration which runs whatever
code the attacker wants to have executed in the victim’s process. This is
especially easy to do if the default port is used, but not hard even if a
different port is used. To avoid the risk of this happening, use the
<code class="docutils literal notranslate"><span class="pre">verify</span></code> argument to <a class="reference internal" href="logging.config.html#logging.config.listen" title="logging.config.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code></a> to prevent unrecognised
configurations from being applied.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">verify</span></code> 인자가 추가되었습니다.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>리스너에 기존 로거를 비활성화하지 않는 구성을 보내려면, <a class="reference internal" href="logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictConfig()</span></code></a>를 사용하도록 구성에 JSON 형식을 사용해야 합니다. 이 방법은 보내는 구성에서 <code class="docutils literal notranslate"><span class="pre">disable_existing_loggers</span></code>를 <code class="docutils literal notranslate"><span class="pre">False</span></code>로 지정할 수 있도록 합니다.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.config.stopListening">
<span class="sig-prename descclassname"><span class="pre">logging.config.</span></span><span class="sig-name descname"><span class="pre">stopListening</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="logging.config.html#logging.config.stopListening" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="logging.config.html#logging.config.listen" title="logging.config.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code></a>에 대한 호출로 만들어진 리스닝 서버를 중지합니다. 이것은 일반적으로 <a class="reference internal" href="logging.config.html#logging.config.listen" title="logging.config.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code></a>의 반환 값에 대해 <code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code>을 호출하기 전에 호출됩니다.</p>
</dd></dl>

</section>
<section id="security-considerations">
<h2>Security considerations<a class="headerlink" href="logging.config.html#security-considerations" title="Link to this heading">¶</a></h2>
<p>The logging configuration functionality tries to offer convenience, and in part this
is done by offering the ability to convert text in configuration files into Python
objects used in logging configuration - for example, as described in
<a class="reference internal" href="logging.config.html#logging-config-dict-userdef"><span class="std std-ref">사용자 정의 객체</span></a>. However, these same mechanisms (importing
callables from user-defined modules and calling them with parameters from the
configuration) could be used to invoke any code you like, and for this reason you
should treat configuration files from untrusted sources with <em>extreme caution</em> and
satisfy yourself that nothing bad can happen if you load them, before actually loading
them.</p>
</section>
<section id="configuration-dictionary-schema">
<span id="logging-config-dictschema"></span><h2>구성 딕셔너리 스키마<a class="headerlink" href="logging.config.html#configuration-dictionary-schema" title="Link to this heading">¶</a></h2>
<p>로깅 구성을 기술하려면 만들려는 다양한 객체와 그들 간의 연결을 나열해야 합니다; 예를 들어, ‘console’이라는 처리기를 만든 다음 ‘startup’이라는 로거가 ‘console’ 처리기에 메시지를 보낼 것이라고 말할 수 있습니다. 사용자 자신의 포매터나 처리기 클래스를 작성할 수 있으므로, 이러한 객체가 <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 모듈에서 제공하는 객체로만 제한되지는 않습니다. 이러한 클래스의 매개 변수는 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>과 같은 외부 객체를 포함할 수도 있습니다. 이러한 객체와 연결을 기술하는 문법은 아래의 <a class="reference internal" href="logging.config.html#logging-config-dict-connections"><span class="std std-ref">객체 연결</span></a>에 정의되어 있습니다.</p>
<section id="dictionary-schema-details">
<h3>딕셔너리 스키마 세부사항<a class="headerlink" href="logging.config.html#dictionary-schema-details" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictConfig()</span></code></a>에 전달되는 딕셔너리에는 반드시 다음 키가 있어야 합니다:</p>
<ul class="simple">
<li><p><em>version</em> - 스키마 버전을 나타내는 정숫값으로 설정됩니다. 현재 유효한 유일한 값은 1이지만, 이 키를 사용하면 과거 호환성을 유지하면서 스키마를 발전시킬 수 있습니다.</p></li>
</ul>
<p>다른 모든 키는 선택 사항이지만, 있으면 아래에 설명된 대로 해석됩니다. 아래에서 ‘구성 딕셔너리(configuring dict)’가 언급되는 모든 경우에, 특수한 <code class="docutils literal notranslate"><span class="pre">'()'</span></code> 키를 검사해서 사용자 정의 인스턴스화가 필요한지를 확인합니다. 있다면, 아래의 <a class="reference internal" href="logging.config.html#logging-config-dict-userdef"><span class="std std-ref">사용자 정의 객체</span></a>에 설명된 메커니즘을 사용하여 인스턴스를 만듭니다; 그렇지 않다면, 어떤 인스턴스를 만들지를 결정하는데 문맥이 사용됩니다.</p>
<ul id="logging-config-dictschema-formatters">
<li><p><em>formatters</em> - 해당 값은 딕셔너리인데, 각 키는 포매터 id이고, 각 값은 해당 <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 인스턴스를 구성하는 방법을 설명하는 딕셔너리입니다.</p>
<p>The configuring dict is searched for the following optional keys
which correspond to the arguments passed to create a
<a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> object:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">format</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">datefmt</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">style</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">validate</span></code> (since version &gt;=3.8)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaults</span></code> (since version &gt;=3.12)</p></li>
</ul>
<p>An optional <code class="docutils literal notranslate"><span class="pre">class</span></code> key indicates the name of the formatter’s
class (as a dotted module and class name).  The instantiation
arguments are as for <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a>, thus this key is
most useful for instantiating a customised subclass of
<a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a>.  For example, the alternative class
might present exception tracebacks in an expanded or condensed
format.  If your formatter requires different or extra configuration
keys, you should use <a class="reference internal" href="logging.config.html#logging-config-dict-userdef"><span class="std std-ref">사용자 정의 객체</span></a>.</p>
</li>
<li><p><em>filters</em> - 해당 값은 딕셔너리인데, 각 키가 필터 id이고 각 값은 해당 Filter 인스턴스를 구성하는 방법을 설명하는 딕셔너리입니다.</p>
<p>구성 딕셔너리는 키 <code class="docutils literal notranslate"><span class="pre">name</span></code>(기본값은 빈 문자열)으로 검색되며, 이는 <a class="reference internal" href="logging.html#logging.Filter" title="logging.Filter"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Filter</span></code></a> 인스턴스를 만드는 데 사용됩니다.</p>
</li>
<li><p><em>handlers</em> - 해당 값은 딕셔너리인데, 각 키가 처리기 id이고 각 값은 해당 Handler 인스턴스를 구성하는 방법을 설명하는 딕셔너리입니다.</p>
<p>구성 딕셔너리는 다음 키에서 검색합니다:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">class</span></code> (필수). 이것은 처리기 클래스의 완전히 정규화된 이름입니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">level</span></code> (선택). 처리기의 수준.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">formatter</span></code> (선택). 이 처리기의 포매터의 id.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">filters</span></code> (선택). 이 처리기의 필터의 id의 리스트.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span><code class="docutils literal notranslate"><span class="pre">filters</span></code> can take filter instances in addition to ids.</p>
</div>
</li>
</ul>
<p>모든 <em>다른</em> 키는, 처리기의 생성자에 키워드 인자로 전달됩니다. 예를 들어, 다음과 같이 주어진 조각에서:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">handlers</span><span class="p">:</span>
<span class="w">  </span><span class="nt">console</span><span class="p">:</span>
<span class="w">    </span><span class="nt">class </span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">logging.StreamHandler</span>
<span class="w">    </span><span class="nt">formatter</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">brief</span>
<span class="w">    </span><span class="nt">level   </span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">INFO</span>
<span class="w">    </span><span class="nt">filters</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">allow_foo</span><span class="p p-Indicator">]</span>
<span class="w">    </span><span class="nt">stream  </span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">ext://sys.stdout</span>
<span class="w">  </span><span class="nt">file</span><span class="p">:</span>
<span class="w">    </span><span class="nt">class </span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">logging.handlers.RotatingFileHandler</span>
<span class="w">    </span><span class="nt">formatter</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">precise</span>
<span class="w">    </span><span class="nt">filename</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">logconfig.log</span>
<span class="w">    </span><span class="nt">maxBytes</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1024</span>
<span class="w">    </span><span class="nt">backupCount</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">3</span>
</pre></div>
</div>
<p>id가 <code class="docutils literal notranslate"><span class="pre">console</span></code> 인 처리기는 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>를 하부 스트림으로 사용하는 <a class="reference internal" href="logging.handlers.html#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.StreamHandler</span></code></a>로 인스턴스가 만들어집니다. id가 <code class="docutils literal notranslate"><span class="pre">file</span></code> 인 처리기는 키워드 인자 <code class="docutils literal notranslate"><span class="pre">filename='logconfig.log',</span> <span class="pre">maxBytes=1024,</span> <span class="pre">backupCount=3</span></code>를 사용하여 <a class="reference internal" href="logging.handlers.html#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.handlers.RotatingFileHandler</span></code></a>로 인스턴스가 만들어집니다.</p>
</li>
<li><p><em>loggers</em> - 해당 값은 딕셔너리인데, 각 키가 로거 이름이고 각 값은 해당 Logger 인스턴스를 구성하는 방법을 설명하는 딕셔너리입니다.</p>
<p>구성 딕셔너리는 다음 키에서 검색합니다:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">level</span></code> (선택). 로거의 수준.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">propagate</span></code> (선택). 로거의 전파(propagation) 설정.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">filters</span></code> (선택). 이 로거의 필터의 id의 리스트</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span><code class="docutils literal notranslate"><span class="pre">filters</span></code> can take filter instances in addition to ids.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">handlers</span></code> (선택). 이 로거의 처리기의 id의 리스트.</p></li>
</ul>
<p>지정된 로거는 지정된 수준, 전파, 필터와 처리기에 따라 구성됩니다.</p>
</li>
<li><p><em>root</em> - 루트 로거에 대한 구성입니다. <code class="docutils literal notranslate"><span class="pre">propagate</span></code> 설정을 적용할 수 없다는 점을 제외하고 구성 처리는 모든 로거와 같습니다.</p></li>
<li><p><em>incremental</em> - 구성을 기존 구성의 증분으로 해석할지 여부. 이 값의 기본값은 <code class="docutils literal notranslate"><span class="pre">False</span></code>이며, 이는 지정된 구성이 기존 구성을 기존 <a class="reference internal" href="logging.config.html#logging.config.fileConfig" title="logging.config.fileConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">fileConfig()</span></code></a> API에서 사용된 것과 같은 의미로 대체 함을 뜻합니다.</p>
<p>지정된 값이 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, <a class="reference internal" href="logging.config.html#logging-config-dict-incremental"><span class="std std-ref">증분 구성</span></a> 절에서 설명하는 대로 구성이 처리됩니다.</p>
</li>
<li><p><em>disable_existing_loggers</em> - 기존의 루트가 아닌 로거를 비활성화할지 여부. 이 설정은 <a class="reference internal" href="logging.config.html#logging.config.fileConfig" title="logging.config.fileConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">fileConfig()</span></code></a>의 같은 이름의 매개 변수를 반영합니다. 없으면, 이 매개 변수의 기본값은 <code class="docutils literal notranslate"><span class="pre">True</span></code>입니다. <em>incremental</em>이 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면 이 값은 무시됩니다.</p></li>
</ul>
</section>
<section id="incremental-configuration">
<span id="logging-config-dict-incremental"></span><h3>증분 구성<a class="headerlink" href="logging.config.html#incremental-configuration" title="Link to this heading">¶</a></h3>
<p>증분 구성에 완벽한 유연성을 제공하기는 어렵습니다. 예를 들어, 필터와 포매터와 같은 객체는 익명이므로, 일단 구성이 설정되면, 이러한 익명 객체를 참조하여 구성을 보강할 수 없습니다.</p>
<p>또한, 일단 구성이 설정되면, 실행 시간에 로거, 처리기, 필터, 포매터의 객체 그래프를 임의로 변경해야 할 강력한 사례는 없습니다; 로거와 처리기의 상세도는 단지 수준(과, loggers에서는 전파 플래그)을 설정하여 제어할 수 있습니다. 객체 그래프를 임의로 안전하게 변경하는 것은 다중 스레드 환경에서 문제가 됩니다; 불가능하지는 않지만, 구현에 추가되는 복잡성을 상쇄할만한 가치가 없습니다.</p>
<p>따라서, 구성 딕셔너리의 <code class="docutils literal notranslate"><span class="pre">incremental</span></code> 키가 있고 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, 시스템은 <code class="docutils literal notranslate"><span class="pre">formatters</span></code>와 <code class="docutils literal notranslate"><span class="pre">filters</span></code> 항목을 완전히 무시하고 <code class="docutils literal notranslate"><span class="pre">handlers</span></code> 항목의 <code class="docutils literal notranslate"><span class="pre">level</span></code> 설정과 <code class="docutils literal notranslate"><span class="pre">loggers</span></code>와 <code class="docutils literal notranslate"><span class="pre">root</span></code> 항목의 <code class="docutils literal notranslate"><span class="pre">level</span></code>과 <code class="docutils literal notranslate"><span class="pre">propagate</span></code> 설정만 처리합니다.</p>
<p>구성 딕셔너리의 값을 사용하면 구성을 피클 된 딕셔너리의 형태로 네트워크를 통해 소켓 리스너로 전송할 수 있습니다. 따라서, 장기 실행 응용 프로그램의 로깅 상세도는 응용 프로그램을 중지하고 다시 시작할 필요 없이 도중에 변경될 수 있습니다.</p>
</section>
<section id="object-connections">
<span id="logging-config-dict-connections"></span><h3>객체 연결<a class="headerlink" href="logging.config.html#object-connections" title="Link to this heading">¶</a></h3>
<p>스키마는 객체 그래프에서 서로 연결된 로깅 객체 집합(로거, 처리기, 포매터, 필터)을 기술합니다. 따라서, 스키마는 객체 간의 연결을 표현할 필요가 있습니다. 예를 들어, 일단 구성되면, 특정 로거가 특정 처리기에 연결된다고 합시다. 이 토론의 목적을 위해, 둘 간의 연결에서 로거는 소스를, 처리기는 대상(destination)을 나타낸다고 할 수 있습니다. 물론 구성된 객체에서 이것은 처리기에 대한 참조를 갖는 로거로 표현됩니다. 구성 딕셔너리에서, 각 대상 객체에 명확하게 식별하는 id를 부여한 다음, 소스 객체의 구성에서 그 id를 사용하여, 소스와 그 id를 갖는 대상 객체 사이에 연결이 있음을 나타냅니다.</p>
<p>그래서, 예를 들어, 다음 YAML 조각을 고려해보십시오:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">formatters</span><span class="p">:</span>
<span class="w">  </span><span class="nt">brief</span><span class="p">:</span>
<span class="w">    </span><span class="c1"># configuration for formatter with id &#39;brief&#39; goes here</span>
<span class="w">  </span><span class="nt">precise</span><span class="p">:</span>
<span class="w">    </span><span class="c1"># configuration for formatter with id &#39;precise&#39; goes here</span>
<span class="nt">handlers</span><span class="p">:</span>
<span class="w">  </span><span class="nt">h1</span><span class="p">:</span><span class="w"> </span><span class="c1">#This is an id</span>
<span class="w">   </span><span class="c1"># configuration of handler with id &#39;h1&#39; goes here</span>
<span class="w">   </span><span class="nt">formatter</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">brief</span>
<span class="w">  </span><span class="nt">h2</span><span class="p">:</span><span class="w"> </span><span class="c1">#This is another id</span>
<span class="w">   </span><span class="c1"># configuration of handler with id &#39;h2&#39; goes here</span>
<span class="w">   </span><span class="nt">formatter</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">precise</span>
<span class="nt">loggers</span><span class="p">:</span>
<span class="w">  </span><span class="nt">foo.bar.baz</span><span class="p">:</span>
<span class="w">    </span><span class="c1"># other configuration for logger &#39;foo.bar.baz&#39;</span>
<span class="w">    </span><span class="nt">handlers</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">h1</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="nv">h2</span><span class="p p-Indicator">]</span>
</pre></div>
</div>
<p>(참고: 딕셔너리에 해당하는 파이썬 소스 형식보다 약간 더 읽기 쉬우므로 여기에서 YAML을 사용했습니다.)</p>
<p>로거의 id는 로거로의 참조를 얻기 위해서 프로그램적으로 사용되는 로거 이름입니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>. 포매터와 필터의 id는 임의의 문자열 값(가령 위의 <code class="docutils literal notranslate"><span class="pre">brief</span></code>, <code class="docutils literal notranslate"><span class="pre">precise</span></code>)이 될 수 있으며, 일시적이므로 구성 딕셔너리 처리에만 의미가 있고 객체 간의 연결을 결정하는 데 사용되며, 구성 호출이 완료된 후에는 어디에도 남아있지 않습니다.</p>
<p>위의 조각은 <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>라는 로거에 두 개의 처리기가 연결되어 있어야 하며, 이 처리기들은 처리기 id <code class="docutils literal notranslate"><span class="pre">h1</span></code>과 <code class="docutils literal notranslate"><span class="pre">h2</span></code>에 의해 기술됩니다. <code class="docutils literal notranslate"><span class="pre">h1</span></code>의 포매터는 id <code class="docutils literal notranslate"><span class="pre">brief</span></code>로 기술되는 것이고, <code class="docutils literal notranslate"><span class="pre">h2</span></code>의 포매터는 id <code class="docutils literal notranslate"><span class="pre">precise</span></code>로 기술되는 것입니다.</p>
</section>
<section id="user-defined-objects">
<span id="logging-config-dict-userdef"></span><h3>사용자 정의 객체<a class="headerlink" href="logging.config.html#user-defined-objects" title="Link to this heading">¶</a></h3>
<p>스키마는 처리기, 필터 및 포매터에 대한 사용자 정의 객체를 지원합니다. (로거에는 인스턴스마다 다른 형이 필요하지 않으므로, 이 구성 스키마에는 사용자 정의 로거 클래스에 대한 지원이 없습니다.)</p>
<p>구성할 객체는 구성을 자세히 설명하는 딕셔너리로 시술됩니다. 어떤 곳에서는, 로깅 시스템이 객체를 어떻게 인스턴스화할지 문맥으로부터 추측할 수 있지만, 사용자 정의 객체를 인스턴스화 해야 할 때, 시스템은 이를 수행하는 방법을 알 수 없습니다. 사용자 정의 객체 인스턴스화를 위한 완벽한 유연성을 제공하기 위해, 사용자는 ‘팩토리’를 제공해야 하는데, 구성 딕셔너리로 호출되고 인스턴스화 된 객체를 반환하는 콜러블입니다. 이것은 특수키 <code class="docutils literal notranslate"><span class="pre">'()'</span></code>로 제공되는 팩토리로의 절대적 임포트 경로로 표시됩니다. 다음은 구체적인 예입니다:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">formatters</span><span class="p">:</span>
<span class="w">  </span><span class="nt">brief</span><span class="p">:</span>
<span class="w">    </span><span class="nt">format</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;%(message)s&#39;</span>
<span class="w">  </span><span class="nt">default</span><span class="p">:</span>
<span class="w">    </span><span class="nt">format</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;%(asctime)s</span><span class="nv"> </span><span class="s">%(levelname)-8s</span><span class="nv"> </span><span class="s">%(name)-15s</span><span class="nv"> </span><span class="s">%(message)s&#39;</span>
<span class="w">    </span><span class="nt">datefmt</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;%Y-%m-%d</span><span class="nv"> </span><span class="s">%H:%M:%S&#39;</span>
<span class="w">  </span><span class="nt">custom</span><span class="p">:</span>
<span class="w">      </span><span class="nt">()</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">my.package.customFormatterFactory</span>
<span class="w">      </span><span class="nt">bar</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">baz</span>
<span class="w">      </span><span class="nt">spam</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">99.9</span>
<span class="w">      </span><span class="nt">answer</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">42</span>
</pre></div>
</div>
<p>위의 YAML 조각은 세 가지 포매터를 정의합니다. 첫 번째(id <code class="docutils literal notranslate"><span class="pre">brief</span></code>)는 지정된 포맷 문자열을 갖는 표준 <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Formatter</span></code></a> 인스턴스입니다. 두 번째(id <code class="docutils literal notranslate"><span class="pre">default</span></code>)는 더 긴 포맷을 가지며 명시적으로 시간 포맷을 정의하기도 하고, 이 두 포맷 문자열로 초기화된 <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Formatter</span></code></a>가 됩니다. 파이썬 소스 형식으로 표시하면, <code class="docutils literal notranslate"><span class="pre">brief</span></code>와 <code class="docutils literal notranslate"><span class="pre">default</span></code> 포매터는 각각 다음과 같은 구성 서브 딕셔너리를 갖습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s1">&#39;format&#39;</span> <span class="p">:</span> <span class="s1">&#39;</span><span class="si">%(message)s</span><span class="s1">&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>그리고:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s1">&#39;format&#39;</span> <span class="p">:</span> <span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> </span><span class="si">%(levelname)-8s</span><span class="s1"> </span><span class="si">%(name)-15s</span><span class="s1"> </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">,</span>
  <span class="s1">&#39;datefmt&#39;</span> <span class="p">:</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>그리고, 이 딕셔너리에는 특수키 <code class="docutils literal notranslate"><span class="pre">'()'</span></code>가 포함되어 있지 않으므로, 문맥에서 인스턴스가 추론됩니다: 결과적으로, 표준 <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Formatter</span></code></a> 인스턴스가 만들어집니다. 세 번째 포매터(id <code class="docutils literal notranslate"><span class="pre">custom</span></code>)에 대한 구성 서브 딕셔너리는 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s1">&#39;()&#39;</span> <span class="p">:</span> <span class="s1">&#39;my.package.customFormatterFactory&#39;</span><span class="p">,</span>
  <span class="s1">&#39;bar&#39;</span> <span class="p">:</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span>
  <span class="s1">&#39;spam&#39;</span> <span class="p">:</span> <span class="mf">99.9</span><span class="p">,</span>
  <span class="s1">&#39;answer&#39;</span> <span class="p">:</span> <span class="mi">42</span>
<span class="p">}</span>
</pre></div>
</div>
<p>여기에는 특수키 <code class="docutils literal notranslate"><span class="pre">'()'</span></code>가 포함되어 있는데, 사용자 정의 인스턴스가 필요하다는 뜻입니다. 이때, 지정된 팩토리 콜러블이 사용됩니다. 그것이 실제 콜러블이면 직접 사용됩니다 - 그렇지 않고, (예에서와같이) 문자열을 지정하면 일반적인 임포트 메커니즘을 사용하여 실제 콜러블을 얻습니다. 콜러블은 구성 서브 딕셔너리의 <strong>나머지</strong> 항목을 키워드 인자로 호출됩니다. 위의 예제에서, id가 <code class="docutils literal notranslate"><span class="pre">custom</span></code>인 포매터는 다음과 같은 호출이 반환한다고 가정합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">my</span><span class="o">.</span><span class="n">package</span><span class="o">.</span><span class="n">customFormatterFactory</span><span class="p">(</span><span class="n">bar</span><span class="o">=</span><span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="n">spam</span><span class="o">=</span><span class="mf">99.9</span><span class="p">,</span> <span class="n">answer</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>The values for keys such as <code class="docutils literal notranslate"><span class="pre">bar</span></code>, <code class="docutils literal notranslate"><span class="pre">spam</span></code> and <code class="docutils literal notranslate"><span class="pre">answer</span></code> in
the above example should not be configuration dictionaries or references such
as <code class="docutils literal notranslate"><span class="pre">cfg://foo</span></code> or <code class="docutils literal notranslate"><span class="pre">ext://bar</span></code>, because they will not be processed by the
configuration machinery, but passed to the callable as-is.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">'()'</span></code> 키가 유효한 키워드 매개 변수 이름이 아니라서 특수키로 사용되었습니다. 그러므로 호출에 사용되는 키워드 인자의 이름과 충돌하지 않습니다. <code class="docutils literal notranslate"><span class="pre">'()'</span></code>는 해당 값이 콜러블이라는 표시로도 기능합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>The <code class="docutils literal notranslate"><span class="pre">filters</span></code> member of <code class="docutils literal notranslate"><span class="pre">handlers</span></code> and <code class="docutils literal notranslate"><span class="pre">loggers</span></code> can take
filter instances in addition to ids.</p>
</div>
<p>You can also specify a special key <code class="docutils literal notranslate"><span class="pre">'.'</span></code> whose value is a dictionary is a
mapping of attribute names to values. If found, the specified attributes will
be set on the user-defined object before it is returned. Thus, with the
following configuration:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s1">&#39;()&#39;</span> <span class="p">:</span> <span class="s1">&#39;my.package.customFormatterFactory&#39;</span><span class="p">,</span>
  <span class="s1">&#39;bar&#39;</span> <span class="p">:</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span>
  <span class="s1">&#39;spam&#39;</span> <span class="p">:</span> <span class="mf">99.9</span><span class="p">,</span>
  <span class="s1">&#39;answer&#39;</span> <span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
  <span class="s1">&#39;.&#39;</span> <span class="p">{</span>
    <span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span>
    <span class="s1">&#39;baz&#39;</span><span class="p">:</span> <span class="s1">&#39;bozz&#39;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>the returned formatter will have attribute <code class="docutils literal notranslate"><span class="pre">foo</span></code> set to <code class="docutils literal notranslate"><span class="pre">'bar'</span></code> and
attribute <code class="docutils literal notranslate"><span class="pre">baz</span></code> set to <code class="docutils literal notranslate"><span class="pre">'bozz'</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>The values for attributes such as <code class="docutils literal notranslate"><span class="pre">foo</span></code> and <code class="docutils literal notranslate"><span class="pre">baz</span></code> in
the above example should not be configuration dictionaries or references such
as <code class="docutils literal notranslate"><span class="pre">cfg://foo</span></code> or <code class="docutils literal notranslate"><span class="pre">ext://bar</span></code>, because they will not be processed by the
configuration machinery, but set as attribute values as-is.</p>
</div>
</section>
<section id="handler-configuration-order">
<span id="handler-config-dict-order"></span><h3>Handler configuration order<a class="headerlink" href="logging.config.html#handler-configuration-order" title="Link to this heading">¶</a></h3>
<p>Handlers are configured in alphabetical order of their keys, and a configured
handler replaces the configuration dictionary in (a working copy of) the
<code class="docutils literal notranslate"><span class="pre">handlers</span></code> dictionary in the schema. If you use a construct such as
<code class="docutils literal notranslate"><span class="pre">cfg://handlers.foo</span></code>, then initially <code class="docutils literal notranslate"><span class="pre">handlers['foo']</span></code> points to the
configuration dictionary for the handler named <code class="docutils literal notranslate"><span class="pre">foo</span></code>, and later (once that
handler has been configured) it points to the configured handler instance.
Thus, <code class="docutils literal notranslate"><span class="pre">cfg://handlers.foo</span></code> could resolve to either a dictionary or a handler
instance. In general, it is wise to name handlers in a way such that dependent
handlers are configured _after_ any handlers they depend on; that allows
something like <code class="docutils literal notranslate"><span class="pre">cfg://handlers.foo</span></code> to be used in configuring a handler that
depends on handler <code class="docutils literal notranslate"><span class="pre">foo</span></code>. If that dependent handler were named <code class="docutils literal notranslate"><span class="pre">bar</span></code>,
problems would result, because the configuration of <code class="docutils literal notranslate"><span class="pre">bar</span></code> would be attempted
before that of <code class="docutils literal notranslate"><span class="pre">foo</span></code>, and <code class="docutils literal notranslate"><span class="pre">foo</span></code> would not yet have been configured.
However, if the dependent handler were named <code class="docutils literal notranslate"><span class="pre">foobar</span></code>, it would be configured
after <code class="docutils literal notranslate"><span class="pre">foo</span></code>, with the result that <code class="docutils literal notranslate"><span class="pre">cfg://handlers.foo</span></code> would resolve to
configured handler <code class="docutils literal notranslate"><span class="pre">foo</span></code>, and not its configuration dictionary.</p>
</section>
<section id="access-to-external-objects">
<span id="logging-config-dict-externalobj"></span><h3>외부 객체에 대한 액세스<a class="headerlink" href="logging.config.html#access-to-external-objects" title="Link to this heading">¶</a></h3>
<p>구성에서 구성 외부의 객체를 참조해야 하는 경우가 있습니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>. 구성 딕셔너리가 파이썬 코드를 사용하여 만들어질 때는 간단하지만, 구성이 텍스트 파일(예를 들어, JSON, YAML)을 통해 제공될 때 문제가 발생합니다. 텍스트 파일에서는, <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>를 리터럴 문자열 <code class="docutils literal notranslate"><span class="pre">'sys.stderr'</span></code>과 구별하는 표준 방법이 없습니다. 이 구별을 쉽게 하기 위해, 구성 시스템은 문자열 값에서 특정 접두사를 찾아 특수하게 처리합니다. 예를 들어, 리터럴 문자열 <code class="docutils literal notranslate"><span class="pre">'ext://sys.stderr'</span></code>이 구성에서 값으로 제공되면, <code class="docutils literal notranslate"><span class="pre">ext://</span></code>는 제거되고 값의 나머지 부분을 일반 임포트 메커니즘을 사용하여 처리합니다.</p>
<p>이러한 접두사의 처리는 프로토콜 처리와 유사한 방식으로 수행됩니다: 정규식 <code class="docutils literal notranslate"><span class="pre">^(?P&lt;prefix&gt;[a-z]+)://(?P&lt;suffix&gt;.*)$</span></code>와 일치하는 접두사를 찾는 일반 메커니즘이 있습니다. <code class="docutils literal notranslate"><span class="pre">prefix</span></code>가 인식되면 <code class="docutils literal notranslate"><span class="pre">suffix</span></code>는 접두사 종속적 방식으로 처리되고 처리 결과가 문자열 값을 대체합니다. 접두사가 인식되지 않으면, 문자열 값은 그대로 남습니다.</p>
</section>
<section id="access-to-internal-objects">
<span id="logging-config-dict-internalobj"></span><h3>내부 객체에 대한 액세스<a class="headerlink" href="logging.config.html#access-to-internal-objects" title="Link to this heading">¶</a></h3>
<p>외부 객체뿐만 아니라, 때로 구성에 있는 객체를 참조할 필요도 있습니다. 이것은 구성 시스템이 알고 있는 것들에 대해 묵시적으로 수행됩니다. 예를 들어, 로거나 처리기의 <code class="docutils literal notranslate"><span class="pre">level</span></code>에 대한 문자열 값 <code class="docutils literal notranslate"><span class="pre">'DEBUG'</span></code>은 자동으로 값 <code class="docutils literal notranslate"><span class="pre">logging.DEBUG</span></code>으로 변환되고, <code class="docutils literal notranslate"><span class="pre">handlers</span></code>, <code class="docutils literal notranslate"><span class="pre">filters</span></code> 및 <code class="docutils literal notranslate"><span class="pre">formatter</span></code> 항목은 객체 id를 받아서 적절한 대상 객체로 결정합니다.</p>
<p>하지만, <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 모듈에 알려지지 않은 사용자 정의 객체에는 더욱 일반적인 메커니즘이 필요합니다. 예를 들어, 위임할 다른 처리기인 <code class="docutils literal notranslate"><span class="pre">target</span></code> 인자를 취하는 <a class="reference internal" href="logging.handlers.html#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.handlers.MemoryHandler</span></code></a>를 고려해봅시다. 시스템이 이미 이 클래스에 대해 알고 있으므로, 구성에서, 주어진 <code class="docutils literal notranslate"><span class="pre">target</span></code>은 단지 관련 target 처리기의 객체 id이기만 하면 되며, 시스템은 id로부터 처리기를 결정합니다. 그러나 사용자가 <code class="docutils literal notranslate"><span class="pre">alternate</span></code> 처리기를 갖는 <code class="docutils literal notranslate"><span class="pre">my.package.MyHandler</span></code>를 정의하면, 구성 시스템은 <code class="docutils literal notranslate"><span class="pre">alternate</span></code>가 처리기를 참조한다는 것을 알 수 없습니다. 이 문제를 해결하기 위해, 일반 결정 시스템은 사용자가 다음과 같이 지정할 수 있게 합니다:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">handlers</span><span class="p">:</span>
<span class="w">  </span><span class="nt">file</span><span class="p">:</span>
<span class="w">    </span><span class="c1"># configuration of file handler goes here</span>

<span class="w">  </span><span class="nt">custom</span><span class="p">:</span>
<span class="w">    </span><span class="nt">()</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">my.package.MyHandler</span>
<span class="w">    </span><span class="nt">alternate</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">cfg://handlers.file</span>
</pre></div>
</div>
<p>리터럴 문자열 <code class="docutils literal notranslate"><span class="pre">'cfg://handlers.file'</span></code>은 <code class="docutils literal notranslate"><span class="pre">ext://</span></code> 접두사가 있는 문자열과 비슷하게 결정되지만, 임포트 이름 공간이 아닌 구성 자체를 조회합니다. 이 메커니즘은 <code class="docutils literal notranslate"><span class="pre">str.format</span></code>에서 제공하는 것과 유사한 방식으로 점이나 인덱스로 액세스하는 것을 허락합니다. 따라서, 구성에서 다음과 같은 조각이 주어질 때:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">handlers</span><span class="p">:</span>
<span class="w">  </span><span class="nt">email</span><span class="p">:</span>
<span class="w">    </span><span class="nt">class</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">logging.handlers.SMTPHandler</span>
<span class="w">    </span><span class="nt">mailhost</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">localhost</span>
<span class="w">    </span><span class="nt">fromaddr</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">my_app@domain.tld</span>
<span class="w">    </span><span class="nt">toaddrs</span><span class="p">:</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">support_team@domain.tld</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">dev_team@domain.tld</span>
<span class="w">    </span><span class="nt">subject</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Houston, we have a problem.</span>
</pre></div>
</div>
<p>in the configuration, the string <code class="docutils literal notranslate"><span class="pre">'cfg://handlers'</span></code> would resolve to
the dict with key <code class="docutils literal notranslate"><span class="pre">handlers</span></code>, the string <code class="docutils literal notranslate"><span class="pre">'cfg://handlers.email</span></code>
would resolve to the dict with key <code class="docutils literal notranslate"><span class="pre">email</span></code> in the <code class="docutils literal notranslate"><span class="pre">handlers</span></code> dict,
and so on.  The string <code class="docutils literal notranslate"><span class="pre">'cfg://handlers.email.toaddrs[1]</span></code> would
resolve to <code class="docutils literal notranslate"><span class="pre">'dev_team&#64;domain.tld'</span></code> and the string
<code class="docutils literal notranslate"><span class="pre">'cfg://handlers.email.toaddrs[0]'</span></code> would resolve to the value
<code class="docutils literal notranslate"><span class="pre">'support_team&#64;domain.tld'</span></code>. The <code class="docutils literal notranslate"><span class="pre">subject</span></code> value could be accessed
using either <code class="docutils literal notranslate"><span class="pre">'cfg://handlers.email.subject'</span></code> or, equivalently,
<code class="docutils literal notranslate"><span class="pre">'cfg://handlers.email[subject]'</span></code>.  The latter form only needs to be
used if the key contains spaces or non-alphanumeric characters.  If an
index value consists only of decimal digits, access will be attempted
using the corresponding integer value, falling back to the string
value if needed.</p>
<p>문자열 <code class="docutils literal notranslate"><span class="pre">cfg://handlers.myhandler.mykey.123</span></code>이 주어지면, <code class="docutils literal notranslate"><span class="pre">config_dict['handlers']['myhandler']['mykey']['123']</span></code>으로 변환됩니다. 문자열이 <code class="docutils literal notranslate"><span class="pre">cfg://handlers.myhandler.mykey[123]</span></code>로 지정되면, 시스템은 <code class="docutils literal notranslate"><span class="pre">config_dict['handlers']['myhandler']['mykey'][123]</span></code>에서 값을 가져오려고 시도하고, 실패하면 <code class="docutils literal notranslate"><span class="pre">config_dict['handlers']['myhandler']['mykey']['123']</span></code>으로 폴백합니다.</p>
</section>
<section id="import-resolution-and-custom-importers">
<span id="logging-import-resolution"></span><h3>임포트 결정과 사용자 정의 임포터<a class="headerlink" href="logging.config.html#import-resolution-and-custom-importers" title="Link to this heading">¶</a></h3>
<p>임포트 결정은, 기본적으로, 임포트 하는데 내장 <a class="reference internal" href="functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수를 사용합니다. 이것을 자신의 임포트 메커니즘으로 바꾸고 싶을 수 있습니다: 그렇다면, <code class="xref py py-class docutils literal notranslate"><span class="pre">DictConfigurator</span></code>나 그것의 슈퍼 클래스(<code class="xref py py-class docutils literal notranslate"><span class="pre">BaseConfigurator</span></code> 클래스)의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">importer</span></code> 어트리뷰트를 바꿀 수 있습니다. 그러나, 함수가 클래스에서 디스크립터를 통해 액세스 되는 방식 때문에 주의해야 합니다. 파이썬 콜러블을 사용하여 임포트를 수행하려고 하고, 인스턴스 수준이 아닌 클래스 수준에서 정의하려고 한다면, <a class="reference internal" href="functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>로 감쌀 필요가 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">importlib</span> <span class="kn">import</span> <span class="n">import_module</span>
<span class="kn">from</span> <span class="nn">logging.config</span> <span class="kn">import</span> <span class="n">BaseConfigurator</span>

<span class="n">BaseConfigurator</span><span class="o">.</span><span class="n">importer</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">import_module</span><span class="p">)</span>
</pre></div>
</div>
<p>구성자 <em>instance</em>에서 임포트 콜러블을 설정한다면, <a class="reference internal" href="functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>로 감쌀 필요가 없습니다.</p>
</section>
<section id="configuring-queuehandler-and-queuelistener">
<span id="configure-queue"></span><h3>Configuring QueueHandler and QueueListener<a class="headerlink" href="logging.config.html#configuring-queuehandler-and-queuelistener" title="Link to this heading">¶</a></h3>
<p>If you want to configure a <a class="reference internal" href="logging.handlers.html#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueHandler</span></code></a>, noting that this
is normally used in conjunction with a <a class="reference internal" href="logging.handlers.html#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueListener</span></code></a>, you
can configure both together. After the configuration, the <code class="docutils literal notranslate"><span class="pre">QueueListener</span></code> instance
will be available as the <a class="reference internal" href="logging.handlers.html#logging.handlers.QueueHandler.listener" title="logging.handlers.QueueHandler.listener"><code class="xref py py-attr docutils literal notranslate"><span class="pre">listener</span></code></a> attribute of
the created handler, and that in turn will be available to you using
<a class="reference internal" href="logging.html#logging.getHandlerByName" title="logging.getHandlerByName"><code class="xref py py-func docutils literal notranslate"><span class="pre">getHandlerByName()</span></code></a> and passing the name you have used for the
<code class="docutils literal notranslate"><span class="pre">QueueHandler</span></code> in your configuration. The dictionary schema for configuring the pair
is shown in the example YAML snippet below.</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">handlers</span><span class="p">:</span>
<span class="w">  </span><span class="nt">qhand</span><span class="p">:</span>
<span class="w">    </span><span class="nt">class</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">logging.handlers.QueueHandler</span>
<span class="w">    </span><span class="nt">queue</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">my.module.queue_factory</span>
<span class="w">    </span><span class="nt">listener</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">my.package.CustomListener</span>
<span class="w">    </span><span class="nt">handlers</span><span class="p">:</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">hand_name_1</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">hand_name_2</span>
<span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">queue</span></code> and <code class="docutils literal notranslate"><span class="pre">listener</span></code> keys are optional.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">queue</span></code> key is present, the corresponding value can be one of the following:</p>
<ul class="simple">
<li><p>An actual instance of <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a> or a subclass thereof. This is of course
only possible if you are constructing or modifying the configuration dictionary in
code.</p></li>
<li><p>A string that resolves to a callable which, when called with no arguments, returns
the <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a> instance to use. That callable could be a
<a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a> subclass or a function which returns a suitable queue instance,
such as <code class="docutils literal notranslate"><span class="pre">my.module.queue_factory()</span></code>.</p></li>
<li><p>A dict with a <code class="docutils literal notranslate"><span class="pre">'()'</span></code> key which is constructed in the usual way as discussed in
<a class="reference internal" href="logging.config.html#logging-config-dict-userdef"><span class="std std-ref">사용자 정의 객체</span></a>. The result of this construction should be a
<a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a> instance.</p></li>
</ul>
<p>If the  <code class="docutils literal notranslate"><span class="pre">queue</span></code> key is absent, a standard unbounded <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a> instance is
created and used.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">listener</span></code> key is present, the corresponding value can be one of the following:</p>
<ul class="simple">
<li><p>A subclass of <a class="reference internal" href="logging.handlers.html#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.handlers.QueueListener</span></code></a>. This is of course only
possible if you are constructing or modifying the configuration dictionary in
code.</p></li>
<li><p>A string which resolves to a class which is a subclass of <code class="docutils literal notranslate"><span class="pre">QueueListener</span></code>, such as
<code class="docutils literal notranslate"><span class="pre">'my.package.CustomListener'</span></code>.</p></li>
<li><p>A dict with a <code class="docutils literal notranslate"><span class="pre">'()'</span></code> key which is constructed in the usual way as discussed in
<a class="reference internal" href="logging.config.html#logging-config-dict-userdef"><span class="std std-ref">사용자 정의 객체</span></a>. The result of this construction should be a
callable with the same signature as the <code class="docutils literal notranslate"><span class="pre">QueueListener</span></code> initializer.</p></li>
</ul>
<p>If the <code class="docutils literal notranslate"><span class="pre">listener</span></code> key is absent, <a class="reference internal" href="logging.handlers.html#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.handlers.QueueListener</span></code></a> is used.</p>
<p>The values under the <code class="docutils literal notranslate"><span class="pre">handlers</span></code> key are the names of other handlers in the
configuration (not shown in the above snippet) which will be passed to the queue
listener.</p>
<p>Any custom queue handler and listener classes will need to be defined with the same
initialization signatures as <a class="reference internal" href="logging.handlers.html#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueHandler</span></code></a> and
<a class="reference internal" href="logging.handlers.html#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueListener</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</section>
</section>
<section id="configuration-file-format">
<span id="logging-config-fileformat"></span><h2>구성 파일 형식<a class="headerlink" href="logging.config.html#configuration-file-format" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="logging.config.html#logging.config.fileConfig" title="logging.config.fileConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">fileConfig()</span></code></a>이 이해하는 구성 파일 형식은 <a class="reference internal" href="configparser.html#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a> 기능을 기반으로 합니다. 파일에는 <code class="docutils literal notranslate"><span class="pre">[loggers]</span></code>, <code class="docutils literal notranslate"><span class="pre">[handlers]</span></code> 및 <code class="docutils literal notranslate"><span class="pre">[formatters]</span></code>라는 섹션이 있어야 하며, 이 섹션에서는 파일에 정의된 각 유형의 엔티티를 이름으로 식별합니다. 이러한 엔티티마다 해당 엔티티 구성 방법을 식별하는 별도의 섹션이 있습니다. 따라서, <code class="docutils literal notranslate"><span class="pre">[loggers]</span></code> 섹션에서 <code class="docutils literal notranslate"><span class="pre">log01</span></code>이라고 이름 붙은 로거에 대해, 관련 구성 세부 사항은 <code class="docutils literal notranslate"><span class="pre">[logger_log01]</span></code> 섹션에 담깁니다. 마찬가지로, <code class="docutils literal notranslate"><span class="pre">[handlers]</span></code> 섹션에서 <code class="docutils literal notranslate"><span class="pre">hand01</span></code>이라고 부르는 처리기는 <code class="docutils literal notranslate"><span class="pre">[handler_hand01]</span></code>이라는 섹션에 구성이 담기고, <code class="docutils literal notranslate"><span class="pre">[formatters]</span></code> 섹션에서 <code class="docutils literal notranslate"><span class="pre">form01</span></code>이라고 부르는 포매터는 <code class="docutils literal notranslate"><span class="pre">[formatter_form01]</span></code>이라는 섹션에서 구성이 지정됩니다. 루트 로거 구성은 <code class="docutils literal notranslate"><span class="pre">[logger_root]</span></code>라는 섹션에서 지정해야 합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="logging.config.html#logging.config.fileConfig" title="logging.config.fileConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">fileConfig()</span></code></a> API는 <a class="reference internal" href="logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictConfig()</span></code></a> API보다 오래되었으며 로깅의 특정 측면을 다루는 기능을 제공하지 않습니다. 예를 들어, <a class="reference internal" href="logging.config.html#logging.config.fileConfig" title="logging.config.fileConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">fileConfig()</span></code></a>를 사용해서는 간단한 정수 수준을 넘어서는 메시지 필터링을 제공하는 <a class="reference internal" href="logging.html#logging.Filter" title="logging.Filter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Filter</span></code></a> 객체를 구성할 수 없습니다. 로깅 구성에 <a class="reference internal" href="logging.html#logging.Filter" title="logging.Filter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Filter</span></code></a> 인스턴스가 필요하면, <a class="reference internal" href="logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictConfig()</span></code></a>를 사용해야 합니다. 향후 구성 기능의 개선은 <a class="reference internal" href="logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictConfig()</span></code></a>에 추가될 것임에 유의하십시오. 따라서, 편리할 때 이 새로운 API로 전환하는 것을 고려해 볼 가치가 있습니다.</p>
</div>
<p>파일에 있는 이 절의 예는 아래에 나와 있습니다.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[loggers]</span>
<span class="na">keys</span><span class="o">=</span><span class="s">root,log02,log03,log04,log05,log06,log07</span>

<span class="k">[handlers]</span>
<span class="na">keys</span><span class="o">=</span><span class="s">hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09</span>

<span class="k">[formatters]</span>
<span class="na">keys</span><span class="o">=</span><span class="s">form01,form02,form03,form04,form05,form06,form07,form08,form09</span>
</pre></div>
</div>
<p>루트 로거는 수준과 처리기 목록을 지정해야 합니다. 루트 로거 섹션의 예가 아래에 나와 있습니다.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[logger_root]</span>
<span class="na">level</span><span class="o">=</span><span class="s">NOTSET</span>
<span class="na">handlers</span><span class="o">=</span><span class="s">hand01</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">level</span></code> entry can be one of <code class="docutils literal notranslate"><span class="pre">DEBUG,</span> <span class="pre">INFO,</span> <span class="pre">WARNING,</span> <span class="pre">ERROR,</span> <span class="pre">CRITICAL</span></code> or
<code class="docutils literal notranslate"><span class="pre">NOTSET</span></code>. For the root logger only, <code class="docutils literal notranslate"><span class="pre">NOTSET</span></code> means that all messages will be
logged. Level values are <a class="reference internal" href="functions.html#func-eval"><span class="std std-ref">evaluated</span></a> in the context of the <code class="docutils literal notranslate"><span class="pre">logging</span></code>
package’s namespace.</p>
<p><code class="docutils literal notranslate"><span class="pre">handlers</span></code> 항목은 <code class="docutils literal notranslate"><span class="pre">[handlers]</span></code> 섹션에 나타나야 하는 처리기 이름의 쉼표로 구분된 목록입니다. 이 이름들은 <code class="docutils literal notranslate"><span class="pre">[handlers]</span></code> 섹션에 나타나야 하며, 구성 파일에 해당 섹션이 있어야 합니다.</p>
<p>루트 로거가 아닌 로거의 경우, 몇 가지 추가 정보가 필요합니다. 이것은 다음 예제가 보여줍니다.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[logger_parser]</span>
<span class="na">level</span><span class="o">=</span><span class="s">DEBUG</span>
<span class="na">handlers</span><span class="o">=</span><span class="s">hand01</span>
<span class="na">propagate</span><span class="o">=</span><span class="s">1</span>
<span class="na">qualname</span><span class="o">=</span><span class="s">compiler.parser</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">level</span></code>과 <code class="docutils literal notranslate"><span class="pre">handlers</span></code> 항목은 루트 로거에서처럼 해석됩니다. 단, 루트가 아닌 로거의 수준이 <code class="docutils literal notranslate"><span class="pre">NOTSET</span></code>로 지정되면, 시스템은 로거의 유효 수준을 판별하기 위해 상위 계층 로거를 참조합니다. <code class="docutils literal notranslate"><span class="pre">propagate</span></code> 항목은 메시지가 이 로거로부터 더 높은 로거 계층의 처리기로 전파되어야 함을 나타내려면 1로 설정되고, 메시지가 계층 위의 처리기로 전달되지 <strong>않음</strong>을 나타내려면 0으로 설정됩니다. <code class="docutils literal notranslate"><span class="pre">qualname</span></code> 항목은 로거의 계층적 채널 이름, 즉 응용 프로그램에서 로거를 가져오는 데 사용되는 이름입니다.</p>
<p>처리기 구성을 지정하는 섹션은 다음과 같이 예시됩니다.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[handler_hand01]</span>
<span class="na">class</span><span class="o">=</span><span class="s">StreamHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">NOTSET</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form01</span>
<span class="na">args</span><span class="o">=</span><span class="s">(sys.stdout,)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">class</span></code> 항목은 (<code class="docutils literal notranslate"><span class="pre">logging</span></code> 패키지의 이름 공간에서 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>로 결정되는) 처리기의 클래스를 나타냅니다. <code class="docutils literal notranslate"><span class="pre">level</span></code>은 로거에서처럼 해석되며, <code class="docutils literal notranslate"><span class="pre">NOTSET</span></code>은 ‘모든 것을 로깅’을 의미합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">formatter</span></code> 항목은 이 처리기의 포매터의 키 이름을 나타냅니다. 비어 있으면, 기본 포매터(<code class="docutils literal notranslate"><span class="pre">logging._defaultFormatter</span></code>)가 사용됩니다. 이름이 지정되면, <code class="docutils literal notranslate"><span class="pre">[formatters]</span></code> 섹션에 나타나야 하며 구성 파일에 해당 섹션이 있어야 합니다.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">args</span></code> entry, when <a class="reference internal" href="functions.html#func-eval"><span class="std std-ref">evaluated</span></a> in the context of the <code class="docutils literal notranslate"><span class="pre">logging</span></code>
package’s namespace, is the list of arguments to the constructor for the handler
class. Refer to the constructors for the relevant handlers, or to the examples
below, to see how typical entries are constructed. If not provided, it defaults
to <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">kwargs</span></code> entry, when <a class="reference internal" href="functions.html#func-eval"><span class="std std-ref">evaluated</span></a> in the context of the
<code class="docutils literal notranslate"><span class="pre">logging</span></code> package’s namespace, is the keyword argument dict to the constructor
for the handler class. If not provided, it defaults to <code class="docutils literal notranslate"><span class="pre">{}</span></code>.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[handler_hand02]</span>
<span class="na">class</span><span class="o">=</span><span class="s">FileHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">DEBUG</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form02</span>
<span class="na">args</span><span class="o">=</span><span class="s">(&#39;python.log&#39;, &#39;w&#39;)</span>

<span class="k">[handler_hand03]</span>
<span class="na">class</span><span class="o">=</span><span class="s">handlers.SocketHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">INFO</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form03</span>
<span class="na">args</span><span class="o">=</span><span class="s">(&#39;localhost&#39;, handlers.DEFAULT_TCP_LOGGING_PORT)</span>

<span class="k">[handler_hand04]</span>
<span class="na">class</span><span class="o">=</span><span class="s">handlers.DatagramHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">WARN</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form04</span>
<span class="na">args</span><span class="o">=</span><span class="s">(&#39;localhost&#39;, handlers.DEFAULT_UDP_LOGGING_PORT)</span>

<span class="k">[handler_hand05]</span>
<span class="na">class</span><span class="o">=</span><span class="s">handlers.SysLogHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">ERROR</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form05</span>
<span class="na">args</span><span class="o">=</span><span class="s">((&#39;localhost&#39;, handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler.LOG_USER)</span>

<span class="k">[handler_hand06]</span>
<span class="na">class</span><span class="o">=</span><span class="s">handlers.NTEventLogHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">CRITICAL</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form06</span>
<span class="na">args</span><span class="o">=</span><span class="s">(&#39;Python Application&#39;, &#39;&#39;, &#39;Application&#39;)</span>

<span class="k">[handler_hand07]</span>
<span class="na">class</span><span class="o">=</span><span class="s">handlers.SMTPHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">WARN</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form07</span>
<span class="na">args</span><span class="o">=</span><span class="s">(&#39;localhost&#39;, &#39;from@abc&#39;, [&#39;user1@abc&#39;, &#39;user2@xyz&#39;], &#39;Logger Subject&#39;)</span>
<span class="na">kwargs</span><span class="o">=</span><span class="s">{&#39;timeout&#39;: 10.0}</span>

<span class="k">[handler_hand08]</span>
<span class="na">class</span><span class="o">=</span><span class="s">handlers.MemoryHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">NOTSET</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form08</span>
<span class="na">target</span><span class="o">=</span>
<span class="na">args</span><span class="o">=</span><span class="s">(10, ERROR)</span>

<span class="k">[handler_hand09]</span>
<span class="na">class</span><span class="o">=</span><span class="s">handlers.HTTPHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">NOTSET</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form09</span>
<span class="na">args</span><span class="o">=</span><span class="s">(&#39;localhost:9022&#39;, &#39;/log&#39;, &#39;GET&#39;)</span>
<span class="na">kwargs</span><span class="o">=</span><span class="s">{&#39;secure&#39;: True}</span>
</pre></div>
</div>
<p>포매터 구성을 지정하는 섹션은 다음과 같이 예시됩니다.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[formatter_form01]</span>
<span class="na">format</span><span class="o">=</span><span class="s">F1 %(asctime)s %(levelname)s %(message)s %(customfield)s</span>
<span class="na">datefmt</span><span class="o">=</span>
<span class="na">style</span><span class="o">=</span><span class="s">%</span>
<span class="na">validate</span><span class="o">=</span><span class="s">True</span>
<span class="na">defaults</span><span class="o">=</span><span class="s">{&#39;customfield&#39;: &#39;defaultvalue&#39;}</span>
<span class="na">class</span><span class="o">=</span><span class="s">logging.Formatter</span>
</pre></div>
</div>
<p>The arguments for the formatter configuration are the same as the keys
in the dictionary schema <a class="reference internal" href="logging.config.html#logging-config-dictschema-formatters"><span class="std std-ref">formatters section</span></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">defaults</span></code> entry, when <a class="reference internal" href="functions.html#func-eval"><span class="std std-ref">evaluated</span></a> in the context of
the <code class="docutils literal notranslate"><span class="pre">logging</span></code> package’s namespace, is a dictionary of default values for
custom formatting fields. If not provided, it defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>위에서 설명한 대로 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>를 사용하기 때문에, <a class="reference internal" href="logging.config.html#logging.config.listen" title="logging.config.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code></a>을 사용하여 소켓을 통해 구성을 보내고 받을 때 발생할 수 있는 잠재적인 보안 위험이 있습니다. 위험은 상호 신뢰가 없는 여러 사용자가 같은 기계에서 코드를 실행할 때로 제한됩니다; 자세한 내용은 <a class="reference internal" href="logging.config.html#logging.config.listen" title="logging.config.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code></a> 설명서를 참조하십시오.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt>모듈 <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a></dt><dd><p>logging 모듈에 관한 API 레퍼런스.</p>
</dd>
<dt>모듈 <a class="reference internal" href="logging.handlers.html#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a></dt><dd><p>logging 모듈에 포함된 유용한 처리기.</p>
</dd>
</dl>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="logging.config.html#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code> — Logging configuration</a><ul>
<li><a class="reference internal" href="logging.config.html#configuration-functions">구성 함수</a></li>
<li><a class="reference internal" href="logging.config.html#security-considerations">Security considerations</a></li>
<li><a class="reference internal" href="logging.config.html#configuration-dictionary-schema">구성 딕셔너리 스키마</a><ul>
<li><a class="reference internal" href="logging.config.html#dictionary-schema-details">딕셔너리 스키마 세부사항</a></li>
<li><a class="reference internal" href="logging.config.html#incremental-configuration">증분 구성</a></li>
<li><a class="reference internal" href="logging.config.html#object-connections">객체 연결</a></li>
<li><a class="reference internal" href="logging.config.html#user-defined-objects">사용자 정의 객체</a></li>
<li><a class="reference internal" href="logging.config.html#handler-configuration-order">Handler configuration order</a></li>
<li><a class="reference internal" href="logging.config.html#access-to-external-objects">외부 객체에 대한 액세스</a></li>
<li><a class="reference internal" href="logging.config.html#access-to-internal-objects">내부 객체에 대한 액세스</a></li>
<li><a class="reference internal" href="logging.config.html#import-resolution-and-custom-importers">임포트 결정과 사용자 정의 임포터</a></li>
<li><a class="reference internal" href="logging.config.html#configuring-queuehandler-and-queuelistener">Configuring QueueHandler and QueueListener</a></li>
</ul>
</li>
<li><a class="reference internal" href="logging.config.html#configuration-file-format">구성 파일 형식</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="logging.html"
                          title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code> — Logging facility for Python</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="logging.handlers.html"
                          title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code> — Logging handlers</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/logging.config.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="사이드바 닫기">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="logging.handlers.html" title="logging.handlers — Logging handlers"
             >다음</a> |</li>
        <li class="right" >
          <a href="logging.html" title="logging — Logging facility for Python"
             >이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >일반 운영 체제 서비스</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="logging.config.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code> — Logging configuration</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    저작권
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="../../../license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      최종 업데이트: Jun 09, 2024 (17:23 UTC)
    
      <a href="../../../bugs.html">Found a bug</a>?
    
    <br />

    <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7 버전으로 생성되었습니다.
    </div>

    <script type="text/javascript" src="../_static/switchers.js"></script>
  </body>
</html>