<!DOCTYPE html>

<html lang="ko" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="re — Regular expression operations" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/re.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Source code: Lib/re/ 이 모듈은 Perl에 있는 것과 유사한 정규식 일치 연산을 제공합니다. Both patterns and strings to be searched can be Unicode strings ( str) as well as 8-bit strings ( bytes). However, Unicode strings and 8..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Source code: Lib/re/ 이 모듈은 Perl에 있는 것과 유사한 정규식 일치 연산을 제공합니다. Both patterns and strings to be searched can be Unicode strings ( str) as well as 8-bit strings ( bytes). However, Unicode strings and 8..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>re — Regular expression operations &#8212; Python 3.12.4 문서</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css%3Fv=80d5e7a1.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css%3Fv=bb723527.css" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css%3Fv=b20cc3f5.css" />
    
    <script src="../_static/documentation_options.js%3Fv=3050f571"></script>
    <script src="../_static/doctools.js%3Fv=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js%3Fv=dc90522c"></script>
    <script src="../_static/translations.js%3Fv=b5f768d8"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.12.4 문서에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="difflib — Helpers for computing deltas" href="difflib.html" />
    <link rel="prev" title="string — Common string operations" href="string.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="../../../3/library/re.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" />
                <input type="submit" value="이동"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="re.html#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Regular expression operations</a><ul>
<li><a class="reference internal" href="re.html#regular-expression-syntax">정규식 문법</a></li>
<li><a class="reference internal" href="re.html#module-contents">모듈 내용</a><ul>
<li><a class="reference internal" href="re.html#flags">Flags</a></li>
<li><a class="reference internal" href="re.html#functions">Functions</a></li>
<li><a class="reference internal" href="re.html#exceptions">Exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="re.html#regular-expression-objects">정규식 객체</a></li>
<li><a class="reference internal" href="re.html#match-objects">일치 객체</a></li>
<li><a class="reference internal" href="re.html#regular-expression-examples">정규식 예제</a><ul>
<li><a class="reference internal" href="re.html#checking-for-a-pair">쌍 검사하기</a></li>
<li><a class="reference internal" href="re.html#simulating-scanf">scanf() 시뮬레이션</a></li>
<li><a class="reference internal" href="re.html#search-vs-match">search() 대 match()</a></li>
<li><a class="reference internal" href="re.html#making-a-phonebook">전화번호부 만들기</a></li>
<li><a class="reference internal" href="re.html#text-munging">텍스트 뒤섞기</a></li>
<li><a class="reference internal" href="re.html#finding-all-adverbs">모든 부사 찾기</a></li>
<li><a class="reference internal" href="re.html#finding-all-adverbs-and-their-positions">모든 부사와 그 위치 찾기</a></li>
<li><a class="reference internal" href="re.html#raw-string-notation">날 문자열 표기법</a></li>
<li><a class="reference internal" href="re.html#writing-a-tokenizer">토크나이저 작성하기</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="string.html"
                          title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code> — Common string operations</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="difflib.html"
                          title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code> — Helpers for computing deltas</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/re.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="difflib.html" title="difflib — Helpers for computing deltas"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="string.html" title="string — Common string operations"
             accesskey="P">이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="text.html" accesskey="U">텍스트 처리 서비스</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="re.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Regular expression operations</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-re">
<span id="re-regular-expression-operations"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Regular expression operations<a class="headerlink" href="re.html#module-re" title="Link to this heading">¶</a></h1>
<p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/re/">Lib/re/</a></p>
<hr class="docutils" />
<p>이 모듈은 Perl에 있는 것과 유사한 정규식 일치 연산을 제공합니다.</p>
<p>Both patterns and strings to be searched can be Unicode strings (<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>)
as well as 8-bit strings (<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>).
However, Unicode strings and 8-bit strings cannot be mixed:
that is, you cannot match a Unicode string with a bytes pattern or
vice-versa; similarly, when asking for a substitution, the replacement
string must be of the same type as both the pattern and the search string.</p>
<p>Regular expressions use the backslash character (<code class="docutils literal notranslate"><span class="pre">'\'</span></code>) to indicate
special forms or to allow special characters to be used without invoking
their special meaning.  This collides with Python’s usage of the same
character for the same purpose in string literals; for example, to match
a literal backslash, one might have to write <code class="docutils literal notranslate"><span class="pre">'\\\\'</span></code> as the pattern
string, because the regular expression must be <code class="docutils literal notranslate"><span class="pre">\\</span></code>, and each
backslash must be expressed as <code class="docutils literal notranslate"><span class="pre">\\</span></code> inside a regular Python string
literal. Also, please note that any invalid escape sequences in Python’s
usage of the backslash in string literals now generate a <a class="reference internal" href="exceptions.html#SyntaxWarning" title="SyntaxWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxWarning</span></code></a>
and in the future this will become a <a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>. This behaviour
will happen even if it is a valid escape sequence for a regular expression.</p>
<p>해결책은 정규식 패턴에 파이썬의 날 문자열(raw string) 표기법을 사용하는 것입니다; 역 슬래시는 <code class="docutils literal notranslate"><span class="pre">'r'</span></code> 접두어가 붙은 문자열 리터럴에서 특별한 방법으로 처리되지 않습니다. 따라서 <code class="docutils literal notranslate"><span class="pre">r&quot;\n&quot;</span></code>은 <code class="docutils literal notranslate"><span class="pre">'\'</span></code>와 <code class="docutils literal notranslate"><span class="pre">'n'</span></code>을 포함하는 두 글자 문자열이고, <code class="docutils literal notranslate"><span class="pre">&quot;\n&quot;</span></code>은 개행을 포함하는 한 글자 문자열입니다. 일반적으로 패턴은, 이 날 문자열 표기법을 사용하여 파이썬 코드로 표현됩니다.</p>
<p>대부분 정규식 연산은 모듈 수준 함수와 <a class="reference internal" href="re.html#re-objects"><span class="std std-ref">컴파일된 정규식</span></a>의 메서드로 사용할 수 있다는 점에 유의해야 합니다. 함수는 정규식 객체를 먼저 컴파일할 필요가 없도록 하는 바로 가기이지만, 일부 미세 조정 매개 변수가 빠져있습니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>The third-party <a class="reference external" href="https://pypi.org/project/regex/">regex</a> module,
which has an API compatible with the standard library <a class="reference internal" href="re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> module,
but offers additional functionality and a more thorough Unicode support.</p>
</div>
<section id="regular-expression-syntax">
<span id="re-syntax"></span><h2>정규식 문법<a class="headerlink" href="re.html#regular-expression-syntax" title="Link to this heading">¶</a></h2>
<p>정규식(또는 RE)은 일치하는 문자열 집합을 지정합니다; 이 모듈의 함수는 특정 문자열이 주어진 정규식과 일치하는지 확인할 수 있도록 합니다 (또는 주어진 정규식이 특정 문자열과 일치하는지, 결국 같은 결과를 줍니다).</p>
<p>정규식을 이어붙여서 새로운 정규식을 만들 수 있습니다; <em>A</em>와 <em>B</em>가 모두 정규식이면 <em>AB</em>도 정규식입니다. 일반적으로 문자열 <em>p</em>가 <em>A</em>와 일치하고 다른 문자열 <em>q</em>가 <em>B</em>와 일치하면 문자열 <em>pq</em>가 AB와 일치합니다. 이것은 <em>A</em>나 <em>B</em>가 우선순위가 낮은 연산, <em>A</em>와 <em>B</em> 사이의 경계 조건 또는 숫자 그룹 참조를 포함하지 않는 한 성립합니다. 따라서, 복잡한 정규식은 여기에 설명된 것과 같은 더 단순한 기본 정규식으로 쉽게 구성할 수 있습니다. 정규식의 이론과 구현에 관한 자세한 내용은 Friedl 책 <a class="reference internal" href="re.html#frie09" id="id1"><span>[Frie09]</span></a>, 또는 컴파일러 작성에 관한 거의 모든 교과서를 참조하십시오.</p>
<p>정규식의 형식에 대한 간단한 설명이 이어집니다. 더 자세한 정보와 더 친절한 소개는 <a class="reference internal" href="../howto/regex.html#regex-howto"><span class="std std-ref">정규식 HOWTO</span></a>를 참조하십시오.</p>
<p>정규식은 특수 문자와 일반 문자를 모두 포함 할 수 있습니다. <code class="docutils literal notranslate"><span class="pre">'A'</span></code>, <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'0'</span></code>과 같은 대부분의 일반 문자는 가장 단순한 정규식입니다; 그들은 단순히 자신과 일치합니다. 일반 문자를 이어 붙일 수 있어서, <code class="docutils literal notranslate"><span class="pre">last</span></code>는 <code class="docutils literal notranslate"><span class="pre">'last'</span></code> 문자열과 일치합니다. (이 절의 나머지 부분에서는, RE를 (보통 따옴표 없이) <code class="docutils literal notranslate"><span class="pre">이런</span> <span class="pre">특별한</span> <span class="pre">스타일</span></code>로, 일치할 문자열은 <code class="docutils literal notranslate"><span class="pre">'작은따옴표</span> <span class="pre">안에'</span></code> 씁니다.)</p>
<p><code class="docutils literal notranslate"><span class="pre">'|'</span></code>나 <code class="docutils literal notranslate"><span class="pre">'('</span></code>와 같은 일부 문자는 특수합니다. 특수 문자는 일반 문자의 클래스를 나타내거나, 그 주변의 정규식이 해석되는 방식에 영향을 줍니다.</p>
<p>Repetition operators or quantifiers (<code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">{m,n}</span></code>, etc) cannot be
directly nested. This avoids ambiguity with the non-greedy modifier suffix
<code class="docutils literal notranslate"><span class="pre">?</span></code>, and with other modifiers in other implementations. To apply a second
repetition to an inner repetition, parentheses may be used. For example,
the expression <code class="docutils literal notranslate"><span class="pre">(?:a{6})*</span></code> matches any multiple of six <code class="docutils literal notranslate"><span class="pre">'a'</span></code> characters.</p>
<p>특수 문자는 다음과 같습니다:</p>
<dl class="simple" id="index-0">
<dt><code class="docutils literal notranslate"><span class="pre">.</span></code></dt><dd><p>(점.) 기본 모드에서, 이것은 개행 문자를 제외한 모든 문자와 일치합니다. <a class="reference internal" href="re.html#re.DOTALL" title="re.DOTALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">DOTALL</span></code></a> 플래그가 지정되면, 개행 문자를 포함한 모든 문자와 일치합니다.</p>
</dd>
</dl>
<dl class="simple" id="index-1">
<dt><code class="docutils literal notranslate"><span class="pre">^</span></code></dt><dd><p>(캐럿.) 문자열의 시작과 일치하고, <a class="reference internal" href="re.html#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> 모드에서는 각 개행 직후에도 일치합니다.</p>
</dd>
</dl>
<dl class="simple" id="index-2">
<dt><code class="docutils literal notranslate"><span class="pre">$</span></code></dt><dd><p>문자열의 끝이나 문자열 끝의 개행 문자 바로 직전과 일치하고, <a class="reference internal" href="re.html#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> 모드에서는 개행 문자 앞에서도 일치합니다. <code class="docutils literal notranslate"><span class="pre">foo</span></code>는 ‘foo’와 ‘foobar’를 모두 일치시키는 반면, 정규식 <code class="docutils literal notranslate"><span class="pre">foo$</span></code>는 ‘foo’ 만 일치합니다. 흥미롭게도, <code class="docutils literal notranslate"><span class="pre">'foo1\nfoo2\n'</span></code>에서 <code class="docutils literal notranslate"><span class="pre">foo.$</span></code>를 검색하면 ‘foo2’ 는 정상적으로 일치되지만, ‘foo1’은 <a class="reference internal" href="re.html#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> 모드에서 검색됩니다; <code class="docutils literal notranslate"><span class="pre">'foo\n'</span></code>에서 단일 <code class="docutils literal notranslate"><span class="pre">$</span></code>를 검색하면 두 개의 (빈) 일치가 발견됩니다: 하나는 개행 직전에, 다른 하나는 문자열 끝에.</p>
</dd>
</dl>
<dl class="simple" id="index-3">
<dt><code class="docutils literal notranslate"><span class="pre">*</span></code></dt><dd><p>결과 RE가 선행 RE의 가능한 한 많은 0회 이상의 반복과 일치하도록 합니다. <code class="docutils literal notranslate"><span class="pre">ab*</span></code>는 ‘a’, ‘ab’ 또는 ‘a’ 다음에 임의의 수의 ‘b’가 오는 것과 일치합니다.</p>
</dd>
</dl>
<dl class="simple" id="index-4">
<dt><code class="docutils literal notranslate"><span class="pre">+</span></code></dt><dd><p>결과 RE가 선행 RE의 1회 이상의 반복과 일치하도록 합니다. <code class="docutils literal notranslate"><span class="pre">ab+</span></code>는 ‘a’ 다음에 하나 이상의 ‘b’가 오는 것과 일치합니다; 단지 ‘a’와는 일치하지 않습니다.</p>
</dd>
</dl>
<dl class="simple" id="index-5">
<dt><code class="docutils literal notranslate"><span class="pre">?</span></code></dt><dd><p>결과 RE가 선행 RE의 0 또는 1 반복과 일치하도록 합니다. <code class="docutils literal notranslate"><span class="pre">ab?</span></code>는 ‘a’나 ‘ab’와 일치합니다.</p>
</dd>
</dl>
<dl class="simple" id="index-6">
<dt><code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">+?</span></code>, <code class="docutils literal notranslate"><span class="pre">??</span></code></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'?'</span></code> quantifiers are all <em class="dfn">greedy</em>; they match
as much text as possible.  Sometimes this behaviour isn’t desired; if the RE
<code class="docutils literal notranslate"><span class="pre">&lt;.*&gt;</span></code> is matched against <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;</span> <span class="pre">b</span> <span class="pre">&lt;c&gt;'</span></code>, it will match the entire
string, and not just <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;'</span></code>.  Adding <code class="docutils literal notranslate"><span class="pre">?</span></code> after the quantifier makes it
perform the match in <em class="dfn">non-greedy</em> or <em class="dfn">minimal</em> fashion; as <em>few</em>
characters as possible will be matched.  Using the RE <code class="docutils literal notranslate"><span class="pre">&lt;.*?&gt;</span></code> will match
only <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;'</span></code>.</p>
</dd>
</dl>
<dl id="index-7">
<dt><code class="docutils literal notranslate"><span class="pre">*+</span></code>, <code class="docutils literal notranslate"><span class="pre">++</span></code>, <code class="docutils literal notranslate"><span class="pre">?+</span></code></dt><dd><p>Like the <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'?'</span></code> quantifiers, those where <code class="docutils literal notranslate"><span class="pre">'+'</span></code> is
appended also match as many times as possible.
However, unlike the true greedy quantifiers, these do not allow
back-tracking when the expression following it fails to match.
These are known as <em class="dfn">possessive</em> quantifiers.
For example, <code class="docutils literal notranslate"><span class="pre">a*a</span></code> will match <code class="docutils literal notranslate"><span class="pre">'aaaa'</span></code> because the <code class="docutils literal notranslate"><span class="pre">a*</span></code> will match
all 4 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>s, but, when the final <code class="docutils literal notranslate"><span class="pre">'a'</span></code> is encountered, the
expression is backtracked so that in the end the <code class="docutils literal notranslate"><span class="pre">a*</span></code> ends up matching
3 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>s total, and the fourth <code class="docutils literal notranslate"><span class="pre">'a'</span></code> is matched by the final <code class="docutils literal notranslate"><span class="pre">'a'</span></code>.
However, when <code class="docutils literal notranslate"><span class="pre">a*+a</span></code> is used to match <code class="docutils literal notranslate"><span class="pre">'aaaa'</span></code>, the <code class="docutils literal notranslate"><span class="pre">a*+</span></code> will
match all 4 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, but when the final <code class="docutils literal notranslate"><span class="pre">'a'</span></code> fails to find any more
characters to match, the expression cannot be backtracked and will thus
fail to match.
<code class="docutils literal notranslate"><span class="pre">x*+</span></code>, <code class="docutils literal notranslate"><span class="pre">x++</span></code> and <code class="docutils literal notranslate"><span class="pre">x?+</span></code> are equivalent to <code class="docutils literal notranslate"><span class="pre">(?&gt;x*)</span></code>, <code class="docutils literal notranslate"><span class="pre">(?&gt;x+)</span></code>
and <code class="docutils literal notranslate"><span class="pre">(?&gt;x?)</span></code> correspondingly.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd>
</dl>
<dl id="index-8">
<dt><code class="docutils literal notranslate"><span class="pre">{m}</span></code></dt><dd><p>선행 RE의 정확히 <em>m</em> 복사가 일치하도록 지정합니다; 적은 횟수의 일치는 전체 RE가 일치하지 않게 됩니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">a{6}</span></code>는 정확히 6개의 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 문자와 일치하지만, 5개의 문자와는 일치하지 않습니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{m,n}</span></code></dt><dd><p>결과 RE를 선행 RE의 <em>m</em>에서 <em>n</em> 사이의 최대한 많은 반복과 일치하도록 합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code>는 3에서 5개의 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 문자와 일치합니다. <em>m</em>을 생략하면 하한값 0이 지정되고, <em>n</em>을 생략하면 무한한 상한이 지정됩니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">a{4,}b</span></code>는 <code class="docutils literal notranslate"><span class="pre">'aaaab'</span></code> 나 1000개의 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 문자와 <code class="docutils literal notranslate"><span class="pre">'b'</span></code>가 일치하지만, <code class="docutils literal notranslate"><span class="pre">'aaab'</span></code>는 일치하지 않습니다. 콤마는 생략할 수 없습니다, 그렇지 않으면 한정자가 앞에서 설명한 형식과 혼동될 수 있습니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{m,n}?</span></code></dt><dd><p>Causes the resulting RE to match from <em>m</em> to <em>n</em> repetitions of the preceding
RE, attempting to match as <em>few</em> repetitions as possible.  This is the
non-greedy version of the previous quantifier.  For example, on the
6-character string <code class="docutils literal notranslate"><span class="pre">'aaaaaa'</span></code>, <code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code> will match 5 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> characters,
while <code class="docutils literal notranslate"><span class="pre">a{3,5}?</span></code> will only match 3 characters.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{m,n}+</span></code></dt><dd><p>Causes the resulting RE to match from <em>m</em> to <em>n</em> repetitions of the
preceding RE, attempting to match as many repetitions as possible
<em>without</em> establishing any backtracking points.
This is the possessive version of the quantifier above.
For example, on the 6-character string <code class="docutils literal notranslate"><span class="pre">'aaaaaa'</span></code>, <code class="docutils literal notranslate"><span class="pre">a{3,5}+aa</span></code>
attempt to match 5 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> characters, then, requiring 2 more <code class="docutils literal notranslate"><span class="pre">'a'</span></code>s,
will need more characters than available and thus fail, while
<code class="docutils literal notranslate"><span class="pre">a{3,5}aa</span></code> will match with <code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code> capturing 5, then 4 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>s
by backtracking and then the final 2 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>s are matched by the final
<code class="docutils literal notranslate"><span class="pre">aa</span></code> in the pattern.
<code class="docutils literal notranslate"><span class="pre">x{m,n}+</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">(?&gt;x{m,n})</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd>
</dl>
<dl id="index-9">
<dt><code class="docutils literal notranslate"><span class="pre">\</span></code></dt><dd><p>특수 문자를 이스케이프 하거나 (<code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'?'</span></code> 등의 문자를 일치시킬 수 있도록 합니다), 특수 시퀀스를 알립니다; 특수 시퀀스는 아래에서 설명합니다.</p>
<p>날 문자열을 사용하여 패턴을 표현하지 않는다면, 파이썬이 문자열 리터럴에서 이스케이프 시퀀스로 역 슬래시를 사용한다는 것을 기억하십시오; 이스케이프 시퀀스가 파이썬의 구문 분석기에 의해 인식되지 않으면, 역 슬래시와 후속 문자가 결과 문자열에 포함됩니다. 그러나 파이썬이 결과 시퀀스를 인식한다면 역 슬래시는 두 번 반복되어야 합니다. 이것은 복잡하고 이해하기 어렵기 때문에, 가장 단순한 표현 이외에는 날 문자열을 사용하는 것이 좋습니다.</p>
</dd>
</dl>
<dl id="index-10">
<dt><code class="docutils literal notranslate"><span class="pre">[]</span></code></dt><dd><p>문자 집합을 나타내는 데 사용됩니다. 집합 안에서:</p>
<ul class="simple">
<li><p>문자는 개별적으로 나열 할 수 있습니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">[amk]</span></code>는 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'k'</span></code>와 일치합니다.</p></li>
</ul>
<ul class="simple" id="index-11">
<li><p>문자의 범위는 <code class="docutils literal notranslate"><span class="pre">'-'</span></code>로 구분된 두 문자를 주고는 것으로 나타낼 수 있습니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code>는 모든 소문자 ASCII 문자와 일치하고, <code class="docutils literal notranslate"><span class="pre">[0-5][0-9]</span></code>는 <code class="docutils literal notranslate"><span class="pre">00</span></code>에서 <code class="docutils literal notranslate"><span class="pre">59</span></code>까지의 모든 두 자리 숫자와 일치하며, <code class="docutils literal notranslate"><span class="pre">[0-9A-Fa-f]</span></code>는 모든 16진수와 일치합니다. <code class="docutils literal notranslate"><span class="pre">-</span></code>가 이스케이프 처리되거나 (예를 들어 <code class="docutils literal notranslate"><span class="pre">[a\-z]</span></code>) 첫 번째나 마지막 문자로 배치되면 (예를 들어 <code class="docutils literal notranslate"><span class="pre">[-a]</span></code>나 <code class="docutils literal notranslate"><span class="pre">[a-]</span></code>) 리터럴 <code class="docutils literal notranslate"><span class="pre">'-'</span></code>와 일치합니다.</p></li>
<li><p>특수 문자는 집합 내에서 특별한 의미를 상실합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">[(+*)]</span></code>는 리터럴 문자 <code class="docutils literal notranslate"><span class="pre">'('</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code>, <code class="docutils literal notranslate"><span class="pre">'*'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">')'</span></code>와 일치합니다.</p></li>
</ul>
<ul class="simple" id="index-12">
<li><p>Character classes such as <code class="docutils literal notranslate"><span class="pre">\w</span></code> or <code class="docutils literal notranslate"><span class="pre">\S</span></code> (defined below) are also accepted
inside a set, although the characters they match depend on the <a class="reference internal" href="re.html#flags">flags</a> used.</p></li>
</ul>
<ul class="simple" id="index-13">
<li><p>범위 내에 있지 않은 문자는 <em class="dfn">여집합(complementing)</em>을 만들어 일치할 수 있습니다. 집합의 첫 번째 문자가 <code class="docutils literal notranslate"><span class="pre">'^'</span></code>이면, 집합에 속하지 <em>않은</em> 모든 문자가 일치합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">[^5]</span></code>는 <code class="docutils literal notranslate"><span class="pre">'5'</span></code>를 제외한 모든 문자와 일치하며, <code class="docutils literal notranslate"><span class="pre">[^^]</span></code>는 <code class="docutils literal notranslate"><span class="pre">'^'</span></code>를 제외한 모든 문자와 일치합니다. <code class="docutils literal notranslate"><span class="pre">^</span></code>는 집합의 첫 번째 문자가 아닐 때 특별한 의미가 없습니다.</p></li>
<li><p>To match a literal <code class="docutils literal notranslate"><span class="pre">']'</span></code> inside a set, precede it with a backslash, or
place it at the beginning of the set.  For example, both <code class="docutils literal notranslate"><span class="pre">[()[\]{}]</span></code> and
<code class="docutils literal notranslate"><span class="pre">[]()[{}]</span></code> will match a right bracket, as well as left bracket, braces,
and parentheses.</p></li>
</ul>
<ul class="simple">
<li><p><a class="reference external" href="https://unicode.org/reports/tr18/">유니코드 기술 표준 #18</a> 에서 정의하는 중첩 집합과 집합 연산의 지원이 다음에 추가될 수 있습니다. 이것은 문법을 변경하므로, 이 변경을 용이하게 하기 위해 당분간 <a class="reference internal" href="exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a>이 모호한 경우에 발생합니다. 여기에는 리터럴 <code class="docutils literal notranslate"><span class="pre">'['</span></code>로 시작하거나 리터럴 문자 시퀀스 <code class="docutils literal notranslate"><span class="pre">'--'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&amp;&amp;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'~~'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">'||'</span></code>가 포함된 집합이 포함됩니다. 경고를 피하려면 역 슬래시로 이스케이프 처리하십시오.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>문자 집합이 미래에 의미가 변할 구조를 포함하고 있다면 <a class="reference internal" href="exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a>이 발생합니다.</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-14">
<dt><code class="docutils literal notranslate"><span class="pre">|</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">A|B</span></code>(여기서 <em>A</em>와 <em>B</em>는 임의의 RE일 수 있습니다)는 <em>A</em>나 <em>B</em>와 일치하는 정규식을 만듭니다. 이러한 방식으로 임의의 수의 RE를 <code class="docutils literal notranslate"><span class="pre">'|'</span></code>로 분리 할 수 있습니다. 이것은 그룹(아래를 참조하세요)에서도 사용할 수 있습니다. 대상 문자열이 스캔 될 때 <code class="docutils literal notranslate"><span class="pre">'|'</span></code>로 구분된 RE는 왼쪽에서 오른쪽으로 시도됩니다. 한 패턴이 완전히 일치하면, 해당 분기가 받아들여집니다. 이는 일단 <em>A</em>가 일치하면, <em>B</em>는 전체적으로 더 긴 일치를 생성하더라도 더 검사되지 않는다는 것을 뜻합니다. 즉, <code class="docutils literal notranslate"><span class="pre">'|'</span></code> 연산자는 절대로 탐욕적이지 않습니다. 리터럴 <code class="docutils literal notranslate"><span class="pre">'|'</span></code>와 일치시키려면, <code class="docutils literal notranslate"><span class="pre">\|</span></code>를 사용하거나, <code class="docutils literal notranslate"><span class="pre">[|]</span></code>처럼 문자 클래스 안에 넣으십시오.</p>
</dd>
</dl>
<dl class="simple" id="index-15">
<dt><code class="docutils literal notranslate"><span class="pre">(...)</span></code></dt><dd><p>괄호 안에 있는 정규식과 일치하며, 그룹의 시작과 끝을 나타냅니다; 그룹의 내용은 일치가 수행된 후 조회할 수 있으며, 나중에 문자열에서 <code class="docutils literal notranslate"><span class="pre">\number</span></code> 특수 시퀀스로 일치시킬 수 있습니다 (아래에서 설명됩니다). 리터럴 <code class="docutils literal notranslate"><span class="pre">'('</span></code>나 <code class="docutils literal notranslate"><span class="pre">')'</span></code>를 일치시키려면, <code class="docutils literal notranslate"><span class="pre">\(</span></code>나 <code class="docutils literal notranslate"><span class="pre">\)</span></code>를 사용하거나, 문자 클래스 안에 넣으십시오: <code class="docutils literal notranslate"><span class="pre">[(]</span></code>, <code class="docutils literal notranslate"><span class="pre">[)]</span></code>.</p>
</dd>
</dl>
<dl id="index-16">
<dt><code class="docutils literal notranslate"><span class="pre">(?...)</span></code></dt><dd><p>이것은 확장 표기법입니다 (그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">'('</span></code> 다음에 오는 <code class="docutils literal notranslate"><span class="pre">'?'``는</span> <span class="pre">의미가</span> <span class="pre">없습니다).</span> <span class="pre">``'?'</span></code> 다음의 첫 번째 문자는 확장의 의미와 이후의 문법을 결정합니다. 확장은 대개 새 그룹을 만들지 않습니다; 이 규칙에 대한 유일한 예외는 <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code>입니다. 다음은 현재 지원되는 확장입니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?aiLmsux)</span></code></dt><dd><p>(One or more letters from the set
<code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>.)
The group matches the empty string;
the letters set the corresponding flags for the entire regular expression:</p>
<ul class="simple">
<li><p><a class="reference internal" href="re.html#re.A" title="re.A"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.A</span></code></a> (ASCII-only matching)</p></li>
<li><p><a class="reference internal" href="re.html#re.I" title="re.I"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.I</span></code></a> (ignore case)</p></li>
<li><p><a class="reference internal" href="re.html#re.L" title="re.L"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.L</span></code></a> (locale dependent)</p></li>
<li><p><a class="reference internal" href="re.html#re.M" title="re.M"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.M</span></code></a> (multi-line)</p></li>
<li><p><a class="reference internal" href="re.html#re.S" title="re.S"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.S</span></code></a> (dot matches all)</p></li>
<li><p><a class="reference internal" href="re.html#re.U" title="re.U"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code></a> (Unicode matching)</p></li>
<li><p><a class="reference internal" href="re.html#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a> (verbose)</p></li>
</ul>
<p>(The flags are described in <a class="reference internal" href="re.html#contents-of-module-re"><span class="std std-ref">모듈 내용</span></a>.)
This is useful if you wish to include the flags as part of the
regular expression, instead of passing a <em>flag</em> argument to the
<a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> function.
Flags should be used first in the expression string.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>This construction can only be used at the start of the expression.</p>
</div>
</dd>
</dl>
<dl id="index-17">
<dt><code class="docutils literal notranslate"><span class="pre">(?:...)</span></code></dt><dd><p>일반 괄호의 비 포착 버전. 괄호 안의 정규식과 일치하지만, 그룹과 일치하는 부분 문자열은 일치를 수행한 후 조회하거나 나중에 패턴에서 참조할 수 <em>없습니다</em>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?aiLmsux-imsx:...)</span></code></dt><dd><p>(Zero or more letters from the set
<code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>,
optionally followed by <code class="docutils literal notranslate"><span class="pre">'-'</span></code> followed by
one or more letters from the <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>.)
The letters set or remove the corresponding flags for the part of the expression:</p>
<ul class="simple">
<li><p><a class="reference internal" href="re.html#re.A" title="re.A"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.A</span></code></a> (ASCII-only matching)</p></li>
<li><p><a class="reference internal" href="re.html#re.I" title="re.I"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.I</span></code></a> (ignore case)</p></li>
<li><p><a class="reference internal" href="re.html#re.L" title="re.L"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.L</span></code></a> (locale dependent)</p></li>
<li><p><a class="reference internal" href="re.html#re.M" title="re.M"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.M</span></code></a> (multi-line)</p></li>
<li><p><a class="reference internal" href="re.html#re.S" title="re.S"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.S</span></code></a> (dot matches all)</p></li>
<li><p><a class="reference internal" href="re.html#re.U" title="re.U"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code></a> (Unicode matching)</p></li>
<li><p><a class="reference internal" href="re.html#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a> (verbose)</p></li>
</ul>
<p>(The flags are described in <a class="reference internal" href="re.html#contents-of-module-re"><span class="std std-ref">모듈 내용</span></a>.)</p>
<p>The letters <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code> and <code class="docutils literal notranslate"><span class="pre">'u'</span></code> are mutually exclusive when used
as inline flags, so they can’t be combined or follow <code class="docutils literal notranslate"><span class="pre">'-'</span></code>.  Instead,
when one of them appears in an inline group, it overrides the matching mode
in the enclosing group.  In Unicode patterns <code class="docutils literal notranslate"><span class="pre">(?a:...)</span></code> switches to
ASCII-only matching, and <code class="docutils literal notranslate"><span class="pre">(?u:...)</span></code> switches to Unicode matching
(default).  In bytes patterns <code class="docutils literal notranslate"><span class="pre">(?L:...)</span></code> switches to locale dependent
matching, and <code class="docutils literal notranslate"><span class="pre">(?a:...)</span></code> switches to ASCII-only matching (default).
This override is only in effect for the narrow inline group, and the
original matching mode is restored outside of the group.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>문자 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">'u'</span></code>도 그룹에서 사용할 수 있습니다.</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?&gt;...)</span></code></dt><dd><p>Attempts to match <code class="docutils literal notranslate"><span class="pre">...</span></code> as if it was a separate regular expression, and
if successful, continues to match the rest of the pattern following it.
If the subsequent pattern fails to match, the stack can only be unwound
to a point <em>before</em> the <code class="docutils literal notranslate"><span class="pre">(?&gt;...)</span></code> because once exited, the expression,
known as an <em class="dfn">atomic group</em>, has thrown away all stack points within
itself.
Thus, <code class="docutils literal notranslate"><span class="pre">(?&gt;.*).</span></code> would never match anything because first the <code class="docutils literal notranslate"><span class="pre">.*</span></code>
would match all characters possible, then, having nothing left to match,
the final <code class="docutils literal notranslate"><span class="pre">.</span></code> would fail to match.
Since there are no stack points saved in the Atomic Group, and there is
no stack point before it, the entire expression would thus fail to match.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd>
</dl>
<dl id="index-18">
<dt><code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code></dt><dd><p>Similar to regular parentheses, but the substring matched by the group is
accessible via the symbolic group name <em>name</em>.  Group names must be valid
Python identifiers, and in <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> patterns they can only contain
bytes in the ASCII range.  Each group name must be defined only once within
a regular expression.  A symbolic group is also a numbered group, just as if
the group were not named.</p>
<p>이름 있는 그룹은 세 가지 문맥에서 참조될 수 있습니다. 패턴이 <code class="docutils literal notranslate"><span class="pre">(?P&lt;quote&gt;['&quot;]).*?(?P=quote)</span></code>면 (즉, 작은따옴표나 큰따옴표로 인용된 문자열과 일치):</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>그룹 “quote”에 대한 참조 문맥</p></th>
<th class="head"><p>참조하는 방법</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>같은 패턴 자체에서</p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(?P=quote)</span></code> (보이는 대로)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\1</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>일치 객체 <em>m</em>을 처리할 때</p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">m.group('quote')</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m.end('quote')</span></code> (등)</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">re.sub()</span></code>의 <em>repl</em> 인자로 전달되는 문자열에서</p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\g&lt;quote&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\g&lt;1&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\1</span></code></p></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span>In <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> patterns, group <em>name</em> can only contain bytes
in the ASCII range (<code class="docutils literal notranslate"><span class="pre">b'\x00'</span></code>-<code class="docutils literal notranslate"><span class="pre">b'\x7f'</span></code>).</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-19">
<dt><code class="docutils literal notranslate"><span class="pre">(?P=name)</span></code></dt><dd><p>이름있는 그룹에 대한 역참조; <em>name</em>이라는 이름의 앞선 그룹과 일치하는 텍스트와 일치합니다.</p>
</dd>
</dl>
<dl class="simple" id="index-20">
<dt><code class="docutils literal notranslate"><span class="pre">(?#...)</span></code></dt><dd><p>주석; 괄호의 내용은 단순히 무시됩니다.</p>
</dd>
</dl>
<dl class="simple" id="index-21">
<dt><code class="docutils literal notranslate"><span class="pre">(?=...)</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">...</span></code>가 다음과 일치하면 일치하지만, 문자열을 소비하지는 않습니다. 이를 <em class="dfn">미리 보기 어서션 (lookahead assertion)</em>이라고 합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">Isaac</span> <span class="pre">(?=Asimov)</span></code>는 <code class="docutils literal notranslate"><span class="pre">'Asimov'</span></code>가 뒤따를 때만 <code class="docutils literal notranslate"><span class="pre">'Isaac</span> <span class="pre">'</span></code>과 일치합니다.</p>
</dd>
</dl>
<dl class="simple" id="index-22">
<dt><code class="docutils literal notranslate"><span class="pre">(?!...)</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">...</span></code>가 다음과 일치하지 않으면 일치합니다. 이것은 <em class="dfn">부정적인 미리 보기 어서션 (negative lookahead assertion)</em>입니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">Isaac</span> <span class="pre">(?!Asimov)</span></code>는 <code class="docutils literal notranslate"><span class="pre">'Asimov'</span></code>가 뒤따르지 <em>않을</em> 때 만 <code class="docutils literal notranslate"><span class="pre">'Isaac</span> <span class="pre">'</span></code>과 일치합니다.</p>
</dd>
</dl>
<dl id="index-23">
<dt><code class="docutils literal notranslate"><span class="pre">(?&lt;=...)</span></code></dt><dd><p>문자열의 현재 위치 앞에 현재 위치에서 끝나는 <code class="docutils literal notranslate"><span class="pre">...</span></code>와의 일치가 있으면 일치합니다. 이를 <em class="dfn">긍정적인 되돌아보기 어서션 (positive lookbehind assertion)</em>이라고 합니다. 되돌아보기가 3문자를 백업하고 포함된 패턴이 일치하는지 확인하기 때문에 <code class="docutils literal notranslate"><span class="pre">(?&lt;=abc)def</span></code>는 <code class="docutils literal notranslate"><span class="pre">'abcdef'</span></code>에서 일치를 찾습니다. 포함된 패턴은 고정 길이의 문자열과 일치해야 합니다, 즉, <code class="docutils literal notranslate"><span class="pre">abc</span></code>나 <code class="docutils literal notranslate"><span class="pre">a|b</span></code>는 허용되지만, <code class="docutils literal notranslate"><span class="pre">a*</span></code>와 <code class="docutils literal notranslate"><span class="pre">a{3,4}</span></code>는 허용되지 않습니다. 긍정적인 되돌아보기 어서션으로 시작하는 패턴은 검색되는 문자열의 시작 부분에서 일치하지 않음에 유의하십시오; <a class="reference internal" href="re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a> 함수보다는 <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> 함수를 사용하기를 원할 것입니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;(?&lt;=abc)def&#39;</span><span class="p">,</span> <span class="s1">&#39;abcdef&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
</pre></div>
</div>
<p>이 예에서는 하이픈 다음의 단어를 찾습니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?&lt;=-)\w+&#39;</span><span class="p">,</span> <span class="s1">&#39;spam-egg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;egg&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>고정 길이의 그룹 참조에 대한 지원이 추가되었습니다.</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-24">
<dt><code class="docutils literal notranslate"><span class="pre">(?&lt;!...)</span></code></dt><dd><p>문자열의 현재 위치 앞에 <code class="docutils literal notranslate"><span class="pre">...</span></code>와의 일치가 없으면 일치합니다. 이를 <em class="dfn">부정적인 뒤돌아보기 어서션 (negative lookbehind assertion)</em>이라고 합니다. 긍정적인 뒤돌아보기 어서션과 마찬가지로, 포함된 패턴은 고정 길이의 문자열과 일치해야 합니다. 부정적인 뒤돌아보기 어서션으로 시작하는 패턴은 검색되는 문자열의 시작 부분에서 일치 할 수 있습니다.</p>
</dd>
</dl>
<span id="re-conditional-expression"></span><dl id="index-25">
<dt><code class="docutils literal notranslate"><span class="pre">(?(id/name)yes-pattern|no-pattern)</span></code></dt><dd><p>주어진 <em>id</em>나 <em>name</em>의 그룹이 있으면 <code class="docutils literal notranslate"><span class="pre">yes-pattern</span></code>과, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">no-pattern</span></code>과 일치하려고 시도합니다. <code class="docutils literal notranslate"><span class="pre">no-pattern</span></code>은 선택적이며 생략될 수 있습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">(&lt;)?(\w+&#64;\w+(?:\.\w+)+)(?(1)&gt;|$)</span></code>는 정교하지 않은 전자 메일 일치 패턴인데, <code class="docutils literal notranslate"><span class="pre">'&lt;user&#64;host.com&gt;'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">'user&#64;host.com'</span></code>과 일치하지만, <code class="docutils literal notranslate"><span class="pre">'&lt;user&#64;host.com'</span></code>이나 <code class="docutils literal notranslate"><span class="pre">'user&#64;host.com&gt;'</span></code>과는 일치하지 않습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span>Group <em>id</em> can only contain ASCII digits.
In <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> patterns, group <em>name</em> can only contain bytes
in the ASCII range (<code class="docutils literal notranslate"><span class="pre">b'\x00'</span></code>-<code class="docutils literal notranslate"><span class="pre">b'\x7f'</span></code>).</p>
</div>
</dd>
</dl>
<p id="re-special-sequences">특수 시퀀스는 <code class="docutils literal notranslate"><span class="pre">'\'</span></code>와 아래 목록의 문자로 구성됩니다. 일반 문자가 ASCII 숫자나 ASCII 글자가 아니면, 결과 RE는 두 번째 문자와 일치합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">\$</span></code>는 문자 <code class="docutils literal notranslate"><span class="pre">'$'</span></code>와 일치합니다.</p>
<dl class="simple" id="index-26">
<dt><code class="docutils literal notranslate"><span class="pre">\number</span></code></dt><dd><p>같은 번호의 그룹 내용과 일치합니다. 그룹은 1부터 번호가 매겨집니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">(.+)</span> <span class="pre">\1</span></code>은 <code class="docutils literal notranslate"><span class="pre">'the</span> <span class="pre">the'</span></code>나 <code class="docutils literal notranslate"><span class="pre">'55</span> <span class="pre">55'</span></code>와 일치하지만, <code class="docutils literal notranslate"><span class="pre">'thethe'</span></code>와는 일치하지 않습니다 (그룹 뒤의 공백에 유의하십시오). 이 특수 시퀀스는 첫 99개 그룹 중 하나와 일치하는 데에만 사용될 수 있습니다. <em>number</em>의 첫 자릿수가 0이거나, <em>number</em>가 3 자릿수면, 그룹 일치로 해석되지 않고, 8진수 값 <em>number</em>를 갖는 문자로 해석됩니다. 문자 클래스의 <code class="docutils literal notranslate"><span class="pre">'['</span></code>와 <code class="docutils literal notranslate"><span class="pre">']'</span></code> 안에서는, 모든 숫자 이스케이프가 문자로 처리됩니다.</p>
</dd>
</dl>
<dl class="simple" id="index-27">
<dt><code class="docutils literal notranslate"><span class="pre">\A</span></code></dt><dd><p>문자열의 시작 부분에서만 일치합니다.</p>
</dd>
</dl>
<dl id="index-28">
<dt><code class="docutils literal notranslate"><span class="pre">\b</span></code></dt><dd><p>Matches the empty string, but only at the beginning or end of a word.
A word is defined as a sequence of word characters.
Note that formally, <code class="docutils literal notranslate"><span class="pre">\b</span></code> is defined as the boundary
between a <code class="docutils literal notranslate"><span class="pre">\w</span></code> and a <code class="docutils literal notranslate"><span class="pre">\W</span></code> character (or vice versa),
or between <code class="docutils literal notranslate"><span class="pre">\w</span></code> and the beginning or end of the string.
This means that <code class="docutils literal notranslate"><span class="pre">r'\bat\b'</span></code> matches <code class="docutils literal notranslate"><span class="pre">'at'</span></code>, <code class="docutils literal notranslate"><span class="pre">'at.'</span></code>, <code class="docutils literal notranslate"><span class="pre">'(at)'</span></code>,
and <code class="docutils literal notranslate"><span class="pre">'as</span> <span class="pre">at</span> <span class="pre">ay'</span></code> but not <code class="docutils literal notranslate"><span class="pre">'attempt'</span></code> or <code class="docutils literal notranslate"><span class="pre">'atlas'</span></code>.</p>
<p>The default word characters in Unicode (str) patterns
are Unicode alphanumerics and the underscore,
but this can be changed by using the <a class="reference internal" href="re.html#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag.
Word boundaries are determined by the current locale
if the <a class="reference internal" href="re.html#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> flag is used.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>Inside a character range, <code class="docutils literal notranslate"><span class="pre">\b</span></code> represents the backspace character,
for compatibility with Python’s string literals.</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-29">
<dt><code class="docutils literal notranslate"><span class="pre">\B</span></code></dt><dd><p>Matches the empty string,
but only when it is <em>not</em> at the beginning or end of a word.
This means that <code class="docutils literal notranslate"><span class="pre">r'at\B'</span></code> matches <code class="docutils literal notranslate"><span class="pre">'athens'</span></code>, <code class="docutils literal notranslate"><span class="pre">'atom'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'attorney'</span></code>, but not <code class="docutils literal notranslate"><span class="pre">'at'</span></code>, <code class="docutils literal notranslate"><span class="pre">'at.'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'at!'</span></code>.
<code class="docutils literal notranslate"><span class="pre">\B</span></code> is the opposite of <code class="docutils literal notranslate"><span class="pre">\b</span></code>,
so word characters in Unicode (str) patterns
are Unicode alphanumerics or the underscore,
although this can be changed by using the <a class="reference internal" href="re.html#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag.
Word boundaries are determined by the current locale
if the <a class="reference internal" href="re.html#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> flag is used.</p>
</dd>
</dl>
<dl id="index-30">
<dt><code class="docutils literal notranslate"><span class="pre">\d</span></code></dt><dd><dl>
<dt>유니코드 (str) 패턴일 때:</dt><dd><p>Matches any Unicode decimal digit
(that is, any character in Unicode character category <a class="reference external" href="https://www.unicode.org/versions/Unicode15.0.0/ch04.pdf#G134153">[Nd]</a>).
This includes <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>, and also many other digit characters.</p>
<p>Matches <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code> if the <a class="reference internal" href="re.html#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used.</p>
</dd>
<dt>8비트 (bytes) 패턴일 때:</dt><dd><p>Matches any decimal digit in the ASCII character set;
this is equivalent to <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<dl id="index-31">
<dt><code class="docutils literal notranslate"><span class="pre">\D</span></code></dt><dd><p>Matches any character which is not a decimal digit.
This is the opposite of <code class="docutils literal notranslate"><span class="pre">\d</span></code>.</p>
<p>Matches <code class="docutils literal notranslate"><span class="pre">[^0-9]</span></code> if the <a class="reference internal" href="re.html#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used.</p>
</dd>
</dl>
<dl id="index-32">
<dt><code class="docutils literal notranslate"><span class="pre">\s</span></code></dt><dd><dl>
<dt>유니코드 (str) 패턴일 때:</dt><dd><p>Matches Unicode whitespace characters (which includes
<code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code>, and also many other characters, for example the
non-breaking spaces mandated by typography rules in many
languages).</p>
<p>Matches <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code> if the <a class="reference internal" href="re.html#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used.</p>
</dd>
<dt>8비트 (bytes) 패턴일 때:</dt><dd><p>ASCII 문자 집합에서 공백으로 간주하는 문자와 일치합니다; 이것은 <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code>와 동등합니다.</p>
</dd>
</dl>
</dd>
</dl>
<dl id="index-33">
<dt><code class="docutils literal notranslate"><span class="pre">\S</span></code></dt><dd><p>Matches any character which is not a whitespace character. This is
the opposite of <code class="docutils literal notranslate"><span class="pre">\s</span></code>.</p>
<p>Matches <code class="docutils literal notranslate"><span class="pre">[^</span> <span class="pre">\t\n\r\f\v]</span></code> if the <a class="reference internal" href="re.html#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used.</p>
</dd>
</dl>
<dl id="index-34">
<dt><code class="docutils literal notranslate"><span class="pre">\w</span></code></dt><dd><dl>
<dt>유니코드 (str) 패턴일 때:</dt><dd><p>Matches Unicode word characters;
this includes all Unicode alphanumeric characters
(as defined by <a class="reference internal" href="stdtypes.html#str.isalnum" title="str.isalnum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.isalnum()</span></code></a>),
as well as the underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>).</p>
<p>Matches <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code> if the <a class="reference internal" href="re.html#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used.</p>
</dd>
<dt>8비트 (bytes) 패턴일 때:</dt><dd><p>Matches characters considered alphanumeric in the ASCII character set;
this is equivalent to <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code>.
If the <a class="reference internal" href="re.html#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> flag is used,
matches characters considered alphanumeric in the current locale and the underscore.</p>
</dd>
</dl>
</dd>
</dl>
<dl id="index-35">
<dt><code class="docutils literal notranslate"><span class="pre">\W</span></code></dt><dd><p>Matches any character which is not a word character.
This is the opposite of <code class="docutils literal notranslate"><span class="pre">\w</span></code>.
By default, matches non-underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>) characters
for which <a class="reference internal" href="stdtypes.html#str.isalnum" title="str.isalnum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.isalnum()</span></code></a> returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>Matches <code class="docutils literal notranslate"><span class="pre">[^a-zA-Z0-9_]</span></code> if the <a class="reference internal" href="re.html#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used.</p>
<p>If the <a class="reference internal" href="re.html#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> flag is used,
matches characters which are neither alphanumeric in the current locale
nor the underscore.</p>
</dd>
</dl>
<dl class="simple" id="index-36">
<dt><code class="docutils literal notranslate"><span class="pre">\Z</span></code></dt><dd><p>문자열 끝에만 일치합니다.</p>
</dd>
</dl>
<p id="index-37">Most of the <a class="reference internal" href="../reference/lexical_analysis.html#escape-sequences"><span class="std std-ref">escape sequences</span></a> supported by Python
string literals are also accepted by the regular expression parser:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>\<span class="n">a</span>      \<span class="n">b</span>      \<span class="n">f</span>      \<span class="n">n</span>
\<span class="n">N</span>      \<span class="n">r</span>      \<span class="n">t</span>      \<span class="n">u</span>
\<span class="n">U</span>      \<span class="n">v</span>      \<span class="n">x</span>      \\
</pre></div>
</div>
<p>(<code class="docutils literal notranslate"><span class="pre">\b</span></code>는 단어 경계를 나타내는 데 사용되며, 문자 클래스 내에서만 “백스페이스”를 의미함에 유의하십시오.)</p>
<p><code class="docutils literal notranslate"><span class="pre">'\u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'\U'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'\N'</span></code> escape sequences are
only recognized in Unicode (str) patterns.
In bytes patterns they are errors.
Unknown escapes of ASCII letters are reserved
for future use and treated as errors.</p>
<p>8진수 이스케이프는 제한된 형식으로 포함됩니다. 첫 번째 숫자가 0이거나, 3개의 8진수가 있으면, 8진수 이스케이프로 간주합니다. 그렇지 않으면, 그룹 참조입니다. 문자열 리터럴과 마찬가지로, 8진수 이스케이프 길이는 항상 최대 3자리입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><code class="docutils literal notranslate"><span class="pre">'\u'</span></code>와 <code class="docutils literal notranslate"><span class="pre">'\U'</span></code> 이스케이프 시퀀스가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><code class="docutils literal notranslate"><span class="pre">'\'</span></code>와 ASCII 글자로 구성된 알 수 없는 이스케이프는 이제 에러입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>The <code class="samp docutils literal notranslate"><span class="pre">'\N{</span><em><span class="pre">name</span></em><span class="pre">}'</span></code> escape sequence has been added. As in string literals,
it expands to the named Unicode character (e.g. <code class="docutils literal notranslate"><span class="pre">'\N{EM</span> <span class="pre">DASH}'</span></code>).</p>
</div>
</section>
<section id="module-contents">
<span id="contents-of-module-re"></span><h2>모듈 내용<a class="headerlink" href="re.html#module-contents" title="Link to this heading">¶</a></h2>
<p>모듈은 몇 가지 함수, 상수 및 예외를 정의합니다. 함수 중 일부는 컴파일된 정규식의 모든 기능을 갖춘 메서드의 단순화된 버전입니다. 대부분의 사소하지 않은 응용 프로그램은 항상 컴파일된 형식을 사용합니다.</p>
<section id="flags">
<h3>Flags<a class="headerlink" href="re.html#flags" title="Link to this heading">¶</a></h3>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>플래그 상수는 이제 <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a>의 서브 클래스인 <a class="reference internal" href="re.html#re.RegexFlag" title="re.RegexFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegexFlag</span></code></a>의 인스턴스입니다.</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="re.RegexFlag">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">RegexFlag</span></span><a class="headerlink" href="re.html#re.RegexFlag" title="Link to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a> class containing the regex options listed below.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11: </span>- added to <code class="docutils literal notranslate"><span class="pre">__all__</span></code></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.A">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">A</span></span><a class="headerlink" href="re.html#re.A" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="re.ASCII">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">ASCII</span></span><a class="headerlink" href="re.html#re.ASCII" title="Link to this definition">¶</a></dt>
<dd><p>Make <code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code>, <code class="docutils literal notranslate"><span class="pre">\d</span></code>, <code class="docutils literal notranslate"><span class="pre">\D</span></code>, <code class="docutils literal notranslate"><span class="pre">\s</span></code> and <code class="docutils literal notranslate"><span class="pre">\S</span></code>
perform ASCII-only matching instead of full Unicode matching.  This is only
meaningful for Unicode (str) patterns, and is ignored for bytes patterns.</p>
<p>Corresponds to the inline flag <code class="docutils literal notranslate"><span class="pre">(?a)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>The <a class="reference internal" href="re.html#re.U" title="re.U"><code class="xref py py-const docutils literal notranslate"><span class="pre">U</span></code></a> flag still exists for backward compatibility,
but is redundant in Python 3 since
matches are Unicode by default for <code class="docutils literal notranslate"><span class="pre">str</span></code> patterns,
and Unicode matching isn’t allowed for bytes patterns.
<a class="reference internal" href="re.html#re.UNICODE" title="re.UNICODE"><code class="xref py py-const docutils literal notranslate"><span class="pre">UNICODE</span></code></a> and the inline flag <code class="docutils literal notranslate"><span class="pre">(?u)</span></code> are similarly redundant.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.DEBUG">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">DEBUG</span></span><a class="headerlink" href="re.html#re.DEBUG" title="Link to this definition">¶</a></dt>
<dd><p>Display debug information about compiled expression.</p>
<p>No corresponding inline flag.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.I">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">I</span></span><a class="headerlink" href="re.html#re.I" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="re.IGNORECASE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">IGNORECASE</span></span><a class="headerlink" href="re.html#re.IGNORECASE" title="Link to this definition">¶</a></dt>
<dd><p>Perform case-insensitive matching;
expressions like <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code> will also  match lowercase letters.
Full Unicode matching (such as <code class="docutils literal notranslate"><span class="pre">Ü</span></code> matching <code class="docutils literal notranslate"><span class="pre">ü</span></code>)
also works unless the <a class="reference internal" href="re.html#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag
is used to disable non-ASCII matches.
The current locale does not change the effect of this flag
unless the <a class="reference internal" href="re.html#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> flag is also used.</p>
<p>Corresponds to the inline flag <code class="docutils literal notranslate"><span class="pre">(?i)</span></code>.</p>
<p>Note that when the Unicode patterns <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code> or <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code> are used in
combination with the <a class="reference internal" href="re.html#re.IGNORECASE" title="re.IGNORECASE"><code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code></a> flag, they will match the 52 ASCII
letters and 4 additional non-ASCII letters: ‘İ’ (U+0130, Latin capital
letter I with dot above), ‘ı’ (U+0131, Latin small letter dotless i),
‘ſ’ (U+017F, Latin small letter long s) and ‘K’ (U+212A, Kelvin sign).
If the <a class="reference internal" href="re.html#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used, only letters ‘a’ to ‘z’
and ‘A’ to ‘Z’ are matched.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.L">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="re.html#re.L" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="re.LOCALE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">LOCALE</span></span><a class="headerlink" href="re.html#re.LOCALE" title="Link to this definition">¶</a></dt>
<dd><p>Make <code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code> and case-insensitive matching
dependent on the current locale.
This flag can be used only with bytes patterns.</p>
<p>Corresponds to the inline flag <code class="docutils literal notranslate"><span class="pre">(?L)</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>This flag is discouraged; consider Unicode matching instead.
The locale mechanism is very unreliable
as it only handles one “culture” at a time
and only works with 8-bit locales.
Unicode matching is enabled by default for Unicode (str) patterns
and it is able to handle different locales and languages.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="re.html#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> can be used only with bytes patterns
and is not compatible with <a class="reference internal" href="re.html#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>Compiled regular expression objects with the <a class="reference internal" href="re.html#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> flag
no longer depend on the locale at compile time.
Only the locale at matching time affects the result of matching.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.M">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">M</span></span><a class="headerlink" href="re.html#re.M" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="re.MULTILINE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">MULTILINE</span></span><a class="headerlink" href="re.html#re.MULTILINE" title="Link to this definition">¶</a></dt>
<dd><p>When specified, the pattern character <code class="docutils literal notranslate"><span class="pre">'^'</span></code> matches at the beginning of the
string and at the beginning of each line (immediately following each newline);
and the pattern character <code class="docutils literal notranslate"><span class="pre">'$'</span></code> matches at the end of the string and at the
end of each line (immediately preceding each newline).  By default, <code class="docutils literal notranslate"><span class="pre">'^'</span></code>
matches only at the beginning of the string, and <code class="docutils literal notranslate"><span class="pre">'$'</span></code> only at the end of the
string and immediately before the newline (if any) at the end of the string.</p>
<p>Corresponds to the inline flag <code class="docutils literal notranslate"><span class="pre">(?m)</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.NOFLAG">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">NOFLAG</span></span><a class="headerlink" href="re.html#re.NOFLAG" title="Link to this definition">¶</a></dt>
<dd><p>Indicates no flag being applied, the value is <code class="docutils literal notranslate"><span class="pre">0</span></code>.  This flag may be used
as a default value for a function keyword argument or as a base value that
will be conditionally ORed with other flags.  Example of use as a default
value:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">NOFLAG</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.S">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">S</span></span><a class="headerlink" href="re.html#re.S" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="re.DOTALL">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">DOTALL</span></span><a class="headerlink" href="re.html#re.DOTALL" title="Link to this definition">¶</a></dt>
<dd><p>Make the <code class="docutils literal notranslate"><span class="pre">'.'</span></code> special character match any character at all, including a
newline; without this flag, <code class="docutils literal notranslate"><span class="pre">'.'</span></code> will match anything <em>except</em> a newline.</p>
<p>Corresponds to the inline flag <code class="docutils literal notranslate"><span class="pre">(?s)</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.U">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">U</span></span><a class="headerlink" href="re.html#re.U" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="re.UNICODE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">UNICODE</span></span><a class="headerlink" href="re.html#re.UNICODE" title="Link to this definition">¶</a></dt>
<dd><p>In Python 3, Unicode characters are matched by default
for <code class="docutils literal notranslate"><span class="pre">str</span></code> patterns.
This flag is therefore redundant with <strong>no effect</strong>
and is only kept for backward compatibility.</p>
<p>See <a class="reference internal" href="re.html#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> to restrict matching to ASCII characters instead.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.X">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">X</span></span><a class="headerlink" href="re.html#re.X" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="re.VERBOSE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">VERBOSE</span></span><a class="headerlink" href="re.html#re.VERBOSE" title="Link to this definition">¶</a></dt>
<dd><p id="index-38">This flag allows you to write regular expressions that look nicer and are
more readable by allowing you to visually separate logical sections of the
pattern and add comments. Whitespace within the pattern is ignored, except
when in a character class, or when preceded by an unescaped backslash,
or within tokens like <code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">(?:</span></code> or <code class="docutils literal notranslate"><span class="pre">(?P&lt;...&gt;</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">(?</span> <span class="pre">:</span></code>
and <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">?</span></code> are not allowed.
When a line contains a <code class="docutils literal notranslate"><span class="pre">#</span></code> that is not in a character class and is not
preceded by an unescaped backslash, all characters from the leftmost such
<code class="docutils literal notranslate"><span class="pre">#</span></code> through the end of the line are ignored.</p>
<p>이것은 십진수와 일치하는 다음 두 정규식 객체는 기능적으로 같음을 뜻합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;\d +  # the integral part</span>
<span class="s2">                   \.    # the decimal point</span>
<span class="s2">                   \d *  # some fractional digits&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+\.\d*&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>인라인 플래그 <code class="docutils literal notranslate"><span class="pre">(?x)</span></code> 에 해당합니다.</p>
</dd></dl>

</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="re.html#functions" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="re.compile">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">compile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.compile" title="Link to this definition">¶</a></dt>
<dd><p>정규식 패턴을 <a class="reference internal" href="re.html#re-objects"><span class="std std-ref">정규식 객체</span></a>로 컴파일합니다. 정규식 객체는 아래에 설명되는 <a class="reference internal" href="re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a>, <a class="reference internal" href="re.html#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> 및 기타 메서드를 일치시키는 데 사용할 수 있습니다.</p>
<p>The expression’s behaviour can be modified by specifying a <em>flags</em> value.
Values can be any of the <a class="reference internal" href="re.html#flags">flags</a> variables, combined using bitwise OR
(the <code class="docutils literal notranslate"><span class="pre">|</span></code> operator).</p>
<p>시퀀스</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p>는 다음과 동등합니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p>하지만 정규식이 단일 프로그램에서 여러 번 사용될 때, <a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>을 사용하고 결과 정규식 객체를 저장하여 재사용하는 것이 더 효율적입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>과 모듈 수준 일치 함수에 전달된 가장 최근 패턴의 컴파일된 버전이 캐시 되므로, 한 번에 몇 가지 정규식만 사용하는 프로그램은 정규식 컴파일에 대해 신경 쓸 필요가 없습니다.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.search">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.search" title="Link to this definition">¶</a></dt>
<dd><p>Scan through <em>string</em> looking for the first location where the regular expression
<em>pattern</em> produces a match, and return a corresponding <a class="reference internal" href="re.html#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>. Return
<code class="docutils literal notranslate"><span class="pre">None</span></code> if no position in the string matches the pattern; note that this is
different from finding a zero-length match at some point in the string.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.match">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.match" title="Link to this definition">¶</a></dt>
<dd><p>If zero or more characters at the beginning of <em>string</em> match the regular
expression <em>pattern</em>, return a corresponding <a class="reference internal" href="re.html#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>.  Return
<code class="docutils literal notranslate"><span class="pre">None</span></code> if the string does not match the pattern; note that this is
different from a zero-length match.</p>
<p><a class="reference internal" href="re.html#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> 모드에서도, <a class="reference internal" href="re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a>는 각 줄의 시작 부분이 아니라 문자열의 시작 부분에서만 일치함에 유의하십시오.</p>
<p><em>string</em>의 모든 위치에서 일치를 찾으려면, 대신 <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a>를 사용하십시오 (<a class="reference internal" href="re.html#search-vs-match"><span class="std std-ref">search() 대 match()</span></a>도 참조하십시오).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.fullmatch">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">fullmatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.fullmatch" title="Link to this definition">¶</a></dt>
<dd><p>If the whole <em>string</em> matches the regular expression <em>pattern</em>, return a
corresponding <a class="reference internal" href="re.html#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>.  Return <code class="docutils literal notranslate"><span class="pre">None</span></code> if the string does not match
the pattern; note that this is different from a zero-length match.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.split">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.split" title="Link to this definition">¶</a></dt>
<dd><p><em>string</em>을 <em>pattern</em>으로 나눕니다. <em>pattern</em>에서 포착하는 괄호가 사용되면 패턴의 모든 그룹 텍스트도 결과 리스트의 일부로 반환됩니다. <em>maxsplit</em>이 0이 아니면, 최대 <em>maxsplit</em> 분할이 발생하고, 나머지 문자열이 리스트의 마지막 요소로 반환됩니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words&#39;, &#39;words&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W+)&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words, words.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;[a-f]+&#39;</span><span class="p">,</span> <span class="s1">&#39;0a3B9&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="go">[&#39;0&#39;, &#39;3&#39;, &#39;9&#39;]</span>
</pre></div>
</div>
<p>구분자에 포착하는 그룹이 있고 문자열 시작 부분에서 일치하면, 결과는 빈 문자열로 시작됩니다. 문자열의 끝에 대해서도 마찬가지입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W+)&#39;</span><span class="p">,</span> <span class="s1">&#39;...words, words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;...&#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;...&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<p>그런 식으로, 구분자 구성 요소는 항상 결과 리스트 내의 같은 상대 인덱스에서 발견됩니다.</p>
<p>패턴에 대한 빈(empty) 일치는 이전의 빈 일치와 인접하지 않을 때만 문자열을 분할합니다.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W*&#39;</span><span class="p">,</span> <span class="s1">&#39;...words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;&#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;d&#39;, &#39;s&#39;, &#39;&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W*)&#39;</span><span class="p">,</span> <span class="s1">&#39;...words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;...&#39;, &#39;&#39;, &#39;&#39;, &#39;w&#39;, &#39;&#39;, &#39;o&#39;, &#39;&#39;, &#39;r&#39;, &#39;&#39;, &#39;d&#39;, &#39;&#39;, &#39;s&#39;, &#39;...&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.1에서 변경: </span>선택적 flags 인자를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>빈 문자열과 일치 할 수 있는 패턴으로 분할하는 지원을 추가했습니다.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.findall">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">findall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.findall" title="Link to this definition">¶</a></dt>
<dd><p>Return all non-overlapping matches of <em>pattern</em> in <em>string</em>, as a list of
strings or tuples.  The <em>string</em> is scanned left-to-right, and matches
are returned in the order found.  Empty matches are included in the result.</p>
<p>The result depends on the number of capturing groups in the pattern.
If there are no groups, return a list of strings matching the whole
pattern.  If there is exactly one group, return a list of strings
matching that group.  If multiple groups are present, return a list
of tuples of strings matching the groups.  Non-capturing groups do not
affect the form of the result.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\bf[a-z]*&#39;</span><span class="p">,</span> <span class="s1">&#39;which foot or hand fell fastest&#39;</span><span class="p">)</span>
<span class="go">[&#39;foot&#39;, &#39;fell&#39;, &#39;fastest&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\w+)=(\d+)&#39;</span><span class="p">,</span> <span class="s1">&#39;set width=20 and height=10&#39;</span><span class="p">)</span>
<span class="go">[(&#39;width&#39;, &#39;20&#39;), (&#39;height&#39;, &#39;10&#39;)]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>비어 있지 않은 일치는 이제 이전의 비어 있는 일치 직후에 시작할 수 있습니다.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.finditer">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">finditer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.finditer" title="Link to this definition">¶</a></dt>
<dd><p>Return an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> yielding <a class="reference internal" href="re.html#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a> objects over
all non-overlapping matches for the RE <em>pattern</em> in <em>string</em>.  The <em>string</em>
is scanned left-to-right, and matches are returned in the order found.  Empty
matches are included in the result.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>비어 있지 않은 일치는 이제 이전의 비어 있는 일치 직후에 시작할 수 있습니다.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.sub">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.sub" title="Link to this definition">¶</a></dt>
<dd><p><em>string</em>에서 겹치지 않는 <em>pattern</em>의 가장 왼쪽 일치를 <em>repl</em>로 치환하여 얻은 문자열을 반환합니다. 패턴을 찾지 못하면, <em>string</em>이 변경되지 않고 반환됩니다. <em>repl</em>은 문자열이나 함수가 될 수 있습니다; 문자열이면 모든 역 슬래시 이스케이프가 처리됩니다. 즉, <code class="docutils literal notranslate"><span class="pre">\n</span></code>은 단일 개행 문자로 변환되고, <code class="docutils literal notranslate"><span class="pre">\r</span></code>는 캐리지 리턴으로 변환되고, 등등. 알 수 없는 ASCII 글자 이스케이프는 나중에 사용하기 위해 예약되어 있으며 에러로 처리됩니다. <code class="docutils literal notranslate"><span class="pre">\&amp;</span></code>와 같은 다른 알려지지 않은 이스케이프는 그대로 있습니다. <code class="docutils literal notranslate"><span class="pre">\6</span></code>과 같은 역참조는 패턴에서 그룹 6과 일치하는 부분 문자열로 치환됩니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="sa">r</span><span class="s1">&#39;static PyObject*\npy_\1(void)\n{&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="s1">&#39;def myfunc():&#39;</span><span class="p">)</span>
<span class="go">&#39;static PyObject*\npy_myfunc(void)\n{&#39;</span>
</pre></div>
</div>
<p>If <em>repl</em> is a function, it is called for every non-overlapping occurrence of
<em>pattern</em>.  The function takes a single <a class="reference internal" href="re.html#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a> argument, and returns
the replacement string.  For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">dashrepl</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39; &#39;</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;-&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;-{1,2}&#39;</span><span class="p">,</span> <span class="n">dashrepl</span><span class="p">,</span> <span class="s1">&#39;pro----gram-files&#39;</span><span class="p">)</span>
<span class="go">&#39;pro--gram files&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\sAND\s&#39;</span><span class="p">,</span> <span class="s1">&#39; &amp; &#39;</span><span class="p">,</span> <span class="s1">&#39;Baked Beans And Spam&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="go">&#39;Baked Beans &amp; Spam&#39;</span>
</pre></div>
</div>
<p>The pattern may be a string or a <a class="reference internal" href="re.html#re.Pattern" title="re.Pattern"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pattern</span></code></a>.</p>
<p>선택적 인자 <em>count</em>는 치환될 패턴 발생의 최대 수입니다; <em>count</em>는 음수가 아닌 정수여야 합니다. 생략되거나 0이면, 모든 발생이 치환됩니다. 패턴에 대한 빈 일치는 이전의 빈 일치와 인접하지 않을 때만 치환되므로, <code class="docutils literal notranslate"><span class="pre">sub('x*',</span> <span class="pre">'-',</span> <span class="pre">'abxd')</span></code>는 <code class="docutils literal notranslate"><span class="pre">'-a-b--d-'</span></code>를 반환합니다.</p>
<p id="index-39">문자열형 <em>repl</em> 인자에서, 위에 설명된 문자 이스케이프와 역참조 외에, <code class="docutils literal notranslate"><span class="pre">\g&lt;name&gt;</span></code>는 <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code> 문법으로 정의한 <code class="docutils literal notranslate"><span class="pre">name</span></code>이라는 그룹에 일치하는 부분 문자열을 사용합니다. <code class="docutils literal notranslate"><span class="pre">\g&lt;number&gt;</span></code>는 해당 그룹 번호를 사용합니다; 따라서 <code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;</span></code>는 <code class="docutils literal notranslate"><span class="pre">\2</span></code>와 동등하지만, <code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;0</span></code>와 같은 치환에서 모호하지 않습니다. <code class="docutils literal notranslate"><span class="pre">\20</span></code>은 그룹 2에 대한 참조에 리터럴 문자 <code class="docutils literal notranslate"><span class="pre">'0'</span></code>이 뒤에 오는 것이 아니라, 그룹 20에 대한 참조로 해석됩니다. 역참조 <code class="docutils literal notranslate"><span class="pre">\g&lt;0&gt;</span></code>은 RE와 일치하는 전체 부분 문자열을 치환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.1에서 변경: </span>선택적 flags 인자를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>일치하지 않는 그룹은 빈 문자열로 치환됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><em>pattern</em>의 <code class="docutils literal notranslate"><span class="pre">'\'</span></code>와 ASCII 글자(letter)로 구성된 알 수 없는 이스케이프는 이제 에러입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>repl</em>의 <code class="docutils literal notranslate"><span class="pre">'\'</span></code>와 ASCII 글자(letter)로 구성된 알 수 없는 이스케이프는 이제 에러입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>패턴에 대한 빈 일치는 이전의 비어 있지 않은 일치와 인접 할 때 치환됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span>Group <em>id</em> can only contain ASCII digits.
In <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> replacement strings, group <em>name</em> can only contain bytes
in the ASCII range (<code class="docutils literal notranslate"><span class="pre">b'\x00'</span></code>-<code class="docutils literal notranslate"><span class="pre">b'\x7f'</span></code>).</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.subn">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">subn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.subn" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a>와 같은 연산을 수행하지만, 튜플 <code class="docutils literal notranslate"><span class="pre">(new_string,</span> <span class="pre">number_of_subs_made)</span></code>를 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.1에서 변경: </span>선택적 flags 인자를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>일치하지 않는 그룹은 빈 문자열로 치환됩니다.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.escape">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">escape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.escape" title="Link to this definition">¶</a></dt>
<dd><p><em>pattern</em>에서 특수 문자를 이스케이프 처리합니다. 이것은 정규식 메타 문자가 포함되어있을 수 있는 임의의 리터럴 문자열을 일치시키려는 경우에 유용합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;https://www.python.org&#39;</span><span class="p">))</span>
<span class="go">https://www\.python\.org</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">legal_chars</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span> <span class="o">+</span> <span class="s2">&quot;!#$%&amp;&#39;*+-.^_`|~:&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]+&#39;</span> <span class="o">%</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">legal_chars</span><span class="p">))</span>
<span class="go">[abcdefghijklmnopqrstuvwxyz0123456789!\#\$%\&amp;&#39;\*\+\-\.\^_`\|\~:]+</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">operators</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;**&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))))</span>
<span class="go">/|\-|\+|\*\*|\*</span>
</pre></div>
</div>
<p>이 함수는 <a class="reference internal" href="re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a>와 <a class="reference internal" href="re.html#re.subn" title="re.subn"><code class="xref py py-func docutils literal notranslate"><span class="pre">subn()</span></code></a>의 치환 문자열에 사용하면 안 되며, 역 슬래시만 이스케이프 해야 합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">digits_re</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\d+&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span> <span class="o">=</span> <span class="s1">&#39;/usr/sbin/sendmail - 0 errors, 12 warnings&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">digits_re</span><span class="p">,</span> <span class="n">digits_re</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">),</span> <span class="n">sample</span><span class="p">))</span>
<span class="go">/usr/sbin/sendmail - \d+ errors, \d+ warnings</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><code class="docutils literal notranslate"><span class="pre">'_'</span></code> 문자는 더는 이스케이프 되지 않습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>정규식에서 특별한 의미를 가질 수 있는 문자만 이스케이프 됩니다. 결과적으로, <code class="docutils literal notranslate"><span class="pre">'!'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&quot;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'%'</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;'&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">','</span></code>, <code class="docutils literal notranslate"><span class="pre">'/'</span></code>, <code class="docutils literal notranslate"><span class="pre">':'</span></code>, <code class="docutils literal notranslate"><span class="pre">';'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'='</span></code>, <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> 및 ‘<cite>”</cite>'는 더는 이스케이프 되지 않습니다.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.purge">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">purge</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.purge" title="Link to this definition">¶</a></dt>
<dd><p>정규식 캐시를 지웁니다.</p>
</dd></dl>

</section>
<section id="exceptions">
<h3>Exceptions<a class="headerlink" href="re.html#exceptions" title="Link to this heading">¶</a></h3>
<dl class="py exception">
<dt class="sig sig-object py" id="re.error">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pattern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.error" title="Link to this definition">¶</a></dt>
<dd><p>여기에 있는 함수 중 하나에 전달된 문자열이 유효한 정규식이 아니거나 (예를 들어, 쌍을 이루지 않는 괄호가 들어있을 수 있습니다) 컴파일이나 일치 중에 다른 에러가 발생할 때 발생하는 예외. 문자열에 패턴과의 일치가 포함되지 않을 때 에러가 발생하지는 않습니다. 에러 인스턴스에는 다음과 같은 추가 어트리뷰트가 있습니다:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="re.error.msg">
<span class="sig-name descname"><span class="pre">msg</span></span><a class="headerlink" href="re.html#re.error.msg" title="Link to this definition">¶</a></dt>
<dd><p>포맷되지 않은 에러 메시지.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.error.pattern">
<span class="sig-name descname"><span class="pre">pattern</span></span><a class="headerlink" href="re.html#re.error.pattern" title="Link to this definition">¶</a></dt>
<dd><p>정규식 패턴.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.error.pos">
<span class="sig-name descname"><span class="pre">pos</span></span><a class="headerlink" href="re.html#re.error.pos" title="Link to this definition">¶</a></dt>
<dd><p>컴파일이 실패한 위치를 가리키는 <em>pattern</em>의 인덱스 (<code class="docutils literal notranslate"><span class="pre">None</span></code>일 수 있습니다).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.error.lineno">
<span class="sig-name descname"><span class="pre">lineno</span></span><a class="headerlink" href="re.html#re.error.lineno" title="Link to this definition">¶</a></dt>
<dd><p><em>pos</em>에 해당하는 줄 (<code class="docutils literal notranslate"><span class="pre">None</span></code>일 수 있습니다).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.error.colno">
<span class="sig-name descname"><span class="pre">colno</span></span><a class="headerlink" href="re.html#re.error.colno" title="Link to this definition">¶</a></dt>
<dd><p><em>pos</em>에 해당하는 열 (<code class="docutils literal notranslate"><span class="pre">None</span></code>일 수 있습니다).</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>추가 어트리뷰트가 추가되었습니다.</p>
</div>
</dd></dl>

</section>
</section>
<section id="regular-expression-objects">
<span id="re-objects"></span><h2>정규식 객체<a class="headerlink" href="re.html#regular-expression-objects" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="re.Pattern">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">Pattern</span></span><a class="headerlink" href="re.html#re.Pattern" title="Link to this definition">¶</a></dt>
<dd><p>Compiled regular expression object returned by <a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span><a class="reference internal" href="re.html#re.Pattern" title="re.Pattern"><code class="xref py py-class docutils literal notranslate"><span class="pre">re.Pattern</span></code></a> supports <code class="docutils literal notranslate"><span class="pre">[]</span></code> to indicate a Unicode (str) or bytes pattern.
See <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.search">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.Pattern.search" title="Link to this definition">¶</a></dt>
<dd><p>Scan through <em>string</em> looking for the first location where this regular
expression produces a match, and return a corresponding <a class="reference internal" href="re.html#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>.
Return <code class="docutils literal notranslate"><span class="pre">None</span></code> if no position in the string matches the pattern; note that
this is different from finding a zero-length match at some point in the string.</p>
<p>선택적 두 번째 매개 변수 <em>pos</em>는 검색을 시작할 문자열의 인덱스를 제공합니다; 기본값은 <code class="docutils literal notranslate"><span class="pre">0</span></code>입니다. 이것은 문자열을 슬라이싱하는 것과 완전히 동등하지는 않습니다; <code class="docutils literal notranslate"><span class="pre">'^'</span></code> 패턴 문자는 문자열의 실제 시작 부분과 개행 직후의 위치에서 일치하지만, 검색을 시작할 색인에서 반드시 일치하지는 않습니다.</p>
<p>선택적 매개 변수 <em>endpos</em>는 문자열을 어디까지 검색할지를 제한합니다; 문자열이 <em>endpos</em> 문자 길이인 것처럼 취급되어, 일치를 찾기 위해 <em>pos</em>에서 <code class="docutils literal notranslate"><span class="pre">endpos</span> <span class="pre">-</span> <span class="pre">1</span></code>까지의 문자만 검색됩니다. <em>endpos</em>가 <em>pos</em>보다 작으면 일치는 없습니다; 그렇지 않으면, <em>rx</em>가 컴파일된 정규식 객체일 때, <code class="docutils literal notranslate"><span class="pre">rx.search(string,</span> <span class="pre">0,</span> <span class="pre">50)</span></code>는 <code class="docutils literal notranslate"><span class="pre">rx.search(string[:50],</span> <span class="pre">0)</span></code>와 동등합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>     <span class="c1"># Match at index 0</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;d&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># No match; search doesn&#39;t include the &quot;d&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.match">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.Pattern.match" title="Link to this definition">¶</a></dt>
<dd><p>If zero or more characters at the <em>beginning</em> of <em>string</em> match this regular
expression, return a corresponding <a class="reference internal" href="re.html#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>. Return <code class="docutils literal notranslate"><span class="pre">None</span></code> if the
string does not match the pattern; note that this is different from a
zero-length match.</p>
<p>선택적 <em>pos</em>와 <em>endpos</em> 매개 변수는 <a class="reference internal" href="re.html#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> 메서드에서와 같은 의미입니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;o&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>      <span class="c1"># No match as &quot;o&quot; is not at the start of &quot;dog&quot;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># Match as &quot;o&quot; is the 2nd character of &quot;dog&quot;.</span>
<span class="go">&lt;re.Match object; span=(1, 2), match=&#39;o&#39;&gt;</span>
</pre></div>
</div>
<p><em>string</em>의 임의 위치에서 일치를 찾으려면, 대신 <a class="reference internal" href="re.html#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>를 사용하십시오 (<a class="reference internal" href="re.html#search-vs-match"><span class="std std-ref">search() 대 match()</span></a>도 참조하십시오).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.fullmatch">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">fullmatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.Pattern.fullmatch" title="Link to this definition">¶</a></dt>
<dd><p>If the whole <em>string</em> matches this regular expression, return a corresponding
<a class="reference internal" href="re.html#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>.  Return <code class="docutils literal notranslate"><span class="pre">None</span></code> if the string does not match the pattern;
note that this is different from a zero-length match.</p>
<p>선택적 <em>pos</em>와 <em>endpos</em> 매개 변수는 <a class="reference internal" href="re.html#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> 메서드에서와 같은 의미입니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;o[gh]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>      <span class="c1"># No match as &quot;o&quot; is not at the start of &quot;dog&quot;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;ogre&quot;</span><span class="p">)</span>     <span class="c1"># No match as not the full string matches.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;doggie&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>   <span class="c1"># Matches within given limits.</span>
<span class="go">&lt;re.Match object; span=(1, 3), match=&#39;og&#39;&gt;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.split">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.Pattern.split" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="re.html#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a> 함수와 같은데, 컴파일된 패턴을 사용합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.findall">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">findall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.Pattern.findall" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="re.html#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a> 함수와 유사한데, 컴파일된 패턴을 사용합니다. 하지만, <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>처럼 검색 영역을 제한하는 선택적 <em>pos</em>와 <em>endpos</em> 매개 변수도 받아들입니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.finditer">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">finditer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.Pattern.finditer" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="re.html#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a> 함수와 유사한데, 컴파일된 패턴을 사용합니다. 하지만, <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>처럼 검색 영역을 제한하는 선택적 <em>pos</em>와 <em>endpos</em> 매개 변수도 받아들입니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.sub">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">repl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.Pattern.sub" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> 함수와 같은데, 컴파일된 패턴을 사용합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.subn">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">subn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">repl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.Pattern.subn" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="re.html#re.subn" title="re.subn"><code class="xref py py-func docutils literal notranslate"><span class="pre">subn()</span></code></a> 함수와 같은데, 컴파일된 패턴을 사용합니다.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Pattern.flags">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">flags</span></span><a class="headerlink" href="re.html#re.Pattern.flags" title="Link to this definition">¶</a></dt>
<dd><p>The regex matching flags.  This is a combination of the flags given to
<a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>, any <code class="docutils literal notranslate"><span class="pre">(?...)</span></code> inline flags in the pattern, and implicit
flags such as <a class="reference internal" href="re.html#re.UNICODE" title="re.UNICODE"><code class="xref py py-const docutils literal notranslate"><span class="pre">UNICODE</span></code></a> if the pattern is a Unicode string.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Pattern.groups">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">groups</span></span><a class="headerlink" href="re.html#re.Pattern.groups" title="Link to this definition">¶</a></dt>
<dd><p>패턴에 있는 포착 그룹 수.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Pattern.groupindex">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">groupindex</span></span><a class="headerlink" href="re.html#re.Pattern.groupindex" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">(?P&lt;id&gt;)</span></code>로 정의된 기호 그룹 이름을 그룹 번호에 매핑하는 딕셔너리. 패턴에 기호 그룹이 사용되지 않으면 딕셔너리는 비어 있습니다.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Pattern.pattern">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">pattern</span></span><a class="headerlink" href="re.html#re.Pattern.pattern" title="Link to this definition">¶</a></dt>
<dd><p>패턴 객체가 컴파일된 패턴 문자열.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><a class="reference internal" href="copy.html#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a>와 <a class="reference internal" href="copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a> 지원이 추가되었습니다. 컴파일된 정규식 객체는 원자적이라고 간주합니다.</p>
</div>
</section>
<section id="match-objects">
<span id="id3"></span><h2>일치 객체<a class="headerlink" href="re.html#match-objects" title="Link to this heading">¶</a></h2>
<p>일치 객체는 항상 불리언 값 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 가집니다. <a class="reference internal" href="re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a>와 <a class="reference internal" href="re.html#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>는 일치가 없을 때 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환하기 때문에, 간단한 <code class="docutils literal notranslate"><span class="pre">if</span></code> 문으로 일치가 있는지 검사할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
<span class="k">if</span> <span class="n">match</span><span class="p">:</span>
    <span class="n">process</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="re.Match">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">Match</span></span><a class="headerlink" href="re.html#re.Match" title="Link to this definition">¶</a></dt>
<dd><p>Match object returned by successful <code class="docutils literal notranslate"><span class="pre">match</span></code>es and <code class="docutils literal notranslate"><span class="pre">search</span></code>es.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span><a class="reference internal" href="re.html#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">re.Match</span></code></a> supports <code class="docutils literal notranslate"><span class="pre">[]</span></code> to indicate a Unicode (str) or bytes match.
See <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.expand">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">template</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.Match.expand" title="Link to this definition">¶</a></dt>
<dd><p>Return the string obtained by doing backslash substitution on the template
string <em>template</em>, as done by the <a class="reference internal" href="re.html#re.Pattern.sub" title="re.Pattern.sub"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code></a> method.
Escapes such as <code class="docutils literal notranslate"><span class="pre">\n</span></code> are converted to the appropriate characters,
and numeric backreferences (<code class="docutils literal notranslate"><span class="pre">\1</span></code>, <code class="docutils literal notranslate"><span class="pre">\2</span></code>) and named backreferences
(<code class="docutils literal notranslate"><span class="pre">\g&lt;1&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">\g&lt;name&gt;</span></code>) are replaced by the contents of the
corresponding group. The backreference <code class="docutils literal notranslate"><span class="pre">\g&lt;0&gt;</span></code> will be
replaced by the entire match.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>일치하지 않는 그룹은 빈 문자열로 치환됩니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.group">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">group</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">group1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.Match.group" title="Link to this definition">¶</a></dt>
<dd><p>일치의 하나 이상의 서브 그룹을 반환합니다. 단일 인자가 있으면, 결과는 단일 문자열입니다; 인자가 여러 개면, 결과는 인자당 하나의 항목이 있는 튜플입니다. 인자가 없으면, <em>group1</em>의 기본값은 0입니다 (전체 일치가 반환됩니다). <em>groupN</em> 인자가 0이면, 해당 반환 값은 전체 일치 문자열입니다; 경계를 포함하는 범위 [1..99]에 있으면, 해당 괄호로 묶은 그룹과 일치하는 문자열입니다. 그룹 번호가 음수이거나 패턴에 정의된 그룹 수보다 크면, <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 예외가 발생합니다. 패턴이 일치하지 않는 부분에 그룹이 포함되어 있으면, 해당 결과는 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. 그룹이 여러 번 일치하는 패턴의 일부에 포함되어 있으면, 마지막 일치가 반환됩니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+) (\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton, physicist&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>       <span class="c1"># The entire match</span>
<span class="go">&#39;Isaac Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>       <span class="c1"># The first parenthesized subgroup.</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>       <span class="c1"># The second parenthesized subgroup.</span>
<span class="go">&#39;Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>    <span class="c1"># Multiple arguments give us a tuple.</span>
<span class="go">(&#39;Isaac&#39;, &#39;Newton&#39;)</span>
</pre></div>
</div>
<p>정규식이 <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code> 문법을 사용하면, <em>groupN</em> 인자는 그룹 이름으로 그룹을 식별하는 문자열일 수도 있습니다. 문자열 인자가 패턴의 그룹 이름으로 사용되지 않으면, <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 예외가 발생합니다.</p>
<p>적당히 복잡한 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Malcolm Reynolds&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;first_name&#39;</span><span class="p">)</span>
<span class="go">&#39;Malcolm&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;last_name&#39;</span><span class="p">)</span>
<span class="go">&#39;Reynolds&#39;</span>
</pre></div>
</div>
<p>이름있는 그룹은 인덱스로 참조할 수도 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;Malcolm&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;Reynolds&#39;</span>
</pre></div>
</div>
<p>그룹이 여러 번 일치하면, 마지막 일치만 액세스 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(..)+&quot;</span><span class="p">,</span> <span class="s2">&quot;a1b2c3&quot;</span><span class="p">)</span>  <span class="c1"># Matches 3 times.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                        <span class="c1"># Returns only the last match.</span>
<span class="go">&#39;c3&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.__getitem__">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.Match.__getitem__" title="Link to this definition">¶</a></dt>
<dd><p>이것은 <code class="docutils literal notranslate"><span class="pre">m.group(g)</span></code>와 같습니다. 일치에서 개별 그룹에 더 쉽게 액세스 할 수 있게 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+) (\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton, physicist&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>       <span class="c1"># The entire match</span>
<span class="go">&#39;Isaac Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>       <span class="c1"># The first parenthesized subgroup.</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>       <span class="c1"># The second parenthesized subgroup.</span>
<span class="go">&#39;Newton&#39;</span>
</pre></div>
</div>
<p>Named groups are supported as well:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="s1">&#39;first_name&#39;</span><span class="p">]</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="s1">&#39;last_name&#39;</span><span class="p">]</span>
<span class="go">&#39;Newton&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.groups">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">groups</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.Match.groups" title="Link to this definition">¶</a></dt>
<dd><p>1에서 패턴에 있는 그룹의 수까지, 일치의 모든 서브 그룹을 포함하는 튜플을 반환합니다. <em>default</em> 인자는 일치에 참여하지 않은 그룹에 사용됩니다; 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\d+)\.(\d+)&quot;</span><span class="p">,</span> <span class="s2">&quot;24.1632&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">(&#39;24&#39;, &#39;1632&#39;)</span>
</pre></div>
</div>
<p>우리가 소수점과 그 이후의 모든 것을 선택적으로 만들면, 모든 그룹이 일치에 참여하지 않을 수 있습니다. 이 그룹은 <em>default</em> 인자가 주어지지 않는 한 기본값 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\d+)\.?(\d+)?&quot;</span><span class="p">,</span> <span class="s2">&quot;24&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>      <span class="c1"># Second group defaults to None.</span>
<span class="go">(&#39;24&#39;, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>   <span class="c1"># Now, the second group defaults to &#39;0&#39;.</span>
<span class="go">(&#39;24&#39;, &#39;0&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.groupdict">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">groupdict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.Match.groupdict" title="Link to this definition">¶</a></dt>
<dd><p>일치의 모든 <em>이름 있는</em> 서브 그룹을 포함하고, 서브 그룹의 이름을 키로 사용하는 딕셔너리를 반환합니다. <em>default</em> 인자는 일치에 참여하지 않은 그룹에 사용됩니다; 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Malcolm Reynolds&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
<span class="go">{&#39;first_name&#39;: &#39;Malcolm&#39;, &#39;last_name&#39;: &#39;Reynolds&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.start">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.Match.start" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="re.Match.end">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">end</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.Match.end" title="Link to this definition">¶</a></dt>
<dd><p><em>group</em>과 일치하는 부분 문자열의 시작과 끝 인덱스를 반환합니다; <em>group</em>의 기본값은 0입니다 (전체 일치 문자열을 뜻합니다). <em>group</em>이 있지만, 일치에 기여하지 않으면, <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환합니다. 일치 객체 <em>m</em>과 일치에 기여한 그룹 <em>g</em>에서, 그룹 <em>g</em>와 일치하는 부분 문자열(<code class="docutils literal notranslate"><span class="pre">m.group(g)</span></code>와 동등합니다)은 다음과 같습니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">.</span><span class="n">string</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">g</span><span class="p">):</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">g</span><span class="p">)]</span>
</pre></div>
</div>
<p><em>group</em>이 널 문자열과 일치하면 <code class="docutils literal notranslate"><span class="pre">m.start(group)</span></code>은 <code class="docutils literal notranslate"><span class="pre">m.end(group)</span></code>와 같음에 유의하십시오. 예를 들어, <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">re.search('b(c?)',</span> <span class="pre">'cba')</span></code> 이후에, <code class="docutils literal notranslate"><span class="pre">m.start(0)</span></code>은 1이고, <code class="docutils literal notranslate"><span class="pre">m.end(0)</span></code>은 2이며, <code class="docutils literal notranslate"><span class="pre">m.start(1)</span></code>과 <code class="docutils literal notranslate"><span class="pre">m.end(1)</span></code>은 모두 2이고, <code class="docutils literal notranslate"><span class="pre">m.start(2)</span></code>는 <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 예외를 발생시킵니다.</p>
<p>전자 메일 주소에서 <em>remove_this</em>를 제거하는 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">email</span> <span class="o">=</span> <span class="s2">&quot;tony@tiremove_thisger.net&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;remove_this&quot;</span><span class="p">,</span> <span class="n">email</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span><span class="p">[:</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">()]</span> <span class="o">+</span> <span class="n">email</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">():]</span>
<span class="go">&#39;tony@tiger.net&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.span">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">span</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="re.html#re.Match.span" title="Link to this definition">¶</a></dt>
<dd><p>일치가 <em>m</em>일 때, 2-튜플 <code class="docutils literal notranslate"><span class="pre">(m.start(group),</span> <span class="pre">m.end(group))</span></code>를 반환합니다. <em>group</em>이 일치에 기여하지 않으면, 이것은 <code class="docutils literal notranslate"><span class="pre">(-1,</span> <span class="pre">-1)</span></code>임에 유의하십시오. <em>group</em>의 기본값은 0으로, 전체 일치입니다.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.pos">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">pos</span></span><a class="headerlink" href="re.html#re.Match.pos" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="re.html#re-objects"><span class="std std-ref">정규식 객체</span></a>의 <a class="reference internal" href="re.html#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>나 <a class="reference internal" href="re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> 메서드에 전달된 <em>pos</em> 값. 이것은 RE 엔진이 일치를 찾기 시작한 string에 대한 인덱스입니다.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.endpos">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">endpos</span></span><a class="headerlink" href="re.html#re.Match.endpos" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="re.html#re-objects"><span class="std std-ref">정규식 객체</span></a>의 <a class="reference internal" href="re.html#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>나 <a class="reference internal" href="re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> 메서드에 전달된 <em>endpos</em> 값. 이것은 RE 엔진이 넘어가지 않을 string에 대한 인덱스입니다.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.lastindex">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">lastindex</span></span><a class="headerlink" href="re.html#re.Match.lastindex" title="Link to this definition">¶</a></dt>
<dd><p>마지막으로 일치하는 포착 그룹의 정수 인덱스, 또는 그룹이 전혀 일치하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>. 예를 들어, 정규식 <code class="docutils literal notranslate"><span class="pre">(a)b</span></code>, <code class="docutils literal notranslate"><span class="pre">((a)(b))</span></code> 및 <code class="docutils literal notranslate"><span class="pre">((ab))</span></code>는 문자열 <code class="docutils literal notranslate"><span class="pre">'ab'</span></code>에 적용될 경우 <code class="docutils literal notranslate"><span class="pre">lastindex</span> <span class="pre">==</span> <span class="pre">1</span></code>이 되지만, <code class="docutils literal notranslate"><span class="pre">(a)(b)</span></code> 정규식은 같은 문자열에 적용될 때 <code class="docutils literal notranslate"><span class="pre">lastindex</span> <span class="pre">==</span> <span class="pre">2</span></code>가 됩니다.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.lastgroup">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">lastgroup</span></span><a class="headerlink" href="re.html#re.Match.lastgroup" title="Link to this definition">¶</a></dt>
<dd><p>마지막으로 일치하는 포착 그룹의 이름, 또는 그룹에 이름이 없거나, 그룹이 전혀 일치하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.re">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">re</span></span><a class="headerlink" href="re.html#re.Match.re" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a>나 <a class="reference internal" href="re.html#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> 메서드가 이 일치 인스턴스를 생성한 <a class="reference internal" href="re.html#re-objects"><span class="std std-ref">정규식 객체</span></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.string">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">string</span></span><a class="headerlink" href="re.html#re.Match.string" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="re.html#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a>나 <a class="reference internal" href="re.html#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>에 전달된 문자열.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><a class="reference internal" href="copy.html#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a>와 <a class="reference internal" href="copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a> 지원이 추가되었습니다. 일치 객체는 원자적이라고 간주합니다.</p>
</div>
</section>
<section id="regular-expression-examples">
<span id="re-examples"></span><h2>정규식 예제<a class="headerlink" href="re.html#regular-expression-examples" title="Link to this heading">¶</a></h2>
<section id="checking-for-a-pair">
<h3>쌍 검사하기<a class="headerlink" href="re.html#checking-for-a-pair" title="Link to this heading">¶</a></h3>
<p>이 예제에서는, 다음과 같은 도우미 함수를 사용하여 좀 더 세련되게 일치 객체를 표시합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">displaymatch</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="s1">&#39;&lt;Match: </span><span class="si">%r</span><span class="s1">, groups=</span><span class="si">%r</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(),</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>
</pre></div>
</div>
<p>플레이어의 패를 5문자 문자열로 나타내는 포커 프로그램을 작성하고 있다고 가정해봅시다. “a”는 에이스, “k”는 킹, “q”는 퀸, “j”는 잭, “t”는 10, “2”에서 “9”는 그 값의 카드를 나타냅니다.</p>
<p>주어진 문자열이 유효한 패인지 보려면, 다음과 같이 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">valid</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[a2-9tjqk]</span><span class="si">{5}</span><span class="s2">$&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt5q&quot;</span><span class="p">))</span>  <span class="c1"># Valid.</span>
<span class="go">&quot;&lt;Match: &#39;akt5q&#39;, groups=()&gt;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt5e&quot;</span><span class="p">))</span>  <span class="c1"># Invalid.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt&quot;</span><span class="p">))</span>    <span class="c1"># Invalid.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;727ak&quot;</span><span class="p">))</span>  <span class="c1"># Valid.</span>
<span class="go">&quot;&lt;Match: &#39;727ak&#39;, groups=()&gt;&quot;</span>
</pre></div>
</div>
<p>마지막 패 <code class="docutils literal notranslate"><span class="pre">&quot;727ak&quot;</span></code>는 페어, 즉 같은 값의 카드 두 장을 포함합니다. 이것을 정규식과 일치시키려면, 역참조를 다음과 같이 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;717ak&quot;</span><span class="p">))</span>     <span class="c1"># Pair of 7s.</span>
<span class="go">&quot;&lt;Match: &#39;717&#39;, groups=(&#39;7&#39;,)&gt;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;718ak&quot;</span><span class="p">))</span>     <span class="c1"># No pairs.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;354aa&quot;</span><span class="p">))</span>     <span class="c1"># Pair of aces.</span>
<span class="go">&quot;&lt;Match: &#39;354aa&#39;, groups=(&#39;a&#39;,)&gt;&quot;</span>
</pre></div>
</div>
<p>페어가 어떤 카드로 구성되어 있는지 알아내려면, 다음과 같이 일치 객체의 <a class="reference internal" href="re.html#re.Match.group" title="re.Match.group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a> 메서드를 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;717ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;7&#39;</span>

<span class="go"># Error because re.match() returns None, which doesn&#39;t have a group() method:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;718ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#23&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">,</span> <span class="s2">&quot;718ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;NoneType&#39; object has no attribute &#39;group&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;354aa&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
</pre></div>
</div>
</section>
<section id="simulating-scanf">
<h3>scanf() 시뮬레이션<a class="headerlink" href="re.html#simulating-scanf" title="Link to this heading">¶</a></h3>
<p id="index-40">Python does not currently have an equivalent to <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code>.  Regular
expressions are generally more powerful, though also more verbose, than
<code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> format strings.  The table below offers some more-or-less
equivalent mappings between <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> format tokens and regular
expressions.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> Token</p></th>
<th class="head"><p>정규식</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%5c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.{5}</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%d</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?\d+</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%e</span></code>, <code class="docutils literal notranslate"><span class="pre">%E</span></code>, <code class="docutils literal notranslate"><span class="pre">%f</span></code>, <code class="docutils literal notranslate"><span class="pre">%g</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(\d+(\.\d*)?|\.\d+)([eE][-+]?\d+)?</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%i</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(0[xX][\dA-Fa-f]+|0[0-7]*|\d+)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%o</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?[0-7]+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%s</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\S+</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%u</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\d+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%x</span></code>, <code class="docutils literal notranslate"><span class="pre">%X</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(0[xX])?[\dA-Fa-f]+</span></code></p></td>
</tr>
</tbody>
</table>
<p>다음과 같은 문자열에서 파일명과 숫자를 추출하려면</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">sendmail</span> <span class="o">-</span> <span class="mi">0</span> <span class="n">errors</span><span class="p">,</span> <span class="mi">4</span> <span class="n">warnings</span>
</pre></div>
</div>
<p>you would use a <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> format like</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">s</span> <span class="o">-</span> <span class="o">%</span><span class="n">d</span> <span class="n">errors</span><span class="p">,</span> <span class="o">%</span><span class="n">d</span> <span class="n">warnings</span>
</pre></div>
</div>
<p>동등한 정규식은 다음과 같습니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span>\<span class="n">S</span><span class="o">+</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span>\<span class="n">d</span><span class="o">+</span><span class="p">)</span> <span class="n">errors</span><span class="p">,</span> <span class="p">(</span>\<span class="n">d</span><span class="o">+</span><span class="p">)</span> <span class="n">warnings</span>
</pre></div>
</div>
</section>
<section id="search-vs-match">
<span id="id4"></span><h3>search() 대 match()<a class="headerlink" href="re.html#search-vs-match" title="Link to this heading">¶</a></h3>
<p>Python offers different primitive operations based on regular expressions:</p>
<ul class="simple">
<li><p><a class="reference internal" href="re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a> checks for a match only at the beginning of the string</p></li>
<li><p><a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a> checks for a match anywhere in the string
(this is what Perl does by default)</p></li>
<li><p><a class="reference internal" href="re.html#re.fullmatch" title="re.fullmatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.fullmatch()</span></code></a> checks for entire string to be a match</p></li>
</ul>
<p>예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>    <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>   <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(2, 3), match=&#39;c&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;p.*n&quot;</span><span class="p">,</span> <span class="s2">&quot;python&quot;</span><span class="p">)</span> <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(0, 6), match=&#39;python&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;r.*n&quot;</span><span class="p">,</span> <span class="s2">&quot;python&quot;</span><span class="p">)</span> <span class="c1"># No match</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">'^'</span></code>로 시작하는 정규식은 <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a>와 함께 사용하여 문자열 시작 부분의 일치로 제한 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>    <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>  <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^a&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>  <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;a&#39;&gt;</span>
</pre></div>
</div>
<p>그러나 <a class="reference internal" href="re.html#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> 모드에서 <a class="reference internal" href="re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a>는 문자열 시작 부분에서만 일치하지만, <code class="docutils literal notranslate"><span class="pre">'^'</span></code>로 시작하는 정규식을 <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a>에 사용하면 각 줄의 시작 부분에서 일치합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;A</span><span class="se">\n</span><span class="s2">B</span><span class="se">\n</span><span class="s2">X&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>  <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^X&quot;</span><span class="p">,</span> <span class="s2">&quot;A</span><span class="se">\n</span><span class="s2">B</span><span class="se">\n</span><span class="s2">X&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>  <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(4, 5), match=&#39;X&#39;&gt;</span>
</pre></div>
</div>
</section>
<section id="making-a-phonebook">
<h3>전화번호부 만들기<a class="headerlink" href="re.html#making-a-phonebook" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="re.html#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a>는 문자열을, 전달된 패턴으로 구분된 리스트로 분할합니다. 이 메서드는 전화번호부를 만드는 다음 예제에서 보이듯이 텍스트 데이터를 파이썬에서 쉽게 읽고 수정할 수 있는 데이터 구조로 변환하는 데 매우 중요합니다.</p>
<p>먼저, 여기 입력이 있습니다. 보통 파일에서 올 수 있습니다만, 여기서는 삼중 따옴표로 묶인 문자열 문법을 사용합니다.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Ross McFluff: 834.345.1254 155 Elm Street</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="s2">Ronald Heathmore: 892.345.3428 436 Finley Avenue</span>
<span class="gp">... </span><span class="s2">Frank Burger: 925.541.7625 662 South Dogwood Way</span>
<span class="gp">...</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="s2">Heather Albrecht: 548.326.4584 919 Park Place&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>항목은 하나 이상의 개행으로 구분됩니다. 이제 비어있지 않은 각 줄이 항목이 되도록 문자열을 리스트로 변환합니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">entries</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">+&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entries</span>
<span class="go">[&#39;Ross McFluff: 834.345.1254 155 Elm Street&#39;,</span>
<span class="go">&#39;Ronald Heathmore: 892.345.3428 436 Finley Avenue&#39;,</span>
<span class="go">&#39;Frank Burger: 925.541.7625 662 South Dogwood Way&#39;,</span>
<span class="go">&#39;Heather Albrecht: 548.326.4584 919 Park Place&#39;]</span>
</pre></div>
</div>
<p>마지막으로, 각 항목을 이름, 성, 전화번호 및 주소로 구성된 리스트로 분할합니다. 주소에 우리의 분할 패턴인 스페이스가 들어있기 때문에, <a class="reference internal" href="re.html#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">maxsplit</span></code> 매개 변수를 사용합니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:? &quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span>
<span class="go">[[&#39;Ross&#39;, &#39;McFluff&#39;, &#39;834.345.1254&#39;, &#39;155 Elm Street&#39;],</span>
<span class="go">[&#39;Ronald&#39;, &#39;Heathmore&#39;, &#39;892.345.3428&#39;, &#39;436 Finley Avenue&#39;],</span>
<span class="go">[&#39;Frank&#39;, &#39;Burger&#39;, &#39;925.541.7625&#39;, &#39;662 South Dogwood Way&#39;],</span>
<span class="go">[&#39;Heather&#39;, &#39;Albrecht&#39;, &#39;548.326.4584&#39;, &#39;919 Park Place&#39;]]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">:?</span></code> 패턴은 결과 리스트에 나타나지 않도록, 성 뒤의 콜론과 일치합니다. <code class="docutils literal notranslate"><span class="pre">maxsplit</span></code>로 <code class="docutils literal notranslate"><span class="pre">4</span></code>를 사용하면, 번지수를 거리 이름과 분리 할 수 있습니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:? &quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span>
<span class="go">[[&#39;Ross&#39;, &#39;McFluff&#39;, &#39;834.345.1254&#39;, &#39;155&#39;, &#39;Elm Street&#39;],</span>
<span class="go">[&#39;Ronald&#39;, &#39;Heathmore&#39;, &#39;892.345.3428&#39;, &#39;436&#39;, &#39;Finley Avenue&#39;],</span>
<span class="go">[&#39;Frank&#39;, &#39;Burger&#39;, &#39;925.541.7625&#39;, &#39;662&#39;, &#39;South Dogwood Way&#39;],</span>
<span class="go">[&#39;Heather&#39;, &#39;Albrecht&#39;, &#39;548.326.4584&#39;, &#39;919&#39;, &#39;Park Place&#39;]]</span>
</pre></div>
</div>
</section>
<section id="text-munging">
<h3>텍스트 뒤섞기<a class="headerlink" href="re.html#text-munging" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a>는 패턴의 모든 일치를 문자열이나 함수의 결과로 치환합니다. 이 예제는 <a class="reference internal" href="re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a>에 텍스트를 “뒤섞는”, 즉 문장의 각 단어에서 첫 번째 문자와 마지막 문자를 제외한 모든 문자의 순서를 무작위로 바꾸는 함수를 사용하는 방법을 보여줍니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">repl</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">inner_word</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">inner_word</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inner_word</span><span class="p">)</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Professor Abdolmalek, please report your absences promptly.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w)(\w+)(\w)&quot;</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">&#39;Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w)(\w+)(\w)&quot;</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">&#39;Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.&#39;</span>
</pre></div>
</div>
</section>
<section id="finding-all-adverbs">
<h3>모든 부사 찾기<a class="headerlink" href="re.html#finding-all-adverbs" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="re.html#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a>은 <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a>처럼 첫 번째 등장뿐만 아니라, 패턴의 <em>모든</em> 등장과 일치합니다. 예를 들어, 작가가 어떤 텍스트에서 부사를 모두 찾고 싶으면, 다음과 같은 방식으로 <a class="reference internal" href="re.html#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a>을 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;He was carefully disguised but captured quickly by police.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\w+ly\b&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">[&#39;carefully&#39;, &#39;quickly&#39;]</span>
</pre></div>
</div>
</section>
<section id="finding-all-adverbs-and-their-positions">
<h3>모든 부사와 그 위치 찾기<a class="headerlink" href="re.html#finding-all-adverbs-and-their-positions" title="Link to this heading">¶</a></h3>
<p>If one wants more information about all matches of a pattern than the matched
text, <a class="reference internal" href="re.html#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a> is useful as it provides <a class="reference internal" href="re.html#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a> objects
instead of strings.  Continuing with the previous example, if a writer wanted
to find all of the adverbs <em>and their positions</em> in some text, they would use
<a class="reference internal" href="re.html#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a> in the following manner:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;He was carefully disguised but captured quickly by police.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\w+ly\b&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
<span class="go">07-16: carefully</span>
<span class="go">40-47: quickly</span>
</pre></div>
</div>
</section>
<section id="raw-string-notation">
<h3>날 문자열 표기법<a class="headerlink" href="re.html#raw-string-notation" title="Link to this heading">¶</a></h3>
<p>날 문자열 표기법(<code class="docutils literal notranslate"><span class="pre">r&quot;text&quot;</span></code>)은 정규식을 합리적인 상태로 유지합니다. 이것 없이는, 정규식의 모든 역 슬래시(<code class="docutils literal notranslate"><span class="pre">'\'</span></code>)를 이스케이프 하기 위해 그 앞에 또 하나의 역 슬래시를 붙여야 합니다. 예를 들어, 다음 두 코드 줄은 기능상으로 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\W(.)\1\W&quot;</span><span class="p">,</span> <span class="s2">&quot; ff &quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 4), match=&#39; ff &#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">W(.)</span><span class="se">\\</span><span class="s2">1</span><span class="se">\\</span><span class="s2">W&quot;</span><span class="p">,</span> <span class="s2">&quot; ff &quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 4), match=&#39; ff &#39;&gt;</span>
</pre></div>
</div>
<p>리터럴 역 슬래시와 일치시키려면, 정규식에서 이스케이프 되어야 합니다. 날 문자열 표기법을 사용하면, <code class="docutils literal notranslate"><span class="pre">r&quot;\\&quot;</span></code>이 됩니다. 날 문자열 표기법을 사용하지 않으면, <code class="docutils literal notranslate"><span class="pre">&quot;\\\\&quot;</span></code>를 사용해야 하는데, 다음 코드 줄들은 기능적으로 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;\\&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;\\&#39;&gt;</span>
</pre></div>
</div>
</section>
<section id="writing-a-tokenizer">
<h3>토크나이저 작성하기<a class="headerlink" href="re.html#writing-a-tokenizer" title="Link to this heading">¶</a></h3>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Lexical_analysis">토크나이저나 스캐너</a>는 문자열을 분석하여 문자 그룹을 분류합니다. 이것은 컴파일러나 인터프리터를 작성하는 데 유용한 첫 번째 단계입니다.</p>
<p>텍스트 범주는 정규식으로 지정됩니다. 이 기법은 이들을 하나의 마스터 정규식으로 결합하고 연속적인 일치를 반복하는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NamedTuple</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="k">class</span> <span class="nc">Token</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">line</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">column</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
    <span class="n">keywords</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="s1">&#39;FOR&#39;</span><span class="p">,</span> <span class="s1">&#39;NEXT&#39;</span><span class="p">,</span> <span class="s1">&#39;GOSUB&#39;</span><span class="p">,</span> <span class="s1">&#39;RETURN&#39;</span><span class="p">}</span>
    <span class="n">token_specification</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;NUMBER&#39;</span><span class="p">,</span>   <span class="sa">r</span><span class="s1">&#39;\d+(\.\d*)?&#39;</span><span class="p">),</span>  <span class="c1"># Integer or decimal number</span>
        <span class="p">(</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span>   <span class="sa">r</span><span class="s1">&#39;:=&#39;</span><span class="p">),</span>           <span class="c1"># Assignment operator</span>
        <span class="p">(</span><span class="s1">&#39;END&#39;</span><span class="p">,</span>      <span class="sa">r</span><span class="s1">&#39;;&#39;</span><span class="p">),</span>            <span class="c1"># Statement terminator</span>
        <span class="p">(</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span>       <span class="sa">r</span><span class="s1">&#39;[A-Za-z]+&#39;</span><span class="p">),</span>    <span class="c1"># Identifiers</span>
        <span class="p">(</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span>       <span class="sa">r</span><span class="s1">&#39;[+\-*/]&#39;</span><span class="p">),</span>      <span class="c1"># Arithmetic operators</span>
        <span class="p">(</span><span class="s1">&#39;NEWLINE&#39;</span><span class="p">,</span>  <span class="sa">r</span><span class="s1">&#39;\n&#39;</span><span class="p">),</span>           <span class="c1"># Line endings</span>
        <span class="p">(</span><span class="s1">&#39;SKIP&#39;</span><span class="p">,</span>     <span class="sa">r</span><span class="s1">&#39;[ \t]+&#39;</span><span class="p">),</span>       <span class="c1"># Skip over spaces and tabs</span>
        <span class="p">(</span><span class="s1">&#39;MISMATCH&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;.&#39;</span><span class="p">),</span>            <span class="c1"># Any other character</span>
    <span class="p">]</span>
    <span class="n">tok_regex</span> <span class="o">=</span> <span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;(?P&lt;</span><span class="si">%s</span><span class="s1">&gt;</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">token_specification</span><span class="p">)</span>
    <span class="n">line_num</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">line_start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">mo</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">tok_regex</span><span class="p">,</span> <span class="n">code</span><span class="p">):</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">lastgroup</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">-</span> <span class="n">line_start</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;NUMBER&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">value</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;ID&#39;</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span><span class="p">:</span>
            <span class="n">line_start</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="n">line_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;SKIP&#39;</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;MISMATCH&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s1"> unexpected on line </span><span class="si">{</span><span class="n">line_num</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">Token</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">line_num</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>

<span class="n">statements</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    IF quantity THEN</span>
<span class="s1">        total := total + price * quantity;</span>
<span class="s1">        tax := price * 0.05;</span>
<span class="s1">    ENDIF;</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">statements</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
</pre></div>
</div>
<p>토크나이저는 다음과 같은 출력을 생성합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;quantity&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;:=&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">17</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;quantity&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">33</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">41</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;tax&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;:=&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;NUMBER&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">27</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<div role="list" class="citation-list">
<div class="citation" id="frie09" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="re.html#id1">Frie09</a><span class="fn-bracket">]</span></span>
<p>Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O’Reilly Media, 2009. 이 책의 세 번째 판은 더는 파이썬을 다루지 않지만, 초판은 훌륭한 정규식 패턴 작성을 아주 자세하게 다루었습니다.</p>
</div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="re.html#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Regular expression operations</a><ul>
<li><a class="reference internal" href="re.html#regular-expression-syntax">정규식 문법</a></li>
<li><a class="reference internal" href="re.html#module-contents">모듈 내용</a><ul>
<li><a class="reference internal" href="re.html#flags">Flags</a></li>
<li><a class="reference internal" href="re.html#functions">Functions</a></li>
<li><a class="reference internal" href="re.html#exceptions">Exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="re.html#regular-expression-objects">정규식 객체</a></li>
<li><a class="reference internal" href="re.html#match-objects">일치 객체</a></li>
<li><a class="reference internal" href="re.html#regular-expression-examples">정규식 예제</a><ul>
<li><a class="reference internal" href="re.html#checking-for-a-pair">쌍 검사하기</a></li>
<li><a class="reference internal" href="re.html#simulating-scanf">scanf() 시뮬레이션</a></li>
<li><a class="reference internal" href="re.html#search-vs-match">search() 대 match()</a></li>
<li><a class="reference internal" href="re.html#making-a-phonebook">전화번호부 만들기</a></li>
<li><a class="reference internal" href="re.html#text-munging">텍스트 뒤섞기</a></li>
<li><a class="reference internal" href="re.html#finding-all-adverbs">모든 부사 찾기</a></li>
<li><a class="reference internal" href="re.html#finding-all-adverbs-and-their-positions">모든 부사와 그 위치 찾기</a></li>
<li><a class="reference internal" href="re.html#raw-string-notation">날 문자열 표기법</a></li>
<li><a class="reference internal" href="re.html#writing-a-tokenizer">토크나이저 작성하기</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="string.html"
                          title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code> — Common string operations</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="difflib.html"
                          title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code> — Helpers for computing deltas</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/re.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="사이드바 닫기">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="difflib.html" title="difflib — Helpers for computing deltas"
             >다음</a> |</li>
        <li class="right" >
          <a href="string.html" title="string — Common string operations"
             >이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="text.html" >텍스트 처리 서비스</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="re.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Regular expression operations</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    저작권
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="../../../license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      최종 업데이트: Jun 09, 2024 (17:23 UTC)
    
      <a href="../../../bugs.html">Found a bug</a>?
    
    <br />

    <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7 버전으로 생성되었습니다.
    </div>

    <script type="text/javascript" src="../_static/switchers.js"></script>
  </body>
</html>