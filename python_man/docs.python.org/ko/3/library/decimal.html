<!DOCTYPE html>

<html lang="ko" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="decimal — Decimal fixed point and floating point arithmetic" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/decimal.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="소스 코드: Lib/decimal.py The decimal module provides support for fast correctly rounded decimal floating point arithmetic. It offers several advantages over the float datatype: Decimal “은 사람을 염두에 두고 설..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="소스 코드: Lib/decimal.py The decimal module provides support for fast correctly rounded decimal floating point arithmetic. It offers several advantages over the float datatype: Decimal “은 사람을 염두에 두고 설..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>decimal — Decimal fixed point and floating point arithmetic &#8212; Python 3.12.4 문서</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css%3Fv=80d5e7a1.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css%3Fv=bb723527.css" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css%3Fv=b20cc3f5.css" />
    
    <script src="../_static/documentation_options.js%3Fv=3050f571"></script>
    <script src="../_static/doctools.js%3Fv=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js%3Fv=dc90522c"></script>
    <script src="../_static/translations.js%3Fv=b5f768d8"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.12.4 문서에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="fractions — Rational numbers" href="fractions.html" />
    <link rel="prev" title="cmath — Mathematical functions for complex numbers" href="cmath.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="../../../3/library/decimal.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" />
                <input type="submit" value="이동"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="decimal.html#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code> — Decimal fixed point and floating point arithmetic</a><ul>
<li><a class="reference internal" href="decimal.html#quick-start-tutorial">빠른 시작 자습서</a></li>
<li><a class="reference internal" href="decimal.html#decimal-objects">Decimal 객체</a><ul>
<li><a class="reference internal" href="decimal.html#logical-operands">논리적 피연산자</a></li>
</ul>
</li>
<li><a class="reference internal" href="decimal.html#context-objects">Context 객체</a></li>
<li><a class="reference internal" href="decimal.html#constants">상수</a></li>
<li><a class="reference internal" href="decimal.html#rounding-modes">자리 올림 모드</a></li>
<li><a class="reference internal" href="decimal.html#signals">신호</a></li>
<li><a class="reference internal" href="decimal.html#floating-point-notes">부동 소수점 노트</a><ul>
<li><a class="reference internal" href="decimal.html#mitigating-round-off-error-with-increased-precision">증가시킨 정밀도로 자리 올림 오차 줄이기</a></li>
<li><a class="reference internal" href="decimal.html#special-values">특수 값</a></li>
</ul>
</li>
<li><a class="reference internal" href="decimal.html#working-with-threads">스레드로 작업하기</a></li>
<li><a class="reference internal" href="decimal.html#recipes">조리법</a></li>
<li><a class="reference internal" href="decimal.html#decimal-faq">Decimal FAQ</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="cmath.html"
                          title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code> — Mathematical functions for complex numbers</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="fractions.html"
                          title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions</span></code> — Rational numbers</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/decimal.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="fractions.html" title="fractions — Rational numbers"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="cmath.html" title="cmath — Mathematical functions for complex numbers"
             accesskey="P">이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="numeric.html" accesskey="U">숫자와 수학 모듈</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="decimal.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code> — Decimal fixed point and floating point arithmetic</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-decimal">
<span id="decimal-decimal-fixed-point-and-floating-point-arithmetic"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code> — Decimal fixed point and floating point arithmetic<a class="headerlink" href="decimal.html#module-decimal" title="Link to this heading">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/decimal.py">Lib/decimal.py</a></p>
<hr class="docutils" />
<p>The <a class="reference internal" href="decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> module provides support for fast correctly rounded
decimal floating point arithmetic. It offers several advantages over the
<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> datatype:</p>
<ul>
<li><p>Decimal “은 사람을 염두에 두고 설계된 부동 소수점 모델에 기반하고, 필연적으로 최고 원리를 갖습니다 – 컴퓨터는 사람들이 학교에서 배우는 산술과 같은 방식으로 동작하는 산술을 반드시 제공해야 한다.” – 십진 산술 명세에서 발췌.</p></li>
<li><p>Decimal numbers can be represented exactly.  In contrast, numbers like
<code class="docutils literal notranslate"><span class="pre">1.1</span></code> and <code class="docutils literal notranslate"><span class="pre">2.2</span></code> do not have exact representations in binary
floating point. End users typically would not expect <code class="docutils literal notranslate"><span class="pre">1.1</span> <span class="pre">+</span> <span class="pre">2.2</span></code> to display
as <code class="docutils literal notranslate"><span class="pre">3.3000000000000003</span></code> as it does with binary floating point.</p></li>
<li><p>The exactness carries over into arithmetic.  In decimal floating point, <code class="docutils literal notranslate"><span class="pre">0.1</span>
<span class="pre">+</span> <span class="pre">0.1</span> <span class="pre">+</span> <span class="pre">0.1</span> <span class="pre">-</span> <span class="pre">0.3</span></code> is exactly equal to zero.  In binary floating point, the result
is <code class="docutils literal notranslate"><span class="pre">5.5511151231257827e-017</span></code>.  While near to zero, the differences
prevent reliable equality testing and differences can accumulate. For this
reason, decimal is preferred in accounting applications which have strict
equality invariants.</p></li>
<li><p>The decimal module incorporates a notion of significant places so that <code class="docutils literal notranslate"><span class="pre">1.30</span>
<span class="pre">+</span> <span class="pre">1.20</span></code> is <code class="docutils literal notranslate"><span class="pre">2.50</span></code>.  The trailing zero is kept to indicate significance.
This is the customary presentation for monetary applications. For
multiplication, the “schoolbook” approach uses all the figures in the
multiplicands.  For instance, <code class="docutils literal notranslate"><span class="pre">1.3</span> <span class="pre">*</span> <span class="pre">1.2</span></code> gives <code class="docutils literal notranslate"><span class="pre">1.56</span></code> while <code class="docutils literal notranslate"><span class="pre">1.30</span> <span class="pre">*</span>
<span class="pre">1.20</span></code> gives <code class="docutils literal notranslate"><span class="pre">1.5600</span></code>.</p></li>
<li><p>하드웨어 기반 이진 부동 소수점과는 달리, decimal 모듈은 사용자가 변경할 수 있는 정밀도(기본값은 28자리)를 가지며, 주어진 문제에 따라 필요한 만큼 커질 수 있습니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.1428571428571428571428571429&#39;)</span>
</pre></div>
</div>
</li>
<li><p>이진 및 십진 부동 소수점 모두 출판된 표준에 따라 구현됩니다. 내장 float 형이 기능의 적당한 부분만을 드러내지만, decimal 모듈은 표준의 모든 필수 부분을 노출합니다. 필요한 경우, 프로그래머는 자리 올림(rounding) 및 신호(signal) 처리를 완전히 제어할 수 있습니다. 여기에는 정확하지 않은 연산을 차단하기 위한 예외를 사용하여 정확한 산술을 강제하는 옵션이 포함됩니다.</p></li>
<li><p>decimal 모듈은 “편견 없이, (때로 고정 소수점 산술이라고도 불리는) 정확한 자리 올림 없는 십진 산술과 자리 올림 있는 부동 소수점 산술을 모두” 지원하도록 설계되었습니다. – 십진 산술 명세에서 발췌.</p></li>
</ul>
<p>모듈 설계의 중심 개념은 세 가지입니다: 십진수, 산술을 위한 컨텍스트, 신호(signal).</p>
<p>A decimal number is immutable.  It has a sign, coefficient digits, and an
exponent.  To preserve significance, the coefficient digits do not truncate
trailing zeros.  Decimals also include special values such as
<code class="docutils literal notranslate"><span class="pre">Infinity</span></code>, <code class="docutils literal notranslate"><span class="pre">-Infinity</span></code>, and <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.  The standard also
differentiates <code class="docutils literal notranslate"><span class="pre">-0</span></code> from <code class="docutils literal notranslate"><span class="pre">+0</span></code>.</p>
<p>산술 컨텍스트는 정밀도, 자리 올림 규칙, 지수에 대한 제한, 연산 결과를 나타내는 플래그 및 신호가 예외로 처리될지를 결정하는 트랩 활성화기(trap enabler)를 지정하는 환경입니다. 자리 올림 옵션에는 <a class="reference internal" href="decimal.html#decimal.ROUND_CEILING" title="decimal.ROUND_CEILING"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_CEILING</span></code></a>, <a class="reference internal" href="decimal.html#decimal.ROUND_DOWN" title="decimal.ROUND_DOWN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_DOWN</span></code></a>, <a class="reference internal" href="decimal.html#decimal.ROUND_FLOOR" title="decimal.ROUND_FLOOR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_FLOOR</span></code></a>, <a class="reference internal" href="decimal.html#decimal.ROUND_HALF_DOWN" title="decimal.ROUND_HALF_DOWN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_DOWN</span></code></a>, <a class="reference internal" href="decimal.html#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>, <a class="reference internal" href="decimal.html#decimal.ROUND_HALF_UP" title="decimal.ROUND_HALF_UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_UP</span></code></a>, <a class="reference internal" href="decimal.html#decimal.ROUND_UP" title="decimal.ROUND_UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_UP</span></code></a> 및 <a class="reference internal" href="decimal.html#decimal.ROUND_05UP" title="decimal.ROUND_05UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_05UP</span></code></a> 가 있습니다.</p>
<p>신호는 계산 과정에서 발생하는 예외적인 조건의 그룹입니다. 응용 프로그램의 필요에 따라, 신호가 무시되거나, 정보로 간주하거나, 예외로 처리될 수 있습니다. decimal 모듈의 신호는 <a class="reference internal" href="decimal.html#decimal.Clamped" title="decimal.Clamped"><code class="xref py py-const docutils literal notranslate"><span class="pre">Clamped</span></code></a>, <a class="reference internal" href="decimal.html#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a>, <a class="reference internal" href="decimal.html#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-const docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a>, <a class="reference internal" href="decimal.html#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a>, <a class="reference internal" href="decimal.html#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a>, <a class="reference internal" href="decimal.html#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-const docutils literal notranslate"><span class="pre">Subnormal</span></code></a>, <a class="reference internal" href="decimal.html#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-const docutils literal notranslate"><span class="pre">Overflow</span></code></a>, <a class="reference internal" href="decimal.html#decimal.Underflow" title="decimal.Underflow"><code class="xref py py-const docutils literal notranslate"><span class="pre">Underflow</span></code></a>, <a class="reference internal" href="decimal.html#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> 입니다.</p>
<p>각 신호에는 플래그와 트랩 활성화기가 있습니다. 신호와 만났을 때, 플래그가 1로 설정되고 트랩 활성화기가 1로 설정된 경우, 예외가 발생합니다. 플래그는 상태가 유지되므로(sticky) 계산을 감시하기 전에 재설정할 필요가 있습니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<ul class="simple">
<li><p>IBM’s General Decimal Arithmetic Specification, <a class="reference external" href="https://speleotrove.com/decimal/decarith.html">The General Decimal Arithmetic
Specification</a>.</p></li>
</ul>
</div>
<section id="quick-start-tutorial">
<span id="decimal-tutorial"></span><h2>빠른 시작 자습서<a class="headerlink" href="decimal.html#quick-start-tutorial" title="Link to this heading">¶</a></h2>
<p>decimal을 사용하는 일반적인 시작은 모듈을 임포트하고, <a class="reference internal" href="decimal.html#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 로 현재 컨텍스트를 보고, 필요하다면 정밀도, 자리 올림 또는 활성화된 트랩에 대해 새 값을 설정하는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span>
<span class="go">Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[], traps=[Overflow, DivisionByZero,</span>
<span class="go">        InvalidOperation])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">7</span>       <span class="c1"># Set a new precision</span>
</pre></div>
</div>
<p>Decimal instances can be constructed from integers, strings, floats, or tuples.
Construction from an integer or a float performs an exact conversion of the
value of that integer or float.  Decimal numbers include special values such as
<code class="docutils literal notranslate"><span class="pre">NaN</span></code> which stands for “Not a number”, positive and negative
<code class="docutils literal notranslate"><span class="pre">Infinity</span></code>, and <code class="docutils literal notranslate"><span class="pre">-0</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">Decimal(&#39;10&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.14&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.14&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.140000000000000124344978758017532527446746826171875&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Decimal(&#39;3.14&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="go">Decimal(&#39;1.4142135623730951&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.5&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.414213562373095048801688724&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;NaN&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-Infinity&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;-Infinity&#39;)</span>
</pre></div>
</div>
<p><a class="reference internal" href="decimal.html#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> 신호를 트랩 하는 경우, 실수로 생성자나 대소비교에서 Decimal 수와 실수(float)를 혼합하면 예외가 발생합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">getcontext</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">FloatOperation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.FloatOperation</span>: <span class="n">[&lt;class &#39;decimal.FloatOperation&#39;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.5&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">3.7</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.FloatOperation</span>: <span class="n">[&lt;class &#39;decimal.FloatOperation&#39;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.5&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mf">3.5</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<p>새로운 Decimal의 유효 숫자는 입력된 숫자의 개수에 의해서만 결정됩니다. 컨텍스트 정밀도 및 자리 올림은 오직 산술 연산 중에만 작용합니다.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.0&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.1415926535&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.7182818285&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.85987&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">rounding</span> <span class="o">=</span> <span class="n">ROUND_UP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.7182818285&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.85988&#39;)</span>
</pre></div>
</div>
<p>C 버전의 내부 제한을 초과하면, Decimal 을 만들 때 <a class="reference internal" href="decimal.html#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> 를 일으킵니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;1e9999999999999999999&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.InvalidOperation</span>: <span class="n">[&lt;class &#39;decimal.InvalidOperation&#39;&gt;]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경.</span></p>
</div>
<p>Decimal은 파이썬의 다른 부분들과 잘 어울립니다. 다음은 십진 부동 소수점으로 부린 작은 묘기입니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="s1">&#39;1.34 1.87 3.45 2.35 1.00 0.03 9.25&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;9.25&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">[Decimal(&#39;0.03&#39;), Decimal(&#39;1.00&#39;), Decimal(&#39;1.34&#39;), Decimal(&#39;1.87&#39;),</span>
<span class="go"> Decimal(&#39;2.35&#39;), Decimal(&#39;3.45&#39;), Decimal(&#39;9.25&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;19.29&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;1.34&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.34</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.3&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="mi">5</span>
<span class="go">Decimal(&#39;6.70&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="go">Decimal(&#39;2.5058&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">%</span> <span class="n">a</span>
<span class="go">Decimal(&#39;0.77&#39;)</span>
</pre></div>
</div>
<p>그리고 Decimal에는 몇 가지 수학 함수도 있습니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
<span class="go">Decimal(&#39;1.414213562373095048801688724&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.718281828459045235360287471&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ln</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.302585092994045684017991455&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">log10</span><span class="p">()</span>
<span class="go">Decimal(&#39;1&#39;)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="decimal.html#decimal.Decimal.quantize" title="decimal.Decimal.quantize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code></a> method rounds a number to a fixed exponent.  This method is
useful for monetary applications that often round results to a fixed number of
places:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.325&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;.01&#39;</span><span class="p">),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span>
<span class="go">Decimal(&#39;7.32&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.325&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.&#39;</span><span class="p">),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_UP</span><span class="p">)</span>
<span class="go">Decimal(&#39;8&#39;)</span>
</pre></div>
</div>
<p>위에서 보듯이, <a class="reference internal" href="decimal.html#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 함수는 현재 컨텍스트에 액세스하고 설정을 변경할 수 있게 합니다. 이 방법은 대부분 응용 프로그램의 요구를 충족시킵니다.</p>
<p>고급 작업을 위해, Context() 생성자를 사용하여 대체 컨텍스트를 만드는 것이 유용할 수 있습니다. 대체 컨텍스트를 활성화하려면, <a class="reference internal" href="decimal.html#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a> 함수를 사용하십시오.</p>
<p>표준에 따라, <a class="reference internal" href="decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> 모듈은 당장 사용할 수 있는 두 개의 표준 컨텍스트 <a class="reference internal" href="decimal.html#decimal.BasicContext" title="decimal.BasicContext"><code class="xref py py-const docutils literal notranslate"><span class="pre">BasicContext</span></code></a> 와 <a class="reference internal" href="decimal.html#decimal.ExtendedContext" title="decimal.ExtendedContext"><code class="xref py py-const docutils literal notranslate"><span class="pre">ExtendedContext</span></code></a> 를 제공합니다. 특히 전자는 많은 트랩이 활성화되어있어 디버깅에 유용합니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">myothercontext</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_HALF_DOWN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">myothercontext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857142857142857142857142857142857142857142857142857142857&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ExtendedContext</span>
<span class="go">Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[], traps=[])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857143&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">BasicContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#143&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">-toplevel-</span>
<span class="w">    </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">DivisionByZero</span>: <span class="n">x / 0</span>
</pre></div>
</div>
<p>Contexts also have signal flags for monitoring exceptional conditions
encountered during computations.  The flags remain set until explicitly cleared,
so it is best to clear the flags before each set of monitored computations by
using the <a class="reference internal" href="decimal.html#decimal.Context.clear_flags" title="decimal.Context.clear_flags"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clear_flags()</span></code></a> method.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">clear_flags</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">355</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">113</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.14159292&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span>
<span class="go">Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[])</span>
</pre></div>
</div>
<p>The <em>flags</em> entry shows that the rational approximation to pi was
rounded (digits beyond the context precision were thrown away) and that the
result is inexact (some of the discarded digits were non-zero).</p>
<p>Individual traps are set using the dictionary in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">traps</span></code>
attribute of a context:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">DivisionByZero</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#112&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">-toplevel-</span>
<span class="w">    </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">DivisionByZero</span>: <span class="n">x / 0</span>
</pre></div>
</div>
<p>대부분 프로그램은 프로그램 시작 시에 한 번만 현재 컨텍스트를 조정합니다. 그리고, 많은 응용 프로그램에서, 데이터는 루프 내에서 단일형변환으로 <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>로 변환되어, 프로그램 대부분은 다른 파이썬 숫자 형과 별로 다르지 않게 데이터를 조작합니다.</p>
</section>
<section id="decimal-objects">
<span id="decimal-decimal"></span><h2>Decimal 객체<a class="headerlink" href="decimal.html#decimal-objects" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decimal.Decimal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Decimal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'0'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal" title="Link to this definition">¶</a></dt>
<dd><p><em>value</em> 를 기반으로 새 <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 객체를 만듭니다.</p>
<p><em>value</em> 는 정수, 문자열, 튜플, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 또는 다른 <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 객체일 수 있습니다. <em>value</em> 가 주어지지 않으면, <code class="docutils literal notranslate"><span class="pre">Decimal('0')</span></code> 을 반환합니다. <em>value</em> 가 문자열이면, 앞뒤의 공백 문자 및 밑줄이 제거된 후 십진수 문자열 문법에 맞아야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sign</span>           <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;+&#39;</span> <span class="o">|</span> <span class="s1">&#39;-&#39;</span>
<span class="n">digit</span>          <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;0&#39;</span> <span class="o">|</span> <span class="s1">&#39;1&#39;</span> <span class="o">|</span> <span class="s1">&#39;2&#39;</span> <span class="o">|</span> <span class="s1">&#39;3&#39;</span> <span class="o">|</span> <span class="s1">&#39;4&#39;</span> <span class="o">|</span> <span class="s1">&#39;5&#39;</span> <span class="o">|</span> <span class="s1">&#39;6&#39;</span> <span class="o">|</span> <span class="s1">&#39;7&#39;</span> <span class="o">|</span> <span class="s1">&#39;8&#39;</span> <span class="o">|</span> <span class="s1">&#39;9&#39;</span>
<span class="n">indicator</span>      <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;e&#39;</span> <span class="o">|</span> <span class="s1">&#39;E&#39;</span>
<span class="n">digits</span>         <span class="p">:</span><span class="o">:=</span>  <span class="n">digit</span> <span class="p">[</span><span class="n">digit</span><span class="p">]</span><span class="o">...</span>
<span class="n">decimal</span><span class="o">-</span><span class="n">part</span>   <span class="p">:</span><span class="o">:=</span>  <span class="n">digits</span> <span class="s1">&#39;.&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span> <span class="o">|</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span><span class="p">]</span> <span class="n">digits</span>
<span class="n">exponent</span><span class="o">-</span><span class="n">part</span>  <span class="p">:</span><span class="o">:=</span>  <span class="n">indicator</span> <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">digits</span>
<span class="n">infinity</span>       <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;Infinity&#39;</span> <span class="o">|</span> <span class="s1">&#39;Inf&#39;</span>
<span class="n">nan</span>            <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;NaN&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span> <span class="o">|</span> <span class="s1">&#39;sNaN&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span>
<span class="n">numeric</span><span class="o">-</span><span class="n">value</span>  <span class="p">:</span><span class="o">:=</span>  <span class="n">decimal</span><span class="o">-</span><span class="n">part</span> <span class="p">[</span><span class="n">exponent</span><span class="o">-</span><span class="n">part</span><span class="p">]</span> <span class="o">|</span> <span class="n">infinity</span>
<span class="n">numeric</span><span class="o">-</span><span class="n">string</span> <span class="p">:</span><span class="o">:=</span>  <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">numeric</span><span class="o">-</span><span class="n">value</span> <span class="o">|</span> <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">nan</span>
</pre></div>
</div>
<p>위의 <code class="docutils literal notranslate"><span class="pre">digit</span></code> 가 나타나는 곳에는 다른 유니코드 십진수도 허용됩니다. 여기에는 다양한 다른 알파벳(예를 들어, 인도-아라비아와 데바나가리 숫자)의 십진수와 전각 숫자 <code class="docutils literal notranslate"><span class="pre">'\uff10'</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">'\uff19'</span></code> 까지 포함됩니다.</p>
<p>If <em>value</em> is a <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, it should have three components, a sign
(<code class="docutils literal notranslate"><span class="pre">0</span></code> for positive or <code class="docutils literal notranslate"><span class="pre">1</span></code> for negative), a <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of
digits, and an integer exponent. For example, <code class="docutils literal notranslate"><span class="pre">Decimal((0,</span> <span class="pre">(1,</span> <span class="pre">4,</span> <span class="pre">1,</span> <span class="pre">4),</span> <span class="pre">-3))</span></code>
returns <code class="docutils literal notranslate"><span class="pre">Decimal('1.414')</span></code>.</p>
<p><em>value</em> 가 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 면, 이진 부동 소수점 값은 손실 없이 정확한 십진수로 변환됩니다. 이 변환에는 종종 53자리 이상의 정밀도가 필요할 수 있습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">Decimal(float('1.1'))</span></code> 은 <code class="docutils literal notranslate"><span class="pre">Decimal('1.100000000000000088817841970012523233890533447265625')</span></code> 로 변환됩니다.</p>
<p><em>context</em> 정밀도는 저장되는 자릿수에 영향을 주지 않습니다. 저장되는 자릿수는 <em>value</em> 의 자릿수만으로 결정됩니다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">Decimal('3.00000')</span></code> 은 컨텍스트 정밀도가 단지 3이라도 5개의 모든 0을 기록합니다.</p>
<p>The purpose of the <em>context</em> argument is determining what to do if <em>value</em> is a
malformed string.  If the context traps <a class="reference internal" href="decimal.html#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a>, an exception
is raised; otherwise, the constructor returns a new Decimal with the value of
<code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p>
<p>일단 만들어지면, <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 객체는 불변입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>생성자에 대한 인자는 이제 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 인스턴스가 될 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 인자는 <a class="reference internal" href="decimal.html#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> 트랩이 설정되면 예외를 발생시킵니다. 기본적으로 트랩은 꺼져 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>코드에서의 정수와 부동 소수점 리터럴과 마찬가지로, 밑줄로 무리 지을 수 있습니다.</p>
</div>
<p>십진 부동 소수점 객체는 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>나 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>와 같은 다른 내장 숫자 형과 많은 성질을 공유합니다. 일반적인 수학 연산과 특수 메서드가 모두 적용됩니다. 마찬가지로, 십진 객체는 복사, 피클, 인쇄, 딕셔너리 키로 사용, 집합 원소로 사용, 비교, 정렬 및 다른 형(가령 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 또는 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>)으로 코어션될 수 있습니다.</p>
<p>Decimal 객체에 대한 산술과 정수 및 실수에 대한 산술에는 약간의 차이가 있습니다. Decimal 객체에 나머지 연산자 <code class="docutils literal notranslate"><span class="pre">%</span></code> 가 적용될 때, 결과의 부호는 제수의 부호가 아닌 <em>피제수</em>의 부호가 됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">%</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Decimal(&#39;-3&#39;)</span>
</pre></div>
</div>
<p>정수 나눗셈 연산자 <code class="docutils literal notranslate"><span class="pre">//</span></code> 의 동작 역시 비슷한 차이를 보입니다. 즉, 가장 가까운 정수로 내림하는 대신 실제 몫의 정수 부(0을 향해 자르기)를 돌려줍니다. 그래서 일반적인 항등식 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y)</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code> 를 유지합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="mi">7</span> <span class="o">//</span> <span class="mi">4</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Decimal(&#39;-1&#39;)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">%</span></code> 와 <code class="docutils literal notranslate"><span class="pre">//</span></code> 연산자는 명세에 설명된 대로 각각 <code class="docutils literal notranslate"><span class="pre">remainder</span></code> 와 <code class="docutils literal notranslate"><span class="pre">divide-integer</span></code> 연산을 구현합니다.</p>
<p>Decimal 객체는 일반적으로 산술 연산에서 float 나 <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a> 인스턴스와 결합 할 수 없습니다: 예를 들어, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 에 a <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>을 더하려고 하면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으킵니다. 그러나, 파이썬의 비교 연산자를 사용하여 <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스 <code class="docutils literal notranslate"><span class="pre">x</span></code> 와 다른 숫자 <code class="docutils literal notranslate"><span class="pre">y</span></code> 를 비교할 수 있습니다. 이렇게 해서 서로 다른 형의 숫자 간에 동등 비교를 할 때 혼란스러운 결과를 피합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스와 다른 숫자 형 사이의 혼합형 비교가 이제 완전히 지원됩니다.</p>
</div>
<p>표준 숫자 속성에 더해, 십진 부동 소수점 객체에는 여러 가지 특별한 메서드가 있습니다:</p>
<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.adjusted">
<span class="sig-name descname"><span class="pre">adjusted</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.adjusted" title="Link to this definition">¶</a></dt>
<dd><p>최상위 숫자만 남을 때까지 계수의 가장 오른쪽 숫자들을 밀어내도록 조정된 지수를 반환합니다. <code class="docutils literal notranslate"><span class="pre">Decimal('321e+5').adjusted()</span></code> 는 7을 반환합니다. 소수점으로부터의 최상위 유효 숫자의 위치를 결정하는 데 사용됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.as_integer_ratio">
<span class="sig-name descname"><span class="pre">as_integer_ratio</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.as_integer_ratio" title="Link to this definition">¶</a></dt>
<dd><p>주어진 <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스를, 분모가 양수인 기약 분수로 나타내는 정수의 쌍 <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code> 을 돌려줍니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-3.14&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(-157, 50)</span>
</pre></div>
</div>
<p>변환은 정확합니다. 무한대는 OverflowError를, NaN 은 ValueError를 일으킵니다.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.as_tuple">
<span class="sig-name descname"><span class="pre">as_tuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.as_tuple" title="Link to this definition">¶</a></dt>
<dd><p>숫자의 <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a> 표현을 반환합니다: <code class="docutils literal notranslate"><span class="pre">DecimalTuple(sign,</span> <span class="pre">digits,</span> <span class="pre">exponent)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.canonical">
<span class="sig-name descname"><span class="pre">canonical</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.canonical" title="Link to this definition">¶</a></dt>
<dd><p>인자의 규범적인 인코딩을 돌려줍니다. 현재 <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스의 인코딩은 항상 규범적이므로, 이 연산은 인자를 변경하지 않고 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.compare">
<span class="sig-name descname"><span class="pre">compare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.compare" title="Link to this definition">¶</a></dt>
<dd><p>두 Decimal 인스턴스의 값을 비교합니다. <a class="reference internal" href="decimal.html#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a> 는 Decimal 인스턴스를 반환하고, 피연산자 중 하나가 NaN이면 결과는 NaN입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="ow">or</span> <span class="n">b</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">NaN</span>  <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>            <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-1&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">==</span> <span class="n">b</span>           <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>            <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.compare_signal">
<span class="sig-name descname"><span class="pre">compare_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.compare_signal" title="Link to this definition">¶</a></dt>
<dd><p>이 연산은, 모든 NaN 이 신호를 준다는 것을 제외하면 <a class="reference internal" href="decimal.html#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a> 메서드와 같습니다. 즉, 피연산자가 모두 신호를 주는 NaN이 아니면, 모든 조용한 NaN 피연산자가 마치 신호를 주는 NaN 인 것처럼 처리됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.compare_total">
<span class="sig-name descname"><span class="pre">compare_total</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.compare_total" title="Link to this definition">¶</a></dt>
<dd><p>두 개의 피연산자를 숫자 값 대신 추상 표현을 사용하여 비교합니다. <a class="reference internal" href="decimal.html#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a> 메서드와 비슷하지만, 결과는 <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스에 대해 전 순서(total ordering)를 부여합니다. 같은 숫자 값을 갖지만 다른 표현의 두 <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스는 이 순서에 의해 다른 것으로 비교됩니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;12.0&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">compare_total</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;12&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-1&#39;)</span>
</pre></div>
</div>
<p>조용한 NaN과 신호를 주는 NaN도 전 순서에 포함됩니다. 이 함수의 결과는, 두 피연산자가 같은 표현을 가질 때 <code class="docutils literal notranslate"><span class="pre">Decimal('0')</span></code>, 첫 번째 피연산자가 전 순서에서 두 번째 피연산자보다 낮으면 <code class="docutils literal notranslate"><span class="pre">Decimal('-1')</span></code>, 첫 번째 피연산자가 전 순서에서 두 번째 피연산자보다 높으면 <code class="docutils literal notranslate"><span class="pre">Decimal('1')</span></code> 입니다. 전 순서에 대한 세부 사항은 명세를 참조하십시오.</p>
<p>이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다. 예외적으로, 두 번째 피연산자를 정확하게 변환할 수 없으면 C 버전은 InvalidOperation을 발생시킬 수 있습니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.compare_total_mag">
<span class="sig-name descname"><span class="pre">compare_total_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.compare_total_mag" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="decimal.html#decimal.Decimal.compare_total" title="decimal.Decimal.compare_total"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare_total()</span></code></a>처럼 두 개의 피연산자를 숫자 값 대신 추상 표현을 사용하여 비교하지만, 각 피연산자의 부호를 무시합니다. <code class="docutils literal notranslate"><span class="pre">x.compare_total_mag(y)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.copy_abs().compare_total(y.copy_abs())</span></code> 와 동등합니다.</p>
<p>이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다. 예외적으로, 두 번째 피연산자를 정확하게 변환할 수 없으면 C 버전은 InvalidOperation을 발생시킬 수 있습니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.conjugate">
<span class="sig-name descname"><span class="pre">conjugate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.conjugate" title="Link to this definition">¶</a></dt>
<dd><p>그냥 self를 돌려줍니다. 이 메서드는 Decimal 명세를 준수하기 위한 것뿐입니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.copy_abs">
<span class="sig-name descname"><span class="pre">copy_abs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.copy_abs" title="Link to this definition">¶</a></dt>
<dd><p>인자의 절댓값을 반환합니다. 이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.copy_negate">
<span class="sig-name descname"><span class="pre">copy_negate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.copy_negate" title="Link to this definition">¶</a></dt>
<dd><p>인자의 음의 부정을 돌려줍니다. 이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.copy_sign">
<span class="sig-name descname"><span class="pre">copy_sign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.copy_sign" title="Link to this definition">¶</a></dt>
<dd><p>두 번째 피연산자의 부호와 같은 부호로 설정된 첫 번째 피연산자의 복사본을 반환합니다. 예를 들어:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">copy_sign</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-1.5&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-2.3&#39;)</span>
</pre></div>
</div>
<p>이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다. 예외적으로, 두 번째 피연산자를 정확하게 변환할 수 없으면 C 버전은 InvalidOperation을 발생시킬 수 있습니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.exp" title="Link to this definition">¶</a></dt>
<dd><p>주어진 숫자에 대한 (자연) 지수 함수 <code class="docutils literal notranslate"><span class="pre">e**x</span></code> 의 값을 반환합니다. 결과는 <a class="reference internal" href="decimal.html#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a> 자리 올림 모드를 사용하여 올바르게 자리 올림 됩니다.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.718281828459045235360287471&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">321</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.561702493119680037517373933E+139&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.from_float">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_float</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.from_float" title="Link to this definition">¶</a></dt>
<dd><p>Alternative constructor that only accepts instances of <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> or
<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>.</p>
<p>Note <code class="docutils literal notranslate"><span class="pre">Decimal.from_float(0.1)</span></code> is not the same as <code class="docutils literal notranslate"><span class="pre">Decimal('0.1')</span></code>.
Since 0.1 is not exactly representable in binary floating point, the
value is stored as the nearest representable value which is
<code class="docutils literal notranslate"><span class="pre">0x1.999999999999ap-4</span></code>.  That equivalent value in decimal is
<code class="docutils literal notranslate"><span class="pre">0.1000000000000000055511151231257827021181583404541015625</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>파이썬 3.2 이후부터는, <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스를 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>에서 직접 생성할 수 있습니다.</p>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.1000000000000000055511151231257827021181583404541015625&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;NaN&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-Infinity&#39;)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.fma">
<span class="sig-name descname"><span class="pre">fma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">third</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.fma" title="Link to this definition">¶</a></dt>
<dd><p>합성된 곱셈-덧셈(fused multiply-add). 중간값 self*other의 자리 올림 없이 self*other+third를 반환합니다.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">Decimal(&#39;11&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_canonical">
<span class="sig-name descname"><span class="pre">is_canonical</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.is_canonical" title="Link to this definition">¶</a></dt>
<dd><p>인자가 규범적이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다. 현재 <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스는 항상 규범적이므로 이 연산은 항상 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_finite">
<span class="sig-name descname"><span class="pre">is_finite</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.is_finite" title="Link to this definition">¶</a></dt>
<dd><p>인자가 유한 수이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 인자가 무한대나 NaN 이면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_infinite">
<span class="sig-name descname"><span class="pre">is_infinite</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.is_infinite" title="Link to this definition">¶</a></dt>
<dd><p>인자가 양이나 음의 무한대면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_nan">
<span class="sig-name descname"><span class="pre">is_nan</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.is_nan" title="Link to this definition">¶</a></dt>
<dd><p>인자가 (조용한 또는 신호를 주는) NaN이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_normal">
<span class="sig-name descname"><span class="pre">is_normal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.is_normal" title="Link to this definition">¶</a></dt>
<dd><p>인자가 <em>정상(normal)</em> 유한 수이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환합니다. 인자가 0, 비정상(subnormal), 무한대 또는 NaN 이면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_qnan">
<span class="sig-name descname"><span class="pre">is_qnan</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.is_qnan" title="Link to this definition">¶</a></dt>
<dd><p>인자가 조용한 NaN이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_signed">
<span class="sig-name descname"><span class="pre">is_signed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.is_signed" title="Link to this definition">¶</a></dt>
<dd><p>인자가 음의 부호를 가지면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다. 0과 NaN 모두 부호를 가질 수 있다는 것에 유의하세요.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_snan">
<span class="sig-name descname"><span class="pre">is_snan</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.is_snan" title="Link to this definition">¶</a></dt>
<dd><p>인자가 신호를 주는 NaN이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_subnormal">
<span class="sig-name descname"><span class="pre">is_subnormal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.is_subnormal" title="Link to this definition">¶</a></dt>
<dd><p>인자가 비정상(subnormal)이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_zero">
<span class="sig-name descname"><span class="pre">is_zero</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.is_zero" title="Link to this definition">¶</a></dt>
<dd><p>인자가 (양 또는 음의) 0이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.ln">
<span class="sig-name descname"><span class="pre">ln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.ln" title="Link to this definition">¶</a></dt>
<dd><p>피연산자의 자연로그(밑 e)를 반환합니다. 결과는 <a class="reference internal" href="decimal.html#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a> 자리 올림 모드를 사용하여 올바르게 반올림됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.log10">
<span class="sig-name descname"><span class="pre">log10</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.log10" title="Link to this definition">¶</a></dt>
<dd><p>피연산자의 상용로그를 반환합니다. 결과는 <a class="reference internal" href="decimal.html#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a> 자리 올림 모드를 사용하여 올바르게 반올림됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.logb">
<span class="sig-name descname"><span class="pre">logb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.logb" title="Link to this definition">¶</a></dt>
<dd><p>0이 아닌 수의 경우, 피연산자의 조정된 지수를 <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스로 반환합니다. 피연산자가 0이면 <code class="docutils literal notranslate"><span class="pre">Decimal('-Infinity')</span></code> 가 반환되고 <a class="reference internal" href="decimal.html#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-const docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> 플래그가 발생합니다. 피연산자가 무한대면 <code class="docutils literal notranslate"><span class="pre">Decimal('Infinity')</span></code> 가 반환됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.logical_and">
<span class="sig-name descname"><span class="pre">logical_and</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.logical_and" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="decimal.html#decimal.Decimal.logical_and" title="decimal.Decimal.logical_and"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_and()</span></code></a> 는 두 개의 <em>논리적 피연산자</em>(<a class="reference internal" href="decimal.html#logical-operands-label"><span class="std std-ref">논리적 피연산자</span></a>를 보세요)를 취하는 논리적 연산입니다. 결과는 두 피연산자의 자릿수별 <code class="docutils literal notranslate"><span class="pre">and</span></code> 입니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.logical_invert">
<span class="sig-name descname"><span class="pre">logical_invert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.logical_invert" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="decimal.html#decimal.Decimal.logical_invert" title="decimal.Decimal.logical_invert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_invert()</span></code></a> 는 논리적 연산입니다. 결과는 피연산자의 자릿수별 반전입니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.logical_or">
<span class="sig-name descname"><span class="pre">logical_or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.logical_or" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="decimal.html#decimal.Decimal.logical_or" title="decimal.Decimal.logical_or"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_or()</span></code></a> 는 두 개의 <em>논리적 피연산자</em>(<a class="reference internal" href="decimal.html#logical-operands-label"><span class="std std-ref">논리적 피연산자</span></a>를 보세요)를 취하는 논리적 연산입니다. 결과는 두 피연산자의 자릿수별 <code class="docutils literal notranslate"><span class="pre">or</span></code> 입니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.logical_xor">
<span class="sig-name descname"><span class="pre">logical_xor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.logical_xor" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="decimal.html#decimal.Decimal.logical_xor" title="decimal.Decimal.logical_xor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_xor()</span></code></a>은 두 개의 <em>논리적 피연산자</em>(<a class="reference internal" href="decimal.html#logical-operands-label"><span class="std std-ref">논리적 피연산자</span></a>를 보세요)를 취하는 논리적 연산입니다. 결과는 두 피연산자의 자릿수별 배타적 or입니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.max">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.max" title="Link to this definition">¶</a></dt>
<dd><p>Like <code class="docutils literal notranslate"><span class="pre">max(self,</span> <span class="pre">other)</span></code> except that the context rounding rule is applied
before returning and that <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values are either signaled or
ignored (depending on the context and whether they are signaling or
quiet).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.max_mag">
<span class="sig-name descname"><span class="pre">max_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.max_mag" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="decimal.html#decimal.Decimal.max" title="decimal.Decimal.max"><code class="xref py py-meth docutils literal notranslate"><span class="pre">max()</span></code></a>와 비슷하지만, 피연산자의 절댓값을 사용하여 비교가 이루어집니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.min">
<span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.min" title="Link to this definition">¶</a></dt>
<dd><p>Like <code class="docutils literal notranslate"><span class="pre">min(self,</span> <span class="pre">other)</span></code> except that the context rounding rule is applied
before returning and that <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values are either signaled or
ignored (depending on the context and whether they are signaling or
quiet).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.min_mag">
<span class="sig-name descname"><span class="pre">min_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.min_mag" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="decimal.html#decimal.Decimal.min" title="decimal.Decimal.min"><code class="xref py py-meth docutils literal notranslate"><span class="pre">min()</span></code></a>과 비슷하지만, 피연산자의 절댓값을 사용하여 비교가 이루어집니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.next_minus">
<span class="sig-name descname"><span class="pre">next_minus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.next_minus" title="Link to this definition">¶</a></dt>
<dd><p>주어진 피연산자보다 작고, 주어진 컨텍스트(또는 context가 주어지지 않으면 현재 스레드의 컨텍스트)에서 표현 가능한 가장 큰 수를 돌려줍니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.next_plus">
<span class="sig-name descname"><span class="pre">next_plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.next_plus" title="Link to this definition">¶</a></dt>
<dd><p>주어진 피연산자보다 크고, 주어진 컨텍스트(또는 context가 주어지지 않으면 현재 스레드의 컨텍스트)에서 표현 가능한 가장 작은 수를 돌려줍니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.next_toward">
<span class="sig-name descname"><span class="pre">next_toward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.next_toward" title="Link to this definition">¶</a></dt>
<dd><p>두 피연산자가 같지 않으면, 두 번째 피연산자의 방향으로 첫 번째 피연산자에 가장 가까운 숫자를 반환합니다. 두 피연산자가 수치로 같으면, 첫 번째 피연산자의 복사본을 반환하는데, 부호를 두 번째 피연산자의 것으로 설정합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.normalize" title="Link to this definition">¶</a></dt>
<dd><p>Used for producing canonical values of an equivalence
class within either the current context or the specified context.</p>
<p>This has the same semantics as the unary plus operation, except that if
the final result is finite it is reduced to its simplest form, with all
trailing zeros removed and its sign preserved. That is, while the
coefficient is non-zero and a multiple of ten the coefficient is divided
by ten and the exponent is incremented by 1. Otherwise (the coefficient is
zero) the exponent is set to 0. In all cases the sign is unchanged.</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">Decimal('32.100')</span></code> and <code class="docutils literal notranslate"><span class="pre">Decimal('0.321000e+2')</span></code> both
normalize to the equivalent value <code class="docutils literal notranslate"><span class="pre">Decimal('32.1')</span></code>.</p>
<p>Note that rounding is applied <em>before</em> reducing to simplest form.</p>
<p>In the latest versions of the specification, this operation is also known
as <code class="docutils literal notranslate"><span class="pre">reduce</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.number_class">
<span class="sig-name descname"><span class="pre">number_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.number_class" title="Link to this definition">¶</a></dt>
<dd><p>피연산자의 <em>클래스</em> 를 설명하는 문자열을 반환합니다. 반환 값은 다음 10개의 문자열 중 하나입니다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;-Infinity&quot;</span></code>, 피연산자가 음의 무한대임을 나타냅니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;-Normal&quot;</span></code>, 피연산자가 음의 정상 수임을 나타냅니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;-Subnormal&quot;</span></code>, 피연산자가 음의 비정상 수임을 나타냅니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;-Zero&quot;</span></code>, 피연산자가 음의 0임을 나타냅니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;+Zero&quot;</span></code>, 피연산자가 양의 0임을 나타냅니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;+Subnormal&quot;</span></code>, 피연산자가 양의 비정상 수임을 나타냅니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;+Normal&quot;</span></code>, 피연산자가 양의 정상 수임을 나타냅니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;+Infinity&quot;</span></code>, 피연산자가 양의 무한대임을 나타냅니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;NaN&quot;</span></code>, 피연산자가 조용한 NaN(Not a Number)임을 나타냅니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;sNaN&quot;</span></code>, 피연산자가 신호를 주는 NaN임을 나타냅니다.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.quantize">
<span class="sig-name descname"><span class="pre">quantize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.quantize" title="Link to this definition">¶</a></dt>
<dd><p>자리 올림 후에 첫 번째 피연산자와 같고 두 번째 피연산자의 지수를 갖는 값을 반환합니다.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.41421356&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.000&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;1.414&#39;)</span>
</pre></div>
</div>
<p>다른 연산과 달리, quantize 연산 후의 계수의 길이가 정밀도보다 크면, <a class="reference internal" href="decimal.html#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> 신호를 줍니다. 이는, 에러 조건이 없으면, quantize 된 지수가 항상 오른쪽 피연산자의 지수와 같음을 보장합니다.</p>
<p>또한, 다른 연산과는 달리, 결과가 비정상(subnormal)이고 부정확한 경우조차도, quantize는 결코 Underflow 신호를 보내지 않습니다.</p>
<p>두 번째 피연산자의 지수가 첫 번째 피연산자의 지수보다 크면 자리 올림이 필요할 수 있습니다. 이 경우, 자리 올림 모드는 (주어지면) <code class="docutils literal notranslate"><span class="pre">rounding</span></code> 인자에 의해 결정됩니다. 그렇지 않으면 주어진 <code class="docutils literal notranslate"><span class="pre">context</span></code> 인자에 의해 결정됩니다; 두 인자 모두 주어지지 않으면, 현재 스레드의 컨텍스트의 자리 올림 모드가 사용됩니다.</p>
<p>An error is returned whenever the resulting exponent is greater than
<code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code> or less than <a class="reference internal" href="decimal.html#decimal.Context.Etiny" title="decimal.Context.Etiny"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Etiny()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.radix">
<span class="sig-name descname"><span class="pre">radix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.radix" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 클래스가 모든 산술을 수행하는 진수(기수)인 <code class="docutils literal notranslate"><span class="pre">Decimal(10)</span></code> 을 반환합니다. 명세와의 호환성을 위해 포함됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.remainder_near">
<span class="sig-name descname"><span class="pre">remainder_near</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.remainder_near" title="Link to this definition">¶</a></dt>
<dd><p><em>self</em> 를 <em>other</em> 로 나눈 나머지를 반환합니다. 이것은 나머지의 절댓값을 최소화하기 위해 나머지의 부호가 선택된다는 점에서 <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">%</span> <span class="pre">other</span></code> 와 다릅니다. 좀 더 정확히 말하면, 반환 값은 <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">other</span></code> 인데, 여기서 <code class="docutils literal notranslate"><span class="pre">n</span></code> 은 <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">/</span> <span class="pre">other</span></code> 의 정확한 값에 가장 가까운 정수이고, 두 개의 정수와의 거리가 같으면 짝수가 선택됩니다.</p>
<p>결과가 0이면 그 부호는 <em>self</em> 의 부호가 됩니다.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;-2&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;5&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;-5&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.rotate">
<span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.rotate" title="Link to this definition">¶</a></dt>
<dd><p>첫 번째 피연산자의 계수를 두 번째 피연산자로 지정된 양만큼 회전한 결과를 반환합니다. 두 번째 피연산자는 -precision에서 precision 범위의 정수여야 합니다. 두 번째 피연산자의 절댓값은 회전할 자리의 수를 나타냅니다. 두 번째 피연산자가 양수면 왼쪽으로 회전합니다; 그렇지 않으면 오른쪽으로 회전합니다. 필요하면 정밀도에 맞추기 위해 첫 번째 피연산자의 계수에 0이 왼쪽에 채워집니다. 첫 번째 피연산자의 부호와 지수는 변경되지 않습니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.same_quantum">
<span class="sig-name descname"><span class="pre">same_quantum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.same_quantum" title="Link to this definition">¶</a></dt>
<dd><p>Test whether self and other have the same exponent or whether both are
<code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p>
<p>이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다. 예외적으로, 두 번째 피연산자를 정확하게 변환할 수 없으면 C 버전은 InvalidOperation을 발생시킬 수 있습니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.scaleb">
<span class="sig-name descname"><span class="pre">scaleb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.scaleb" title="Link to this definition">¶</a></dt>
<dd><p>첫 번째 피연산자의 지수를 두 번째 피연산자만큼 조정한 값을 반환합니다. 달리 표현하면, 첫 번째 피연산자에 <code class="docutils literal notranslate"><span class="pre">10**other</span></code> 를 곱한 값을 반환합니다. 두 번째 피연산자는 정수여야 합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.shift">
<span class="sig-name descname"><span class="pre">shift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.shift" title="Link to this definition">¶</a></dt>
<dd><p>첫 번째 피연산자의 계수를 두 번째 피연산자로 지정된 양만큼 이동한 결과를 반환합니다. 두 번째 피연산자는 -precision에서 precision 범위의 정수여야 합니다. 두 번째 피연산자의 절댓값은 이동할 자리의 수를 나타냅니다. 두 번째 피연산자가 양수면 왼쪽으로 이동합니다; 그렇지 않으면 오른쪽으로 이동합니다. 이동으로 인해 계수에 들어오는 숫자는 0입니다. 첫 번째 피연산자의 부호와 지수는 변경되지 않습니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.sqrt">
<span class="sig-name descname"><span class="pre">sqrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.sqrt" title="Link to this definition">¶</a></dt>
<dd><p>인자의 제곱근을 완전한 정밀도로 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.to_eng_string">
<span class="sig-name descname"><span class="pre">to_eng_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.to_eng_string" title="Link to this definition">¶</a></dt>
<dd><p>문자열로 변환합니다. 지수가 필요하면 공학 표기법을 사용합니다.</p>
<p>공학 표기법의 지수는 3의 배수입니다. 이렇게 하면 소수점 왼쪽에 최대 3자리를 남기게 되고, 하나나 두 개의 후행 0을 추가해야 할 수 있습니다.</p>
<p>예를 들어, 이 메서드는 <code class="docutils literal notranslate"><span class="pre">Decimal('123E+1')</span></code> 을 <code class="docutils literal notranslate"><span class="pre">Decimal('1.23E+3')</span></code> 으로 변환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.to_integral">
<span class="sig-name descname"><span class="pre">to_integral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.to_integral" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="decimal.html#decimal.Decimal.to_integral_value" title="decimal.Decimal.to_integral_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_integral_value()</span></code></a> 메서드와 같습니다. <code class="docutils literal notranslate"><span class="pre">to_integral</span></code> 이름은 이전 버전과의 호환성을 위해 유지되었습니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.to_integral_exact">
<span class="sig-name descname"><span class="pre">to_integral_exact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.to_integral_exact" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="decimal.html#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a> 나 <a class="reference internal" href="decimal.html#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a> 신호를 주면서 가장 가까운 정수로 자리 올림 합니다. 자리 올림 모드는 (주어지면) <code class="docutils literal notranslate"><span class="pre">rounding</span></code> 매개 변수에 의해, 그렇지 않으면 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">context</span></code> 에 의해 결정됩니다. 두 매개 변수 모두 지정되지 않으면, 현재 컨텍스트의 자리 올림 모드가 사용됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.to_integral_value">
<span class="sig-name descname"><span class="pre">to_integral_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Decimal.to_integral_value" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="decimal.html#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a> 나 <a class="reference internal" href="decimal.html#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a> 신호를 주지 않고 가장 가까운 정수로 자리 올림 합니다. 주어지면, <em>rounding</em> 을 적용합니다; 그렇지 않으면, 제공된 <em>context</em> 나 현재 컨텍스트의 자리 올림 방법을 사용합니다.</p>
</dd></dl>

</dd></dl>

<section id="logical-operands">
<span id="logical-operands-label"></span><h3>논리적 피연산자<a class="headerlink" href="decimal.html#logical-operands" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="decimal.html#decimal.Decimal.logical_and" title="decimal.Decimal.logical_and"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_and()</span></code></a>, <a class="reference internal" href="decimal.html#decimal.Decimal.logical_invert" title="decimal.Decimal.logical_invert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_invert()</span></code></a>, <a class="reference internal" href="decimal.html#decimal.Decimal.logical_or" title="decimal.Decimal.logical_or"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_or()</span></code></a>,
and <a class="reference internal" href="decimal.html#decimal.Decimal.logical_xor" title="decimal.Decimal.logical_xor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_xor()</span></code></a> methods expect their arguments to be <em>logical
operands</em>.  A <em>logical operand</em> is a <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> instance whose
exponent and sign are both zero, and whose digits are all either
<code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</section>
</section>
<section id="context-objects">
<span id="decimal-context"></span><h2>Context 객체<a class="headerlink" href="decimal.html#context-objects" title="Link to this heading">¶</a></h2>
<p>컨텍스트는 산술 연산을 위한 환경입니다. 정밀도를 제어하고, 자리 올림 규칙을 설정하며, 어떤 신호가 예외로 처리되는지 결정하고, 지수의 범위를 제한합니다.</p>
<p>각 스레드는 자신만의 현재 컨텍스트를 가지는데, <a class="reference internal" href="decimal.html#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 와 <a class="reference internal" href="decimal.html#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a> 함수를 사용하여 액세스하거나 변경합니다:</p>
<dl class="py function">
<dt class="sig sig-object py" id="decimal.getcontext">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">getcontext</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.getcontext" title="Link to this definition">¶</a></dt>
<dd><p>활성 스레드의 현재 컨텍스트를 돌려줍니다.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decimal.setcontext">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">setcontext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.setcontext" title="Link to this definition">¶</a></dt>
<dd><p>활성 스레드의 현재 컨텍스트를 <em>c</em> 로 설정합니다.</p>
</dd></dl>

<p>또한 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문과 <a class="reference internal" href="decimal.html#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">localcontext()</span></code></a> 함수를 사용하여 활성 컨텍스트를 일시적으로 변경할 수 있습니다.</p>
<dl class="py function">
<dt class="sig sig-object py" id="decimal.localcontext">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">localcontext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.localcontext" title="Link to this definition">¶</a></dt>
<dd><p>Return a context manager that will set the current context for the active thread
to a copy of <em>ctx</em> on entry to the with-statement and restore the previous context
when exiting the with-statement. If no context is specified, a copy of the
current context is used.  The <em>kwargs</em> argument is used to set the attributes
of the new context.</p>
<p>예를 들어, 다음 코드는 현재 십진 정밀도를 42자리로 설정하고, 계산을 수행한 다음, 이전 컨텍스트를 자동으로 복원합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">localcontext</span>

<span class="k">with</span> <span class="n">localcontext</span><span class="p">()</span> <span class="k">as</span> <span class="n">ctx</span><span class="p">:</span>
    <span class="n">ctx</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">42</span>   <span class="c1"># Perform a high precision calculation</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">calculate_something</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="o">+</span><span class="n">s</span>  <span class="c1"># Round the final result back to the default precision</span>
</pre></div>
</div>
<p>Using keyword arguments, the code would be the following:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">localcontext</span>

<span class="k">with</span> <span class="n">localcontext</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span> <span class="k">as</span> <span class="n">ctx</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">calculate_something</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="o">+</span><span class="n">s</span>
</pre></div>
</div>
<p>Raises <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> if <em>kwargs</em> supplies an attribute that <a class="reference internal" href="decimal.html#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> doesn’t
support.  Raises either <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> or <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> if <em>kwargs</em> supplies an
invalid value for an attribute.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span><a class="reference internal" href="decimal.html#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">localcontext()</span></code></a> now supports setting context attributes through the use of keyword arguments.</p>
</div>
</dd></dl>

<p>아래에 설명된 <a class="reference internal" href="decimal.html#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 생성자를 사용하여 새로운 컨텍스트를 만들 수도 있습니다. 또한, 이 모듈은 세 가지 미리 만들어진 컨텍스트를 제공합니다:</p>
<dl class="py class">
<dt class="sig sig-object py" id="decimal.BasicContext">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">BasicContext</span></span><a class="headerlink" href="decimal.html#decimal.BasicContext" title="Link to this definition">¶</a></dt>
<dd><p>이것은 일반 십진 산술 명세에서 정의된 표준 컨텍스트입니다. 정밀도는 9로 설정됩니다. 자리 올림은 <a class="reference internal" href="decimal.html#decimal.ROUND_HALF_UP" title="decimal.ROUND_HALF_UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_UP</span></code></a>으로 설정됩니다. 모든 플래그가 지워집니다. 모든 트랩은 <a class="reference internal" href="decimal.html#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a>, <a class="reference internal" href="decimal.html#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a>, <a class="reference internal" href="decimal.html#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-const docutils literal notranslate"><span class="pre">Subnormal</span></code></a>을 제외하고는 활성화됩니다 (예외로 처리됩니다).</p>
<p>많은 트랩이 활성화되었으므로, 이 컨텍스트는 디버깅에 유용합니다.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.ExtendedContext">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ExtendedContext</span></span><a class="headerlink" href="decimal.html#decimal.ExtendedContext" title="Link to this definition">¶</a></dt>
<dd><p>이것은 일반 십진 산술 명세에서 정의된 표준 컨텍스트입니다. 정밀도는 9로 설정됩니다. 자리 올림은 <a class="reference internal" href="decimal.html#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>으로 설정됩니다. 모든 플래그가 지워집니다. 아무 트랩도 활성화되지 않습니다 (그래서 계산 중에 예외가 발생하지 않습니다).</p>
<p>Because the traps are disabled, this context is useful for applications that
prefer to have result value of <code class="docutils literal notranslate"><span class="pre">NaN</span></code> or <code class="docutils literal notranslate"><span class="pre">Infinity</span></code> instead of
raising exceptions.  This allows an application to complete a run in the
presence of conditions that would otherwise halt the program.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.DefaultContext">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">DefaultContext</span></span><a class="headerlink" href="decimal.html#decimal.DefaultContext" title="Link to this definition">¶</a></dt>
<dd><p>이 컨텍스트는 새로운 컨텍스트의 프로토타입으로 <a class="reference internal" href="decimal.html#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 생성자에 의해 사용됩니다. 필드(가령 정밀도)를 변경하면 <a class="reference internal" href="decimal.html#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 생성자에 의해 생성된 새로운 컨텍스트에 대한 기본값을 변경하는 효과가 있습니다.</p>
<p>이 컨텍스트는 다중 스레드 환경에서 가장 유용합니다. 스레드가 시작되기 전에 필드 중 하나를 변경하면 시스템 전체의 기본값을 설정하는 효과가 있습니다. 스레드가 시작된 후에 필드를 변경하는 것은. 스레드 동기화를 통해 경쟁 조건을 방지해야 하므로 권장되지 않습니다.</p>
<p>단일 스레드 환경에서는, 이 컨텍스트를 아예 사용하지 않는 것이 좋습니다. 대신, 아래에 설명된 대로 명시적으로 컨텍스트를 만드십시오.</p>
<p>The default values are <code class="xref py py-attr docutils literal notranslate"><span class="pre">Context.prec</span></code>=<code class="docutils literal notranslate"><span class="pre">28</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">Context.rounding</span></code>=<a class="reference internal" href="decimal.html#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>,
and enabled traps for <a class="reference internal" href="decimal.html#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-class docutils literal notranslate"><span class="pre">Overflow</span></code></a>, <a class="reference internal" href="decimal.html#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a>, and
<a class="reference internal" href="decimal.html#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-class docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a>.</p>
</dd></dl>

<p>3개의 제공된 컨텍스트 외에도, 새로운 컨텍스트를 <a class="reference internal" href="decimal.html#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 생성자를 사용하여 만들 수 있습니다.</p>
<dl class="py class">
<dt class="sig sig-object py" id="decimal.Context">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">capitals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context" title="Link to this definition">¶</a></dt>
<dd><p>새로운 컨텍스트를 만듭니다. 필드가 지정되지 않았거나 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 이면, 기본값은 <a class="reference internal" href="decimal.html#decimal.DefaultContext" title="decimal.DefaultContext"><code class="xref py py-const docutils literal notranslate"><span class="pre">DefaultContext</span></code></a> 에서 복사됩니다. <em>flags</em> 필드가 지정되지 않았거나 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 이면, 모든 플래그가 지워집니다.</p>
<p><em>prec</em> is an integer in the range [<code class="docutils literal notranslate"><span class="pre">1</span></code>, <a class="reference internal" href="decimal.html#decimal.MAX_PREC" title="decimal.MAX_PREC"><code class="xref py py-const docutils literal notranslate"><span class="pre">MAX_PREC</span></code></a>] that sets
the precision for arithmetic operations in the context.</p>
<p><em>rounding</em> 옵션은 <a class="reference internal" href="decimal.html#rounding-modes">자리 올림 모드</a> 섹션에 나열된 상수 중 하나입니다.</p>
<p><em>traps</em> 과 <em>flags</em> 필드는 설정할 신호를 나열합니다. 일반적으로, 새 컨텍스트는 트랩만 설정하고 플래그는 지워진 채로 두어야 합니다.</p>
<p>The <em>Emin</em> and <em>Emax</em> fields are integers specifying the outer limits allowable
for exponents. <em>Emin</em> must be in the range [<a class="reference internal" href="decimal.html#decimal.MIN_EMIN" title="decimal.MIN_EMIN"><code class="xref py py-const docutils literal notranslate"><span class="pre">MIN_EMIN</span></code></a>, <code class="docutils literal notranslate"><span class="pre">0</span></code>],
<em>Emax</em> in the range [<code class="docutils literal notranslate"><span class="pre">0</span></code>, <a class="reference internal" href="decimal.html#decimal.MAX_EMAX" title="decimal.MAX_EMAX"><code class="xref py py-const docutils literal notranslate"><span class="pre">MAX_EMAX</span></code></a>].</p>
<p>The <em>capitals</em> field is either <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span></code> (the default). If set to
<code class="docutils literal notranslate"><span class="pre">1</span></code>, exponents are printed with a capital <code class="docutils literal notranslate"><span class="pre">E</span></code>; otherwise, a
lowercase <code class="docutils literal notranslate"><span class="pre">e</span></code> is used: <code class="docutils literal notranslate"><span class="pre">Decimal('6.02e+23')</span></code>.</p>
<p>The <em>clamp</em> field is either <code class="docutils literal notranslate"><span class="pre">0</span></code> (the default) or <code class="docutils literal notranslate"><span class="pre">1</span></code>.
If set to <code class="docutils literal notranslate"><span class="pre">1</span></code>, the exponent <code class="docutils literal notranslate"><span class="pre">e</span></code> of a <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>
instance representable in this context is strictly limited to the
range <code class="docutils literal notranslate"><span class="pre">Emin</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">e</span> <span class="pre">&lt;=</span> <span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code>.  If <em>clamp</em> is
<code class="docutils literal notranslate"><span class="pre">0</span></code> then a weaker condition holds: the adjusted exponent of
the <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> instance is at most <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code>.  When <em>clamp</em> is
<code class="docutils literal notranslate"><span class="pre">1</span></code>, a large normal number will, where possible, have its
exponent reduced and a corresponding number of zeros added to its
coefficient, in order to fit the exponent constraints; this
preserves the value of the number but loses information about
significant trailing zeros.  For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">create_decimal</span><span class="p">(</span><span class="s1">&#39;1.23e999&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.23000E+999&#39;)</span>
</pre></div>
</div>
<p>A <em>clamp</em> value of <code class="docutils literal notranslate"><span class="pre">1</span></code> allows compatibility with the
fixed-width decimal interchange formats specified in IEEE 754.</p>
<p>The <a class="reference internal" href="decimal.html#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> class defines several general purpose methods as well as
a large number of methods for doing arithmetic directly in a given context.
In addition, for each of the <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> methods described above (with
the exception of the <a class="reference internal" href="decimal.html#decimal.Decimal.adjusted" title="decimal.Decimal.adjusted"><code class="xref py py-meth docutils literal notranslate"><span class="pre">adjusted()</span></code></a> and <a class="reference internal" href="decimal.html#decimal.Decimal.as_tuple" title="decimal.Decimal.as_tuple"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_tuple()</span></code></a> methods) there is
a corresponding <a class="reference internal" href="decimal.html#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> method.  For example, for a <a class="reference internal" href="decimal.html#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a>
instance <code class="docutils literal notranslate"><span class="pre">C</span></code> and <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> instance <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">C.exp(x)</span></code> is
equivalent to <code class="docutils literal notranslate"><span class="pre">x.exp(context=C)</span></code>.  Each <a class="reference internal" href="decimal.html#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> method accepts a
Python integer (an instance of <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) anywhere that a
Decimal instance is accepted.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.clear_flags">
<span class="sig-name descname"><span class="pre">clear_flags</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.clear_flags" title="Link to this definition">¶</a></dt>
<dd><p>Resets all of the flags to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.clear_traps">
<span class="sig-name descname"><span class="pre">clear_traps</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.clear_traps" title="Link to this definition">¶</a></dt>
<dd><p>Resets all of the traps to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.copy" title="Link to this definition">¶</a></dt>
<dd><p>컨텍스트의 복사본을 돌려줍니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.copy_decimal">
<span class="sig-name descname"><span class="pre">copy_decimal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.copy_decimal" title="Link to this definition">¶</a></dt>
<dd><p>Decimal 인스턴스 num의 복사본을 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.create_decimal">
<span class="sig-name descname"><span class="pre">create_decimal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.create_decimal" title="Link to this definition">¶</a></dt>
<dd><p><em>self</em> 를 컨텍스트로 사용해서, <em>num</em> 으로 새 Decimal 인스턴스를 만듭니다. <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 생성자와 달리, 컨텍스트 정밀도, 자리 올림 방법, 플래그 및 트랩이 변환에 적용됩니다.</p>
<p>이는 상수가 보통 응용 프로그램에 필요한 것보다 더 큰 정밀도로 제공되기 때문에 유용합니다. 또 다른 이점은 자리 올림이 현재 정밀도를 초과하는 자릿수로 인한 의도하지 않은 결과를 즉시 제거한다는 것입니다. 다음 예제에서, 자리 올림 되지 않은 입력을 사용한다는 것은 합계에 0을 추가하면 결과가 달라질 수 있음을 의미합니다.:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.4445&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.0023&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.45&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.4445&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.0023&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.44&#39;)</span>
</pre></div>
</div>
<p>이 메서드는 IBM 명세의 to-number 연산을 구현합니다. 인자가 문자열이면, 선행 또는 후행 공백이나 밑줄이 허용되지 않습니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.create_decimal_from_float">
<span class="sig-name descname"><span class="pre">create_decimal_from_float</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.create_decimal_from_float" title="Link to this definition">¶</a></dt>
<dd><p>float <em>f</em> 로 새 Decimal 인스턴스를 만들지만, <em>self</em> 를 컨텍스트로 사용하여 자리 올림 합니다. <a class="reference internal" href="decimal.html#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Decimal.from_float()</span></code></a> 클래스 메서드와는 달리, 컨텍스트 정밀도, 자리 올림 방법, 플래그 및 트랩이 변환에 적용됩니다.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.1415&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">    </span><span class="o">...</span>
<span class="gr">decimal.Inexact</span>: <span class="n">None</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.Etiny">
<span class="sig-name descname"><span class="pre">Etiny</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.Etiny" title="Link to this definition">¶</a></dt>
<dd><p>비정상 결과에 대한 최소 지수 값인 <code class="docutils literal notranslate"><span class="pre">Emin</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code> 과 같은 값을 반환합니다. 언더 플로우가 발생하면, 지수는 <a class="reference internal" href="decimal.html#decimal.Context.Etiny" title="decimal.Context.Etiny"><code class="xref py py-const docutils literal notranslate"><span class="pre">Etiny</span></code></a> 로 설정됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.Etop">
<span class="sig-name descname"><span class="pre">Etop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.Etop" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code> 과 같은 값을 반환합니다.</p>
</dd></dl>

<p>십진수로 작업하는 일반적인 접근법은 <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스를 생성한 다음 활성 스레드의 현재 컨텍스트 내에서 진행되는 산술 연산을 적용하는 것입니다. 다른 방법은 특정 컨텍스트 내에서 계산하기 위해 컨텍스트 메서드를 사용하는 것입니다. 메서드는 <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 클래스의 메서드와 비슷하며 여기에서는 간단히 설명합니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.abs">
<span class="sig-name descname"><span class="pre">abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.abs" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 의 절댓값을 돌려줍니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.add" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 와 <em>y</em> 의 합을 돌려줍니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.canonical">
<span class="sig-name descname"><span class="pre">canonical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.canonical" title="Link to this definition">¶</a></dt>
<dd><p>같은 Decimal 객체 <em>x</em> 를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.compare">
<span class="sig-name descname"><span class="pre">compare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.compare" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 와 <em>y</em> 를 수치로 비교합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.compare_signal">
<span class="sig-name descname"><span class="pre">compare_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.compare_signal" title="Link to this definition">¶</a></dt>
<dd><p>두 피연산자의 값을 수치로 비교합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.compare_total">
<span class="sig-name descname"><span class="pre">compare_total</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.compare_total" title="Link to this definition">¶</a></dt>
<dd><p>추상 표현을 사용하여 두 피연산자를 비교합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.compare_total_mag">
<span class="sig-name descname"><span class="pre">compare_total_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.compare_total_mag" title="Link to this definition">¶</a></dt>
<dd><p>부호를 무시하고, 추상 표현을 사용하여 두 피연산자를 비교합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.copy_abs">
<span class="sig-name descname"><span class="pre">copy_abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.copy_abs" title="Link to this definition">¶</a></dt>
<dd><p>부호가 0으로 설정되어있는 <em>x</em> 의 복사본을 돌려줍니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.copy_negate">
<span class="sig-name descname"><span class="pre">copy_negate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.copy_negate" title="Link to this definition">¶</a></dt>
<dd><p>부호가 반전된 <em>x</em> 복사본을 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.copy_sign">
<span class="sig-name descname"><span class="pre">copy_sign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.copy_sign" title="Link to this definition">¶</a></dt>
<dd><p><em>y</em> 에서 <em>x</em> 로 부호를 복사합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.divide">
<span class="sig-name descname"><span class="pre">divide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.divide" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 를 <em>y</em> 로 나눈 값을 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.divide_int">
<span class="sig-name descname"><span class="pre">divide_int</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.divide_int" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 를 <em>y</em> 로 나눈 후 정수로 잘라낸 값을 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.divmod">
<span class="sig-name descname"><span class="pre">divmod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.divmod" title="Link to this definition">¶</a></dt>
<dd><p>두 숫자를 나누고 결과의 정수 부분을 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.exp" title="Link to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">**</span> <span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.fma">
<span class="sig-name descname"><span class="pre">fma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.fma" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 에 <em>y</em> 를 곱한 후 <em>z</em> 를 더한 값을 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_canonical">
<span class="sig-name descname"><span class="pre">is_canonical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.is_canonical" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 가 규범적일 경우 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_finite">
<span class="sig-name descname"><span class="pre">is_finite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.is_finite" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 가 유한이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_infinite">
<span class="sig-name descname"><span class="pre">is_infinite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.is_infinite" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 가 무한대면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_nan">
<span class="sig-name descname"><span class="pre">is_nan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.is_nan" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 가 qNaN 이나 sNaN 이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_normal">
<span class="sig-name descname"><span class="pre">is_normal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.is_normal" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 가 정상 수면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_qnan">
<span class="sig-name descname"><span class="pre">is_qnan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.is_qnan" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 가 조용한 NaN이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_signed">
<span class="sig-name descname"><span class="pre">is_signed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.is_signed" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 가 음수면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_snan">
<span class="sig-name descname"><span class="pre">is_snan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.is_snan" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 가 신호를 주는 NaN 이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_subnormal">
<span class="sig-name descname"><span class="pre">is_subnormal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.is_subnormal" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 가 비정상이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_zero">
<span class="sig-name descname"><span class="pre">is_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.is_zero" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 가 0이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.ln">
<span class="sig-name descname"><span class="pre">ln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.ln" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 의 자연로그(밑 e)를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.log10">
<span class="sig-name descname"><span class="pre">log10</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.log10" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 의 상용로그를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.logb">
<span class="sig-name descname"><span class="pre">logb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.logb" title="Link to this definition">¶</a></dt>
<dd><p>피연산자의 최상위 유효 숫자의 크기의 지수를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.logical_and">
<span class="sig-name descname"><span class="pre">logical_and</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.logical_and" title="Link to this definition">¶</a></dt>
<dd><p>각 피연산자의 자릿수별로 논리적 연산 <em>and</em> 를 적용합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.logical_invert">
<span class="sig-name descname"><span class="pre">logical_invert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.logical_invert" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 의 모든 자릿수를 반전합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.logical_or">
<span class="sig-name descname"><span class="pre">logical_or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.logical_or" title="Link to this definition">¶</a></dt>
<dd><p>각 피연산자의 자릿수별로 논리적 연산 <em>or</em> 를 적용합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.logical_xor">
<span class="sig-name descname"><span class="pre">logical_xor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.logical_xor" title="Link to this definition">¶</a></dt>
<dd><p>각 피연산자의 자릿수별로 논리적 연산 <em>xor</em> 를 적용합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.max">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.max" title="Link to this definition">¶</a></dt>
<dd><p>두 값을 수치로 비교해, 최댓값을 돌려줍니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.max_mag">
<span class="sig-name descname"><span class="pre">max_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.max_mag" title="Link to this definition">¶</a></dt>
<dd><p>부호를 무시하고 값을 수치로 비교합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.min">
<span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.min" title="Link to this definition">¶</a></dt>
<dd><p>두 값을 수치로 비교해, 최솟값을 돌려줍니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.min_mag">
<span class="sig-name descname"><span class="pre">min_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.min_mag" title="Link to this definition">¶</a></dt>
<dd><p>부호를 무시하고 값을 수치로 비교합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.minus">
<span class="sig-name descname"><span class="pre">minus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.minus" title="Link to this definition">¶</a></dt>
<dd><p>minus는 파이썬에서 단항 접두사 빼기 연산자에 해당합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.multiply">
<span class="sig-name descname"><span class="pre">multiply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.multiply" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 와 <em>y</em> 의 곱을 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.next_minus">
<span class="sig-name descname"><span class="pre">next_minus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.next_minus" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 보다 작고 표현 가능한 가장 큰 수를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.next_plus">
<span class="sig-name descname"><span class="pre">next_plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.next_plus" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 보다 크고 표현 가능한 가장 작은 수를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.next_toward">
<span class="sig-name descname"><span class="pre">next_toward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.next_toward" title="Link to this definition">¶</a></dt>
<dd><p><em>y</em> 방향으로 <em>x</em> 에 가장 가까운 숫자를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.normalize" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 를 가장 간단한 형태로 환원합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.number_class">
<span class="sig-name descname"><span class="pre">number_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.number_class" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 의 클래스를 가리키는 문자열을 돌려줍니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.plus">
<span class="sig-name descname"><span class="pre">plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.plus" title="Link to this definition">¶</a></dt>
<dd><p>plus는 파이썬에서 단항 접두사 더하기 연산자에 해당합니다. 이 연산은 컨텍스트 정밀도와 자리 올림을 적용하므로 항등 연산이 <em>아닙니다</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.power">
<span class="sig-name descname"><span class="pre">power</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.power" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">x</span></code> 의 <code class="docutils literal notranslate"><span class="pre">y</span></code> 거듭제곱을 돌려줍니다. 주어지면 <code class="docutils literal notranslate"><span class="pre">modulo</span></code> 모듈로로 환원합니다.</p>
<p>With two arguments, compute <code class="docutils literal notranslate"><span class="pre">x**y</span></code>.  If <code class="docutils literal notranslate"><span class="pre">x</span></code> is negative then <code class="docutils literal notranslate"><span class="pre">y</span></code>
must be integral.  The result will be inexact unless <code class="docutils literal notranslate"><span class="pre">y</span></code> is integral and
the result is finite and can be expressed exactly in ‘precision’ digits.
The rounding mode of the context is used. Results are always correctly rounded
in the Python version.</p>
<p><code class="docutils literal notranslate"><span class="pre">Decimal(0)</span> <span class="pre">**</span> <span class="pre">Decimal(0)</span></code>은 <code class="docutils literal notranslate"><span class="pre">InvalidOperation</span></code>이 되며, <code class="docutils literal notranslate"><span class="pre">InvalidOperation</span></code>가 트랩 되지 않으면, <code class="docutils literal notranslate"><span class="pre">Decimal('NaN')</span></code>이 됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>The C module computes <a class="reference internal" href="decimal.html#decimal.Context.power" title="decimal.Context.power"><code class="xref py py-meth docutils literal notranslate"><span class="pre">power()</span></code></a> in terms of the correctly rounded
<a class="reference internal" href="decimal.html#decimal.Context.exp" title="decimal.Context.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a> and <a class="reference internal" href="decimal.html#decimal.Context.ln" title="decimal.Context.ln"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ln()</span></code></a> functions. The result is well-defined but
only “almost always correctly rounded”.</p>
</div>
<p>세 인자로는 <code class="docutils literal notranslate"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">modulo</span></code> 를 계산합니다. 세 인자 형식의 경우, 인자에 다음과 같은 제한이 있습니다:</p>
<ul class="simple">
<li><p>세 인자는 모두 정수여야 합니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> 는 음수가 아니어야 합니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> 나 <code class="docutils literal notranslate"><span class="pre">y</span></code> 중 적어도 하나는 0이 아니어야 합니다</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">modulo</span></code> 는 0이 아니고 최대 ‘precision’ 자릿수를 가져야 합니다</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">Context.power(x,</span> <span class="pre">y,</span> <span class="pre">modulo)</span></code> 의 결괏값은 무한 정밀도로 <code class="docutils literal notranslate"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">modulo</span></code> 를 계산할 때 얻을 수 있는 값과 같지만, 더 효율적으로 계산됩니다. 결과의 지수는 <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> 및 <code class="docutils literal notranslate"><span class="pre">modulo</span></code> 의 지수와 관계없이 0입니다. 결과는 항상 정확합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.quantize">
<span class="sig-name descname"><span class="pre">quantize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.quantize" title="Link to this definition">¶</a></dt>
<dd><p><em>y</em> 의 지수를 가지는 (자리 올림 된) <em>x</em> 와 같은 값을 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.radix">
<span class="sig-name descname"><span class="pre">radix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.radix" title="Link to this definition">¶</a></dt>
<dd><p>Decimal이기 때문에 단지 10을 반환합니다, :)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.remainder">
<span class="sig-name descname"><span class="pre">remainder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.remainder" title="Link to this definition">¶</a></dt>
<dd><p>정수 나눗셈의 나머지를 반환합니다.</p>
<p>결과가 0이 아닐 때, 결과의 부호는 원래의 피제수와 같습니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.remainder_near">
<span class="sig-name descname"><span class="pre">remainder_near</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.remainder_near" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">n</span></code> 을 반환하는데, <em>n</em> 은 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code> 의 정확한 값에 가장 가까운 정수입니다 (결과가 0이면 그 부호는 <em>x</em> 의 부호가 됩니다).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.rotate">
<span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.rotate" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 를 <em>y</em> 번 회전한 복사본을 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.same_quantum">
<span class="sig-name descname"><span class="pre">same_quantum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.same_quantum" title="Link to this definition">¶</a></dt>
<dd><p>두 피연산자의 지수가 같으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.scaleb">
<span class="sig-name descname"><span class="pre">scaleb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.scaleb" title="Link to this definition">¶</a></dt>
<dd><p>첫 번째 피연산자의 지수에 두 번째 값을 더해서 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.shift">
<span class="sig-name descname"><span class="pre">shift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.shift" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 를 <em>y</em> 번 이동한 복사본을 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.sqrt">
<span class="sig-name descname"><span class="pre">sqrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.sqrt" title="Link to this definition">¶</a></dt>
<dd><p>음이 아닌 수의 제곱근을 컨텍스트의 정밀도로 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.subtract">
<span class="sig-name descname"><span class="pre">subtract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.subtract" title="Link to this definition">¶</a></dt>
<dd><p><em>x</em> 와 <em>y</em> 의 차를 돌려줍니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.to_eng_string">
<span class="sig-name descname"><span class="pre">to_eng_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.to_eng_string" title="Link to this definition">¶</a></dt>
<dd><p>문자열로 변환합니다. 지수가 필요하면 공학 표기법을 사용합니다.</p>
<p>공학 표기법의 지수는 3의 배수입니다. 이렇게 하면 소수점 왼쪽에 최대 3자리를 남기게 되고, 하나나 두 개의 후행 0을 추가해야 할 수 있습니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.to_integral_exact">
<span class="sig-name descname"><span class="pre">to_integral_exact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.to_integral_exact" title="Link to this definition">¶</a></dt>
<dd><p>정수로 자리 올림 합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.to_sci_string">
<span class="sig-name descname"><span class="pre">to_sci_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="decimal.html#decimal.Context.to_sci_string" title="Link to this definition">¶</a></dt>
<dd><p>과학 표기법을 사용하여 숫자를 문자열로 변환합니다.</p>
</dd></dl>

</dd></dl>

</section>
<section id="constants">
<span id="decimal-rounding-modes"></span><h2>상수<a class="headerlink" href="decimal.html#constants" title="Link to this heading">¶</a></h2>
<p>이 절의 상수는 C 모듈에서만 의미가 있습니다. 호환성을 위해 순수 파이썬 버전에도 포함되어 있습니다.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>32-비트</p></th>
<th class="head"><p>64-비트</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="py data">
<dt class="sig sig-object py" id="decimal.MAX_PREC">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">MAX_PREC</span></span><a class="headerlink" href="decimal.html#decimal.MAX_PREC" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p><code class="docutils literal notranslate"><span class="pre">425000000</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">999999999999999999</span></code></p></td>
</tr>
<tr class="row-odd"><td><dl class="py data">
<dt class="sig sig-object py" id="decimal.MAX_EMAX">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">MAX_EMAX</span></span><a class="headerlink" href="decimal.html#decimal.MAX_EMAX" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p><code class="docutils literal notranslate"><span class="pre">425000000</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">999999999999999999</span></code></p></td>
</tr>
<tr class="row-even"><td><dl class="py data">
<dt class="sig sig-object py" id="decimal.MIN_EMIN">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">MIN_EMIN</span></span><a class="headerlink" href="decimal.html#decimal.MIN_EMIN" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p><code class="docutils literal notranslate"><span class="pre">-425000000</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-999999999999999999</span></code></p></td>
</tr>
<tr class="row-odd"><td><dl class="py data">
<dt class="sig sig-object py" id="decimal.MIN_ETINY">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">MIN_ETINY</span></span><a class="headerlink" href="decimal.html#decimal.MIN_ETINY" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p><code class="docutils literal notranslate"><span class="pre">-849999999</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-1999999999999999997</span></code></p></td>
</tr>
</tbody>
</table>
<dl class="py data">
<dt class="sig sig-object py" id="decimal.HAVE_THREADS">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">HAVE_THREADS</span></span><a class="headerlink" href="decimal.html#decimal.HAVE_THREADS" title="Link to this definition">¶</a></dt>
<dd><p>값은 <code class="docutils literal notranslate"><span class="pre">True</span></code>입니다. 이제 파이썬에는 항상 스레드가 있기 때문에, 폐지되었습니다.</p>
</dd></dl>

<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지됨.</span></p>
</div>
<dl class="py data">
<dt class="sig sig-object py" id="decimal.HAVE_CONTEXTVAR">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">HAVE_CONTEXTVAR</span></span><a class="headerlink" href="decimal.html#decimal.HAVE_CONTEXTVAR" title="Link to this definition">¶</a></dt>
<dd><p>The default value is <code class="docutils literal notranslate"><span class="pre">True</span></code>. If Python is <a class="reference internal" href="../using/configure.html#cmdoption-without-decimal-contextvar"><code class="xref std std-option docutils literal notranslate"><span class="pre">configured</span> <span class="pre">using</span>
<span class="pre">the</span> <span class="pre">--without-decimal-contextvar</span> <span class="pre">option</span></code></a>,
the C version uses a thread-local rather than a coroutine-local context and the value
is <code class="docutils literal notranslate"><span class="pre">False</span></code>.  This is slightly faster in some nested context scenarios.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.3.</span></p>
</div>
</dd></dl>

</section>
<section id="rounding-modes">
<h2>자리 올림 모드<a class="headerlink" href="decimal.html#rounding-modes" title="Link to this heading">¶</a></h2>
<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_CEILING">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_CEILING</span></span><a class="headerlink" href="decimal.html#decimal.ROUND_CEILING" title="Link to this definition">¶</a></dt>
<dd><p>Round towards <code class="docutils literal notranslate"><span class="pre">Infinity</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_DOWN">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_DOWN</span></span><a class="headerlink" href="decimal.html#decimal.ROUND_DOWN" title="Link to this definition">¶</a></dt>
<dd><p>0을 향해 자리 올림 합니다.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_FLOOR">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_FLOOR</span></span><a class="headerlink" href="decimal.html#decimal.ROUND_FLOOR" title="Link to this definition">¶</a></dt>
<dd><p>Round towards <code class="docutils literal notranslate"><span class="pre">-Infinity</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_HALF_DOWN">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_HALF_DOWN</span></span><a class="headerlink" href="decimal.html#decimal.ROUND_HALF_DOWN" title="Link to this definition">¶</a></dt>
<dd><p>가장 가까운 값으로 반올림하고, 동률이면 0에서 가까운 것을 선택합니다.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_HALF_EVEN">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_HALF_EVEN</span></span><a class="headerlink" href="decimal.html#decimal.ROUND_HALF_EVEN" title="Link to this definition">¶</a></dt>
<dd><p>가장 가까운 값으로 반올림하고, 동률이면 짝수를 선택합니다.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_HALF_UP">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_HALF_UP</span></span><a class="headerlink" href="decimal.html#decimal.ROUND_HALF_UP" title="Link to this definition">¶</a></dt>
<dd><p>가장 가까운 값으로 반올림하고, 동률이면 0에서 먼 것을 선택합니다.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_UP">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_UP</span></span><a class="headerlink" href="decimal.html#decimal.ROUND_UP" title="Link to this definition">¶</a></dt>
<dd><p>0에서 먼 쪽으로 자리 올림 합니다.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_05UP">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_05UP</span></span><a class="headerlink" href="decimal.html#decimal.ROUND_05UP" title="Link to this definition">¶</a></dt>
<dd><p>0을 향해 자리 올림 했을 때 마지막 숫자가 0이나 5면 0에서 먼 쪽으로 자리 올림 합니다. 그렇지 않으면 0을 향해 자리 올림 합니다.</p>
</dd></dl>

</section>
<section id="signals">
<span id="decimal-signals"></span><h2>신호<a class="headerlink" href="decimal.html#signals" title="Link to this heading">¶</a></h2>
<p>신호는 계산 중 발생하는 조건을 나타냅니다. 각각은 하나의 컨텍스트 플래그와 하나의 컨텍스트 트랩 활성화기에 대응합니다.</p>
<p>컨텍스트 플래그는 조건이 발생할 때마다 설정됩니다. 계산 후에, 플래그는 정보를 얻기 위한 목적으로 확인될 수 있습니다 (예를 들어, 계산이 정확한지를 판별하기 위해). 플래그를 확인한 후 다음 계산을 시작하기 전에 모든 플래그를 지우십시오.</p>
<p>컨텍스트의 트랩 활성화기가 신호에 대해 설정되면, 조건은 파이썬 예외를 일으킵니다. 예를 들어, <a class="reference internal" href="decimal.html#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-class docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> 트랩이 설정되면, 이 조건을 만날 때 <a class="reference internal" href="decimal.html#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> 예외가 발생합니다.</p>
<dl class="py class">
<dt class="sig sig-object py" id="decimal.Clamped">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Clamped</span></span><a class="headerlink" href="decimal.html#decimal.Clamped" title="Link to this definition">¶</a></dt>
<dd><p>표현 제약 조건에 맞도록 지수를 변경했습니다.</p>
<p>Typically, clamping occurs when an exponent falls outside the context’s
<code class="xref py py-attr docutils literal notranslate"><span class="pre">Emin</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code> limits.  If possible, the exponent is reduced to
fit by adding zeros to the coefficient.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.DecimalException">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">DecimalException</span></span><a class="headerlink" href="decimal.html#decimal.DecimalException" title="Link to this definition">¶</a></dt>
<dd><p>다른 신호의 베이스 클래스이고 <a class="reference internal" href="exceptions.html#ArithmeticError" title="ArithmeticError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code></a> 의 서브 클래스입니다.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.DivisionByZero">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">DivisionByZero</span></span><a class="headerlink" href="decimal.html#decimal.DivisionByZero" title="Link to this definition">¶</a></dt>
<dd><p>무한대가 아닌 숫자를 0으로 나눴다는 신호를 줍니다.</p>
<p>Can occur with division, modulo division, or when raising a number to a negative
power.  If this signal is not trapped, returns <code class="docutils literal notranslate"><span class="pre">Infinity</span></code> or
<code class="docutils literal notranslate"><span class="pre">-Infinity</span></code> with the sign determined by the inputs to the calculation.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.Inexact">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Inexact</span></span><a class="headerlink" href="decimal.html#decimal.Inexact" title="Link to this definition">¶</a></dt>
<dd><p>자리 올림이 발생했고 결과가 정확하지 않음을 나타냅니다.</p>
<p>자리 올림 도중 0이 아닌 숫자가 삭제된 경우 신호를 줍니다. 자리 올림 된 결과가 반환됩니다. 신호 플래그나 트랩은 결과가 정확하지 않을 때를 감지하는 데 사용됩니다.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.InvalidOperation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">InvalidOperation</span></span><a class="headerlink" href="decimal.html#decimal.InvalidOperation" title="Link to this definition">¶</a></dt>
<dd><p>유효하지 않은 연산이 수행되었습니다.</p>
<p>Indicates that an operation was requested that does not make sense. If not
trapped, returns <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.  Possible causes include:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Infinity</span> <span class="o">-</span> <span class="n">Infinity</span>
<span class="mi">0</span> <span class="o">*</span> <span class="n">Infinity</span>
<span class="n">Infinity</span> <span class="o">/</span> <span class="n">Infinity</span>
<span class="n">x</span> <span class="o">%</span> <span class="mi">0</span>
<span class="n">Infinity</span> <span class="o">%</span> <span class="n">x</span>
<span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="mi">0</span> <span class="o">**</span> <span class="mi">0</span>
<span class="n">x</span> <span class="o">**</span> <span class="p">(</span><span class="n">non</span><span class="o">-</span><span class="n">integer</span><span class="p">)</span>
<span class="n">x</span> <span class="o">**</span> <span class="n">Infinity</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.Overflow">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Overflow</span></span><a class="headerlink" href="decimal.html#decimal.Overflow" title="Link to this definition">¶</a></dt>
<dd><p>수치적 오버플로.</p>
<p>Indicates the exponent is larger than <code class="xref py py-attr docutils literal notranslate"><span class="pre">Context.Emax</span></code> after rounding has
occurred.  If not trapped, the result depends on the rounding mode, either
pulling inward to the largest representable finite number or rounding outward
to <code class="docutils literal notranslate"><span class="pre">Infinity</span></code>.  In either case, <a class="reference internal" href="decimal.html#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inexact</span></code></a> and <a class="reference internal" href="decimal.html#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rounded</span></code></a>
are also signaled.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.Rounded">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Rounded</span></span><a class="headerlink" href="decimal.html#decimal.Rounded" title="Link to this definition">¶</a></dt>
<dd><p>정보가 손실되지는 않았지만 자리 올림이 발생했습니다.</p>
<p>Signaled whenever rounding discards digits; even if those digits are zero
(such as rounding <code class="docutils literal notranslate"><span class="pre">5.00</span></code> to <code class="docutils literal notranslate"><span class="pre">5.0</span></code>).  If not trapped, returns
the result unchanged.  This signal is used to detect loss of significant
digits.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.Subnormal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Subnormal</span></span><a class="headerlink" href="decimal.html#decimal.Subnormal" title="Link to this definition">¶</a></dt>
<dd><p>Exponent was lower than <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emin</span></code> prior to rounding.</p>
<p>연산 결과가 비정상(지수가 너무 작음)일 때 발생합니다. 트랩 되지 않으면, 결과를 그대로 반환합니다.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.Underflow">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Underflow</span></span><a class="headerlink" href="decimal.html#decimal.Underflow" title="Link to this definition">¶</a></dt>
<dd><p>결과가 0으로 자리 올림 되는 수치적 언더플로.</p>
<p>자리 올림에 의해 비정상 결과가 0으로 밀릴 때 발생합니다. <a class="reference internal" href="decimal.html#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inexact</span></code></a>와 <a class="reference internal" href="decimal.html#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subnormal</span></code></a> 신호도 줍니다.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.FloatOperation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">FloatOperation</span></span><a class="headerlink" href="decimal.html#decimal.FloatOperation" title="Link to this definition">¶</a></dt>
<dd><p>float와 Decimal을 혼합하는 데 더 엄격한 의미를 사용합니다.</p>
<p>신호가 트랩되지 않으면 (기본값), <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 생성자, <a class="reference internal" href="decimal.html#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_decimal()</span></code></a> 및 모든 비교 연산자에서 float와 Decimal을 혼합 할 수 있습니다. 변환과 비교 모두 정확합니다. 복합 연산의 발생은 컨텍스트 플래그에 <a class="reference internal" href="decimal.html#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> 을 설정하여 조용히 기록됩니다. <a class="reference internal" href="decimal.html#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_float()</span></code></a> 나 <a class="reference internal" href="decimal.html#decimal.Context.create_decimal_from_float" title="decimal.Context.create_decimal_from_float"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_decimal_from_float()</span></code></a> 를 사용한 명시적 변환은 플래그를 설정하지 않습니다.</p>
<p>그렇지 않으면 (신호가 트랩되면), 같음 비교와 명시적 변환만 조용히 수행됩니다. 다른 모든 혼합된 연산은 <a class="reference internal" href="decimal.html#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> 을 발생시킵니다.</p>
</dd></dl>

<p>다음 표는 신호의 계층 구조를 요약한 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">exceptions</span><span class="o">.</span><span class="n">ArithmeticError</span><span class="p">(</span><span class="n">exceptions</span><span class="o">.</span><span class="n">Exception</span><span class="p">)</span>
    <span class="n">DecimalException</span>
        <span class="n">Clamped</span>
        <span class="n">DivisionByZero</span><span class="p">(</span><span class="n">DecimalException</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ZeroDivisionError</span><span class="p">)</span>
        <span class="n">Inexact</span>
            <span class="n">Overflow</span><span class="p">(</span><span class="n">Inexact</span><span class="p">,</span> <span class="n">Rounded</span><span class="p">)</span>
            <span class="n">Underflow</span><span class="p">(</span><span class="n">Inexact</span><span class="p">,</span> <span class="n">Rounded</span><span class="p">,</span> <span class="n">Subnormal</span><span class="p">)</span>
        <span class="n">InvalidOperation</span>
        <span class="n">Rounded</span>
        <span class="n">Subnormal</span>
        <span class="n">FloatOperation</span><span class="p">(</span><span class="n">DecimalException</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">TypeError</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="floating-point-notes">
<span id="decimal-notes"></span><h2>부동 소수점 노트<a class="headerlink" href="decimal.html#floating-point-notes" title="Link to this heading">¶</a></h2>
<section id="mitigating-round-off-error-with-increased-precision">
<h3>증가시킨 정밀도로 자리 올림 오차 줄이기<a class="headerlink" href="decimal.html#mitigating-round-off-error-with-increased-precision" title="Link to this heading">¶</a></h3>
<p>The use of decimal floating point eliminates decimal representation error
(making it possible to represent <code class="docutils literal notranslate"><span class="pre">0.1</span></code> exactly); however, some operations
can still incur round-off error when non-zero digits exceed the fixed precision.</p>
<p>자리 올림 오차의 효과는 거의 상쇄되는 양을 더하거나 빼는 것에 의해 증폭되어 유효숫자의 손실로 이어질 수 있습니다. Knuth는 불충분한 정밀도로 자리 올림 된 부동 소수점 산술로 인해 덧셈의 결합 법칙과 배분 법칙이 파괴되는 두 가지 사례를 제공합니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># Examples from Seminumerical Algorithms, Section 4.2.2.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">getcontext</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">8</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">11111113</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">11111111</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.51111111&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span>
<span class="go">Decimal(&#39;9.5111111&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;10&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">20000</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;6.0000003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.01&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
</pre></div>
</div>
<p><a class="reference internal" href="decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> 모듈은 유효숫자의 손실을 피할 수 있을 만큼 정밀도를 확장함으로써 항등 관계를 복구할 수 있게 합니다 :</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">11111113</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">11111111</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.51111111&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span>
<span class="go">Decimal(&#39;9.51111111&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;9.51111111&#39;)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">20000</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;6.0000003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
</pre></div>
</div>
</section>
<section id="special-values">
<h3>특수 값<a class="headerlink" href="decimal.html#special-values" title="Link to this heading">¶</a></h3>
<p>The number system for the <a class="reference internal" href="decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> module provides special values
including <code class="docutils literal notranslate"><span class="pre">NaN</span></code>, <code class="docutils literal notranslate"><span class="pre">sNaN</span></code>, <code class="docutils literal notranslate"><span class="pre">-Infinity</span></code>, <code class="docutils literal notranslate"><span class="pre">Infinity</span></code>,
and two zeros, <code class="docutils literal notranslate"><span class="pre">+0</span></code> and <code class="docutils literal notranslate"><span class="pre">-0</span></code>.</p>
<p>무한대는 다음과 같이 직접 생성될 수 있습니다: <code class="docutils literal notranslate"><span class="pre">Decimal('Infinity')</span></code>. 또한, <a class="reference internal" href="decimal.html#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> 신호가 트랩 되지 않을 때 0으로 나눠서 발생할 수 있습니다. 마찬가지로, <a class="reference internal" href="decimal.html#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Overflow</span></code></a> 신호가 트랩 되지 않을 때, 무한대는 표현 가능한 가장 큰 수의 한계를 넘어서 자리 올림 된 결과가 될 수 있습니다.</p>
<p>무한대는 부호가 있고 (아핀) 산술 연산에 사용될 수 있는데, 매우 크고 불확정적(indeterminate)인 숫자로 취급됩니다. 예를 들어, 무한대에 상수를 더하면 또 다른 무한대를 줍니다.</p>
<p>Some operations are indeterminate and return <code class="docutils literal notranslate"><span class="pre">NaN</span></code>, or if the
<a class="reference internal" href="decimal.html#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> signal is trapped, raise an exception.  For example,
<code class="docutils literal notranslate"><span class="pre">0/0</span></code> returns <code class="docutils literal notranslate"><span class="pre">NaN</span></code> which means “not a number”.  This variety of
<code class="docutils literal notranslate"><span class="pre">NaN</span></code> is quiet and, once created, will flow through other computations
always resulting in another <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.  This behavior can be useful for a
series of computations that occasionally have missing inputs — it allows the
calculation to proceed while flagging specific results as invalid.</p>
<p>A variant is <code class="docutils literal notranslate"><span class="pre">sNaN</span></code> which signals rather than remaining quiet after every
operation.  This is a useful return value when an invalid result needs to
interrupt a calculation for special handling.</p>
<p>The behavior of Python’s comparison operators can be a little surprising where a
<code class="docutils literal notranslate"><span class="pre">NaN</span></code> is involved.  A test for equality where one of the operands is a
quiet or signaling <code class="docutils literal notranslate"><span class="pre">NaN</span></code> always returns <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> (even when doing
<code class="docutils literal notranslate"><span class="pre">Decimal('NaN')==Decimal('NaN')</span></code>), while a test for inequality always returns
<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>.  An attempt to compare two Decimals using any of the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> operators will raise the <a class="reference internal" href="decimal.html#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> signal
if either operand is a <code class="docutils literal notranslate"><span class="pre">NaN</span></code>, and return <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> if this signal is
not trapped.  Note that the General Decimal Arithmetic specification does not
specify the behavior of direct comparisons; these rules for comparisons
involving a <code class="docutils literal notranslate"><span class="pre">NaN</span></code> were taken from the IEEE 854 standard (see Table 3 in
section 5.7).  To ensure strict standards-compliance, use the <a class="reference internal" href="decimal.html#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a>
and <a class="reference internal" href="decimal.html#decimal.Decimal.compare_signal" title="decimal.Decimal.compare_signal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare_signal()</span></code></a> methods instead.</p>
<p>부호 있는 0은 언더플로 하는 계산의 결과일 수 있습니다. 계산을 더 정밀하게 수행한다면 얻게 될 결과의 기호를 유지합니다. 크기가 0이기 때문에, 양과 음의 0은 같다고 취급되며 부호는 정보 용입니다.</p>
<p>서로 다른 부호를 갖는 부호 있는 0이 같은 것에 더해, 여전히 동등한 값이지만 다른 정밀도를 갖는 여러 표현이 존재합니다. 익숙해지는데 약간 시간이 필요합니다. 정규화된 부동 소수점 표현에 익숙한 사람들에게는, 다음 계산이 0과 같은 값을 반환한다는 것이 즉시 명백하지는 않습니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;Infinity&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;0E-1000026&#39;)</span>
</pre></div>
</div>
</section>
</section>
<section id="working-with-threads">
<span id="decimal-threads"></span><h2>스레드로 작업하기<a class="headerlink" href="decimal.html#working-with-threads" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="decimal.html#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 함수는 스레드마다 다른 <a class="reference internal" href="decimal.html#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 객체에 접근합니다. 별도의 스레드 컨텍스트를 갖는다는 것은 스레드가 다른 스레드를 방해하지 않고 변경할 수 있음을 의미합니다 (가령 <code class="docutils literal notranslate"><span class="pre">getcontext().prec=10</span></code>).</p>
<p>마찬가지로, <a class="reference internal" href="decimal.html#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a> 함수는 자동으로 대상을 현재 스레드에 할당합니다.</p>
<p><a class="reference internal" href="decimal.html#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a> 가 <a class="reference internal" href="decimal.html#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 전에 호출되지 않았다면, <a class="reference internal" href="decimal.html#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 는 현재 스레드에서 사용할 새로운 컨텍스트를 자동으로 생성합니다.</p>
<p>새 컨텍스트는 <em>DefaultContext</em> 라는 프로토타입 컨텍스트에서 복사됩니다. 각 스레드가 응용 프로그램 전체에서 같은 값을 사용하도록 기본값을 제어하려면, <em>DefaultContext</em> 객체를 직접 수정하십시오. <a class="reference internal" href="decimal.html#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 를 호출하는 스레드 사이에 경쟁 조건이 없도록, 어떤 스레드가 시작되기 <em>전에</em> 수행되어야 합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set applicationwide defaults for all threads about to be launched</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">rounding</span> <span class="o">=</span> <span class="n">ROUND_DOWN</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">traps</span> <span class="o">=</span> <span class="n">ExtendedContext</span><span class="o">.</span><span class="n">traps</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">InvalidOperation</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">setcontext</span><span class="p">(</span><span class="n">DefaultContext</span><span class="p">)</span>

<span class="c1"># Afterwards, the threads can be started</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t3</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
 <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
</pre></div>
</div>
</section>
<section id="recipes">
<span id="decimal-recipes"></span><h2>조리법<a class="headerlink" href="decimal.html#recipes" title="Link to this heading">¶</a></h2>
<p>다음은 유틸리티 함수로 사용되고 <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 클래스로 작업하는 방법을 보여주는 몇 가지 조리법입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">moneyfmt</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">curr</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">dp</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span>
             <span class="n">pos</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">trailneg</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert Decimal to a money formatted string.</span>

<span class="sd">    places:  required number of places after the decimal point</span>
<span class="sd">    curr:    optional currency symbol before the sign (may be blank)</span>
<span class="sd">    sep:     optional grouping separator (comma, period, space, or blank)</span>
<span class="sd">    dp:      decimal point indicator (comma or period)</span>
<span class="sd">             only specify as blank when places is zero</span>
<span class="sd">    pos:     optional sign for positive numbers: &#39;+&#39;, space or blank</span>
<span class="sd">    neg:     optional sign for negative numbers: &#39;-&#39;, &#39;(&#39;, space or blank</span>
<span class="sd">    trailneg:optional trailing minus indicator:  &#39;-&#39;, &#39;)&#39;, space or blank</span>

<span class="sd">    &gt;&gt;&gt; d = Decimal(&#39;-1234567.8901&#39;)</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;)</span>
<span class="sd">    &#39;-$1,234,567.89&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, places=0, sep=&#39;.&#39;, dp=&#39;&#39;, neg=&#39;&#39;, trailneg=&#39;-&#39;)</span>
<span class="sd">    &#39;1.234.568-&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;, neg=&#39;(&#39;, trailneg=&#39;)&#39;)</span>
<span class="sd">    &#39;($1,234,567.89)&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(Decimal(123456789), sep=&#39; &#39;)</span>
<span class="sd">    &#39;123 456 789.00&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(Decimal(&#39;-0.02&#39;), neg=&#39;&lt;&#39;, trailneg=&#39;&gt;&#39;)</span>
<span class="sd">    &#39;&lt;0.02&gt;&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="n">places</span>      <span class="c1"># 2 places --&gt; &#39;0.01&#39;</span>
    <span class="n">sign</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">as_tuple</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">digits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">digits</span><span class="p">))</span>
    <span class="n">build</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">pop</span>
    <span class="k">if</span> <span class="n">sign</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="n">trailneg</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">places</span><span class="p">):</span>
        <span class="n">build</span><span class="p">(</span><span class="nb">next</span><span class="p">()</span> <span class="k">if</span> <span class="n">digits</span> <span class="k">else</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">places</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">digits</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">build</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="n">neg</span> <span class="k">if</span> <span class="n">sign</span> <span class="k">else</span> <span class="n">pos</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">pi</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute Pi to the current precision.</span>

<span class="sd">    &gt;&gt;&gt; print(pi())</span>
<span class="sd">    3.141592653589793238462643383</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># extra digits for intermediate steps</span>
    <span class="n">three</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>      <span class="c1"># substitute &quot;three=3.0&quot; for regular floats</span>
    <span class="n">lasts</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">da</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">three</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">24</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">na</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="n">na</span><span class="p">,</span> <span class="n">na</span><span class="o">+</span><span class="mi">8</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">da</span> <span class="o">=</span> <span class="n">d</span><span class="o">+</span><span class="n">da</span><span class="p">,</span> <span class="n">da</span><span class="o">+</span><span class="mi">32</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>               <span class="c1"># unary plus applies the new precision</span>

<span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return e raised to the power of x.  Result type matches input type.</span>

<span class="sd">    &gt;&gt;&gt; print(exp(Decimal(1)))</span>
<span class="sd">    2.718281828459045235360287471</span>
<span class="sd">    &gt;&gt;&gt; print(exp(Decimal(2)))</span>
<span class="sd">    7.389056098930650227230427461</span>
<span class="sd">    &gt;&gt;&gt; print(exp(2.0))</span>
<span class="sd">    7.38905609893</span>
<span class="sd">    &gt;&gt;&gt; print(exp(2+0j))</span>
<span class="sd">    (7.38905609893+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>

<span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the cosine of x as measured in radians.</span>

<span class="sd">    The Taylor series approximation works best for a small value of x.</span>
<span class="sd">    For larger values, first compute x = x % (2 * pi).</span>

<span class="sd">    &gt;&gt;&gt; print(cos(Decimal(&#39;0.5&#39;)))</span>
<span class="sd">    0.8775825618903727161162815826</span>
<span class="sd">    &gt;&gt;&gt; print(cos(0.5))</span>
<span class="sd">    0.87758256189</span>
<span class="sd">    &gt;&gt;&gt; print(cos(0.5+0j))</span>
<span class="sd">    (0.87758256189+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">sign</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>

<span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the sine of x as measured in radians.</span>

<span class="sd">    The Taylor series approximation works best for a small value of x.</span>
<span class="sd">    For larger values, first compute x = x % (2 * pi).</span>

<span class="sd">    &gt;&gt;&gt; print(sin(Decimal(&#39;0.5&#39;)))</span>
<span class="sd">    0.4794255386042030002732879352</span>
<span class="sd">    &gt;&gt;&gt; print(sin(0.5))</span>
<span class="sd">    0.479425538604</span>
<span class="sd">    &gt;&gt;&gt; print(sin(0.5+0j))</span>
<span class="sd">    (0.479425538604+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">sign</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>
</pre></div>
</div>
</section>
<section id="decimal-faq">
<span id="id1"></span><h2>Decimal FAQ<a class="headerlink" href="decimal.html#decimal-faq" title="Link to this heading">¶</a></h2>
<p>Q. <code class="docutils literal notranslate"><span class="pre">decimal.Decimal('1234.5')</span></code> 라고 입력하는 것은 귀찮은 일입니다. 대화형 인터프리터를 사용할 때 타자를 최소화할 방법이 있습니까?</p>
<p>A. 일부 사용자는 생성자를 하나의 문자로 축약합니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">(</span><span class="s1">&#39;1.23&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">D</span><span class="p">(</span><span class="s1">&#39;3.45&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.68&#39;)</span>
</pre></div>
</div>
<p>Q. 소수점 두 자리의 고정 소수점 응용 프로그램에서, 일부 입력에 여러 자리가 있고 자리 올림 해야 합니다. 어떤 것은 여분의 자릿수가 없다고 가정되지만, 유효성 검사가 필요합니다. 어떤 방법을 사용해야 합니까?</p>
<p>A. The <a class="reference internal" href="decimal.html#decimal.Decimal.quantize" title="decimal.Decimal.quantize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code></a> method rounds to a fixed number of decimal places. If
the <a class="reference internal" href="decimal.html#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a> trap is set, it is also useful for validation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">TWOPLACES</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>       <span class="c1"># same as Decimal(&#39;0.01&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Round to two places</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.214&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.21&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Validate that a number does not exceed two places</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.21&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">Context</span><span class="p">(</span><span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]))</span>
<span class="go">Decimal(&#39;3.21&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.214&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">Context</span><span class="p">(</span><span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">   </span><span class="c">...</span>
<span class="gr">Inexact</span>: <span class="n">None</span>
</pre></div>
</div>
<p>Q. 일단 유효한 두 자리 입력이 있으면, 응용 프로그램 전체에서 해당 불변성을 어떻게 유지합니까?</p>
<p>A. Some operations like addition, subtraction, and multiplication by an integer
will automatically preserve fixed point.  Others operations, like division and
non-integer multiplication, will change the number of decimal places and need to
be followed-up with a <a class="reference internal" href="decimal.html#decimal.Decimal.quantize" title="decimal.Decimal.quantize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code></a> step:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;102.72&#39;</span><span class="p">)</span>           <span class="c1"># Initial fixed-point values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.17&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>                           <span class="c1"># Addition preserves fixed-point</span>
<span class="go">Decimal(&#39;105.89&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
<span class="go">Decimal(&#39;99.55&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="mi">42</span>                          <span class="c1"># So does integer multiplication</span>
<span class="go">Decimal(&#39;4314.24&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>     <span class="c1"># Must quantize non-integer multiplication</span>
<span class="go">Decimal(&#39;325.62&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>     <span class="c1"># And quantize division</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
</pre></div>
</div>
<p>In developing fixed-point applications, it is convenient to define functions
to handle the <a class="reference internal" href="decimal.html#decimal.Decimal.quantize" title="decimal.Decimal.quantize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code></a> step:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">TWOPLACES</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">TWOPLACES</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>                       <span class="c1"># Automatically preserve fixed-point</span>
<span class="go">Decimal(&#39;325.62&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">div</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
</pre></div>
</div>
<p>Q. There are many ways to express the same value.  The numbers <code class="docutils literal notranslate"><span class="pre">200</span></code>,
<code class="docutils literal notranslate"><span class="pre">200.000</span></code>, <code class="docutils literal notranslate"><span class="pre">2E2</span></code>, and <code class="docutils literal notranslate"><span class="pre">.02E+4</span></code> all have the same value at
various precisions. Is there a way to transform them to a single recognizable
canonical value?</p>
<p>A. The <a class="reference internal" href="decimal.html#decimal.Decimal.normalize" title="decimal.Decimal.normalize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">normalize()</span></code></a> method maps all equivalent values to a single
representative:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="s1">&#39;200 200.000 2E2 .02E+4&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
<span class="go">[Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;)]</span>
</pre></div>
</div>
<p>Q. When does rounding occur in a computation?</p>
<p>A. It occurs <em>after</em> the computation.  The philosophy of the decimal
specification is that numbers are considered exact and are created
independent of the current context.  They can even have greater
precision than current context.  Computations process with those
exact inputs and then rounding (or other context operations) is
applied to the <em>result</em> of the computation:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span>   <span class="c1"># More than 5 digits</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span>                             <span class="c1"># All digits are retained</span>
<span class="go">Decimal(&#39;3.1415926535&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span> <span class="o">+</span> <span class="mi">0</span>                         <span class="c1"># Rounded after an addition</span>
<span class="go">Decimal(&#39;3.1416&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span> <span class="o">-</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.00005&#39;</span><span class="p">)</span>        <span class="c1"># Subtract unrounded numbers, then round</span>
<span class="go">Decimal(&#39;3.1415&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span> <span class="o">+</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.00005&#39;</span><span class="p">)</span><span class="o">.</span>   <span class="c1"># Intermediate values are rounded</span>
<span class="go">Decimal(&#39;3.1416&#39;)</span>
</pre></div>
</div>
<p>Q. 일부 십진수 값은 항상 지수 표기법으로 인쇄됩니다. 지수가 아닌 표현을 얻을 방법이 있습니까?</p>
<p>A. For some values, exponential notation is the only way to express the number
of significant places in the coefficient.  For example, expressing
<code class="docutils literal notranslate"><span class="pre">5.0E+3</span></code> as <code class="docutils literal notranslate"><span class="pre">5000</span></code> keeps the value constant but cannot show the
original’s two-place significance.</p>
<p>응용 프로그램이 유효 숫자를 추적하는 데 신경 쓰지 않으면, 지수 및 후행 0을 제거하고 유효숫자를 잃지만, 값이 바뀌지 않도록 하기는 쉽습니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">remove_exponent</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">d</span><span class="o">.</span><span class="n">to_integral</span><span class="p">()</span> <span class="k">else</span> <span class="n">d</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">remove_exponent</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;5E+3&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;5000&#39;)</span>
</pre></div>
</div>
<p>Q. 일반 float를 <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>로 변환하는 방법이 있습니까?</p>
<p>A. 그렇습니다. 모든 이진 부동 소수점은 Decimal로 정확히 표현될 수 있습니다. 하지만 정확한 변환이 취하는 정밀도는 직관이 제안하는 것보다 더 클 수 있습니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.141592653589793115997963468544185161590576171875&#39;)</span>
</pre></div>
</div>
<p>Q. 복잡한 계산에서, 정밀도가 부족하거나 자리 올림 이상이 발생하여 엉터리 결과를 얻지는 않았는지 확인하려면 어떻게 해야 합니까?</p>
<p>A. decimal 모듈은 결과를 쉽게 테스트할 수 있게 합니다. 가장 좋은 방법은 더 높은 정밀도와 다양한 자리 올림 모드를 사용하여 계산을 다시 실행하는 것입니다. 크게 다른 결과는 정밀도 부족, 자리 올림 모드 문제, 부적절한 입력 또는 수치가 불안정한 알고리즘을 나타냅니다.</p>
<p>컨텍스트 정밀도가 입력이 아닌 연산 결과에 적용된다는 사실을 확인했습니다. 다른 정밀도의 값을 혼합할 때 주의해야 할 것이 있습니까?</p>
<p>A. 그렇습니다. 원칙은 모든 값이 정확한 것으로 간주하므로 해당 값에 대한 산술도 마찬가지라는 것입니다. 결과 만 자리 올림 됩니다. 입력에 대한 이점은 “입력하는 것이 얻는 것”이라는 것입니다. 단점은 입력값을 자리 올림 하는 것을 잊어버리면 결과가 이상하게 보일 수 있다는 점입니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.104&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.104&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.21&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.104&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.000&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.104&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.20&#39;)</span>
</pre></div>
</div>
<p>해법은 정밀도를 높이거나 단항 플러스 연산을 사용하여 입력의 자리 올림을 강제 수행하는 것입니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">+</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.23456789&#39;</span><span class="p">)</span>      <span class="c1"># unary plus triggers rounding</span>
<span class="go">Decimal(&#39;1.23&#39;)</span>
</pre></div>
</div>
<p>다른 방법으로, 입력은 <a class="reference internal" href="decimal.html#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Context.create_decimal()</span></code></a> 메서드를 사용하여 생성 시에 자리 올림 될 수 있습니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span><span class="o">.</span><span class="n">create_decimal</span><span class="p">(</span><span class="s1">&#39;1.2345678&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.2345&#39;)</span>
</pre></div>
</div>
<p>Q. CPython 구현은 커다란 수에서 빠릅니까?</p>
<p>A. Yes.  In the CPython and PyPy3 implementations, the C/CFFI versions of
the decimal module integrate the high speed <a class="reference external" href="https://www.bytereef.org/mpdecimal/doc/libmpdec/index.html">libmpdec</a> library for
arbitrary precision correctly rounded decimal floating point arithmetic <a class="footnote-reference brackets" href="decimal.html#id4" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.
<code class="docutils literal notranslate"><span class="pre">libmpdec</span></code> uses <a class="reference external" href="https://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba multiplication</a>
for medium-sized numbers and the <a class="reference external" href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform_(general)#Number-theoretic_transform">Number Theoretic Transform</a>
for very large numbers.</p>
<p>The context must be adapted for exact arbitrary precision arithmetic. <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emin</span></code>
and <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code> should always be set to the maximum values, <code class="xref py py-attr docutils literal notranslate"><span class="pre">clamp</span></code>
should always be 0 (the default).  Setting <code class="xref py py-attr docutils literal notranslate"><span class="pre">prec</span></code> requires some care.</p>
<p>The easiest approach for trying out bignum arithmetic is to use the maximum
value for <code class="xref py py-attr docutils literal notranslate"><span class="pre">prec</span></code> as well <a class="footnote-reference brackets" href="decimal.html#id5" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="n">MAX_PREC</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="n">MAX_EMAX</span><span class="p">,</span> <span class="n">Emin</span><span class="o">=</span><span class="n">MIN_EMIN</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">256</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">/</span> <span class="mi">128</span>
<span class="go">Decimal(&#39;904625697166532776746648320380374280103671755200316906558262375061821325312&#39;)</span>
</pre></div>
</div>
<p>부정확한 결과의 경우, 64비트 플랫폼에서 <a class="reference internal" href="decimal.html#decimal.MAX_PREC" title="decimal.MAX_PREC"><code class="xref py py-attr docutils literal notranslate"><span class="pre">MAX_PREC</span></code></a>는 너무 크고 사용 가능한 메모리가 충분하지 않을 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">MemoryError</span>
</pre></div>
</div>
<p>On systems with overallocation (e.g. Linux), a more sophisticated approach is to
adjust <code class="xref py py-attr docutils literal notranslate"><span class="pre">prec</span></code> to the amount of available RAM.  Suppose that you have 8GB of
RAM and expect 10 simultaneous operands using a maximum of 500MB each:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Maximum number of digits for a single operand using 500MB in 8-byte words</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># with 19 digits per word (4-byte and 9 digits for the 32-bit build):</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">maxdigits</span> <span class="o">=</span> <span class="mi">19</span> <span class="o">*</span> <span class="p">((</span><span class="mi">500</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check that this works:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="n">maxdigits</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="n">MAX_EMAX</span><span class="p">,</span> <span class="n">Emin</span><span class="o">=</span><span class="n">MIN_EMIN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Fill the available precision with nines:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">logical_invert</span><span class="p">()</span> <span class="o">*</span> <span class="mi">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">524288112</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">  decimal.Inexact</span>: <span class="n">[&lt;class &#39;decimal.Inexact&#39;&gt;]</span>
</pre></div>
</div>
<p>일반적으로 (그리고 특히 초과 할당이 없는 시스템에서), 더 엄격한 경계를 추정하고 모든 계산이 정확할 것으로 예상되면 <a class="reference internal" href="decimal.html#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Inexact</span></code></a> 트랩을 설정하는 것이 좋습니다.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="decimal.html#id2">1</a><span class="fn-bracket">]</span></span>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</aside>
<aside class="footnote brackets" id="id5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="decimal.html#id3">2</a><span class="fn-bracket">]</span></span>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>이 접근법은 정수가 아닌 거듭제곱을 제외한 모든 정확한 결과에 적용됩니다.</p>
</div>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="decimal.html#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code> — Decimal fixed point and floating point arithmetic</a><ul>
<li><a class="reference internal" href="decimal.html#quick-start-tutorial">빠른 시작 자습서</a></li>
<li><a class="reference internal" href="decimal.html#decimal-objects">Decimal 객체</a><ul>
<li><a class="reference internal" href="decimal.html#logical-operands">논리적 피연산자</a></li>
</ul>
</li>
<li><a class="reference internal" href="decimal.html#context-objects">Context 객체</a></li>
<li><a class="reference internal" href="decimal.html#constants">상수</a></li>
<li><a class="reference internal" href="decimal.html#rounding-modes">자리 올림 모드</a></li>
<li><a class="reference internal" href="decimal.html#signals">신호</a></li>
<li><a class="reference internal" href="decimal.html#floating-point-notes">부동 소수점 노트</a><ul>
<li><a class="reference internal" href="decimal.html#mitigating-round-off-error-with-increased-precision">증가시킨 정밀도로 자리 올림 오차 줄이기</a></li>
<li><a class="reference internal" href="decimal.html#special-values">특수 값</a></li>
</ul>
</li>
<li><a class="reference internal" href="decimal.html#working-with-threads">스레드로 작업하기</a></li>
<li><a class="reference internal" href="decimal.html#recipes">조리법</a></li>
<li><a class="reference internal" href="decimal.html#decimal-faq">Decimal FAQ</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="cmath.html"
                          title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code> — Mathematical functions for complex numbers</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="fractions.html"
                          title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions</span></code> — Rational numbers</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/decimal.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="사이드바 닫기">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="fractions.html" title="fractions — Rational numbers"
             >다음</a> |</li>
        <li class="right" >
          <a href="cmath.html" title="cmath — Mathematical functions for complex numbers"
             >이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="numeric.html" >숫자와 수학 모듈</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="decimal.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code> — Decimal fixed point and floating point arithmetic</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    저작권
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="../../../license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      최종 업데이트: Jun 09, 2024 (17:23 UTC)
    
      <a href="../../../bugs.html">Found a bug</a>?
    
    <br />

    <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7 버전으로 생성되었습니다.
    </div>

    <script type="text/javascript" src="../_static/switchers.js"></script>
  </body>
</html>