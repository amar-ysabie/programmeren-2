<!DOCTYPE html>

<html lang="ko" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="이벤트 루프" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/asyncio-eventloop.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="소스 코드: Lib/asyncio/events.py, Lib/asyncio/base_events.py 머리말 이벤트 루프는 모든 asyncio 응용 프로그램의 핵심입니다. 이벤트 루프는 비동기 태스크 및 콜백을 실행하고 네트워크 IO 연산을 수행하며 자식 프로세스를 실행합니다. 응용 프로그램 개발자는 일반적으로 asyncio.run() 과 같은 고수준..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="소스 코드: Lib/asyncio/events.py, Lib/asyncio/base_events.py 머리말 이벤트 루프는 모든 asyncio 응용 프로그램의 핵심입니다. 이벤트 루프는 비동기 태스크 및 콜백을 실행하고 네트워크 IO 연산을 수행하며 자식 프로세스를 실행합니다. 응용 프로그램 개발자는 일반적으로 asyncio.run() 과 같은 고수준..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>이벤트 루프 &#8212; Python 3.12.4 문서</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css%3Fv=80d5e7a1.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css%3Fv=bb723527.css" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css%3Fv=b20cc3f5.css" />
    
    <script src="../_static/documentation_options.js%3Fv=3050f571"></script>
    <script src="../_static/doctools.js%3Fv=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js%3Fv=dc90522c"></script>
    <script src="../_static/translations.js%3Fv=b5f768d8"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.12.4 문서에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="퓨처" href="asyncio-future.html" />
    <link rel="prev" title="예외" href="asyncio-exceptions.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="../../../3/library/asyncio-eventloop.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" />
                <input type="submit" value="이동"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="asyncio-eventloop.html#">이벤트 루프</a><ul>
<li><a class="reference internal" href="asyncio-eventloop.html#event-loop-methods">이벤트 루프 메서드</a><ul>
<li><a class="reference internal" href="asyncio-eventloop.html#running-and-stopping-the-loop">루프 실행 및 중지</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#scheduling-callbacks">콜백 예약하기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#scheduling-delayed-callbacks">지연된 콜백 예약</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#creating-futures-and-tasks">퓨처와 태스크 만들기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#opening-network-connections">네트워크 연결 열기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#creating-network-servers">네트워크 서버 만들기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#transferring-files">파일 전송</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#tls-upgrade">TLS 업그레이드</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#watching-file-descriptors">파일 기술자 관찰하기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#working-with-socket-objects-directly">소켓 객체로 직접 작업하기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#dns">DNS</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#working-with-pipes">파이프로 작업하기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#unix-signals">유닉스 시그널</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#executing-code-in-thread-or-process-pools">스레드 또는 프로세스 풀에서 코드를 실행하기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#error-handling-api">에러 처리 API</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#enabling-debug-mode">디버그 모드 활성화</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#running-subprocesses">자식 프로세스 실행하기</a></li>
</ul>
</li>
<li><a class="reference internal" href="asyncio-eventloop.html#callback-handles">콜백 핸들</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#server-objects">서버 객체</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#event-loop-implementations">이벤트 루프 구현</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#examples">예제</a><ul>
<li><a class="reference internal" href="asyncio-eventloop.html#hello-world-with-call-soon">call_soon()을 사용하는 Hello World</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#display-the-current-date-with-call-later">call_later()로 현재 날짜를 표시합니다.</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#watch-a-file-descriptor-for-read-events">파일 기술자에서 읽기 이벤트를 관찰하기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#set-signal-handlers-for-sigint-and-sigterm">SIGINT 및 SIGTERM에 대한 시그널 처리기 설정</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="asyncio-exceptions.html"
                          title="이전 장">예외</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="asyncio-future.html"
                          title="다음 장">퓨처</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/asyncio-eventloop.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="퓨처"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="asyncio-exceptions.html" title="예외"
             accesskey="P">이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >네트워킹과 프로세스 간 통신</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> — Asynchronous I/O</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="asyncio-eventloop.html">이벤트 루프</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="event-loop">
<span id="asyncio-event-loop"></span><h1>이벤트 루프<a class="headerlink" href="asyncio-eventloop.html#event-loop" title="Link to this heading">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/asyncio/events.py">Lib/asyncio/events.py</a>, <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/asyncio/base_events.py">Lib/asyncio/base_events.py</a></p>
<hr class="docutils" />
<p class="rubric">머리말</p>
<p>이벤트 루프는 모든 asyncio 응용 프로그램의 핵심입니다. 이벤트 루프는 비동기 태스크 및 콜백을 실행하고 네트워크 IO 연산을 수행하며 자식 프로세스를 실행합니다.</p>
<p>응용 프로그램 개발자는 일반적으로 <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>과 같은 고수준의 asyncio 함수를 사용해야 하며, 루프 객체를 참조하거나 메서드를 호출할 필요가 거의 없습니다. 이 절은 주로 이벤트 루프 동작을 세부적으로 제어해야 하는 저수준 코드, 라이브러리 및 프레임워크의 작성자를 대상으로 합니다.</p>
<p class="rubric">이벤트 루프 얻기</p>
<p>다음 저수준 함수를 사용하여 이벤트 루프를 가져오거나 설정하거나 만들 수 있습니다.:</p>
<dl class="py function">
<dt class="sig sig-object py" id="asyncio.get_running_loop">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">get_running_loop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.get_running_loop" title="Link to this definition">¶</a></dt>
<dd><p>현재 OS 스레드에서 실행 중인 이벤트 루프를 반환합니다.</p>
<p>Raise a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> if there is no running event loop.</p>
<p>This function can only be called from a coroutine or a callback.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.get_event_loop">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">get_event_loop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.get_event_loop" title="Link to this definition">¶</a></dt>
<dd><p>현재의 이벤트 루프를 가져옵니다.</p>
<p>When called from a coroutine or a callback (e.g. scheduled with
call_soon or similar API), this function will always return the
running event loop.</p>
<p>If there is no running event loop set, the function will return
the result of the <code class="docutils literal notranslate"><span class="pre">get_event_loop_policy().get_event_loop()</span></code> call.</p>
<p>이 함수는 (특히 사용자 정의 이벤트 루프 정책을 사용할 때) 다소 복잡한 동작을 하므로, 코루틴과 콜백에서 <a class="reference internal" href="asyncio-eventloop.html#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_event_loop()</span></code></a>보다 <a class="reference internal" href="asyncio-eventloop.html#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_running_loop()</span></code></a> 함수를 사용하는 것이 좋습니다.</p>
<p>As noted above, consider using the higher-level <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a> function,
instead of using these lower level functions to manually create and close an
event loop.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.12부터 폐지됨: </span>Deprecation warning is emitted if there is no current event loop.
In some future Python release this will become an error.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.set_event_loop">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">set_event_loop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loop</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.set_event_loop" title="Link to this definition">¶</a></dt>
<dd><p>Set <em>loop</em> as the current event loop for the current OS thread.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.new_event_loop">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">new_event_loop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.new_event_loop" title="Link to this definition">¶</a></dt>
<dd><p>Create and return a new event loop object.</p>
</dd></dl>

<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_event_loop()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.set_event_loop" title="asyncio.set_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_event_loop()</span></code></a> 및 <a class="reference internal" href="asyncio-eventloop.html#asyncio.new_event_loop" title="asyncio.new_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">new_event_loop()</span></code></a> 함수의 동작은 <a class="reference internal" href="asyncio-policy.html#asyncio-policies"><span class="std std-ref">사용자 정의 이벤트 루프 정책 설정</span></a>에 의해 변경될 수 있음에 유의하십시오.</p>
<p class="rubric">목차</p>
<p>이 설명서 페이지는 다음과 같은 절로 구성됩니다:</p>
<ul class="simple">
<li><p><a class="reference internal" href="asyncio-eventloop.html#event-loop-methods">이벤트 루프 메서드</a> 절은 이벤트 루프 API의 레퍼런스 설명서입니다.</p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#callback-handles">콜백 핸들</a> 절은 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a> 및 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a>와 같은 예약 메서드에서 반환된 <a class="reference internal" href="asyncio-eventloop.html#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a> 및 <a class="reference internal" href="asyncio-eventloop.html#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimerHandle</span></code></a> 인스턴스를 설명합니다.</p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#server-objects">서버 객체</a> 절은 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>와 같은 이벤트 루프 메서드에서 반환되는 형을 설명합니다.</p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#event-loop-implementations">이벤트 루프 구현</a> 절은 <a class="reference internal" href="asyncio-eventloop.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> 및 <a class="reference internal" href="asyncio-eventloop.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> 클래스를 설명합니다.</p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#examples">예제</a> 절에서는 일부 이벤트 루프 API로 작업하는 방법을 보여줍니다.</p></li>
</ul>
<section id="event-loop-methods">
<span id="asyncio-event-loop-methods"></span><h2>이벤트 루프 메서드<a class="headerlink" href="asyncio-eventloop.html#event-loop-methods" title="Link to this heading">¶</a></h2>
<p>이벤트 루프에는 다음과 같은 <strong>저수준</strong> API가 있습니다:</p>
<nav class="contents local" id="id1">
<ul class="simple">
<li><p><a class="reference internal" href="asyncio-eventloop.html#running-and-stopping-the-loop" id="id2">루프 실행 및 중지</a></p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#scheduling-callbacks" id="id3">콜백 예약하기</a></p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#scheduling-delayed-callbacks" id="id4">지연된 콜백 예약</a></p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#creating-futures-and-tasks" id="id5">퓨처와 태스크 만들기</a></p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#opening-network-connections" id="id6">네트워크 연결 열기</a></p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#creating-network-servers" id="id7">네트워크 서버 만들기</a></p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#transferring-files" id="id8">파일 전송</a></p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#tls-upgrade" id="id9">TLS 업그레이드</a></p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#watching-file-descriptors" id="id10">파일 기술자 관찰하기</a></p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#working-with-socket-objects-directly" id="id11">소켓 객체로 직접 작업하기</a></p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#dns" id="id12">DNS</a></p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#working-with-pipes" id="id13">파이프로 작업하기</a></p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#unix-signals" id="id14">유닉스 시그널</a></p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#executing-code-in-thread-or-process-pools" id="id15">스레드 또는 프로세스 풀에서 코드를 실행하기</a></p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#error-handling-api" id="id16">에러 처리 API</a></p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#enabling-debug-mode" id="id17">디버그 모드 활성화</a></p></li>
<li><p><a class="reference internal" href="asyncio-eventloop.html#running-subprocesses" id="id18">자식 프로세스 실행하기</a></p></li>
</ul>
</nav>
<section id="running-and-stopping-the-loop">
<h3><a class="toc-backref" href="asyncio-eventloop.html#id2" role="doc-backlink">루프 실행 및 중지</a><a class="headerlink" href="asyncio-eventloop.html#running-and-stopping-the-loop" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.run_until_complete">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">run_until_complete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">future</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.run_until_complete" title="Link to this definition">¶</a></dt>
<dd><p><em>future</em>(<a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>의 인스턴스)가 완료할 때까지 실행합니다.</p>
<p>인자가 <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">코루틴 객체</span></a> 면, <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a>로 실행되도록 묵시적으로 예약 됩니다.</p>
<p>퓨처의 결과를 반환하거나 퓨처의 예외를 일으킵니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.run_forever">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">run_forever</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.run_forever" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a>가 호출될 때까지 이벤트 루프를 실행합니다.</p>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> 가 호출되기 전에 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> 이 호출되었으면, 루프는 시간제한 0으로 I/O 셀렉터를 한 번 폴링하고, I/O 이벤트에 따라 예약된 모든 콜백(과 이미 예약된 것들)을 실행한 다음 종료합니다.</p>
<p>만약 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> 이 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> 가 실행 중일 때 호출되면, 루프는 현재 걸려있는 콜백들을 실행한 다음 종료합니다. 콜백에 의해 예약되는 새 콜백은 이 경우 실행되지 않습니다; 대신 그것들은 다음에 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a>나 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.run_until_complete" title="asyncio.loop.run_until_complete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_until_complete()</span></code></a>가 호출될 때 실행됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.stop">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.stop" title="Link to this definition">¶</a></dt>
<dd><p>이벤트 루프를 중지합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.is_running">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">is_running</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.is_running" title="Link to this definition">¶</a></dt>
<dd><p>이벤트 루프가 현재 실행 중이면 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.is_closed">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">is_closed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.is_closed" title="Link to this definition">¶</a></dt>
<dd><p>이벤트 루프가 닫혔으면 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.close">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.close" title="Link to this definition">¶</a></dt>
<dd><p>이벤트 루프를 닫습니다.</p>
<p>이 함수를 호출할 때 루프는 반드시 실행 중이지 않아야 합니다. 계류 중인 모든 콜백을 버립니다.</p>
<p>이 메서드는 모든 큐를 비우고 실행기를 종료하지만, 실행기가 완료할 때까지 기다리지 않습니다.</p>
<p>이 메서드는 멱등적(itempotent)이고 되돌릴 수 없습니다. 이벤트 루프가 닫힌 후에 다른 메서드를 호출해서는 안 됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.shutdown_asyncgens">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">shutdown_asyncgens</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.shutdown_asyncgens" title="Link to this definition">¶</a></dt>
<dd><p>현재 열려있는 <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">비동기 제너레이터</span></a> 객체를 모두 <a class="reference internal" href="../reference/expressions.html#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> 호출로 닫도록 예약 합니다. 이 메서드를 호출한 후에는, 새 비동기 생성기가 이터레이트 되면 이벤트 루프에서 경고를 보냅니다. 예약된 모든 비동기 제너레이터를 신뢰성 있게 종료하는 데 사용해야 합니다.</p>
<p><a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>가 사용될 때 이 함수를 호출할 필요는 없다는 점에 유의하세요.</p>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">shutdown_asyncgens</span><span class="p">())</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.shutdown_default_executor">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">shutdown_default_executor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.shutdown_default_executor" title="Link to this definition">¶</a></dt>
<dd><p>Schedule the closure of the default executor and wait for it to join all of
the threads in the <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>.
Once this method has been called,
using the default executor with <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a>
will raise a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>.</p>
<p>The <em>timeout</em> parameter specifies the amount of time
(in <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> seconds) the executor will be given to finish joining.
With the default, <code class="docutils literal notranslate"><span class="pre">None</span></code>,
the executor is allowed an unlimited amount of time.</p>
<p>If the <em>timeout</em> is reached, a <a class="reference internal" href="exceptions.html#RuntimeWarning" title="RuntimeWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeWarning</span></code></a> is emitted
and the default executor is terminated
without waiting for its threads to finish joining.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>Do not call this method when using <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>,
as the latter handles default executor shutdown automatically.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span>Added the <em>timeout</em> parameter.</p>
</div>
</dd></dl>

</section>
<section id="scheduling-callbacks">
<h3><a class="toc-backref" href="asyncio-eventloop.html#id3" role="doc-backlink">콜백 예약하기</a><a class="headerlink" href="asyncio-eventloop.html#scheduling-callbacks" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_soon">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_soon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.call_soon" title="Link to this definition">¶</a></dt>
<dd><p>이벤트 루프의 다음 이터레이션 때 <em>args</em> 인자로 호출할 <em>callback</em> <a class="reference internal" href="../glossary.html#term-callback"><span class="xref std std-term">콜백</span></a>을 예약합니다.</p>
<p>Return an instance of <a class="reference internal" href="asyncio-eventloop.html#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Handle</span></code></a>,
which can be used later to cancel the callback.</p>
<p>콜백은 등록된 순서대로 호출됩니다. 각 콜백은 정확히 한 번 호출됩니다.</p>
<p>The optional keyword-only <em>context</em> argument specifies a
custom <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> for the <em>callback</em> to run in.
Callbacks use the current context when no <em>context</em> is provided.</p>
<p>Unlike <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.call_soon_threadsafe" title="asyncio.loop.call_soon_threadsafe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_soon_threadsafe()</span></code></a>, this method is not thread-safe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_soon_threadsafe">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_soon_threadsafe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.call_soon_threadsafe" title="Link to this definition">¶</a></dt>
<dd><p>A thread-safe variant of <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_soon()</span></code></a>. When scheduling callbacks from
another thread, this function <em>must</em> be used, since <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_soon()</span></code></a> is not
thread-safe.</p>
<p>Raises <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> if called on a loop that’s been closed.
This can happen on a secondary thread when the main application is
shutting down.</p>
<p>설명서의 <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span class="std std-ref">동시성과 다중 스레딩</span></a> 절을 참고하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>context</em> 키워드 전용 매개 변수가 추가되었습니다. 자세한 정보는 <span class="target" id="index-12"></span><a class="pep reference external" href="https://peps.python.org/pep-0567/"><strong>PEP 567</strong></a>을 보십시오.</p>
</div>
</dd></dl>

<div class="admonition note" id="asyncio-pass-keywords">
<p class="admonition-title">참고</p>
<p>대부분 <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> 예약 함수는 키워드 인자 전달을 허용하지 않습니다. 그렇게 하려면 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>을 사용하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># will schedule &quot;print(&quot;Hello&quot;, flush=True)&quot;</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span>
    <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
<p>asyncio는 디버그 및 오류 메시지에서 partial 객체를 더욱 잘 표시할 수 있으므로, partial 객체를 사용하는 것이 람다를 사용하는 것보다 편리합니다.</p>
</div>
</section>
<section id="scheduling-delayed-callbacks">
<span id="asyncio-delayed-calls"></span><h3><a class="toc-backref" href="asyncio-eventloop.html#id4" role="doc-backlink">지연된 콜백 예약</a><a class="headerlink" href="asyncio-eventloop.html#scheduling-delayed-callbacks" title="Link to this heading">¶</a></h3>
<p>이벤트 루프는 콜백 함수가 미래의 어떤 시점에서 호출되도록 예약하는 메커니즘을 제공합니다. 이벤트 루프는 단조 시계를 사용하여 시간을 추적합니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_later">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_later</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delay</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.call_later" title="Link to this definition">¶</a></dt>
<dd><p>지정된 <em>delay</em> 초 (int 또는 float) 뒤에 <em>callback</em> 이 호출되도록 예약합니다.</p>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TimerHandle</span></code></a> 의 인스턴스가 반환되는데, 콜백을 취소하는 데 사용할 수 있습니다.</p>
<p><em>callback</em> 은 정확히 한번 호출됩니다. 두 콜백이 정확히 같은 시간에 예약되면, 어떤 것이 먼저 호출되는지는 정의되지 않습니다.</p>
<p>선택적 위치 <em>args</em> 는 호출 될 때 콜백에 전달됩니다. 콜백을 키워드 인자로 호출하고 싶으면 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> 를 사용하십시오.</p>
<p>선택적인 키워드 전용 <em>context</em> 인자는 <em>callback</em> 을 실행할 사용자 정의 <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> 를 지정할 수 있게 합니다. <em>context</em> 가 제공되지 않을 때는 현재 컨텍스트가 사용됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>context</em> 키워드 전용 매개 변수가 추가되었습니다. 자세한 정보는 <span class="target" id="index-13"></span><a class="pep reference external" href="https://peps.python.org/pep-0567/"><strong>PEP 567</strong></a>을 보십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>파이썬 3.7 및 이전 버전에서 기본 이벤트 루프 구현을 사용할 때, <em>delay</em>는 하루를 초과할 수 없었습니다. 이 문제는 파이썬 3.8에서 수정되었습니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_at">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">when</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.call_at" title="Link to this definition">¶</a></dt>
<dd><p>지정된 절대 타임스탬프 <em>when</em>(int 또는 float)에 <em>callback</em> 이 호출되도록 예약합니다. <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.time" title="asyncio.loop.time"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.time()</span></code></a> 과 같은 시간 참조를 사용하십시오.</p>
<p>이 메서드의 동작은 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_later()</span></code></a>와 같습니다.</p>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TimerHandle</span></code></a> 의 인스턴스가 반환되는데, 콜백을 취소하는 데 사용할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>context</em> 키워드 전용 매개 변수가 추가되었습니다. 자세한 정보는 <span class="target" id="index-14"></span><a class="pep reference external" href="https://peps.python.org/pep-0567/"><strong>PEP 567</strong></a>을 보십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>파이썬 3.7 및 이전 버전에서 기본 이벤트 루프 구현을 사용할 때, <em>when</em>와 현재 시각의 차이는 하루를 초과할 수 없었습니다. 이 문제는 파이썬 3.8에서 수정되었습니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.time">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">time</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.time" title="Link to this definition">¶</a></dt>
<dd><p>이벤트 루프의 내부 단조 시계에 따라, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 값으로 현재 시각을 반환합니다.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">참고</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>파이썬 3.7 및 이전 버전에서 제한 시간(상대적인 <em>delay</em> 나 절대적인 <em>when</em>)은 1일을 초과하지 않아야 했습니다. 이 문제는 파이썬 3.8에서 수정되었습니다.</p>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="asyncio-task.html#asyncio.sleep" title="asyncio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.sleep()</span></code></a> 함수.</p>
</div>
</section>
<section id="creating-futures-and-tasks">
<h3><a class="toc-backref" href="asyncio-eventloop.html#id5" role="doc-backlink">퓨처와 태스크 만들기</a><a class="headerlink" href="asyncio-eventloop.html#creating-futures-and-tasks" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_future">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_future</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.create_future" title="Link to this definition">¶</a></dt>
<dd><p>이벤트 루프에 연결된 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 객체를 만듭니다.</p>
<p>이것이 asyncio에서 퓨처를 만드는 데 선호되는 방법입니다. 이렇게 하면 제삼자 이벤트 루프가 Future 객체의 다른 구현(더 나은 성능이나 계측(instrumentation))을 제공할 수 있습니다</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_task">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_task</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coro</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.create_task" title="Link to this definition">¶</a></dt>
<dd><p>Schedule the execution of <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">coroutine</span></a> <em>coro</em>.
Return a <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object.</p>
<p>제삼자 이벤트 루프는 상호 운용성을 위해 자신만의 <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> 의 서브 클래스를 사용할 수 있습니다. 이 경우, 결과 형은 <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> 의 서브 클래스입니다.</p>
<p><em>name</em> 인자가 제공되고 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면, <a class="reference internal" href="asyncio-task.html#asyncio.Task.set_name" title="asyncio.Task.set_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Task.set_name()</span></code></a>을 사용하여 태스크의 이름으로 설정됩니다.</p>
<p>An optional keyword-only <em>context</em> argument allows specifying a
custom <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> for the <em>coro</em> to run in.
The current context copy is created when no <em>context</em> is provided.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>Added the <em>name</em> parameter.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>Added the <em>context</em> parameter.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.set_task_factory">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">set_task_factory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factory</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.set_task_factory" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_task" title="asyncio.loop.create_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_task()</span></code></a> 에 의해 사용되는 태스크 팩토리를 설정합니다.</p>
<p>If <em>factory</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code> the default task factory will be set.
Otherwise, <em>factory</em> must be a <em>callable</em> with the signature matching
<code class="docutils literal notranslate"><span class="pre">(loop,</span> <span class="pre">coro,</span> <span class="pre">context=None)</span></code>, where <em>loop</em> is a reference to the active
event loop, and <em>coro</em> is a coroutine object.  The callable
must return a <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a>-compatible object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.get_task_factory">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">get_task_factory</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.get_task_factory" title="Link to this definition">¶</a></dt>
<dd><p>태스크 팩토리를 반환하거나, 기본값이 사용 중이면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 반환합니다.</p>
</dd></dl>

</section>
<section id="opening-network-connections">
<h3><a class="toc-backref" href="asyncio-eventloop.html#id6" role="doc-backlink">네트워크 연결 열기</a><a class="headerlink" href="asyncio-eventloop.html#opening-network-connections" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_connection">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_connection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_addr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">happy_eyeballs_delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interleave</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="Link to this definition">¶</a></dt>
<dd><p>주어진 <em>host</em> 와 <em>port</em>로 지정된 주소로의 스트리밍 트랜스포트 연결을 엽니다.</p>
<p>The socket family can be either <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a> or
<a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a> depending on <em>host</em> (or the <em>family</em>
argument, if provided).</p>
<p>The socket type will be <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>.</p>
<p><em>protocol_factory</em> 는 반드시 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">asyncio 프로토콜</span></a> 구현을 반환하는 콜러블이어야 합니다.</p>
<p>이 메서드는 백그라운드에서 연결을 맺으려고 시도합니다. 성공하면, <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다.</p>
<p>하부 연산의 시간순 개요는 다음과 같습니다:</p>
<ol class="arabic simple">
<li><p>연결이 맺어지고, 이를 위한 <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">트랜스포트(transport)</span></a> 가 만들어집니다.</p></li>
<li><p><em>protocol_factory</em> 가 인자 없이 호출되고, <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">프로토콜(protocol)</span></a> 인스턴스를 반환할 것으로 기대됩니다.</p></li>
<li><p>프로토콜 인스턴스는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">connection_made()</span></code> 메서드를 호출함으로써 트랜스포트와 연결됩니다.</p></li>
<li><p>성공하면 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 튜플이 반환됩니다.</p></li>
</ol>
<p>만들어진 트랜스포트는 구현 의존적인 양방향 스트림입니다.</p>
<p>다른 인자들:</p>
<ul>
<li><p><em>ssl</em>: 주어지고 거짓이 아니면, SSL/TLS 트랜스포트가 만들어집니다 (기본적으로는 평범한 TCP 트랜스포트가 만들어집니다). <em>ssl</em> 이 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> 객체면, 트랜스포트를 만들 때 이 컨텍스트가 사용됩니다; <em>ssl</em> 이 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> 면, <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> 가 반환하는 기본 컨텍스트가 사용됩니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="ssl.html#ssl-security"><span class="std std-ref">SSL/TLS 보안 고려 사항</span></a></p>
</div>
</li>
<li><p><em>server_hostname</em>는 대상 서버의 인증서가 일치될 호스트 이름을 설정하거나 대체합니다. <em>ssl</em>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아닐 때만 전달되어야 합니다. 기본적으로 <em>host</em> 인자의 값이 사용됩니다. <em>host</em> 가 비어 있으면, 기본값이 없고 <em>server_hostname</em> 값을 전달해야 합니다. <em>server_hostname</em> 이 빈 문자열이면, 호스트 이름 일치가 비활성화됩니다 (이것은 심각한 보안 위험으로, 잠재적인 중간자 공격을 허용하게 됩니다).</p></li>
<li><p><em>family</em>, <em>proto</em>, <em>flags</em> 는 <em>host</em> 결정을 위해 getaddrinfo() 에 전달할 선택적 주소 패밀리, 프로토콜, 플래그입니다. 주어지면, 이것들은 모두 해당하는 <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 모듈 상수에 대응하는 정수여야 합니다.</p></li>
<li><p>주어지면, <em>happy_eyeballs_delay</em>는 이 연결에 대해 Happy Eyeballs를 활성화합니다. 다음 시도를 병렬로 시작하기 전에, 연결 시도가 완료되기를 기다리는 시간(초)을 나타내는 부동 소수점 숫자여야 합니다. 이것은 <span class="target" id="index-15"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8305.html"><strong>RFC 8305</strong></a>에 정의된 “연결 시도 지연(Connection Attempt Delay)” 입니다. RFC에서 권장하는 적절한 기본값은 <code class="docutils literal notranslate"><span class="pre">0.25</span></code>(250밀리 초)입니다.</p></li>
<li><p><em>interleave</em>는 호스트 이름이 여러 IP 주소로 해석될 때 주소 재정렬을 제어합니다. <code class="docutils literal notranslate"><span class="pre">0</span></code>이거나 지정되지 않으면, 재정렬이 수행되지 않고, 주소는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>에 의해 반환된 순서대로 시도됩니다. 양의 정수가 지정되면, 주소는 주소 패밀리에 의해 인터리브 되고, 주어진 정수는 <span class="target" id="index-16"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8305.html"><strong>RFC 8305</strong></a>에 정의된 대로 “첫 번째 주소 패밀리 수(First Address Family Count)”로 해석됩니다. 기본값은 <em>happy_eyeballs_delay</em>가 지정되지 않으면 <code class="docutils literal notranslate"><span class="pre">0</span></code>이고, 지정되면 <code class="docutils literal notranslate"><span class="pre">1</span></code>입니다.</p></li>
<li><p><em>sock</em> 이 주어지면, 트랜스포트가 사용할, 기존의 이미 연결된 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> 객체여야 합니다. <em>sock</em> 이 주어지면, <em>host</em>, <em>port</em>, <em>family</em>, <em>proto</em>, <em>flags</em>, <em>happy_eyeballs_delay</em>, <em>interleave</em>, <em>local_addr</em> 를 지정해서는 안 됩니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>The <em>sock</em> argument transfers ownership of the socket to the
transport created. To close the socket, call the transport’s
<a class="reference internal" href="asyncio-protocol.html#asyncio.BaseTransport.close" title="asyncio.BaseTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> method.</p>
</div>
</li>
<li><p><em>local_addr</em>, if given, is a <code class="docutils literal notranslate"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></code> tuple used
to bind the socket locally.  The <em>local_host</em> and <em>local_port</em>
are looked up using <code class="docutils literal notranslate"><span class="pre">getaddrinfo()</span></code>, similarly to <em>host</em> and <em>port</em>.</p></li>
<li><p><em>ssl_handshake_timeout</em> 은 (TLS 연결의 경우) 연결을 중단하기 전에 TLS 핸드 셰이크가 완료될 때까지 대기하는 시간(초)입니다. <code class="docutils literal notranslate"><span class="pre">None</span></code> (기본값) 이면 <code class="docutils literal notranslate"><span class="pre">60.0</span></code> 초가 사용됩니다.</p></li>
<li><p><em>ssl_shutdown_timeout</em> is the time in seconds to wait for the SSL shutdown
to complete before aborting the connection. <code class="docutils literal notranslate"><span class="pre">30.0</span></code> seconds if <code class="docutils literal notranslate"><span class="pre">None</span></code>
(default).</p></li>
<li><p><em>all_errors</em> determines what exceptions are raised when a connection cannot
be created. By default, only a single <code class="docutils literal notranslate"><span class="pre">Exception</span></code> is raised: the first
exception if there is only one or all errors have same message, or a single
<code class="docutils literal notranslate"><span class="pre">OSError</span></code> with the error messages combined. When <code class="docutils literal notranslate"><span class="pre">all_errors</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>,
an <code class="docutils literal notranslate"><span class="pre">ExceptionGroup</span></code> will be raised containing all exceptions (even if there
is only one).</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><a class="reference internal" href="asyncio-eventloop.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>에 SSL/TLS에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>The socket option <a class="reference internal" href="socket.html#socket-unix-constants"><span class="std std-ref">socket.TCP_NODELAY</span></a> is set by default
for all TCP connections.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>Added the <em>ssl_handshake_timeout</em> parameter.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><em>happy_eyeballs_delay</em>와 <em>interleave</em> 매개 변수가 추가되었습니다.</p>
<p>Happy Eyeballs Algorithm: Success with Dual-Stack Hosts.
When a server’s IPv4 path and protocol are working, but the server’s
IPv6 path and protocol are not working, a dual-stack client
application experiences significant connection delay compared to an
IPv4-only client.  This is undesirable because it causes the
dual-stack client to have a worse user experience.  This document
specifies requirements for algorithms that reduce this user-visible
delay and provides an algorithm.</p>
<p>For more information: <a class="reference external" href="https://datatracker.ietf.org/doc/html/rfc6555">https://datatracker.ietf.org/doc/html/rfc6555</a></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>Added the <em>ssl_shutdown_timeout</em> parameter.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span><em>all_errors</em> was added.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_connection()</span></code></a> 함수는 고수준 대안 API입니다. async/await 코드에서 직접 사용할 수 있는 (<a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>) 쌍을 반환합니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_datagram_endpoint">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_datagram_endpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_addr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remote_addr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reuse_port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_broadcast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.create_datagram_endpoint" title="Link to this definition">¶</a></dt>
<dd><p>데이터 그램 연결을 만듭니다.</p>
<p>The socket family can be either <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a>,
<a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>, or <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>,
depending on <em>host</em> (or the <em>family</em> argument, if provided).</p>
<p>The socket type will be <a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code></a>.</p>
<p><em>protocol_factory</em> 는 반드시 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">프로토콜</span></a> 구현을 반환하는 콜러블이어야 합니다.</p>
<p>성공하면 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 튜플이 반환됩니다.</p>
<p>다른 인자들:</p>
<ul>
<li><p><em>local_addr</em>, if given, is a <code class="docutils literal notranslate"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></code> tuple used
to bind the socket locally.  The <em>local_host</em> and <em>local_port</em>
are looked up using <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>.</p></li>
<li><p><em>remote_addr</em> 이 주어지면, 소켓을 원격 주소에 연결하는 데 사용되는 <code class="docutils literal notranslate"><span class="pre">(remote_host,</span> <span class="pre">remote_port)</span></code> 튜플입니다. <em>remote_host</em> 와 <em>remote_port</em> 는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>를 사용하여 조회됩니다.</p></li>
<li><p><em>family</em>, <em>proto</em>, <em>flags</em> 는 <em>host</em> 결정을 위해 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> 에 전달할 선택적 주소 패밀리, 프로토콜, 플래그입니다. 주어지면, 이것들은 모두 해당하는 <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 모듈 상수에 대응하는 정수여야 합니다.</p></li>
<li><p><em>reuse_port</em> tells the kernel to allow this endpoint to be bound to the
same port as other existing endpoints are bound to, so long as they all
set this flag when being created. This option is not supported on Windows
and some Unixes. If the <a class="reference internal" href="socket.html#socket-unix-constants"><span class="std std-ref">socket.SO_REUSEPORT</span></a> constant is not
defined then this capability is unsupported.</p></li>
<li><p><em>allow_broadcast</em> 는 이 말단이 브로드캐스트 주소로 메시지를 보낼 수 있도록 커널에 알립니다.</p></li>
<li><p><em>sock</em> 은 트랜스포트가 사용할 소켓 객체로, 기존의 이미 연결된 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> 객체를 사용하기 위해 선택적으로 지정할 수 있습니다. 지정되면 <em>local_addr</em> 과 <em>remote_addr</em> 를 생략해야 합니다 (반드시 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 이어야 합니다).</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>The <em>sock</em> argument transfers ownership of the socket to the
transport created. To close the socket, call the transport’s
<a class="reference internal" href="asyncio-protocol.html#asyncio.BaseTransport.close" title="asyncio.BaseTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> method.</p>
</div>
</li>
</ul>
<p><a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-client-protocol"><span class="std std-ref">UDP 메아리 클라이언트 프로토콜</span></a> 과 <a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-server-protocol"><span class="std std-ref">UDP 메아리 서버 프로토콜</span></a> 예제를 참고하세요.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4.4에서 변경: </span>The <em>family</em>, <em>proto</em>, <em>flags</em>, <em>reuse_address</em>, <em>reuse_port</em>,
<em>allow_broadcast</em>, and <em>sock</em> parameters were added.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>윈도우에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8.1에서 변경: </span>The <em>reuse_address</em> parameter is no longer supported, as using
<a class="reference internal" href="socket.html#socket-unix-constants"><span class="std std-ref">socket.SO_REUSEADDR</span></a>
poses a significant security concern for
UDP. Explicitly passing <code class="docutils literal notranslate"><span class="pre">reuse_address=True</span></code> will raise an exception.</p>
<p>UID가 다른 여러 프로세스가 <code class="docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code>를 사용하여 소켓을 같은 UDP 소켓 주소에 할당하면, 들어오는 패킷이 소켓 간에 무작위로 분산될 수 있습니다.</p>
<p>For supported platforms, <em>reuse_port</em> can be used as a replacement for
similar functionality. With <em>reuse_port</em>,
<a class="reference internal" href="socket.html#socket-unix-constants"><span class="std std-ref">socket.SO_REUSEPORT</span></a>
is used instead, which specifically
prevents processes with differing UIDs from assigning sockets to the same
socket address.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>The <em>reuse_address</em> parameter, disabled since Python 3.8.1,
3.7.6 and 3.6.10, has been entirely removed.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_unix_connection">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_unix_connection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.create_unix_connection" title="Link to this definition">¶</a></dt>
<dd><p>유닉스 연결을 만듭니다.</p>
<p>The socket family will be <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>; socket
type will be <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>.</p>
<p>성공하면 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 튜플이 반환됩니다.</p>
<p><em>path</em> 는 유닉스 도메인 소켓의 이름이며, <em>sock</em> 매개 변수가 지정되지 않으면 필수입니다. 추상 유닉스 소켓, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> 경로가 지원됩니다.</p>
<p>이 메서드의 인자에 관한 정보는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> 메서드의 설명서를 참조하십시오.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>Added the <em>ssl_handshake_timeout</em> parameter.
The <em>path</em> parameter can now be a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>Added the <em>ssl_shutdown_timeout</em> parameter.</p>
</div>
</dd></dl>

</section>
<section id="creating-network-servers">
<h3><a class="toc-backref" href="asyncio-eventloop.html#id7" role="doc-backlink">네트워크 서버 만들기</a><a class="headerlink" href="asyncio-eventloop.html#creating-network-servers" title="Link to this heading">¶</a></h3>
<dl class="py method" id="loop-create-server">
<dt class="sig sig-object py" id="asyncio.loop.create_server">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_server</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">socket.AF_UNSPEC</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">socket.AI_PASSIVE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reuse_address</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reuse_port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_serving</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.create_server" title="Link to this definition">¶</a></dt>
<dd><p>Create a TCP server (socket type <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>) listening
on <em>port</em> of the <em>host</em> address.</p>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.Server" title="asyncio.Server"><code class="xref py py-class docutils literal notranslate"><span class="pre">Server</span></code></a> 객체를 반환합니다.</p>
<p>인자:</p>
<ul>
<li><p><em>protocol_factory</em> 는 반드시 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">프로토콜</span></a> 구현을 반환하는 콜러블이어야 합니다.</p></li>
<li><p><em>host</em> 매개 변수는 서버가 리스닝할 위치를 결정하는 여러 형으로 설정할 수 있습니다.:</p>
<ul class="simple">
<li><p><em>host</em>가 문자열이면, TCP 서버는 <em>host</em>로 지정된 단일 네트워크 인터페이스에 바인딩 됩니다.</p></li>
<li><p><em>host</em>가 문자열의 시퀀스면, TCP 서버는 시퀀스로 지정된 모든 네트워크 인터페이스에 바인딩 됩니다.</p></li>
<li><p><em>host</em>가 빈 문자열이거나 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, 모든 인터페이스가 사용되는 것으로 가정하고, 여러 소켓의 리스트가 반환됩니다 (대체로 IPv4 하나와 IPv6 하나).</p></li>
</ul>
</li>
<li><p>The <em>port</em> parameter can be set to specify which port the server should
listen on. If <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), a random unused port will
be selected (note that if <em>host</em> resolves to multiple network interfaces,
a different random port will be selected for each interface).</p></li>
<li><p><em>family</em> can be set to either <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.AF_INET</span></code></a> or
<a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a> to force the socket to use IPv4 or IPv6.
If not set, the <em>family</em> will be determined from host name
(defaults to <a class="reference internal" href="socket.html#socket.AF_UNSPEC" title="socket.AF_UNSPEC"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNSPEC</span></code></a>).</p></li>
<li><p><em>flags</em> 은 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>를 위한 비트 마스크입니다.</p></li>
<li><p><em>sock</em> 은 기존 소켓 객체를 사용하기 위해 선택적으로 지정할 수 있습니다. 지정되면, <em>host</em> 및 <em>port</em> 는 지정할 수 없습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>The <em>sock</em> argument transfers ownership of the socket to the
server created. To close the socket, call the server’s
<a class="reference internal" href="asyncio-eventloop.html#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> method.</p>
</div>
</li>
<li><p><em>backlog</em> 는 <a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code></a> 으로 전달되는 최대 대기 연결 수 입니다 (기본값은 100).</p></li>
<li><p><em>ssl</em> 을 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 인스턴스로 설정하면, 들어오는 연결에 TLS를 사용합니다.</p></li>
<li><p><em>reuse_address</em> 는, 일반적인 시간제한이 만료될 때까지 기다리지 않고, <code class="docutils literal notranslate"><span class="pre">TIME_WAIT</span></code> 상태의 로컬 소켓을 재사용하도록 커널에 알려줍니다. 지정하지 않으면 유닉스에서 자동으로 <code class="docutils literal notranslate"><span class="pre">True</span></code> 로 설정됩니다.</p></li>
<li><p><em>reuse_port</em> 는 모두 만들 때 이 플래그를 설정하는 한, 이 말단이 다른 기존 말단이 바인드 된 것과 같은 포트에 바인드 되도록 허용하도록 커널에 알려줍니다. 이 옵션은 윈도우에서 지원되지 않습니다.</p></li>
<li><p><em>ssl_handshake_timeout</em> 은 (TLS 서버의 경우) 연결을 중단하기 전에 TLS 핸드 셰이크가 완료될 때까지 대기하는 시간(초)입니다. <code class="docutils literal notranslate"><span class="pre">None</span></code> (기본값) 이면 <code class="docutils literal notranslate"><span class="pre">60.0</span></code> 초가 사용됩니다.</p></li>
<li><p><em>ssl_shutdown_timeout</em> is the time in seconds to wait for the SSL shutdown
to complete before aborting the connection. <code class="docutils literal notranslate"><span class="pre">30.0</span></code> seconds if <code class="docutils literal notranslate"><span class="pre">None</span></code>
(default).</p></li>
<li><p><em>start_serving</em> 을 <code class="docutils literal notranslate"><span class="pre">True</span></code> (기본값) 로 설정하면, 생성된 서버가 즉시 연결을 받아들입니다. <code class="docutils literal notranslate"><span class="pre">False</span></code> 로 설정되면, 사용자는 서버가 연결을 받기 시작하도록 <a class="reference internal" href="asyncio-eventloop.html#asyncio.Server.start_serving" title="asyncio.Server.start_serving"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.start_serving()</span></code></a> 이나 <a class="reference internal" href="asyncio-eventloop.html#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.serve_forever()</span></code></a>를 await 해야 합니다.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><a class="reference internal" href="asyncio-eventloop.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>에 SSL/TLS에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5.1에서 변경: </span><em>host</em> 매개 변수는 문자열의 시퀀스가 될 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>Added <em>ssl_handshake_timeout</em> and <em>start_serving</em> parameters.
The socket option <a class="reference internal" href="socket.html#socket-unix-constants"><span class="std std-ref">socket.TCP_NODELAY</span></a> is set by default
for all TCP connections.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>Added the <em>ssl_shutdown_timeout</em> parameter.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a> 함수는 async/await 코드에서 사용할 수 있는 <a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> 및 <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> 쌍을 반환하는 고수준의 대체 API입니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_unix_server">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_unix_server</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_serving</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.create_unix_server" title="Link to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> but works with the
<a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a> socket family.</p>
<p><em>path</em> 는 유닉스 도메인 소켓의 이름이며, <em>sock</em> 매개 변수가 제공되지 않으면 필수입니다. 추상 유닉스 소켓, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> 경로가 지원됩니다.</p>
<p>이 메서드의 인자에 대한 정보는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> 메서드의 설명서를 참조하십시오.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>Added the <em>ssl_handshake_timeout</em> and <em>start_serving</em> parameters.
The <em>path</em> parameter can now be a <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> object.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>Added the <em>ssl_shutdown_timeout</em> parameter.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.connect_accepted_socket">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">connect_accepted_socket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.connect_accepted_socket" title="Link to this definition">¶</a></dt>
<dd><p>이미 받아들인 연결을 트랜스포트/프로토콜 쌍으로 래핑합니다.</p>
<p>이 메서드는 asyncio 밖에서 연결을 받아들이지만, 그 연결을 처리하는데 asyncio 를 사용하는 서버에서 사용됩니다.</p>
<p>매개 변수:</p>
<ul>
<li><p><em>protocol_factory</em> 는 반드시 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">프로토콜</span></a> 구현을 반환하는 콜러블이어야 합니다.</p></li>
<li><p><em>sock</em> 은 <a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.accept</span></code></a> 가 반환한 기존 소켓 객체입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>The <em>sock</em> argument transfers ownership of the socket to the
transport created. To close the socket, call the transport’s
<a class="reference internal" href="asyncio-protocol.html#asyncio.BaseTransport.close" title="asyncio.BaseTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> method.</p>
</div>
</li>
<li><p><em>ssl</em> 을 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 로 설정하면, 들어오는 연결에 SSL을 사용합니다.</p></li>
<li><p><em>ssl_handshake_timeout</em> 은 (SSL 연결의 경우) 연결을 중단하기 전에 SSL 핸드 셰이크가 완료될 때까지 대기하는 시간(초)입니다. <code class="docutils literal notranslate"><span class="pre">None</span></code> (기본값) 이면 <code class="docutils literal notranslate"><span class="pre">60.0</span></code> 초가 사용됩니다.</p></li>
<li><p><em>ssl_shutdown_timeout</em> is the time in seconds to wait for the SSL shutdown
to complete before aborting the connection. <code class="docutils literal notranslate"><span class="pre">30.0</span></code> seconds if <code class="docutils literal notranslate"><span class="pre">None</span></code>
(default).</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>Added the <em>ssl_handshake_timeout</em> parameter.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>Added the <em>ssl_shutdown_timeout</em> parameter.</p>
</div>
</dd></dl>

</section>
<section id="transferring-files">
<h3><a class="toc-backref" href="asyncio-eventloop.html#id8" role="doc-backlink">파일 전송</a><a class="headerlink" href="asyncio-eventloop.html#transferring-files" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sendfile">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sendfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transport</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fallback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.sendfile" title="Link to this definition">¶</a></dt>
<dd><p><em>file</em> 을 <em>transport</em> 로 보냅니다. 전송된 총 바이트 수를 반환합니다.</p>
<p>이 메서드는 가능한 경우 고성능 <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">os.sendfile()</span></code></a> 을 사용합니다.</p>
<p><em>file</em> 는 바이너리 모드로 열린 일반 파일 객체여야 합니다.</p>
<p><em>offset</em> 은 파일 읽기 시작할 위치를 알려줍니다. <em>count</em> 를 제공하면, EOF에 도달할 때까지 파일을 보내는 대신, 전송할 총 바이트 수를 지정합니다. 파일의 위치가 갱신됩니다, 이 메서드가 에러를 일으킬 때조차. 그리고, <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">file.tell()</span></code></a> 는 실제 전송된 바이트 수를 얻는 데 사용될 수 있습니다.</p>
<p><em>fallback</em> 을 <code class="docutils literal notranslate"><span class="pre">True</span></code> 로 설정하면, 플랫폼이 sendfile 시스템 호출을 지원하지 않을 때 (가령 유닉스에서 SSL 소켓을 사용하거나 윈도우인 경우), asyncio 가 파일을 수동으로 읽고 보내도록 합니다.</p>
<p>시스템이 <em>sendfile</em> 시스템 호출을 지원하지 않고 <em>fallback</em> 이 <code class="docutils literal notranslate"><span class="pre">False</span></code> 면 <a class="reference internal" href="asyncio-exceptions.html#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SendfileNotAvailableError</span></code></a> 를 발생시킵니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

</section>
<section id="tls-upgrade">
<h3><a class="toc-backref" href="asyncio-eventloop.html#id9" role="doc-backlink">TLS 업그레이드</a><a class="headerlink" href="asyncio-eventloop.html#tls-upgrade" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.start_tls">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">start_tls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transport</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sslcontext</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.start_tls" title="Link to this definition">¶</a></dt>
<dd><p>기존 트랜스포트 기반 연결을 TLS로 업그레이드합니다.</p>
<p>Create a TLS coder/decoder instance and insert it between the <em>transport</em>
and the <em>protocol</em>. The coder/decoder implements both <em>transport</em>-facing
protocol and <em>protocol</em>-facing transport.</p>
<p>Return the created two-interface instance. After <em>await</em>, the <em>protocol</em>
must stop using the original <em>transport</em> and communicate with the returned
object only because the coder caches <em>protocol</em>-side data and sporadically
exchanges extra TLS session packets with <em>transport</em>.</p>
<p>In some situations (e.g. when the passed transport is already closing) this
may return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>매개 변수:</p>
<ul class="simple">
<li><p><a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_server()</span></code></a>와 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_connection()</span></code></a> 같은 메서드가 반환하는 <em>transport</em> 와 <em>protocol</em> 인스턴스.</p></li>
<li><p><em>sslcontext</em>: 구성된 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 의 인스턴스.</p></li>
<li><p>(<a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_server()</span></code></a> 에 의해 생성된 것과 같은) 서버 측 연결이 업그레이드될 때 <em>server_side</em> 에 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 전달합니다.</p></li>
<li><p><em>server_hostname</em>: 대상 서버의 인증서가 일치될 호스트 이름을 설정하거나 대체합니다.</p></li>
<li><p><em>ssl_handshake_timeout</em> 은 (TLS 연결의 경우) 연결을 중단하기 전에 TLS 핸드 셰이크가 완료될 때까지 대기하는 시간(초)입니다. <code class="docutils literal notranslate"><span class="pre">None</span></code> (기본값) 이면 <code class="docutils literal notranslate"><span class="pre">60.0</span></code> 초가 사용됩니다.</p></li>
<li><p><em>ssl_shutdown_timeout</em> is the time in seconds to wait for the SSL shutdown
to complete before aborting the connection. <code class="docutils literal notranslate"><span class="pre">30.0</span></code> seconds if <code class="docutils literal notranslate"><span class="pre">None</span></code>
(default).</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>Added the <em>ssl_shutdown_timeout</em> parameter.</p>
</div>
</dd></dl>

</section>
<section id="watching-file-descriptors">
<h3><a class="toc-backref" href="asyncio-eventloop.html#id10" role="doc-backlink">파일 기술자 관찰하기</a><a class="headerlink" href="asyncio-eventloop.html#watching-file-descriptors" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.add_reader">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">add_reader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.add_reader" title="Link to this definition">¶</a></dt>
<dd><p><em>fd</em> 파일 기술자가 읽기 가능한지 관찰하기 시작하고, 일단 <em>fd</em>가 읽기 가능해지면 지정한 인자로 <em>callback</em> 을 호출합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.remove_reader">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">remove_reader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.remove_reader" title="Link to this definition">¶</a></dt>
<dd><p>Stop monitoring the <em>fd</em> file descriptor for read availability. Returns
<code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>fd</em> was previously being monitored for reads.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.add_writer">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">add_writer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.add_writer" title="Link to this definition">¶</a></dt>
<dd><p><em>fd</em> 파일 기술자가 쓰기 가능한지 관찰하기 시작하고, 일단 <em>fd</em>가 쓰기 가능해지면 지정한 인자로 <em>callback</em> 을 호출합니다.</p>
<p><em>callback</em> 에 <a class="reference internal" href="asyncio-eventloop.html#asyncio-pass-keywords"><span class="std std-ref">키워드 인자를 전달하려면</span></a> <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>를 사용하십시오.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.remove_writer">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">remove_writer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.remove_writer" title="Link to this definition">¶</a></dt>
<dd><p>Stop monitoring the <em>fd</em> file descriptor for write availability. Returns
<code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>fd</em> was previously being monitored for writes.</p>
</dd></dl>

<p>이 메서드의 일부 제한 사항은 <a class="reference internal" href="asyncio-platforms.html#asyncio-platform-support"><span class="std std-ref">플랫폼 지원</span></a> 절을 참조하십시오.</p>
</section>
<section id="working-with-socket-objects-directly">
<h3><a class="toc-backref" href="asyncio-eventloop.html#id11" role="doc-backlink">소켓 객체로 직접 작업하기</a><a class="headerlink" href="asyncio-eventloop.html#working-with-socket-objects-directly" title="Link to this heading">¶</a></h3>
<p>일반적으로 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> 및 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>와 같은 트랜스포트 기반 API를 사용하는 프로토콜 구현은 소켓을 직접 사용하는 구현보다 빠릅니다. 그러나, 성능이 결정적이지 않고 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> 객체로 직접 작업하는 것이 더 편리한 사용 사례가 있습니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_recv">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_recv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbytes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.sock_recv" title="Link to this definition">¶</a></dt>
<dd><p><em>sock</em> 에서 최대 <em>nbytes</em> 를 수신합니다. <a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recv()</span></code></a> 의 비동기 버전.</p>
<p>수신한 데이터를 바이트열 객체로 반환합니다.</p>
<p><em>sock</em> 은 반드시 비 블로킹 소켓이어야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이 메서드가 항상 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에는 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>를 반환했습니다. 파이썬 3.7부터, 이것은 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> 메서드입니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_recv_into">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_recv_into</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.sock_recv_into" title="Link to this definition">¶</a></dt>
<dd><p><em>sock</em> 에서 <em>buf</em> 버퍼로 데이터를 수신합니다. 블로킹 <a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recv_into()</span></code></a> 메서드를 따라 만들어졌습니다.</p>
<p>버퍼에 기록된 바이트 수를 돌려줍니다.</p>
<p><em>sock</em> 은 반드시 비 블로킹 소켓이어야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_recvfrom">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_recvfrom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bufsize</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.sock_recvfrom" title="Link to this definition">¶</a></dt>
<dd><p>Receive a datagram of up to <em>bufsize</em> from <em>sock</em>.  Asynchronous version of
<a class="reference internal" href="socket.html#socket.socket.recvfrom" title="socket.socket.recvfrom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recvfrom()</span></code></a>.</p>
<p>Return a tuple of (received data, remote address).</p>
<p><em>sock</em> 은 반드시 비 블로킹 소켓이어야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_recvfrom_into">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_recvfrom_into</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbytes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.sock_recvfrom_into" title="Link to this definition">¶</a></dt>
<dd><p>Receive a datagram of up to <em>nbytes</em> from <em>sock</em> into <em>buf</em>.
Asynchronous version of
<a class="reference internal" href="socket.html#socket.socket.recvfrom_into" title="socket.socket.recvfrom_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recvfrom_into()</span></code></a>.</p>
<p>Return a tuple of (number of bytes received, remote address).</p>
<p><em>sock</em> 은 반드시 비 블로킹 소켓이어야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_sendall">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_sendall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.sock_sendall" title="Link to this definition">¶</a></dt>
<dd><p><em>data</em> 를 <em>sock</em> 소켓으로 보냅니다. <a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendall()</span></code></a> 의 비동기 버전.</p>
<p>이 메서드는 <em>data</em> 의 모든 데이터가 송신되거나 에러가 발생할 때까지 소켓으로 계속 송신합니다. 성공하면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 반환됩니다. 에러가 발생하면 예외가 발생합니다. 또한, 연결의 수신 단에서 성공적으로 처리한 (있기는 하다면) 데이터의 크기를 확인하는 방법은 없습니다.</p>
<p><em>sock</em> 은 반드시 비 블로킹 소켓이어야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이 메서드가 항상 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에는 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>를 반환했습니다. 파이썬 3.7부터, 이것은 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> 메서드입니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_sendto">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_sendto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.sock_sendto" title="Link to this definition">¶</a></dt>
<dd><p>Send a datagram from <em>sock</em> to <em>address</em>.
Asynchronous version of
<a class="reference internal" href="socket.html#socket.socket.sendto" title="socket.socket.sendto"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendto()</span></code></a>.</p>
<p>Return the number of bytes sent.</p>
<p><em>sock</em> 은 반드시 비 블로킹 소켓이어야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_connect">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_connect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.sock_connect" title="Link to this definition">¶</a></dt>
<dd><p><em>sock</em>을 <em>address</em>에 있는 원격 소켓에 연결합니다.</p>
<p><a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect()</span></code></a> 의 비동기 버전.</p>
<p><em>sock</em> 은 반드시 비 블로킹 소켓이어야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5.2에서 변경: </span><code class="docutils literal notranslate"><span class="pre">address</span></code> 는 더는 결정될 필요가 없습니다. <code class="docutils literal notranslate"><span class="pre">sock_connect</span></code> 는 <a class="reference internal" href="socket.html#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.inet_pton()</span></code></a>을 호출하여 <em>address</em> 가 이미 결정되었는지를 검사합니다. 그렇지 않으면, <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.getaddrinfo()</span></code></a> 가 <em>address</em> 를 결정하는 데 사용됩니다.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a>과 <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.open_connection()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_accept">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_accept</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.sock_accept" title="Link to this definition">¶</a></dt>
<dd><p>연결을 받아들입니다. 블로킹 <a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.accept()</span></code></a> 메서드를 따라 만들어졌습니다.</p>
<p>소켓은 주소에 바인드 되어 연결을 리스닝해야 합니다. 반환 값은 <code class="docutils literal notranslate"><span class="pre">(conn,</span> <span class="pre">address)</span></code> 쌍인데, <em>conn</em> 은 연결로 데이터를 주고받을 수 있는 <em>새</em> 소켓 객체이고, <em>address</em> 는 연결의 반대편 끝의 소켓에 바인드 된 주소입니다.</p>
<p><em>sock</em> 은 반드시 비 블로킹 소켓이어야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이 메서드가 항상 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에는 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>를 반환했습니다. 파이썬 3.7부터, 이것은 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> 메서드입니다.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>와 <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_sendfile">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_sendfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fallback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.sock_sendfile" title="Link to this definition">¶</a></dt>
<dd><p>가능하면 고성능 <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.sendfile</span></code></a> 을 사용하여 파일을 보냅니다. 전송된 총 바이트 수를 반환합니다.</p>
<p><a class="reference internal" href="socket.html#socket.socket.sendfile" title="socket.socket.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendfile()</span></code></a>의 비동기 버전.</p>
<p><em>sock</em> 은 반드시 비 블로킹 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_STREAM</span></code></a> <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> 이어야 합니다.</p>
<p><em>file</em> 는 바이너리 모드로 열린 일반 파일 객체여야 합니다.</p>
<p><em>offset</em> 은 파일 읽기 시작할 위치를 알려줍니다. <em>count</em> 를 제공하면, EOF에 도달할 때까지 파일을 보내는 대신, 전송할 총 바이트 수를 지정합니다. 파일의 위치가 갱신됩니다, 이 메서드가 에러를 일으킬 때조차. 그리고, <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">file.tell()</span></code></a> 는 실제 전송된 바이트 수를 얻는 데 사용될 수 있습니다.</p>
<p><em>fallback</em> 을 <code class="docutils literal notranslate"><span class="pre">True</span></code> 로 설정하면, 플랫폼이 sendfile 시스템 호출을 지원하지 않을 때 (가령 유닉스에서 SSL 소켓을 사용하거나 윈도우인 경우), asyncio 가 파일을 수동으로 읽고 보내도록 합니다.</p>
<p>시스템이 <em>sendfile</em> 시스템 호출을 지원하지 않고 <em>fallback</em> 이 <code class="docutils literal notranslate"><span class="pre">False</span></code> 면 <a class="reference internal" href="asyncio-exceptions.html#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SendfileNotAvailableError</span></code></a> 를 발생시킵니다.</p>
<p><em>sock</em> 은 반드시 비 블로킹 소켓이어야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

</section>
<section id="dns">
<h3><a class="toc-backref" href="asyncio-eventloop.html#id12" role="doc-backlink">DNS</a><a class="headerlink" href="asyncio-eventloop.html#dns" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.getaddrinfo">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">getaddrinfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.getaddrinfo" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="socket.html#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getaddrinfo()</span></code></a> 의 비동기 버전.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.getnameinfo">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">getnameinfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sockaddr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.getnameinfo" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="socket.html#socket.getnameinfo" title="socket.getnameinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getnameinfo()</span></code></a> 의 비동기 버전.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>getaddrinfo</em> 와 <em>getnameinfo</em> 메서드는 모두 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에 실제로는 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 객체를 반환했습니다. 파이썬 3.7부터 두 가지 메서드 모두 코루틴입니다.</p>
</div>
</section>
<section id="working-with-pipes">
<h3><a class="toc-backref" href="asyncio-eventloop.html#id13" role="doc-backlink">파이프로 작업하기</a><a class="headerlink" href="asyncio-eventloop.html#working-with-pipes" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.connect_read_pipe">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">connect_read_pipe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipe</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.connect_read_pipe" title="Link to this definition">¶</a></dt>
<dd><p>이벤트 루프에 <em>pipe</em>의 읽기용 끝을 등록합니다.</p>
<p><em>protocol_factory</em> 는 반드시 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">asyncio 프로토콜</span></a> 구현을 반환하는 콜러블이어야 합니다.</p>
<p><em>pipe</em>는 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일류 객체</span></a>입니다.</p>
<p>쌍 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>를 반환합니다. 여기서 <em>transport</em>는 <a class="reference internal" href="asyncio-protocol.html#asyncio.ReadTransport" title="asyncio.ReadTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReadTransport</span></code></a> 인터페이스를 지원하고, <em>protocol</em>은 <em>protocol_factory</em>에 의해 인스턴스로 만들어진 객체입니다.</p>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> 이벤트 루프를 사용하면, <em>pipe</em> 는 비 블로킹 모드로 설정됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.connect_write_pipe">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">connect_write_pipe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipe</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.connect_write_pipe" title="Link to this definition">¶</a></dt>
<dd><p>이벤트 루프에 <em>pipe</em>의 쓰기용 끝을 등록합니다.</p>
<p><em>protocol_factory</em> 는 반드시 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">asyncio 프로토콜</span></a> 구현을 반환하는 콜러블이어야 합니다.</p>
<p><em>pipe</em>는 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일류 객체</span></a>입니다.</p>
<p>쌍 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>를 반환합니다. 여기서 <em>transport</em>는 <a class="reference internal" href="asyncio-protocol.html#asyncio.WriteTransport" title="asyncio.WriteTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">WriteTransport</span></code></a> 인터페이스를 지원하고, <em>protocol</em>은 <em>protocol_factory</em>에 의해 인스턴스로 만들어진 객체입니다.</p>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> 이벤트 루프를 사용하면, <em>pipe</em> 는 비 블로킹 모드로 설정됩니다.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">참고</p>
<p>윈도우에서 <a class="reference internal" href="asyncio-eventloop.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a>는 위의 메서드들을 지원하지 않습니다. 윈도우에서는 대신 <a class="reference internal" href="asyncio-eventloop.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>를 사용하십시오.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a> 와 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_shell" title="asyncio.loop.subprocess_shell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_shell()</span></code></a> 메서드.</p>
</div>
</section>
<section id="unix-signals">
<h3><a class="toc-backref" href="asyncio-eventloop.html#id14" role="doc-backlink">유닉스 시그널</a><a class="headerlink" href="asyncio-eventloop.html#unix-signals" title="Link to this heading">¶</a></h3>
<dl class="py method" id="loop-add-signal-handler">
<dt class="sig sig-object py" id="asyncio.loop.add_signal_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">add_signal_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.add_signal_handler" title="Link to this definition">¶</a></dt>
<dd><p><em>callback</em>을 <em>signum</em> 시그널의 처리기로 설정합니다.</p>
<p>콜백은 다른 대기 중인 콜백과 해당 이벤트 루프의 실행 가능한 코루틴과 함께 <em>loop</em>에 의해 호출됩니다. <a class="reference internal" href="signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.signal()</span></code></a>을 사용하여 등록된 시그널 처리기와 달리, 이 함수로 등록된 콜백은 이벤트 루프와 상호 작용할 수 있습니다.</p>
<p>시그널 번호가 유효하지 않거나 잡을 수 없으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 를 발생시킵니다. 처리기를 설정하는 데 문제가 있는 경우 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 를 발생시킵니다.</p>
<p><em>callback</em> 에 <a class="reference internal" href="asyncio-eventloop.html#asyncio-pass-keywords"><span class="std std-ref">키워드 인자를 전달하려면</span></a> <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>를 사용하십시오.</p>
<p><a class="reference internal" href="signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.signal()</span></code></a>와 마찬가지로, 이 함수는 메인 스레드에서 호출되어야 합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.remove_signal_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">remove_signal_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.remove_signal_handler" title="Link to this definition">¶</a></dt>
<dd><p><em>sig</em> 시그널의 처리기를 제거합니다.</p>
<p>시그널 처리기가 제거되면 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를, 주어진 시그널에 처리기가 설정되지 않았으면 <code class="docutils literal notranslate"><span class="pre">False</span></code> 를 반환합니다.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> 모듈.</p>
</div>
</section>
<section id="executing-code-in-thread-or-process-pools">
<h3><a class="toc-backref" href="asyncio-eventloop.html#id15" role="doc-backlink">스레드 또는 프로세스 풀에서 코드를 실행하기</a><a class="headerlink" href="asyncio-eventloop.html#executing-code-in-thread-or-process-pools" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.run_in_executor">
<em class="property"><span class="pre">awaitable</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">run_in_executor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">executor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.run_in_executor" title="Link to this definition">¶</a></dt>
<dd><p>지정된 실행기에서 <em>func</em> 가 호출되도록 배치합니다.</p>
<p><em>executor</em> 인자는 <a class="reference internal" href="concurrent.futures.html#concurrent.futures.Executor" title="concurrent.futures.Executor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Executor</span></code></a> 인스턴스여야 합니다. <em>executor</em> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면 기본 실행기가 사용됩니다.</p>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">concurrent.futures</span>

<span class="k">def</span> <span class="nf">blocking_io</span><span class="p">():</span>
    <span class="c1"># File operations (such as logging) can block the</span>
    <span class="c1"># event loop: run them in a thread pool.</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/dev/urandom&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cpu_bound</span><span class="p">():</span>
    <span class="c1"># CPU-bound operations will block the event loop:</span>
    <span class="c1"># in general it is preferable to run them in a</span>
    <span class="c1"># process pool.</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">7</span><span class="p">))</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="c1">## Options:</span>

    <span class="c1"># 1. Run in the default loop&#39;s executor:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span> <span class="n">blocking_io</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;default thread pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="c1"># 2. Run in a custom thread pool:</span>
    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
            <span class="n">pool</span><span class="p">,</span> <span class="n">blocking_io</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;custom thread pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="c1"># 3. Run in a custom process pool:</span>
    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
            <span class="n">pool</span><span class="p">,</span> <span class="n">cpu_bound</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;custom process pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<p>Note that the entry point guard (<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code>)
is required for option 3 due to the peculiarities of <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a>,
which is used by <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" title="concurrent.futures.ProcessPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProcessPoolExecutor</span></code></a>.
See <a class="reference internal" href="multiprocessing.html#multiprocessing-safe-main-import"><span class="std std-ref">Safe importing of main module</span></a>.</p>
<p>이 메서드는 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 객체를 반환합니다.</p>
<p><em>func</em> 에 <a class="reference internal" href="asyncio-eventloop.html#asyncio-pass-keywords"><span class="std std-ref">키워드 인자를 전달하려면</span></a> <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>를 사용하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5.3에서 변경: </span><a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a> 는 더는 자신이 만드는 스레드 풀 실행기의 <code class="docutils literal notranslate"><span class="pre">max_workers</span></code> 를 설정하지 않습니다. 대신 스레드 풀 실행기(<a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>)가 스스로 기본값을 설정하도록 합니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.set_default_executor">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">set_default_executor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">executor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.set_default_executor" title="Link to this definition">¶</a></dt>
<dd><p>Set <em>executor</em> as the default executor used by <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_in_executor()</span></code></a>.
<em>executor</em> must be an instance of
<a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span><em>executor</em> must be an instance of
<a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="error-handling-api">
<h3><a class="toc-backref" href="asyncio-eventloop.html#id16" role="doc-backlink">에러 처리 API</a><a class="headerlink" href="asyncio-eventloop.html#error-handling-api" title="Link to this heading">¶</a></h3>
<p>이벤트 루프에서 예외를 처리하는 방법을 사용자 정의 할 수 있습니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.set_exception_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">set_exception_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handler</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.set_exception_handler" title="Link to this definition">¶</a></dt>
<dd><p><em>handler</em> 를 새 이벤트 루프 예외 처리기로 설정합니다.</p>
<p><em>handler</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, 기본 예외 처리기가 설정됩니다. 그렇지 않으면, <em>handler</em>는 반드시 <code class="docutils literal notranslate"><span class="pre">(loop,</span> <span class="pre">context)</span></code> 와 일치하는 서명을 가진 콜러블이어야 합니다. 여기서 <code class="docutils literal notranslate"><span class="pre">loop</span></code>는 활성 이벤트 루프에 대한 참조가 될 것이고, <code class="docutils literal notranslate"><span class="pre">context</span></code> 는 예외에 관한 세부 정보를 담고 있는 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 객체가 됩니다 (context에 대한 자세한 내용은 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.call_exception_handler" title="asyncio.loop.call_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_exception_handler()</span></code></a> 문서를 참조하십시오).</p>
<p>If the handler is called on behalf of a <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> or
<a class="reference internal" href="asyncio-eventloop.html#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a>, it is run in the
<a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> of that task or callback handle.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span>The handler may be called in the <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a>
of the task or handle where the exception originated.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.get_exception_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">get_exception_handler</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.get_exception_handler" title="Link to this definition">¶</a></dt>
<dd><p>현재 예외 처리기를 반환하거나, 사용자 정의 예외 처리기가 설정되지 않았으면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.default_exception_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">default_exception_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.default_exception_handler" title="Link to this definition">¶</a></dt>
<dd><p>기본 예외 처리기.</p>
<p>예외가 발생하고 예외 처리기가 설정되지 않았을 때 호출됩니다. 기본 동작으로 위임하려는 사용자 정의 예외 처리기가 호출할 수 있습니다.</p>
<p><em>context</em> 매개 변수는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.call_exception_handler" title="asyncio.loop.call_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_exception_handler()</span></code></a> 에서와 같은 의미입니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_exception_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_exception_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.call_exception_handler" title="Link to this definition">¶</a></dt>
<dd><p>현재 이벤트 루프 예외 처리기를 호출합니다.</p>
<p><em>context</em> 는 다음 키를 포함하는 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 객체입니다 (새 키가 미래의 파이썬 버전에서 추가될 수 있습니다):</p>
<ul class="simple">
<li><p>‘message’: 에러 메시지;</p></li>
<li><p>‘exception’ (선택적): 예외 객체;</p></li>
<li><p>‘future’ (선택적): <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 인스턴스;</p></li>
<li><p>‘task’ (optional): <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a> instance;</p></li>
<li><p>‘handle’ (선택적): <a class="reference internal" href="asyncio-eventloop.html#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Handle</span></code></a> 인스턴스;</p></li>
<li><p>‘protocol’ (선택적): <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">프로토콜</span></a> 인스턴스;</p></li>
<li><p>‘transport’ (선택적): <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">트랜스포트</span></a> 인스턴스;</p></li>
<li><p>‘socket’ (optional): <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> instance;</p></li>
<li><dl class="simple">
<dt>‘asyncgen’ (optional): Asynchronous generator that caused</dt><dd><p>the exception.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 메서드는 서브 클래스 된 이벤트 루프에서 재정의되지 않아야 합니다. 사용자 정의 예외 처리를 위해서는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.set_exception_handler" title="asyncio.loop.set_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_exception_handler()</span></code></a> 메서드를 사용하십시오.</p>
</div>
</dd></dl>

</section>
<section id="enabling-debug-mode">
<h3><a class="toc-backref" href="asyncio-eventloop.html#id17" role="doc-backlink">디버그 모드 활성화</a><a class="headerlink" href="asyncio-eventloop.html#enabling-debug-mode" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.get_debug">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">get_debug</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.get_debug" title="Link to this definition">¶</a></dt>
<dd><p>이벤트 루프의 디버그 모드(<a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>)를 가져옵니다.</p>
<p>기본값은 환경 변수 <span class="target" id="index-17"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONASYNCIODEBUG"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONASYNCIODEBUG</span></code></a> 가 비어 있지 않은 문자열로 설정되면 <code class="docutils literal notranslate"><span class="pre">True</span></code> 이고, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code> 입니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.set_debug">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">set_debug</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">enabled</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="functions.html#bool" title="bool"><span class="pre">bool</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.set_debug" title="Link to this definition">¶</a></dt>
<dd><p>이벤트 루프의 디버그 모드를 설정합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이제 새로운 <a class="reference internal" href="devmode.html#devmode"><span class="std std-ref">파이썬 개발 모드</span></a>를 사용하여 디버그 모드를 활성화할 수도 있습니다.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="asyncio.loop.slow_callback_duration">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">slow_callback_duration</span></span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.slow_callback_duration" title="Link to this definition">¶</a></dt>
<dd><p>This attribute can be used to set the
minimum execution duration in seconds that is considered “slow”.
When debug mode is enabled, “slow” callbacks are logged.</p>
<p>Default value is 100 milliseconds.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="asyncio-dev.html#asyncio-debug-mode"><span class="std std-ref">asyncio의 디버그 모드</span></a>.</p>
</div>
</section>
<section id="running-subprocesses">
<h3><a class="toc-backref" href="asyncio-eventloop.html#id18" role="doc-backlink">자식 프로세스 실행하기</a><a class="headerlink" href="asyncio-eventloop.html#running-subprocesses" title="Link to this heading">¶</a></h3>
<p>이 하위 절에서 설명하는 메서드는 저수준입니다. 일반적인 async/await 코드에서는 대신 고수준의 <a class="reference internal" href="asyncio-subprocess.html#asyncio.create_subprocess_shell" title="asyncio.create_subprocess_shell"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_subprocess_shell()</span></code></a> 및 <a class="reference internal" href="asyncio-subprocess.html#asyncio.create_subprocess_exec" title="asyncio.create_subprocess_exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_subprocess_exec()</span></code></a> 편리 함수를 사용하는 것을 고려하십시오.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>On Windows, the default event loop <a class="reference internal" href="asyncio-eventloop.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> supports
subprocesses, whereas <a class="reference internal" href="asyncio-eventloop.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> does not. See
<a class="reference internal" href="asyncio-platforms.html#asyncio-windows-subprocess"><span class="std std-ref">Subprocess Support on Windows</span></a> for
details.</p>
</div>
<dl class="py method" id="loop-subprocess-exec">
<dt class="sig sig-object py" id="asyncio.loop.subprocess_exec">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">subprocess_exec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stderr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.subprocess_exec" title="Link to this definition">¶</a></dt>
<dd><p><em>args</em>로 지정된 하나 이상의 문자열 인자로 서브 프로세스를 만듭니다.</p>
<p><em>args</em>는 반드시 다음과 같은 것으로 표현되는 문자열의 목록이어야 합니다:</p>
<ul class="simple">
<li><p><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>;</p></li>
<li><p>또는 <a class="reference internal" href="os.html#filesystem-encoding"><span class="std std-ref">파일 시스템 인코딩</span></a>으로로 인코딩된 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p></li>
</ul>
<p>첫 번째 문자열은 프로그램 실행 파일을 지정하고, 나머지 문자열은 인자를 지정합니다. 함께, 문자열 인자들은 프로그램의 <code class="docutils literal notranslate"><span class="pre">argv</span></code>를 구성합니다.</p>
<p>이것은 <code class="docutils literal notranslate"><span class="pre">shell=False</span></code>와 문자열의 목록을 첫 번째 인자로 호출된 표준 라이브러리 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> 클래스와 유사합니다. 그러나 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">Popen</span></code></a>이 문자열 목록인 단일 인자를 받아들이지만, <em>subprocess_exec</em>는 여러 문자열 인자를 받아들입니다.</p>
<p><em>protocol_factory</em>는 반드시 <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.SubprocessProtocol</span></code></a> 클래스의 서브 클래스를 반환하는 콜러블이어야 합니다.</p>
<p>다른 매개 변수:</p>
<ul>
<li><p><em>stdin</em>은 다음 중 하나일 수 있습니다:</p>
<ul class="simple">
<li><p>a file-like object</p></li>
<li><p>an existing file descriptor (a positive integer), for example those created with <a class="reference internal" href="os.html#os.pipe" title="os.pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">os.pipe()</span></code></a></p></li>
<li><p><a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> 상수 (기본값), 새 파이프를 만들고 연결합니다,</p></li>
<li><p>서브 프로세스가 이 프로세스의 파일 기술자를 상속하게 하는 값 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
<li><p>특수 <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> 파일이 사용될 것임을 나타내는 <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> 상수</p></li>
</ul>
</li>
<li><p><em>stdout</em>은 다음 중 하나일 수 있습니다:</p>
<ul class="simple">
<li><p>a file-like object</p></li>
<li><p><a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> 상수 (기본값), 새 파이프를 만들고 연결합니다,</p></li>
<li><p>서브 프로세스가 이 프로세스의 파일 기술자를 상속하게 하는 값 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
<li><p>특수 <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> 파일이 사용될 것임을 나타내는 <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> 상수</p></li>
</ul>
</li>
<li><p><em>stderr</em>은 다음 중 하나일 수 있습니다:</p>
<ul class="simple">
<li><p>a file-like object</p></li>
<li><p><a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> 상수 (기본값), 새 파이프를 만들고 연결합니다,</p></li>
<li><p>서브 프로세스가 이 프로세스의 파일 기술자를 상속하게 하는 값 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
<li><p>특수 <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> 파일이 사용될 것임을 나타내는 <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> 상수</p></li>
<li><p><a class="reference internal" href="subprocess.html#subprocess.STDOUT" title="subprocess.STDOUT"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.STDOUT</span></code></a> 상수, 표준 에러 스트림을 프로세스의 표준 출력 스트림에 연결합니다</p></li>
</ul>
</li>
<li><p>다른 모든 키워드 인자는 해석 없이 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a>로 전달됩니다. 다만, <em>bufsize</em>, <em>universal_newlines</em>, <em>shell</em>, <em>text</em>, <em>encoding</em> 및 <em>errors</em>는 예외인데, 이것들은 지정되지 않아야 합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">asyncio</span></code> 서브 프로세스 API는 스트림을 텍스트로 디코딩하는 것을 지원하지 않습니다. <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a>는 스트림에서 반환된 바이트열을 텍스트로 변환하는 데 사용될 수 있습니다.</p>
</li>
</ul>
<p>If a file-like object passed as <em>stdin</em>, <em>stdout</em> or <em>stderr</em> represents a
pipe, then the other side of this pipe should be registered with
<a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect_write_pipe()</span></code></a> or <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.connect_read_pipe" title="asyncio.loop.connect_read_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect_read_pipe()</span></code></a> for use
with the event loop.</p>
<p>다른 인자에 관한 설명은 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> 클래스의 생성자를 참조하십시오.</p>
<p><code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다. 여기에서 <em>transport</em>는 <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessTransport" title="asyncio.SubprocessTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.SubprocessTransport</span></code></a> 베이스 클래스를 따르고, <em>protocol</em>은 <em>protocol_factory</em>에 의해 인스턴스로 만들어진 객체입니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.subprocess_shell">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">subprocess_shell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmd</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stderr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.loop.subprocess_shell" title="Link to this definition">¶</a></dt>
<dd><p>플랫폼의 “셸” 구문을 사용하는 <em>cmd</em>로 자식 프로세스를 만듭니다. <em>cmd</em>는 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>이나 <a class="reference internal" href="os.html#filesystem-encoding"><span class="std std-ref">파일 시스템 인코딩</span></a>으로 인코딩된 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 일 수 있습니다.</p>
<p>이것은 <code class="docutils literal notranslate"><span class="pre">shell=True</span></code>로 호출된 표준 라이브러리 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> 클래스와 유사합니다.</p>
<p><em>protocol_factory</em>는 반드시 <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubprocessProtocol</span></code></a> 클래스의 서브 클래스를 반환하는 콜러블이어야 합니다.</p>
<p>나머지 인자에 관한 자세한 내용은 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess_exec()</span></code></a>를 참조하십시오.</p>
<p><code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다. 여기서 <em>transport</em>는 <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessTransport" title="asyncio.SubprocessTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubprocessTransport</span></code></a> 베이스 클래스를 따르고, <em>protocol</em>은 <em>protocol_factory</em>에 의해 인스턴스로 만들어진 객체입니다.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Shell_injection#Shell_injection">셸 주입</a> 취약점을 피하고자 모든 공백과 특수 문자를 적절하게 따옴표 처리하는 것은 응용 프로그램의 책임입니다. <a class="reference internal" href="shlex.html#shlex.quote" title="shlex.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">shlex.quote()</span></code></a> 함수를 사용하여 셸 명령을 구성하는 데 사용될 문자열에 있는 공백 및 특수 문자를 올바르게 이스케이프 할 수 있습니다.</p>
</div>
</section>
</section>
<section id="callback-handles">
<h2>콜백 핸들<a class="headerlink" href="asyncio-eventloop.html#callback-handles" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.Handle">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">Handle</span></span><a class="headerlink" href="asyncio-eventloop.html#asyncio.Handle" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.call_soon_threadsafe" title="asyncio.loop.call_soon_threadsafe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon_threadsafe()</span></code></a> 에 의해 반환되는 콜백 래퍼 객체.</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Handle.get_context">
<span class="sig-name descname"><span class="pre">get_context</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.Handle.get_context" title="Link to this definition">¶</a></dt>
<dd><p>Return the <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> object
associated with the handle.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Handle.cancel">
<span class="sig-name descname"><span class="pre">cancel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.Handle.cancel" title="Link to this definition">¶</a></dt>
<dd><p>콜백을 취소합니다. 콜백이 이미 취소되었거나 실행되었다면 이 메서드는 아무 효과가 없습니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Handle.cancelled">
<span class="sig-name descname"><span class="pre">cancelled</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.Handle.cancelled" title="Link to this definition">¶</a></dt>
<dd><p>콜백이 취소되었으면 <code class="docutils literal notranslate"><span class="pre">True</span></code> 을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="asyncio.TimerHandle">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">TimerHandle</span></span><a class="headerlink" href="asyncio-eventloop.html#asyncio.TimerHandle" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a> 및 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.call_at" title="asyncio.loop.call_at"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_at()</span></code></a> 에 의해 반환되는 콜백 래퍼 객체.</p>
<p>이 클래스는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a>의 서브 클래스입니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.TimerHandle.when">
<span class="sig-name descname"><span class="pre">when</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.TimerHandle.when" title="Link to this definition">¶</a></dt>
<dd><p>예약된 콜백 시간을 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 초로 반환합니다.</p>
<p>시간은 절대 타임스탬프입니다. <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.time" title="asyncio.loop.time"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.time()</span></code></a> 과 같은 시간 참조를 사용합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="server-objects">
<h2>서버 객체<a class="headerlink" href="asyncio-eventloop.html#server-objects" title="Link to this heading">¶</a></h2>
<p>Server 객체는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_unix_server" title="asyncio.loop.create_unix_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_unix_server()</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.start_unix_server" title="asyncio.start_unix_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_unix_server()</span></code></a>로 만듭니다.</p>
<p>Do not instantiate the <a class="reference internal" href="asyncio-eventloop.html#asyncio.Server" title="asyncio.Server"><code class="xref py py-class docutils literal notranslate"><span class="pre">Server</span></code></a> class directly.</p>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.Server">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">Server</span></span><a class="headerlink" href="asyncio-eventloop.html#asyncio.Server" title="Link to this definition">¶</a></dt>
<dd><p><em>Server</em> 객체는 비동기 컨텍스트 관리자입니다. <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 문에서 사용될 때, <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 문이 완료되면 서버 객체가 닫혀 있고 새 연결을 받아들이지 않는다는 것이 보장됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="k">async</span> <span class="k">with</span> <span class="n">srv</span><span class="p">:</span>
    <span class="c1"># some code</span>

<span class="c1"># At this point, srv is closed and no longer accepts new connections.</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>Server 객체는 파이썬 3.7부터 비동기 컨텍스트 관리자입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>This class was exposed publicly as <code class="docutils literal notranslate"><span class="pre">asyncio.Server</span></code> in Python 3.9.11, 3.10.3 and 3.11.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.Server.close" title="Link to this definition">¶</a></dt>
<dd><p>서버를 중지합니다: 리스닝 소켓을 닫고 <a class="reference internal" href="asyncio-eventloop.html#asyncio.Server.sockets" title="asyncio.Server.sockets"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sockets</span></code></a> 어트리뷰트를 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정합니다.</p>
<p>이미 받아들여진 클라이언트 연결을 나타내는 소켓은 열린 채로 있습니다.</p>
<p>The server is closed asynchronously; use the <a class="reference internal" href="asyncio-eventloop.html#asyncio.Server.wait_closed" title="asyncio.Server.wait_closed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_closed()</span></code></a>
coroutine to wait until the server is closed (and no more
connections are active).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.get_loop">
<span class="sig-name descname"><span class="pre">get_loop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.Server.get_loop" title="Link to this definition">¶</a></dt>
<dd><p>서버 객체와 연관된 이벤트 루프를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.start_serving">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">start_serving</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.Server.start_serving" title="Link to this definition">¶</a></dt>
<dd><p>연결을 받아들이기 시작합니다.</p>
<p>This method is idempotent, so it can be called when
the server is already serving.</p>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>와 <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncio.start_server()</span></code></a> 의 <em>start_serving</em> 키워드 전용 매개 변수는 즉시 연결을 받아들이지 않는 서버 객체를 만들 수 있도록 합니다. 이 경우 <code class="docutils literal notranslate"><span class="pre">Server.start_serving()</span></code>, 또는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.serve_forever()</span></code></a>를 사용하여 Server가 연결을 받아들이기 시작하도록 할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.serve_forever">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">serve_forever</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.Server.serve_forever" title="Link to this definition">¶</a></dt>
<dd><p>코루틴이 취소될 때까지 연결을 받아들이기 시작합니다. <code class="docutils literal notranslate"><span class="pre">serve_forever</span></code> 태스크를 취소하면 서버가 닫힙니다.</p>
<p>이 메서드는 서버가 이미 연결을 받아들이고 있어도 호출 할 수 있습니다. 하나의 <em>Server</em> 객체 당 하나의 <code class="docutils literal notranslate"><span class="pre">serve_forever</span></code> 태스크만 존재할 수 있습니다.</p>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">client_connected</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">):</span>
    <span class="c1"># Communicate with the client with</span>
    <span class="c1"># reader/writer streams.  For example:</span>
    <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">start_server</span><span class="p">(</span>
        <span class="n">client_connected</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">srv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.is_serving">
<span class="sig-name descname"><span class="pre">is_serving</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.Server.is_serving" title="Link to this definition">¶</a></dt>
<dd><p>서버가 새 연결을 받아들이고 있으면 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.wait_closed">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-name descname"><span class="pre">wait_closed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-eventloop.html#asyncio.Server.wait_closed" title="Link to this definition">¶</a></dt>
<dd><p>Wait until the <a class="reference internal" href="asyncio-eventloop.html#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> method completes and all active
connections have finished.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="asyncio.Server.sockets">
<span class="sig-name descname"><span class="pre">sockets</span></span><a class="headerlink" href="asyncio-eventloop.html#asyncio.Server.sockets" title="Link to this definition">¶</a></dt>
<dd><p>List of socket-like objects, <code class="docutils literal notranslate"><span class="pre">asyncio.trsock.TransportSocket</span></code>, which
the server is listening on.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>파이썬 3.7 이전에는 <code class="docutils literal notranslate"><span class="pre">Server.sockets</span></code> 가 서버 소켓의 내부 리스트를 직접 반환했습니다. 3.7에서는 그 리스트의 복사본이 반환됩니다.</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="event-loop-implementations">
<span id="asyncio-event-loop-implementations"></span><span id="asyncio-event-loops"></span><h2>이벤트 루프 구현<a class="headerlink" href="asyncio-eventloop.html#event-loop-implementations" title="Link to this heading">¶</a></h2>
<p>asyncio에는 두 가지 이벤트 루프 구현이 함께 제공됩니다: <a class="reference internal" href="asyncio-eventloop.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> 및 <a class="reference internal" href="asyncio-eventloop.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>.</p>
<p>기본적으로 asyncio는 유닉스에서 <a class="reference internal" href="asyncio-eventloop.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a>를, 윈도우에서 <a class="reference internal" href="asyncio-eventloop.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>를 사용하도록 구성됩니다.</p>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.SelectorEventLoop">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">SelectorEventLoop</span></span><a class="headerlink" href="asyncio-eventloop.html#asyncio.SelectorEventLoop" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal notranslate"><span class="pre">selectors</span></code></a> 모듈을 기반으로 하는 이벤트 루프.</p>
<p>주어진 플랫폼에서 사용할 수 있는 가장 효율적인 <em>selector</em>를 사용합니다. 정확한 셀렉터 구현을 수동으로 구성하여 사용할 수도 있습니다.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">selectors</span>

<span class="k">class</span> <span class="nc">MyPolicy</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">DefaultEventLoopPolicy</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">new_event_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">selector</span> <span class="o">=</span> <span class="n">selectors</span><span class="o">.</span><span class="n">SelectSelector</span><span class="p">()</span>
      <span class="k">return</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">SelectorEventLoop</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">set_event_loop_policy</span><span class="p">(</span><span class="n">MyPolicy</span><span class="p">())</span>
</pre></div>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스, 윈도우.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="asyncio.ProactorEventLoop">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">ProactorEventLoop</span></span><a class="headerlink" href="asyncio-eventloop.html#asyncio.ProactorEventLoop" title="Link to this definition">¶</a></dt>
<dd><p>“I/O 완료 포트”(IOCP)를 사용하는 윈도우용 이벤트 루프.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 윈도우.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference external" href="https://docs.microsoft.com/en-ca/windows/desktop/FileIO/i-o-completion-ports">I/O 완료 포트에 관한 MSDN 설명서</a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="asyncio.AbstractEventLoop">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">AbstractEventLoop</span></span><a class="headerlink" href="asyncio-eventloop.html#asyncio.AbstractEventLoop" title="Link to this definition">¶</a></dt>
<dd><p>asyncio 호환 이벤트 루프의 추상 베이스 클래스.</p>
<p>The <a class="reference internal" href="asyncio-eventloop.html#asyncio-event-loop-methods"><span class="std std-ref">이벤트 루프 메서드</span></a> section lists all
methods that an alternative implementation of <code class="docutils literal notranslate"><span class="pre">AbstractEventLoop</span></code>
should have defined.</p>
</dd></dl>

</section>
<section id="examples">
<h2>예제<a class="headerlink" href="asyncio-eventloop.html#examples" title="Link to this heading">¶</a></h2>
<p>이 절의 모든 예는 <strong>의도적으로</strong> <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_forever()</span></code></a> 및 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a>와 같은 저수준 이벤트 루프 API를 사용하는 방법을 보여줍니다. 현대 asyncio 응용 프로그램은 거의 이런 식으로 작성할 필요가 없습니다; <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>과 같은 고수준 함수를 사용하는 것을 고려하십시오.</p>
<section id="hello-world-with-call-soon">
<span id="asyncio-example-lowlevel-helloworld"></span><h3>call_soon()을 사용하는 Hello World<a class="headerlink" href="asyncio-eventloop.html#hello-world-with-call-soon" title="Link to this heading">¶</a></h3>
<p>콜백을 예약하기 위해 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a> 메서드를 사용하는 예제. 콜백은 <code class="docutils literal notranslate"><span class="pre">&quot;Hello</span> <span class="pre">World&quot;</span></code> 를 표시한 다음 이벤트 루프를 중지합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">def</span> <span class="nf">hello_world</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A callback to print &#39;Hello World&#39; and stop the event loop&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>

<span class="c1"># Schedule a call to hello_world()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">hello_world</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># Blocking call interrupted by loop.stop()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>코루틴과 <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> 함수로 작성된 유사한 <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">Hello World</span></a> 예제.</p>
</div>
</section>
<section id="display-the-current-date-with-call-later">
<span id="asyncio-example-call-later"></span><h3>call_later()로 현재 날짜를 표시합니다.<a class="headerlink" href="asyncio-eventloop.html#display-the-current-date-with-call-later" title="Link to this heading">¶</a></h3>
<p>초마다 현재 날짜를 표시하는 콜백의 예입니다. 콜백은 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a> 메서드를 사용하여 5초 동안 자신을 다시 예약한 다음 이벤트 루프를 중지합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="k">def</span> <span class="nf">display_date</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">end_time</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>

<span class="c1"># Schedule the first call to display_date()</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">5.0</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># Blocking call interrupted by loop.stop()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>코루틴과 <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> 함수로 작성된 유사한 <a class="reference internal" href="asyncio-task.html#asyncio-example-sleep"><span class="std std-ref">현재 날짜</span></a> 예제.</p>
</div>
</section>
<section id="watch-a-file-descriptor-for-read-events">
<span id="asyncio-example-watch-fd"></span><h3>파일 기술자에서 읽기 이벤트를 관찰하기<a class="headerlink" href="asyncio-eventloop.html#watch-a-file-descriptor-for-read-events" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.add_reader" title="asyncio.loop.add_reader"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_reader()</span></code></a> 메서드를 사용하여 파일 기술자가 데이터를 수신할 때까지 기다렸다가 이벤트 루프를 닫습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socketpair</span>

<span class="c1"># Create a pair of connected file descriptors</span>
<span class="n">rsock</span><span class="p">,</span> <span class="n">wsock</span> <span class="o">=</span> <span class="n">socketpair</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">reader</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">rsock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Received:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>

    <span class="c1"># We are done: unregister the file descriptor</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">remove_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">)</span>

    <span class="c1"># Stop the event loop</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="c1"># Register the file descriptor for read event</span>
<span class="n">loop</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">,</span> <span class="n">reader</span><span class="p">)</span>

<span class="c1"># Simulate the reception of data from the network</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">wsock</span><span class="o">.</span><span class="n">send</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># Run the event loop</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="c1"># We are done. Close sockets and the event loop.</span>
    <span class="n">rsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">wsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<ul class="simple">
<li><p>트랜스포트, 프로토콜, <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> 메서드를 사용한 유사한 <a class="reference internal" href="asyncio-protocol.html#asyncio-example-create-connection"><span class="std std-ref">예제</span></a>.</p></li>
<li><p>고수준의 <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.open_connection()</span></code></a> 함수와 스트림을 사용하는 또 다른 유사한 <a class="reference internal" href="asyncio-stream.html#asyncio-example-create-connection-streams"><span class="std std-ref">예제</span></a>.</p></li>
</ul>
</div>
</section>
<section id="set-signal-handlers-for-sigint-and-sigterm">
<span id="asyncio-example-unix-signals"></span><h3>SIGINT 및 SIGTERM에 대한 시그널 처리기 설정<a class="headerlink" href="asyncio-eventloop.html#set-signal-handlers-for-sigint-and-sigterm" title="Link to this heading">¶</a></h3>
<p>(이 <code class="docutils literal notranslate"><span class="pre">signals</span></code> 예제는 유닉스에서만 작동합니다.)</p>
<p>Register handlers for signals <a class="reference internal" href="signal.html#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGINT</span></code></a> and <a class="reference internal" href="signal.html#signal.SIGTERM" title="signal.SIGTERM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGTERM</span></code></a>
using the <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.add_signal_handler" title="asyncio.loop.add_signal_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_signal_handler()</span></code></a> method:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">signal</span>

<span class="k">def</span> <span class="nf">ask_exit</span><span class="p">(</span><span class="n">signame</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;got signal </span><span class="si">%s</span><span class="s2">: exit&quot;</span> <span class="o">%</span> <span class="n">signame</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">signame</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;SIGINT&#39;</span><span class="p">,</span> <span class="s1">&#39;SIGTERM&#39;</span><span class="p">}:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">add_signal_handler</span><span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">signame</span><span class="p">),</span>
            <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">ask_exit</span><span class="p">,</span> <span class="n">signame</span><span class="p">,</span> <span class="n">loop</span><span class="p">))</span>

    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3600</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Event loop running for 1 hour, press Ctrl+C to interrupt.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pid </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span><span class="si">}</span><span class="s2">: send SIGINT or SIGTERM to exit.&quot;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="asyncio-eventloop.html#">이벤트 루프</a><ul>
<li><a class="reference internal" href="asyncio-eventloop.html#event-loop-methods">이벤트 루프 메서드</a><ul>
<li><a class="reference internal" href="asyncio-eventloop.html#running-and-stopping-the-loop">루프 실행 및 중지</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#scheduling-callbacks">콜백 예약하기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#scheduling-delayed-callbacks">지연된 콜백 예약</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#creating-futures-and-tasks">퓨처와 태스크 만들기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#opening-network-connections">네트워크 연결 열기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#creating-network-servers">네트워크 서버 만들기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#transferring-files">파일 전송</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#tls-upgrade">TLS 업그레이드</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#watching-file-descriptors">파일 기술자 관찰하기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#working-with-socket-objects-directly">소켓 객체로 직접 작업하기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#dns">DNS</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#working-with-pipes">파이프로 작업하기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#unix-signals">유닉스 시그널</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#executing-code-in-thread-or-process-pools">스레드 또는 프로세스 풀에서 코드를 실행하기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#error-handling-api">에러 처리 API</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#enabling-debug-mode">디버그 모드 활성화</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#running-subprocesses">자식 프로세스 실행하기</a></li>
</ul>
</li>
<li><a class="reference internal" href="asyncio-eventloop.html#callback-handles">콜백 핸들</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#server-objects">서버 객체</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#event-loop-implementations">이벤트 루프 구현</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#examples">예제</a><ul>
<li><a class="reference internal" href="asyncio-eventloop.html#hello-world-with-call-soon">call_soon()을 사용하는 Hello World</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#display-the-current-date-with-call-later">call_later()로 현재 날짜를 표시합니다.</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#watch-a-file-descriptor-for-read-events">파일 기술자에서 읽기 이벤트를 관찰하기</a></li>
<li><a class="reference internal" href="asyncio-eventloop.html#set-signal-handlers-for-sigint-and-sigterm">SIGINT 및 SIGTERM에 대한 시그널 처리기 설정</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="asyncio-exceptions.html"
                          title="이전 장">예외</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="asyncio-future.html"
                          title="다음 장">퓨처</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/asyncio-eventloop.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="사이드바 닫기">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="퓨처"
             >다음</a> |</li>
        <li class="right" >
          <a href="asyncio-exceptions.html" title="예외"
             >이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >네트워킹과 프로세스 간 통신</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> — Asynchronous I/O</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="asyncio-eventloop.html">이벤트 루프</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    저작권
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="../../../license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      최종 업데이트: Jun 09, 2024 (17:23 UTC)
    
      <a href="../../../bugs.html">Found a bug</a>?
    
    <br />

    <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7 버전으로 생성되었습니다.
    </div>

    <script type="text/javascript" src="../_static/switchers.js"></script>
  </body>
</html>