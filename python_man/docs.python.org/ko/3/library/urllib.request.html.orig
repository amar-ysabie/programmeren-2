<!DOCTYPE html>

<html lang="ko" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="urllib.request — Extensible library for opening URLs" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/urllib.request.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="소스 코드: Lib/urllib/request.py urllib.request 모듈은 복잡한 세계에서 URL(대부분 HTTP)을 여는 데 도움이 되는 함수와 클래스를 정의합니다 — 기본(basic)과 다이제스트 인증, 리디렉션, 쿠키 등. Availability: not Emscripten, not WASI. This module does not wo..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="소스 코드: Lib/urllib/request.py urllib.request 모듈은 복잡한 세계에서 URL(대부분 HTTP)을 여는 데 도움이 되는 함수와 클래스를 정의합니다 — 기본(basic)과 다이제스트 인증, 리디렉션, 쿠키 등. Availability: not Emscripten, not WASI. This module does not wo..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>urllib.request — Extensible library for opening URLs &#8212; Python 3.12.4 문서</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=bb723527" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=b20cc3f5" />
    
    <script src="../_static/documentation_options.js?v=3050f571"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=b5f768d8"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.12.4 문서에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="urllib.parse — Parse URLs into components" href="urllib.parse.html" />
    <link rel="prev" title="urllib — URL handling modules" href="urllib.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="https://docs.python.org/3/library/urllib.request.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" />
                <input type="submit" value="이동"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> — Extensible library for opening URLs</a><ul>
<li><a class="reference internal" href="#request-objects">Request 객체</a></li>
<li><a class="reference internal" href="#openerdirector-objects">OpenerDirector 객체</a></li>
<li><a class="reference internal" href="#basehandler-objects">BaseHandler 객체</a></li>
<li><a class="reference internal" href="#httpredirecthandler-objects">HTTPRedirectHandler 객체</a></li>
<li><a class="reference internal" href="#httpcookieprocessor-objects">HTTPCookieProcessor 객체</a></li>
<li><a class="reference internal" href="#proxyhandler-objects">ProxyHandler 객체</a></li>
<li><a class="reference internal" href="#httppasswordmgr-objects">HTTPPasswordMgr 객체</a></li>
<li><a class="reference internal" href="#httppasswordmgrwithpriorauth-objects">HTTPPasswordMgrWithPriorAuth 객체</a></li>
<li><a class="reference internal" href="#abstractbasicauthhandler-objects">AbstractBasicAuthHandler 객체</a></li>
<li><a class="reference internal" href="#httpbasicauthhandler-objects">HTTPBasicAuthHandler 객체</a></li>
<li><a class="reference internal" href="#proxybasicauthhandler-objects">ProxyBasicAuthHandler 객체</a></li>
<li><a class="reference internal" href="#abstractdigestauthhandler-objects">AbstractDigestAuthHandler 객체</a></li>
<li><a class="reference internal" href="#httpdigestauthhandler-objects">HTTPDigestAuthHandler 객체</a></li>
<li><a class="reference internal" href="#proxydigestauthhandler-objects">ProxyDigestAuthHandler 객체</a></li>
<li><a class="reference internal" href="#httphandler-objects">HTTPHandler 객체</a></li>
<li><a class="reference internal" href="#httpshandler-objects">HTTPSHandler 객체</a></li>
<li><a class="reference internal" href="#filehandler-objects">FileHandler 객체</a></li>
<li><a class="reference internal" href="#datahandler-objects">DataHandler 객체</a></li>
<li><a class="reference internal" href="#ftphandler-objects">FTPHandler 객체</a></li>
<li><a class="reference internal" href="#cacheftphandler-objects">CacheFTPHandler 객체</a></li>
<li><a class="reference internal" href="#unknownhandler-objects">UnknownHandler 객체</a></li>
<li><a class="reference internal" href="#httperrorprocessor-objects">HTTPErrorProcessor 객체</a></li>
<li><a class="reference internal" href="#examples">예</a></li>
<li><a class="reference internal" href="#legacy-interface">레거시 인터페이스</a></li>
<li><a class="reference internal" href="#urllib-request-restrictions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> 제약 사항</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-urllib.response"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code> — urllib가 사용하는 응답 클래스</a></li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="urllib.html"
                          title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code> — URL handling modules</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="urllib.parse.html"
                          title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code> — Parse URLs into components</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/urllib.request.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="urllib.parse.html" title="urllib.parse — Parse URLs into components"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="urllib.html" title="urllib — URL handling modules"
             accesskey="P">이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">인터넷 프로토콜과 지원</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> — Extensible library for opening URLs</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-urllib.request">
<span id="urllib-request-extensible-library-for-opening-urls"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> — Extensible library for opening URLs<a class="headerlink" href="#module-urllib.request" title="Link to this heading">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/urllib/request.py">Lib/urllib/request.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> 모듈은 복잡한 세계에서 URL(대부분 HTTP)을 여는 데 도움이 되는 함수와 클래스를 정의합니다 — 기본(basic)과 다이제스트 인증, 리디렉션, 쿠키 등.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>더 고수준 HTTP 클라이언트 인터페이스로 <a class="reference external" href="https://requests.readthedocs.io/en/master/">Requests 패키지</a>를 권장합니다.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>On macOS it is unsafe to use this module in programs using
<a class="reference internal" href="os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a> because the <a class="reference internal" href="#urllib.request.getproxies" title="urllib.request.getproxies"><code class="xref py py-func docutils literal notranslate"><span class="pre">getproxies()</span></code></a> implementation for
macOS uses a higher-level system API. Set the environment variable
<code class="docutils literal notranslate"><span class="pre">no_proxy</span></code> to <code class="docutils literal notranslate"><span class="pre">*</span></code> to avoid this problem
(e.g. <code class="docutils literal notranslate"><span class="pre">os.environ[&quot;no_proxy&quot;]</span> <span class="pre">=</span> <span class="pre">&quot;*&quot;</span></code>).</p>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not Emscripten, not WASI.</p>
<p>This module does not work or is not available on WebAssembly platforms
<code class="docutils literal notranslate"><span class="pre">wasm32-emscripten</span></code> and <code class="docutils literal notranslate"><span class="pre">wasm32-wasi</span></code>. See
<a class="reference internal" href="intro.html#wasm-availability"><span class="std std-ref">WebAssembly platforms</span></a> for more information.</p>
</div>
<p><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> 모듈은 다음 함수를 정의합니다:</p>
<dl class="py function">
<dt class="sig sig-object py" id="urllib.request.urlopen">
<span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">urlopen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data=None</span></span></em>, <span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cafile=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">capath=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cadefault=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlopen" title="Link to this definition">¶</a></dt>
<dd><p>Open <em>url</em>, which can be either a string containing a valid, properly
encoded URL, or a <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> object.</p>
<p><em>data</em>는 서버로 전송할 추가 데이터를 지정하는 객체이거나, 그러한 데이터가 필요하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이어야 합니다. 자세한 내용은 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>를 참조하십시오.</p>
<p>urllib.request 모듈은 HTTP/1.1을 사용하고 HTTP 요청에 <code class="docutils literal notranslate"><span class="pre">Connection:close</span></code> 헤더를 포함합니다.</p>
<p>선택적 <em>timeout</em> 매개 변수는 연결 시도와 같은 연산을 블로킹하기 위한 시간제한을 초 단위로 지정합니다 (지정하지 않으면 전역 기본 시간제한 설정이 사용됩니다). 이것은 실제로는 HTTP, HTTPS 및 FTP 연결에서만 작동합니다.</p>
<p><em>context</em>가 지정되면, 다양한 SSL 옵션을 기술하는 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> 인스턴스이어야 합니다. 자세한 내용은 <a class="reference internal" href="http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPSConnection</span></code></a>을 참조하십시오.</p>
<p>선택적 <em>cafile</em>과 <em>capath</em> 매개 변수는 HTTPS 요청을 위한 신뢰할 수 있는 CA 인증서 집합을 지정합니다. <em>cafile</em>은 CA 인증서 번들을 포함하는 단일 파일을 가리켜야 하지만, <em>capath</em>는 해시 된 인증서 파일의 디렉터리를 가리켜야 합니다. 자세한 정보는 <a class="reference internal" href="ssl.html#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_verify_locations()</span></code></a>에서 찾을 수 있습니다.</p>
<p><em>cadefault</em> 매개 변수는 무시됩니다.</p>
<p>이 함수는 항상 <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">컨텍스트 관리자</span></a>로 작동할 수 있고 <em>url</em>, <em>headers</em> 및 <em>status</em> 프로퍼티를 가진 객체를 반환합니다. 이러한 프로퍼티에 대한 자세한 내용은 <a class="reference internal" href="#urllib.response.addinfourl" title="urllib.response.addinfourl"><code class="xref py py-class docutils literal notranslate"><span class="pre">urllib.response.addinfourl</span></code></a>을 참조하십시오.</p>
<p>HTTP 및 HTTPS URL의 경우, 이 함수는 약간 수정된 <a class="reference internal" href="http.client.html#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.client.HTTPResponse</span></code></a> 객체를 반환합니다. 위의 세 가지 새로운 메서드 외에도, msg 어트리뷰트에는 <a class="reference internal" href="http.client.html#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPResponse</span></code></a> 설명서에 지정된 대로 응답 헤더 대신 <a class="reference internal" href="http.client.html#http.client.HTTPResponse.reason" title="http.client.HTTPResponse.reason"><code class="xref py py-attr docutils literal notranslate"><span class="pre">reason</span></code></a> 어트리뷰트와 — 서버가 반환한 이유 문구 — 같은 정보가 포함됩니다.</p>
<p>FTP, 파일 및 데이터 URL과 레거시 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a>와 <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> 클래스에서 명시적으로 처리된 요청의 경우, 이 함수는 <a class="reference internal" href="#urllib.response.addinfourl" title="urllib.response.addinfourl"><code class="xref py py-class docutils literal notranslate"><span class="pre">urllib.response.addinfourl</span></code></a> 객체를 반환합니다.</p>
<p>프로토콜 에러 시 <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>를 발생시킵니다.</p>
<p>아무런 처리기도 요청을 처리하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환될 수 있습니다 (기본 설치된 전역 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>는 <a class="reference internal" href="#urllib.request.UnknownHandler" title="urllib.request.UnknownHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnknownHandler</span></code></a>를 사용하여 이러한 상황이 발생하지 않도록 합니다).</p>
<p>In addition, if proxy settings are detected (for example, when a <code class="docutils literal notranslate"><span class="pre">*_proxy</span></code>
environment variable like <code class="xref std std-envvar docutils literal notranslate"><span class="pre">http_proxy</span></code> is set),
<a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> is default installed and makes sure the requests are
handled through the proxy.</p>
<p>파이썬 2.6 및 이전 버전의 레거시 <code class="docutils literal notranslate"><span class="pre">urllib.urlopen</span></code> 함수는 중단되었습니다; <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.request.urlopen()</span></code></a>는 이전 <code class="docutils literal notranslate"><span class="pre">urllib2.urlopen</span></code>에 해당합니다. 딕셔너리 매개 변수를 <code class="docutils literal notranslate"><span class="pre">urllib.urlopen</span></code>에 전달하여 수행되었던 프락시 처리는 <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> 객체를 사용하여 얻을 수 있습니다.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">fullurl</span></code>, <code class="docutils literal notranslate"><span class="pre">data</span></code>, <code class="docutils literal notranslate"><span class="pre">headers</span></code>, <code class="docutils literal notranslate"><span class="pre">method</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">urllib.Request</span></code>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>cafile</em>과 <em>capath</em>가 추가되었습니다.</p>
<p>HTTPS virtual hosts are now supported if possible (that is, if
<a class="reference internal" href="ssl.html#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-const docutils literal notranslate"><span class="pre">ssl.HAS_SNI</span></code></a> is true).</p>
<p><em>data</em>는 이터러블 객체일 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><em>cadefault</em>가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4.3에서 변경: </span><em>context</em>가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.10에서 변경: </span>HTTPS connection now send an ALPN extension with protocol indicator
<code class="docutils literal notranslate"><span class="pre">http/1.1</span></code> when no <em>context</em> is given. Custom <em>context</em> should set
ALPN protocols with <a class="reference internal" href="ssl.html#ssl.SSLContext.set_alpn_protocols" title="ssl.SSLContext.set_alpn_protocols"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_alpn_protocols()</span></code></a>.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.6부터 폐지됨: </span><em>cafile</em>, <em>capath</em> 및 <em>cadefault</em>는 폐지되어 <em>context</em>로 대체되었습니다. 대신 <a class="reference internal" href="ssl.html#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_cert_chain()</span></code></a>을 사용하거나, <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>가 시스템의 신뢰할 수 있는 CA 인증서를 선택하도록 하십시오.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.request.install_opener">
<span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">install_opener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opener</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.install_opener" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 인스턴스를 기본 전역 오프너로 설치합니다. 오프너 설치는 urlopen이 해당 오프너를 사용하도록 하려는 경우에만 필요합니다; 그렇지 않으면 단순히 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 대신 <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.open()</span></code></a>을 호출하십시오. 코드는 실제 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>를 확인하지 않으며, 적절한 인터페이스를 가진 클래스면 모두 작동합니다.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.request.build_opener">
<span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">build_opener</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">handler</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.build_opener" title="Link to this definition">¶</a></dt>
<dd><p>주어진 순서대로 처리기를 연결하는 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 인스턴스를 반환합니다. <em>handler</em>는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>의 인스턴스이거나 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>의 서브 클래스(이 경우 매개 변수 없이 생성자를 호출할 수 있어야 합니다)일 수 있습니다. 다음과 같은 클래스들의 인스턴스는 <em>handler</em>에 그들, 그들의 인스턴스 또는 그들의 서브 클래스가 포함되지 않는 한 <em>handler</em> 앞에 있습니다: <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> (프락시 설정이 감지되는 경우), <a class="reference internal" href="#urllib.request.UnknownHandler" title="urllib.request.UnknownHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnknownHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPHandler" title="urllib.request.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPDefaultErrorHandler" title="urllib.request.HTTPDefaultErrorHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPDefaultErrorHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPRedirectHandler" title="urllib.request.HTTPRedirectHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPRedirectHandler</span></code></a>, <a class="reference internal" href="#urllib.request.FTPHandler" title="urllib.request.FTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FTPHandler</span></code></a>, <a class="reference internal" href="#urllib.request.FileHandler" title="urllib.request.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPErrorProcessor" title="urllib.request.HTTPErrorProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPErrorProcessor</span></code></a>.</p>
<p>파이썬 설치에 SSL 지원이 있으면 (즉, <a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> 모듈을 임포트 할 수 있으면) <a class="reference internal" href="#urllib.request.HTTPSHandler" title="urllib.request.HTTPSHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPSHandler</span></code></a>도 추가됩니다.</p>
<p><a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 서브 클래스는 또한 <code class="xref py py-attr docutils literal notranslate"><span class="pre">handler_order</span></code> 어트리뷰트를 변경하여 처리기 리스트에서 자신의 위치를 수정할 수 있습니다.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.request.pathname2url">
<span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">pathname2url</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.pathname2url" title="Link to this definition">¶</a></dt>
<dd><p>경로명 <em>path</em>를 경로의 로컬 구문에서 URL의 경로 구성 요소에 사용된 형식으로 변환합니다. 완전한 URL을 생성하지는 않습니다. 반환 값은 <a class="reference internal" href="urllib.parse.html#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a> 함수를 사용하여 이미 인용되었습니다.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.request.url2pathname">
<span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">url2pathname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.url2pathname" title="Link to this definition">¶</a></dt>
<dd><p>경로 구성 요소 <em>path</em>를 퍼센트 인코딩된 URL에서 경로의 로컬 구문으로 변환합니다. 완전한 URL을 받아들이지 않습니다. 이 함수는 <a class="reference internal" href="urllib.parse.html#urllib.parse.unquote" title="urllib.parse.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">unquote()</span></code></a>를 사용하여 <em>path</em>를 디코딩합니다.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.request.getproxies">
<span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">getproxies</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.getproxies" title="Link to this definition">¶</a></dt>
<dd><p>This helper function returns a dictionary of scheme to proxy server URL
mappings. It scans the environment for variables named <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;_proxy</span></code>,
in a case insensitive approach, for all operating systems first, and when it
cannot find it, looks for proxy information from System
Configuration for macOS and Windows Systems Registry for Windows.
If both lowercase and uppercase environment variables exist (and disagree),
lowercase is preferred.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>일반적으로 스크립트가 CGI 환경에서 실행 중임을 나타내는 환경 변수 <code class="docutils literal notranslate"><span class="pre">REQUEST_METHOD</span></code>가 설정되면, 환경 변수 <code class="docutils literal notranslate"><span class="pre">HTTP_PROXY</span></code>(대문자 <code class="docutils literal notranslate"><span class="pre">_PROXY</span></code>)는 무시됩니다. 이 변수는 “Proxy:” HTTP 헤더를 사용하여 클라이언트가 주입할 수 있기 때문입니다. CGI 환경에서 HTTP 프락시를 사용해야 하면, <code class="docutils literal notranslate"><span class="pre">ProxyHandler</span></code>를 명시적으로 사용하거나 변수 이름이 소문자(또는 적어도 <code class="docutils literal notranslate"><span class="pre">_proxy</span></code> 접미사)가 되도록 하십시오.</p>
</div>
</dd></dl>

<p>다음과 같은 클래스가 제공됩니다:</p>
<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.Request">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">Request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">headers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin_req_host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unverifiable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request" title="Link to this definition">¶</a></dt>
<dd><p>이 클래스는 URL 요청의 추상화입니다.</p>
<p><em>url</em> should be a string containing a valid, properly encoded URL.</p>
<p><em>data</em>는 서버로 전송할 추가 데이터를 지정하는 객체이거나, 그러한 데이터가 필요하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이어야 합니다. 현재 HTTP 요청은 <em>data</em>를 사용하는 유일한 요청입니다. 지원되는 객체 형에는 바이트열, 파일류 객체 및 바이트열류 객체의 이터러블이 포함됩니다. <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code>와 <code class="docutils literal notranslate"><span class="pre">Transfer-Encoding</span></code> 헤더 필드가 모두 제공되지 않으면, <a class="reference internal" href="#urllib.request.HTTPHandler" title="urllib.request.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a>는 <em>data</em>의 형에 따라 이러한 헤더를 설정합니다. <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code>는 바이트열 객체를 보내는 데 사용되는 반면, <span class="target" id="index-21"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7230.html"><strong>RFC 7230</strong></a>, 섹션 3.3.1에 지정된 <code class="docutils literal notranslate"><span class="pre">Transfer-Encoding:</span> <span class="pre">chunked</span></code>는 파일과 다른 이터러블을 보내는 데 사용됩니다.</p>
<p>HTTP POST 요청 메서드의 경우, <em>data</em>는 표준 <em class="mimetype">application/x-www-form-urlencoded</em> 형식의 버퍼여야 합니다. <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 함수는 매핑이나 2-튜플의 시퀀스를 취하고 이 형식의 ASCII 문자열을 반환합니다. <em>data</em> 매개 변수로 사용되기 전에 바이트열로 인코딩되어야 합니다.</p>
<p><em>headers</em> should be a dictionary, and will be treated as if
<a class="reference internal" href="#urllib.request.Request.add_header" title="urllib.request.Request.add_header"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_header()</span></code></a> was called with each key and value as arguments.
This is often used to “spoof” the <code class="docutils literal notranslate"><span class="pre">User-Agent</span></code> header value, which is
used by a browser to identify itself – some HTTP servers only
allow requests coming from common browsers as opposed to scripts.
For example, Mozilla Firefox may identify itself as <code class="docutils literal notranslate"><span class="pre">&quot;Mozilla/5.0</span>
<span class="pre">(X11;</span> <span class="pre">U;</span> <span class="pre">Linux</span> <span class="pre">i686)</span> <span class="pre">Gecko/20071127</span> <span class="pre">Firefox/2.0.0.11&quot;</span></code>, while
<a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a>’s default user agent string is
<code class="docutils literal notranslate"><span class="pre">&quot;Python-urllib/2.6&quot;</span></code> (on Python 2.6).
All header keys are sent in camel case.</p>
<p>An appropriate <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> header should be included if the <em>data</em>
argument is present.  If this header has not been provided and <em>data</em>
is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">Content-Type:</span> <span class="pre">application/x-www-form-urlencoded</span></code> will
be added as a default.</p>
<p>다음 두 인자는 제삼자 HTTP 쿠키를 올바르게 처리하는 데에만 관심이 있습니다:</p>
<p><em>origin_req_host</em>는 <span class="target" id="index-22"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2965.html"><strong>RFC 2965</strong></a>에 의해 정의된 대로 오리진 트랜잭션의 요청 호스트여야 합니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">http.cookiejar.request_host(self)</span></code>입니다. 이것은 사용자가 시작한 원래 요청의 호스트 이름이나 IP 주소입니다. 예를 들어, HTML 문서의 이미지에 대한 요청이면, 이미지가 포함된 페이지에 대한 요청의 요청 호스트여야 합니다.</p>
<p><em>unverifiable</em>은 <span class="target" id="index-23"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2965.html"><strong>RFC 2965</strong></a>에서 정의한 대로 요청을 확인할 수 없는지를 표시해야 합니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">False</span></code>입니다. 확인할 수 없는 요청은 사용자에게 URL에 대한 승인 옵션이 없는 요청입니다. 예를 들어, HTML 문서의 이미지에 대한 요청이고, 사용자에게 이미지의 자동 가져오기를 승인할 수 있는 옵션이 없으면, 이것은 참이어야 합니다.</p>
<p><em>method</em>는 사용될 HTTP 요청 메서드를 나타내는 문자열이어야 합니다 (예를 들어 <code class="docutils literal notranslate"><span class="pre">'HEAD'</span></code>). 제공되면, 해당 값은 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code></a> 어트리뷰트에 저장되고 <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a>에서 사용됩니다. 기본값은 <em>data</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면 <code class="docutils literal notranslate"><span class="pre">'GET'</span></code>이고, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">'POST'</span></code>입니다. 서브 클래스는 클래스 자체에서 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code></a> 어트리뷰트를 설정하여 다른 기본 메서드를 나타낼 수 있습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>data 객체가 콘텐츠를 두 번 이상 (예를 들어 콘텐츠를 한 번만 생성 할 수 있는 파일이나 이터러블) 전달할 수 없고 요청이 HTTP 리디렉션이나 인증을 위해 재시도되는 경우, 요청이 예상대로 작동하지 않습니다. <em>data</em>는 헤더 바로 다음에 HTTP 서버로 전송됩니다. 라이브러리에서 100-continue 예상(expectation)을 지원하지 않습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a> 인자가 Request 클래스에 추가됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>클래스 수준에서 기본 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a>를 지정할 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><code class="docutils literal notranslate"><span class="pre">Content-Length</span></code>가 제공되지 않고 <em>data</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이나 바이트열 객체가 아닐 때 에러를 발생시키지 앖습니다. 대신 청크 전송 인코딩(chunked transfer encoding)으로 폴백 합니다.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.OpenerDirector">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">OpenerDirector</span></span><a class="headerlink" href="#urllib.request.OpenerDirector" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 클래스는 서로 연결된 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>들을 통해 URL을 엽니다. 처리기 연결과 에러 복구를 관리합니다.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.BaseHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">BaseHandler</span></span><a class="headerlink" href="#urllib.request.BaseHandler" title="Link to this definition">¶</a></dt>
<dd><p>이것은 등록된 모든 처리기의 베이스 클래스이며 — 간단한 등록 메커니즘만 처리합니다.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPDefaultErrorHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPDefaultErrorHandler</span></span><a class="headerlink" href="#urllib.request.HTTPDefaultErrorHandler" title="Link to this definition">¶</a></dt>
<dd><p>HTTP 에러 응답에 대한 기본 처리기를 정의하는 클래스; 모든 응답은 <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> 예외로 바뀝니다.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPRedirectHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPRedirectHandler</span></span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler" title="Link to this definition">¶</a></dt>
<dd><p>리디렉션을 처리하는 클래스.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPCookieProcessor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPCookieProcessor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cookiejar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPCookieProcessor" title="Link to this definition">¶</a></dt>
<dd><p>HTTP 쿠키를 처리하는 클래스.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.ProxyHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">ProxyHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proxies</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyHandler" title="Link to this definition">¶</a></dt>
<dd><p>Cause requests to go through a proxy. If <em>proxies</em> is given, it must be a
dictionary mapping protocol names to URLs of proxies. The default is to read
the list of proxies from the environment variables
<code class="docutils literal notranslate"><span class="pre">&lt;protocol&gt;_proxy</span></code>.  If no proxy environment variables are set, then
in a Windows environment proxy settings are obtained from the registry’s
Internet Settings section, and in a macOS environment proxy information
is retrieved from the System Configuration Framework.</p>
<p>자동 감지 프락시를 비활성화하려면 빈 딕셔너리를 전달하십시오.</p>
<p><span class="target" id="index-24"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">no_proxy</span></code> 환경 변수를 사용하여 프락시를 통해 도달해서는 안 되는 호스트를 지정할 수 있습니다; 설정되면, 쉼표로 구분된 호스트 이름 접미사의 목록이어야 하며, 선택적으로 <code class="docutils literal notranslate"><span class="pre">:port</span></code>가 추가됩니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">cern.ch,ncsa.uiuc.edu,some.host:8080</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>변수 <code class="docutils literal notranslate"><span class="pre">REQUEST_METHOD</span></code>가 설정되면 <code class="docutils literal notranslate"><span class="pre">HTTP_PROXY</span></code>는 무시됩니다; <a class="reference internal" href="#urllib.request.getproxies" title="urllib.request.getproxies"><code class="xref py py-func docutils literal notranslate"><span class="pre">getproxies()</span></code></a>의 설명서를 참조하십시오.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgr">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPPasswordMgr</span></span><a class="headerlink" href="#urllib.request.HTTPPasswordMgr" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">(realm,</span> <span class="pre">uri)</span> <span class="pre">-&gt;</span> <span class="pre">(user,</span> <span class="pre">password)</span></code> 매핑 데이터베이스를 유지합니다.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgrWithDefaultRealm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">(realm,</span> <span class="pre">uri)</span> <span class="pre">-&gt;</span> <span class="pre">(user,</span> <span class="pre">password)</span></code> 매핑 데이터베이스를 유지합니다. <code class="docutils literal notranslate"><span class="pre">None</span></code> realm은 포괄(catch-all) 영역으로 간주하며 다른 영역에 맞지 않으면 검색됩니다.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgrWithPriorAuth">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPPasswordMgrWithPriorAuth</span></span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">uri</span> <span class="pre">-&gt;</span> <span class="pre">is_authenticated</span></code> 매핑 데이터베이스도 포함하는 <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a>의 변형. BasicAuth 처리기에서 <code class="docutils literal notranslate"><span class="pre">401</span></code> 응답을 먼저 기다리는 대신 인증 자격 증명을 언제 보낼 것인지 결정하는 데 사용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.AbstractBasicAuthHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">AbstractBasicAuthHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">password_mgr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractBasicAuthHandler" title="Link to this definition">¶</a></dt>
<dd><p>원격 호스트와 프락시 모두에서 HTTP 인증을 돕는 믹스인 클래스입니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 객체</span></a>를 참조하십시오. <em>passwd_mgr</em>이 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code>와 <code class="docutils literal notranslate"><span class="pre">update_authenticated</span></code> 메서드도 제공하면 (<a class="reference internal" href="#http-password-mgr-with-prior-auth"><span class="std std-ref">HTTPPasswordMgrWithPriorAuth 객체</span></a>를 참조하십시오), 처리기는 지정된 URI에 대해 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 결과를 사용하여 요청과 함께 인증 자격 증명을 보낼지를 판별합니다. <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code>가 URI에 대해 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환하면, 자격 증명이 전송됩니다. <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>이면, 자격 증명이 전송되지 않으며, 그런 다음 <code class="docutils literal notranslate"><span class="pre">401</span></code> 응답이 수신되면 요청이 인증 자격 증명과 함께 다시 전송됩니다. 인증이 성공하면, 이 URI에 대해 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code>를 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정하기 위해 <code class="docutils literal notranslate"><span class="pre">update_authenticated</span></code>가 호출되어서, 이 URI나 모든 슈퍼 URI에 대한 후속 요청에 인증 자격 증명이 자동으로 포함됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5: </span><code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPBasicAuthHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPBasicAuthHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">password_mgr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPBasicAuthHandler" title="Link to this definition">¶</a></dt>
<dd><p>원격 호스트와의 인증을 처리합니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 객체</span></a>를 참조하십시오. 잘못된 인증 스킴(Authentication scheme)을 제시하면 HTTPBasicAuthHandler 가 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.ProxyBasicAuthHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">ProxyBasicAuthHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">password_mgr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyBasicAuthHandler" title="Link to this definition">¶</a></dt>
<dd><p>프락시와의 인증을 처리합니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 객체</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.AbstractDigestAuthHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">AbstractDigestAuthHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">password_mgr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractDigestAuthHandler" title="Link to this definition">¶</a></dt>
<dd><p>원격 호스트와 프락시 모두에서 HTTP 인증을 돕는 믹스인 클래스입니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 객체</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPDigestAuthHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPDigestAuthHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">password_mgr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPDigestAuthHandler" title="Link to this definition">¶</a></dt>
<dd><p>원격 호스트와의 인증을 처리합니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 객체</span></a>를 참조하십시오. 다이제스트 인증 처리기와 기본 인증 처리기가 모두 추가되면, 다이제스트 인증이 항상 먼저 시도됩니다. 다이제스트 인증이 다시 40x 응답을 반환하면, 기본 인증 처리기로 보내 처리됩니다. 이 처리기 메서드는 Digest나 Basic 이외의 인증 스킴(authentication scheme)이 제공될 때 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>지원되지 않는 인증 스킴에 대해 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.ProxyDigestAuthHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">ProxyDigestAuthHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">password_mgr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyDigestAuthHandler" title="Link to this definition">¶</a></dt>
<dd><p>프락시와의 인증을 처리합니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 객체</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPHandler</span></span><a class="headerlink" href="#urllib.request.HTTPHandler" title="Link to this definition">¶</a></dt>
<dd><p>HTTP URL 열기를 처리하는 클래스.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPSHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPSHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">debuglevel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPSHandler" title="Link to this definition">¶</a></dt>
<dd><p>HTTPS URL 열기를 처리하는 클래스. <em>context</em>와 <em>check_hostname</em>은 <a class="reference internal" href="http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.client.HTTPSConnection</span></code></a>과 같은 의미입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>context</em>와 <em>check_hostname</em>이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.FileHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">FileHandler</span></span><a class="headerlink" href="#urllib.request.FileHandler" title="Link to this definition">¶</a></dt>
<dd><p>로컬 파일을 엽니다.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.DataHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">DataHandler</span></span><a class="headerlink" href="#urllib.request.DataHandler" title="Link to this definition">¶</a></dt>
<dd><p>데이터 URL을 엽니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.FTPHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">FTPHandler</span></span><a class="headerlink" href="#urllib.request.FTPHandler" title="Link to this definition">¶</a></dt>
<dd><p>FTP URL을 엽니다.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.CacheFTPHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">CacheFTPHandler</span></span><a class="headerlink" href="#urllib.request.CacheFTPHandler" title="Link to this definition">¶</a></dt>
<dd><p>지연 시간을 최소화하기 위해 열린 FTP 연결의 캐시를 유지하면서, FTP URL을 엽니다.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.UnknownHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">UnknownHandler</span></span><a class="headerlink" href="#urllib.request.UnknownHandler" title="Link to this definition">¶</a></dt>
<dd><p>알 수 없는 URL을 처리하기 위한 포괄적인(catch-all) 클래스.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.HTTPErrorProcessor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">HTTPErrorProcessor</span></span><a class="headerlink" href="#urllib.request.HTTPErrorProcessor" title="Link to this definition">¶</a></dt>
<dd><p>HTTP 에러 응답을 처리합니다.</p>
</dd></dl>

<section id="request-objects">
<span id="id1"></span><h2>Request 객체<a class="headerlink" href="#request-objects" title="Link to this heading">¶</a></h2>
<p>다음 메서드는 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>의 공용 인터페이스를 설명하므로, 서브 클래스에서 모두 재정의될 수 있습니다. 또한 클라이언트가 구문 분석된 요청을 검사하는 데 사용할 수 있는 몇 가지 공용 어트리뷰트를 정의합니다.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.Request.full_url">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">full_url</span></span><a class="headerlink" href="#urllib.request.Request.full_url" title="Link to this definition">¶</a></dt>
<dd><p>생성자에 전달된 원래 URL.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경.</span></p>
</div>
<p>Request.full_url은 setter, getter 및 deleter가 있는 프로퍼티입니다. <a class="reference internal" href="#urllib.request.Request.full_url" title="urllib.request.Request.full_url"><code class="xref py py-attr docutils literal notranslate"><span class="pre">full_url</span></code></a>을 읽으면 프래그먼트가 있는 원래 요청 URL을 반환합니다 (있다면).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.Request.type">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">type</span></span><a class="headerlink" href="#urllib.request.Request.type" title="Link to this definition">¶</a></dt>
<dd><p>URI 스킴.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.Request.host">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">host</span></span><a class="headerlink" href="#urllib.request.Request.host" title="Link to this definition">¶</a></dt>
<dd><p>URI 주체(authority), 일반적으로 호스트이지만 콜론으로 구분된 포트를 포함할 수도 있습니다.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.Request.origin_req_host">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">origin_req_host</span></span><a class="headerlink" href="#urllib.request.Request.origin_req_host" title="Link to this definition">¶</a></dt>
<dd><p>포트가 없는, 요청의 원래 호스트.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.Request.selector">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">selector</span></span><a class="headerlink" href="#urllib.request.Request.selector" title="Link to this definition">¶</a></dt>
<dd><p>URI 경로. <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>가 프락시를 사용하면, selector는 프락시로 전달되는 전체 URL이 됩니다.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.Request.data">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">data</span></span><a class="headerlink" href="#urllib.request.Request.data" title="Link to this definition">¶</a></dt>
<dd><p>요청의 엔티티 바디, 또는 지정되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="#urllib.request.Request.data" title="urllib.request.Request.data"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.data</span></code></a>의 값을 변경하면 이제 “Content-Length” 헤더가 이전에 설정되거나 계산되었다면 삭제됩니다.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.Request.unverifiable">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">unverifiable</span></span><a class="headerlink" href="#urllib.request.Request.unverifiable" title="Link to this definition">¶</a></dt>
<dd><p>불리언, <span class="target" id="index-25"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2965.html"><strong>RFC 2965</strong></a>에서 정의한 대로 요청을 확인할 수 없는지를 나타냅니다.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.Request.method">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">method</span></span><a class="headerlink" href="#urllib.request.Request.method" title="Link to this definition">¶</a></dt>
<dd><p>사용할 HTTP 요청 메서드. 기본적으로 값은 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>입니다. 이는 <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a>가 사용될 메서드의 일반적인 계산을 수행함을 뜻합니다. <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 서브 클래스의 클래스 수준에서 값을 설정해서 기본값을 제공하거나, <em>method</em> 인자를 통해 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 생성자에 값을 전달하여 값을 설정할 수 있습니다 (그래서 <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a>의 기본 계산을 무시합니다).</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>서브 클래스에서 이제 기본값을 설정할 수 있습니다; 이전에는 생성자 인자를 통해서만 설정할 수 있었습니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.get_method">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">get_method</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_method" title="Link to this definition">¶</a></dt>
<dd><p>HTTP 요청 메서드를 나타내는 문자열을 반환합니다. <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면, 그 값을 반환하고, 그렇지 않으면 <a class="reference internal" href="#urllib.request.Request.data" title="urllib.request.Request.data"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.data</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면 <code class="docutils literal notranslate"><span class="pre">'GET'</span></code>을 반환하거나 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">'POST'</span></code>를 반환합니다. 이것은 HTTP 요청에만 의미가 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>get_method는 이제 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a>의 값을 조사합니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.add_header">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">add_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.add_header" title="Link to this definition">¶</a></dt>
<dd><p>Add another header to the request.  Headers are currently ignored by all
handlers except HTTP handlers, where they are added to the list of headers sent
to the server.  Note that there cannot be more than one header with the same
name, and later calls will overwrite previous calls in case the <em>key</em> collides.
Currently, this is no loss of HTTP functionality, since all headers which have
meaning when used more than once have a (header-specific) way of gaining the
same functionality using only one header.  Note that headers added using
this method are also added to redirected requests.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.add_unredirected_header">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">add_unredirected_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.add_unredirected_header" title="Link to this definition">¶</a></dt>
<dd><p>리디렉션 된 요청에 추가되지 않을 헤더를 추가합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.has_header">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">has_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">header</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.has_header" title="Link to this definition">¶</a></dt>
<dd><p>인스턴스에 명명된 헤더가 있는지를 반환합니다 (일반과 리디렉션되지 않는 것을 모두 확인합니다).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.remove_header">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">remove_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">header</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.remove_header" title="Link to this definition">¶</a></dt>
<dd><p>요청 인스턴스에서 명명된 헤더를 제거합니다 (일반과 리디렉션되지 않은 헤더 모두).</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.get_full_url">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">get_full_url</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_full_url" title="Link to this definition">¶</a></dt>
<dd><p>생성자에 제공된 URL을 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경.</span></p>
</div>
<p><a class="reference internal" href="#urllib.request.Request.full_url" title="urllib.request.Request.full_url"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.full_url</span></code></a>을 반환합니다</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.set_proxy">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">set_proxy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.set_proxy" title="Link to this definition">¶</a></dt>
<dd><p>프락시 서버에 연결하여 요청을 준비합니다. <em>host</em>와 <em>type</em>은 인스턴스의 것을 대체하고, 인스턴스의 selector는 생성자에 제공된 원래 URL이 됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.get_header">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">get_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">header_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_header" title="Link to this definition">¶</a></dt>
<dd><p>지정된 헤더의 값을 반환합니다. 헤더가 없으면, default 값을 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.Request.header_items">
<span class="sig-prename descclassname"><span class="pre">Request.</span></span><span class="sig-name descname"><span class="pre">header_items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.header_items" title="Link to this definition">¶</a></dt>
<dd><p>요청 헤더의 튜플 (header_name, header_value) 리스트를 반환합니다.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>3.3부터 폐지된 add_data, has_data, get_data, get_type, get_host, get_selector, get_origin_req_host 및 is_unverifiable 요청 메서드가 제거되었습니다.</p>
</div>
</section>
<section id="openerdirector-objects">
<span id="opener-director-objects"></span><h2>OpenerDirector 객체<a class="headerlink" href="#openerdirector-objects" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 인스턴스에는 다음과 같은 메서드가 있습니다:</p>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.OpenerDirector.add_handler">
<span class="sig-prename descclassname"><span class="pre">OpenerDirector.</span></span><span class="sig-name descname"><span class="pre">add_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handler</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.add_handler" title="Link to this definition">¶</a></dt>
<dd><p><em>handler</em>는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>의 인스턴스여야 합니다. 다음 메서드가 검색되어, 가능한 체인에 추가됩니다 (HTTP 에러는 특별한 경우임에 유의하십시오). 다음에서 <em>protocol</em>은 처리할 실제 프로토콜로 바꿔야 합니다, 예를 들어 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_response()</span></code>는 HTTP 프로토콜 응답 처리기입니다. 또한 <em>type</em>은 실제 HTTP 코드로 대체해야 합니다, 예를 들어 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_404()</span></code>는 HTTP 404 에러를 처리합니다.</p>
<ul>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code> — signal that the handler knows how to open <em>protocol</em>
URLs.</p>
<p>자세한 정보는 <a class="reference internal" href="#protocol-open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_open()</span></code></a>을 참조하십시오.</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code> — signal that the handler knows how to handle HTTP
errors with HTTP error code <em>type</em>.</p>
<p>자세한 정보는 <a class="reference internal" href="#http-error-nnn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.http_error_&lt;nnn&gt;()</span></code></a>을 참조하십시오.</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_error()</span></code> — signal that the handler knows how to handle errors
from (non-<code class="docutils literal notranslate"><span class="pre">http</span></code>) <em>protocol</em>.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_request()</span></code> — signal that the handler knows how to pre-process
<em>protocol</em> requests.</p>
<p>자세한 정보는 <a class="reference internal" href="#protocol-request"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_request()</span></code></a>를 참조하십시오.</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_response()</span></code> — signal that the handler knows how to
post-process <em>protocol</em> responses.</p>
<p>자세한 정보는 <a class="reference internal" href="#protocol-response"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_response()</span></code></a>를 참조하십시오.</p>
</li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.OpenerDirector.open">
<span class="sig-prename descclassname"><span class="pre">OpenerDirector.</span></span><span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.open" title="Link to this definition">¶</a></dt>
<dd><p>Open the given <em>url</em> (which can be a request object or a string), optionally
passing the given <em>data</em>. Arguments, return values and exceptions raised are
the same as those of <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> (which simply calls the <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a>
method on the currently installed global <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>).  The
optional <em>timeout</em> parameter specifies a timeout in seconds for blocking
operations like the connection attempt (if not specified, the global default
timeout setting will be used). The timeout feature actually works only for
HTTP, HTTPS and FTP connections.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.OpenerDirector.error">
<span class="sig-prename descclassname"><span class="pre">OpenerDirector.</span></span><span class="sig-name descname"><span class="pre">error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proto</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.error" title="Link to this definition">¶</a></dt>
<dd><p>Handle an error of the given protocol.  This will call the registered error
handlers for the given protocol with the given arguments (which are protocol
specific).  The HTTP protocol is a special case which uses the HTTP response
code to determine the specific error handler; refer to the <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code>
methods of the handler classes.</p>
<p>반환 값과 발생하는 예외는 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>과 같습니다.</p>
</dd></dl>

<p>OpenerDirector 객체는 다음 3단계로 URL을 엽니다:</p>
<p>각 단계에서 이러한 메서드가 호출되는 순서는 처리기 인스턴스를 정렬하여 결정됩니다.</p>
<ol class="arabic">
<li><p>Every handler with a method named like <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_request()</span></code> has that
method called to pre-process the request.</p></li>
<li><p>Handlers with a method named like <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code> are called to handle
the request. This stage ends when a handler either returns a non-<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>
value (ie. a response), or raises an exception (usually
<a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>).  Exceptions are allowed to propagate.</p>
<p>In fact, the above algorithm is first tried for methods named
<a class="reference internal" href="#urllib.request.BaseHandler.default_open" title="urllib.request.BaseHandler.default_open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code></a>.  If all such methods return <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, the algorithm
is repeated for methods named like <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code>.  If all such methods
return <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, the algorithm is repeated for methods named
<a class="reference internal" href="#urllib.request.BaseHandler.unknown_open" title="urllib.request.BaseHandler.unknown_open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unknown_open()</span></code></a>.</p>
<p>이러한 메서드의 구현은 부모 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 인스턴스의 <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a>과 <a class="reference internal" href="#urllib.request.OpenerDirector.error" title="urllib.request.OpenerDirector.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error()</span></code></a> 메서드의 호출을 수반할 수 있음에 유의하십시오.</p>
</li>
<li><p>Every handler with a method named like <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_response()</span></code> has that
method called to post-process the response.</p></li>
</ol>
</section>
<section id="basehandler-objects">
<span id="base-handler-objects"></span><h2>BaseHandler 객체<a class="headerlink" href="#basehandler-objects" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 객체는 직접적으로 유용한 몇 가지 메서드와 파생 클래스에서 사용하기 위한 다른 메서드를 제공합니다. 다음은 직접 사용하기 위한 것입니다:</p>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.BaseHandler.add_parent">
<span class="sig-prename descclassname"><span class="pre">BaseHandler.</span></span><span class="sig-name descname"><span class="pre">add_parent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">director</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.add_parent" title="Link to this definition">¶</a></dt>
<dd><p>director를 부모로 추가합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.BaseHandler.close">
<span class="sig-prename descclassname"><span class="pre">BaseHandler.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.close" title="Link to this definition">¶</a></dt>
<dd><p>모든 부모를 제거합니다.</p>
</dd></dl>

<p>다음 어트리뷰트와 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>에서 파생된 클래스에서만 사용해야 합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>The convention has been adopted that subclasses defining
<code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_request()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_response()</span></code> methods are named
<code class="xref py py-class docutils literal notranslate"><span class="pre">*Processor</span></code>; all others are named <code class="xref py py-class docutils literal notranslate"><span class="pre">*Handler</span></code>.</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.BaseHandler.parent">
<span class="sig-prename descclassname"><span class="pre">BaseHandler.</span></span><span class="sig-name descname"><span class="pre">parent</span></span><a class="headerlink" href="#urllib.request.BaseHandler.parent" title="Link to this definition">¶</a></dt>
<dd><p>다른 프로토콜을 사용하여 열거나 에러를 처리하는 데 사용할 수 있는 유효한 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.BaseHandler.default_open">
<span class="sig-prename descclassname"><span class="pre">BaseHandler.</span></span><span class="sig-name descname"><span class="pre">default_open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.default_open" title="Link to this definition">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>에 정의되지 <em>않았지만</em>, 서브 클래스가 모든 URL을 포착하려면 이를 정의해야 합니다.</p>
<p>This method, if implemented, will be called by the parent
<a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>.  It should return a file-like object as described in
the return value of the <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> method of <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>, or <code class="docutils literal notranslate"><span class="pre">None</span></code>.
It should raise <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>, unless a truly exceptional
thing happens (for example, <a class="reference internal" href="exceptions.html#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MemoryError</span></code></a> should not be mapped to
<a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>).</p>
<p>이 메서드는 프로토콜별 open 메서드보다 먼저 호출됩니다.</p>
</dd></dl>

<dl class="py method" id="protocol-open">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BaseHandler.&lt;protocol&gt;_open(req)</span></span></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되지 <em>않았지만</em>, 서브 클래스가 주어진 프로토콜로 URL을 처리하려면 이를 정의해야 합니다.</p>
<p>This method, if defined, will be called by the parent <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>.
Return values should be the same as for  <a class="reference internal" href="#urllib.request.BaseHandler.default_open" title="urllib.request.BaseHandler.default_open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.BaseHandler.unknown_open">
<span class="sig-prename descclassname"><span class="pre">BaseHandler.</span></span><span class="sig-name descname"><span class="pre">unknown_open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.unknown_open" title="Link to this definition">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되지 <em>않았지만</em>, 서브 클래스는 등록된 특정 처리기가 없는 모든 URL을 잡아서 열려면 이를 정의해야 합니다.</p>
<p>구현되면, 이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler.parent" title="urllib.request.BaseHandler.parent"><code class="xref py py-attr docutils literal notranslate"><span class="pre">parent</span></code></a> <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 호출됩니다. 반환 값은 <a class="reference internal" href="#urllib.request.BaseHandler.default_open" title="urllib.request.BaseHandler.default_open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code></a>과 같아야 합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.BaseHandler.http_error_default">
<span class="sig-prename descclassname"><span class="pre">BaseHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_default</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.http_error_default" title="Link to this definition">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되지 <em>않았지만</em>, 서브 클래스는 달리 처리되지 않은 HTTP 에러에 대해 포괄적인 처리를 제공하려면 이를 재정의해야 합니다. 에러가 발생하는 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 자동으로 호출되며, 다른 상황에서는 일반적으로 호출되지 않아야 합니다.</p>
<p><em>req</em>는 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체, <em>fp</em>는 HTTP 에러 바디가 있는 파일류 객체, <em>code</em>는 에러의 3자리 코드, <em>msg</em>는 사용자가 볼 수 있는 코드 설명, <em>hdrs</em>는 에러의 헤더가 있는 매핑 객체가 됩니다.</p>
<p>반환 값과 발생하는 예외는 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>의 것과 같아야 합니다.</p>
</dd></dl>

<dl class="py method" id="http-error-nnn">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BaseHandler.http_error_&lt;nnn&gt;(req,</span> <span class="pre">fp,</span> <span class="pre">code,</span> <span class="pre">msg,</span> <span class="pre">hdrs)</span></span></dt>
<dd><p><em>nnn</em>은 3자리 HTTP 에러 코드여야 합니다. 이 메서드도 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되어 있지 않지만, 존재한다면 코드가 <em>nnn</em> 인 HTTP 에러가 발생할 때 서브 클래스의 인스턴스에 대해 호출됩니다.</p>
<p>특정 HTTP 에러를 처리하려면 서브 클래스가 이 메서드를 재정의해야 합니다.</p>
<p>Arguments, return values and exceptions raised should be the same as for
<a class="reference internal" href="#urllib.request.BaseHandler.http_error_default" title="urllib.request.BaseHandler.http_error_default"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_default()</span></code></a>.</p>
</dd></dl>

<dl class="py method" id="protocol-request">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BaseHandler.&lt;protocol&gt;_request(req)</span></span></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되지 <em>않았지만</em>, 서브 클래스는 주어진 프로토콜의 요청을 전처리하려면 이를 정의해야 합니다.</p>
<p>정의되면, 이 메서드는 부모 상위 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 호출됩니다. <em>req</em>는 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체가 됩니다. 반환 값은 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체여야 합니다.</p>
</dd></dl>

<dl class="py method" id="protocol-response">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BaseHandler.&lt;protocol&gt;_response(req,</span> <span class="pre">response)</span></span></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되지 <em>않았지만</em>, 서브 클래스는 주어진 프로토콜의 응답을 후처리하려면 이를 정의해야 합니다.</p>
<p>정의되면, 이 메서드는 부모 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 호출됩니다. <em>req</em>는 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체가 됩니다. <em>response</em>는 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>의 반환 값과 같은 인터페이스를 구현하는 객체가 됩니다. 반환 값은 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>의 반환 값과 같은 인터페이스를 구현해야 합니다.</p>
</dd></dl>

</section>
<section id="httpredirecthandler-objects">
<span id="http-redirect-handler"></span><h2>HTTPRedirectHandler 객체<a class="headerlink" href="#httpredirecthandler-objects" title="Link to this heading">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>일부 HTTP 리디렉션은 이 모듈의 클라이언트 코드로부터의 액션을 요구합니다. 이 경우, <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a>가 발생합니다. 다양한 리디렉션 코드의 정확한 의미에 대한 자세한 내용은 <span class="target" id="index-26"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2616.html"><strong>RFC 2616</strong></a>을 참조하십시오.</p>
<p>An <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> exception raised as a security consideration if the
HTTPRedirectHandler is presented with a redirected URL which is not an HTTP,
HTTPS or FTP URL.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPRedirectHandler.redirect_request">
<span class="sig-prename descclassname"><span class="pre">HTTPRedirectHandler.</span></span><span class="sig-name descname"><span class="pre">redirect_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">newurl</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.redirect_request" title="Link to this definition">¶</a></dt>
<dd><p>Return a <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> or <code class="docutils literal notranslate"><span class="pre">None</span></code> in response to a redirect. This is called
by the default implementations of the <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_30*()</span></code> methods when a
redirection is received from the server.  If a redirection should take place,
return a new <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> to allow <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_30*()</span></code> to perform the
redirect to <em>newurl</em>.  Otherwise, raise <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> if
no other handler should try to handle this URL, or return <code class="docutils literal notranslate"><span class="pre">None</span></code> if you
can’t but another handler might.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 메서드의 기본 구현은 <span class="target" id="index-27"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2616.html"><strong>RFC 2616</strong></a>을 엄격하게 따르지 않습니다. 즉, <code class="docutils literal notranslate"><span class="pre">POST</span></code> 요청에 대한 301과 302 응답은 사용자의 확인 없이 자동으로 리디렉션 되지 않아야 합니다. 실제로는, 브라우저들이 POST를 <code class="docutils literal notranslate"><span class="pre">GET</span></code>으로 변경하여 이러한 응답의 자동 리디렉션을 허용하며, 기본 구현은 이 동작을 재현합니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPRedirectHandler.http_error_301">
<span class="sig-prename descclassname"><span class="pre">HTTPRedirectHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_301</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Location:</span></code>이나 <code class="docutils literal notranslate"><span class="pre">URI:</span></code> URL로 리디렉션 합니다. 이 메서드는 HTTP ‘moved permanently(영구적으로 이전했음)’ 응답을 받을 때 부모 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 호출됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPRedirectHandler.http_error_302">
<span class="sig-prename descclassname"><span class="pre">HTTPRedirectHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_302</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_302" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a>과 같지만, ‘found(발견됨)’ 응답에 대해 호출됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPRedirectHandler.http_error_303">
<span class="sig-prename descclassname"><span class="pre">HTTPRedirectHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_303</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_303" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a>과 같지만, ‘see other(다른 곳을 보세요)’ 응답에 대해 호출됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPRedirectHandler.http_error_307">
<span class="sig-prename descclassname"><span class="pre">HTTPRedirectHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_307</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_307" title="Link to this definition">¶</a></dt>
<dd><p>The same as <a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a>, but called for the ‘temporary redirect’
response. It does not allow changing the request method from <code class="docutils literal notranslate"><span class="pre">POST</span></code>
to <code class="docutils literal notranslate"><span class="pre">GET</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPRedirectHandler.http_error_308">
<span class="sig-prename descclassname"><span class="pre">HTTPRedirectHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_308</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_308" title="Link to this definition">¶</a></dt>
<dd><p>The same as <a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a>, but called for the ‘permanent redirect’
response. It does not allow changing the request method from <code class="docutils literal notranslate"><span class="pre">POST</span></code>
to <code class="docutils literal notranslate"><span class="pre">GET</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

</section>
<section id="httpcookieprocessor-objects">
<span id="http-cookie-processor"></span><h2>HTTPCookieProcessor 객체<a class="headerlink" href="#httpcookieprocessor-objects" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.HTTPCookieProcessor" title="urllib.request.HTTPCookieProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPCookieProcessor</span></code></a> 인스턴스에는 하나의 어트리뷰트가 있습니다:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.HTTPCookieProcessor.cookiejar">
<span class="sig-prename descclassname"><span class="pre">HTTPCookieProcessor.</span></span><span class="sig-name descname"><span class="pre">cookiejar</span></span><a class="headerlink" href="#urllib.request.HTTPCookieProcessor.cookiejar" title="Link to this definition">¶</a></dt>
<dd><p>쿠키가 저장되는 <a class="reference internal" href="http.cookiejar.html#http.cookiejar.CookieJar" title="http.cookiejar.CookieJar"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.cookiejar.CookieJar</span></code></a>.</p>
</dd></dl>

</section>
<section id="proxyhandler-objects">
<span id="proxy-handler"></span><h2>ProxyHandler 객체<a class="headerlink" href="#proxyhandler-objects" title="Link to this heading">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProxyHandler.&lt;protocol&gt;_open(request)</span></span></dt>
<dd><p>The <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> will have a method <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code> for every
<em>protocol</em> which has a proxy in the <em>proxies</em> dictionary given in the
constructor.  The method will modify requests to go through the proxy, by
calling <code class="docutils literal notranslate"><span class="pre">request.set_proxy()</span></code>, and call the next handler in the chain to
actually execute the protocol.</p>
</dd></dl>

</section>
<section id="httppasswordmgr-objects">
<span id="http-password-mgr"></span><h2>HTTPPasswordMgr 객체<a class="headerlink" href="#httppasswordmgr-objects" title="Link to this heading">¶</a></h2>
<p>이 메서드는 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> 객체에서 사용 가능합니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgr.add_password">
<span class="sig-prename descclassname"><span class="pre">HTTPPasswordMgr.</span></span><span class="sig-name descname"><span class="pre">add_password</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">realm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uri</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">user</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">passwd</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgr.add_password" title="Link to this definition">¶</a></dt>
<dd><p><em>uri</em>는 단일 URI이거나 URI의 시퀀스일 수 있습니다. <em>realm</em>, <em>user</em> 및 <em>passwd</em>는 문자열이어야 합니다. 이는 <em>realm</em>과 지정된 URI 중 어느 하나의 슈퍼 URI에 대한 인증이 주어질 때 <code class="docutils literal notranslate"><span class="pre">(user,</span> <span class="pre">passwd)</span></code>가 인증 토큰으로 사용되도록 합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgr.find_user_password">
<span class="sig-prename descclassname"><span class="pre">HTTPPasswordMgr.</span></span><span class="sig-name descname"><span class="pre">find_user_password</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">realm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">authuri</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgr.find_user_password" title="Link to this definition">¶</a></dt>
<dd><p>주어진 realm과 URI에 대한 사용자/암호를 (있다면) 가져옵니다. 일치하는 사용자/암호가 없으면 이 메서드는 <code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">None)</span></code>을 반환합니다.</p>
<p><a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> 객체의 경우, 주어진 <em>realm</em>에 일치하는 사용자/암호가 없으면 영역 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 검색됩니다.</p>
</dd></dl>

</section>
<section id="httppasswordmgrwithpriorauth-objects">
<span id="http-password-mgr-with-prior-auth"></span><h2>HTTPPasswordMgrWithPriorAuth 객체<a class="headerlink" href="#httppasswordmgrwithpriorauth-objects" title="Link to this heading">¶</a></h2>
<p>이 암호 관리자는 <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a>를 확장하여 인증 자격 증명을 항상 보내야 하는 URI를 추적하는 것을 지원합니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgrWithPriorAuth.add_password">
<span class="sig-prename descclassname"><span class="pre">HTTPPasswordMgrWithPriorAuth.</span></span><span class="sig-name descname"><span class="pre">add_password</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">realm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uri</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">user</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">passwd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_authenticated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.add_password" title="Link to this definition">¶</a></dt>
<dd><p><em>realm</em>, <em>uri</em>, <em>user</em>, <em>passwd</em>는 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr.add_password" title="urllib.request.HTTPPasswordMgr.add_password"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HTTPPasswordMgr.add_password()</span></code></a>와 같습니다. <em>is_authenticated</em>는 주어진 URI나 URI 리스트에 대한 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 플래그의 초깃값을 설정합니다. <em>is_authenticated</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 지정되면, <em>realm</em>는 무시됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgrWithPriorAuth.find_user_password">
<span class="sig-prename descclassname"><span class="pre">HTTPPasswordMgrWithPriorAuth.</span></span><span class="sig-name descname"><span class="pre">find_user_password</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">realm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">authuri</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.find_user_password" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> 객체와 같습니다</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgrWithPriorAuth.update_authenticated">
<span class="sig-prename descclassname"><span class="pre">HTTPPasswordMgrWithPriorAuth.</span></span><span class="sig-name descname"><span class="pre">update_authenticated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uri</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_authenticated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.update_authenticated" title="Link to this definition">¶</a></dt>
<dd><p>주어진 <em>uri</em>나 URI 리스트에 대해 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 플래그를 갱신합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPPasswordMgrWithPriorAuth.is_authenticated">
<span class="sig-prename descclassname"><span class="pre">HTTPPasswordMgrWithPriorAuth.</span></span><span class="sig-name descname"><span class="pre">is_authenticated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">authuri</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.is_authenticated" title="Link to this definition">¶</a></dt>
<dd><p>주어진 URI에 대한 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 플래그의 현재 상태를 반환합니다.</p>
</dd></dl>

</section>
<section id="abstractbasicauthhandler-objects">
<span id="abstract-basic-auth-handler"></span><h2>AbstractBasicAuthHandler 객체<a class="headerlink" href="#abstractbasicauthhandler-objects" title="Link to this heading">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed">
<span class="sig-prename descclassname"><span class="pre">AbstractBasicAuthHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_auth_reqed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">authreq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">headers</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed" title="Link to this definition">¶</a></dt>
<dd><p>사용자/암호 쌍을 가져오고 요청을 다시 시도하여 인증 요청을 처리합니다. <em>authreq</em>는 영역(realm)에 대한 정보가 요청에 포함된 헤더의 이름이어야 하고, <em>host</em>는 인증할 URL과 경로를 지정하고, <em>req</em>는 (실패한) <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체여야 하며, <em>headers</em>는 에러 헤더여야 합니다.</p>
<p><em>host</em>는 주체(예를 들어 <code class="docutils literal notranslate"><span class="pre">&quot;python.org&quot;</span></code>)거나 주체 구성 요소를 포함하는 URL(예를 들어 <code class="docutils literal notranslate"><span class="pre">&quot;http://python.org/&quot;</span></code>)입니다. 어느 경우이든, 주체는 userinfo 구성 요소를 포함하지 않아야 합니다 (따라서, <code class="docutils literal notranslate"><span class="pre">&quot;python.org&quot;</span></code>와 <code class="docutils literal notranslate"><span class="pre">&quot;python.org:80&quot;</span></code>은 좋지만, <code class="docutils literal notranslate"><span class="pre">&quot;joe:password&#64;python.org&quot;</span></code>는 유효하지 않습니다).</p>
</dd></dl>

</section>
<section id="httpbasicauthhandler-objects">
<span id="http-basic-auth-handler"></span><h2>HTTPBasicAuthHandler 객체<a class="headerlink" href="#httpbasicauthhandler-objects" title="Link to this heading">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPBasicAuthHandler.http_error_401">
<span class="sig-prename descclassname"><span class="pre">HTTPBasicAuthHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_401</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPBasicAuthHandler.http_error_401" title="Link to this definition">¶</a></dt>
<dd><p>가능하다면 인증 정보로 요청을 재시도합니다.</p>
</dd></dl>

</section>
<section id="proxybasicauthhandler-objects">
<span id="proxy-basic-auth-handler"></span><h2>ProxyBasicAuthHandler 객체<a class="headerlink" href="#proxybasicauthhandler-objects" title="Link to this heading">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.ProxyBasicAuthHandler.http_error_407">
<span class="sig-prename descclassname"><span class="pre">ProxyBasicAuthHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_407</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyBasicAuthHandler.http_error_407" title="Link to this definition">¶</a></dt>
<dd><p>가능하다면 인증 정보로 요청을 재시도합니다.</p>
</dd></dl>

</section>
<section id="abstractdigestauthhandler-objects">
<span id="abstract-digest-auth-handler"></span><h2>AbstractDigestAuthHandler 객체<a class="headerlink" href="#abstractdigestauthhandler-objects" title="Link to this heading">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed">
<span class="sig-prename descclassname"><span class="pre">AbstractDigestAuthHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_auth_reqed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">authreq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">headers</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed" title="Link to this definition">¶</a></dt>
<dd><p><em>authreq</em>는 영역(realm)에 대한 정보가 요청에 포함된 헤더의 이름이어야 하고, <em>host</em>는 인증할 호스트여야 하고, <em>req</em>는 (실패한) <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체여야 하며, <em>headers</em>는 에러 헤더여야 합니다.</p>
</dd></dl>

</section>
<section id="httpdigestauthhandler-objects">
<span id="http-digest-auth-handler"></span><h2>HTTPDigestAuthHandler 객체<a class="headerlink" href="#httpdigestauthhandler-objects" title="Link to this heading">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPDigestAuthHandler.http_error_401">
<span class="sig-prename descclassname"><span class="pre">HTTPDigestAuthHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_401</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPDigestAuthHandler.http_error_401" title="Link to this definition">¶</a></dt>
<dd><p>가능하다면 인증 정보로 요청을 재시도합니다.</p>
</dd></dl>

</section>
<section id="proxydigestauthhandler-objects">
<span id="proxy-digest-auth-handler"></span><h2>ProxyDigestAuthHandler 객체<a class="headerlink" href="#proxydigestauthhandler-objects" title="Link to this heading">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.ProxyDigestAuthHandler.http_error_407">
<span class="sig-prename descclassname"><span class="pre">ProxyDigestAuthHandler.</span></span><span class="sig-name descname"><span class="pre">http_error_407</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hdrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyDigestAuthHandler.http_error_407" title="Link to this definition">¶</a></dt>
<dd><p>가능하다면 인증 정보로 요청을 재시도합니다.</p>
</dd></dl>

</section>
<section id="httphandler-objects">
<span id="http-handler-objects"></span><h2>HTTPHandler 객체<a class="headerlink" href="#httphandler-objects" title="Link to this heading">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPHandler.http_open">
<span class="sig-prename descclassname"><span class="pre">HTTPHandler.</span></span><span class="sig-name descname"><span class="pre">http_open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPHandler.http_open" title="Link to this definition">¶</a></dt>
<dd><p>HTTP 요청을 보냅니다. <code class="docutils literal notranslate"><span class="pre">req.has_data()</span></code>에 따라, GET이나 POST일 수 있습니다.</p>
</dd></dl>

</section>
<section id="httpshandler-objects">
<span id="https-handler-objects"></span><h2>HTTPSHandler 객체<a class="headerlink" href="#httpshandler-objects" title="Link to this heading">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPSHandler.https_open">
<span class="sig-prename descclassname"><span class="pre">HTTPSHandler.</span></span><span class="sig-name descname"><span class="pre">https_open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPSHandler.https_open" title="Link to this definition">¶</a></dt>
<dd><p>HTTPS 요청을 보냅니다. <code class="docutils literal notranslate"><span class="pre">req.has_data()</span></code>에 따라, GET이나 POST일 수 있습니다.</p>
</dd></dl>

</section>
<section id="filehandler-objects">
<span id="file-handler-objects"></span><h2>FileHandler 객체<a class="headerlink" href="#filehandler-objects" title="Link to this heading">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.FileHandler.file_open">
<span class="sig-prename descclassname"><span class="pre">FileHandler.</span></span><span class="sig-name descname"><span class="pre">file_open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FileHandler.file_open" title="Link to this definition">¶</a></dt>
<dd><p>호스트 이름이 없거나, 호스트 이름이 <code class="docutils literal notranslate"><span class="pre">'localhost'</span></code>인 경우 파일을 로컬에서 엽니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>이 메서드는 로컬 호스트 명에만 적용할 수 있습니다. 원격 호스트 이름이 제공되면, <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>가 발생합니다.</p>
</div>
</dd></dl>

</section>
<section id="datahandler-objects">
<span id="data-handler-objects"></span><h2>DataHandler 객체<a class="headerlink" href="#datahandler-objects" title="Link to this heading">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.DataHandler.data_open">
<span class="sig-prename descclassname"><span class="pre">DataHandler.</span></span><span class="sig-name descname"><span class="pre">data_open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.DataHandler.data_open" title="Link to this definition">¶</a></dt>
<dd><p>데이터 URL을 읽습니다. 이러한 종류의 URL에는 URL 자체에 인코딩된 콘텐츠가 포함됩니다. 데이터 URL 문법은 <span class="target" id="index-28"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2397.html"><strong>RFC 2397</strong></a>에 지정되어 있습니다. 이 구현은 base64로 인코딩된 데이터 URL의 공백을 무시하기 때문에 URL은 소스 파일과 관계없이 줄 넘김 될 수 있습니다. 그러나 일부 브라우저가 base64로 인코딩된 데이터 URL 끝에 패딩이 누락된 것에 대해 신경 쓰지 않지만, 이 구현은 이 경우 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

</section>
<section id="ftphandler-objects">
<span id="ftp-handler-objects"></span><h2>FTPHandler 객체<a class="headerlink" href="#ftphandler-objects" title="Link to this heading">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.FTPHandler.ftp_open">
<span class="sig-prename descclassname"><span class="pre">FTPHandler.</span></span><span class="sig-name descname"><span class="pre">ftp_open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">req</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FTPHandler.ftp_open" title="Link to this definition">¶</a></dt>
<dd><p><em>req</em>로 표시된 FTP 파일을 엽니다. 로그인은 항상 빈 사용자 이름과 암호로 수행됩니다.</p>
</dd></dl>

</section>
<section id="cacheftphandler-objects">
<span id="cacheftp-handler-objects"></span><h2>CacheFTPHandler 객체<a class="headerlink" href="#cacheftphandler-objects" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.CacheFTPHandler" title="urllib.request.CacheFTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">CacheFTPHandler</span></code></a> 객체는 다음과 같은 추가 메서드가 있는 <a class="reference internal" href="#urllib.request.FTPHandler" title="urllib.request.FTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FTPHandler</span></code></a> 객체입니다:</p>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.CacheFTPHandler.setTimeout">
<span class="sig-prename descclassname"><span class="pre">CacheFTPHandler.</span></span><span class="sig-name descname"><span class="pre">setTimeout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.CacheFTPHandler.setTimeout" title="Link to this definition">¶</a></dt>
<dd><p>연결 시간제한을 <em>t</em> 초로 설정합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.CacheFTPHandler.setMaxConns">
<span class="sig-prename descclassname"><span class="pre">CacheFTPHandler.</span></span><span class="sig-name descname"><span class="pre">setMaxConns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.CacheFTPHandler.setMaxConns" title="Link to this definition">¶</a></dt>
<dd><p>캐시 된 최대 연결 수를 <em>m</em>으로 설정합니다.</p>
</dd></dl>

</section>
<section id="unknownhandler-objects">
<span id="unknown-handler-objects"></span><h2>UnknownHandler 객체<a class="headerlink" href="#unknownhandler-objects" title="Link to this heading">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.UnknownHandler.unknown_open">
<span class="sig-prename descclassname"><span class="pre">UnknownHandler.</span></span><span class="sig-name descname"><span class="pre">unknown_open</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.UnknownHandler.unknown_open" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a> 예외를 발생시킵니다.</p>
</dd></dl>

</section>
<section id="httperrorprocessor-objects">
<span id="http-error-processor-objects"></span><h2>HTTPErrorProcessor 객체<a class="headerlink" href="#httperrorprocessor-objects" title="Link to this heading">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPErrorProcessor.http_response">
<span class="sig-prename descclassname"><span class="pre">HTTPErrorProcessor.</span></span><span class="sig-name descname"><span class="pre">http_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">request</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPErrorProcessor.http_response" title="Link to this definition">¶</a></dt>
<dd><p>HTTP 에러 응답을 처리합니다.</p>
<p>200 에러 코드의 경우, 응답 객체가 즉시 반환됩니다.</p>
<p>For non-200 error codes, this simply passes the job on to the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code> handler methods, via <a class="reference internal" href="#urllib.request.OpenerDirector.error" title="urllib.request.OpenerDirector.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.error()</span></code></a>.
Eventually, <a class="reference internal" href="#urllib.request.HTTPDefaultErrorHandler" title="urllib.request.HTTPDefaultErrorHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPDefaultErrorHandler</span></code></a> will raise an
<a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> if no other handler handles the error.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.HTTPErrorProcessor.https_response">
<span class="sig-prename descclassname"><span class="pre">HTTPErrorProcessor.</span></span><span class="sig-name descname"><span class="pre">https_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">request</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">response</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPErrorProcessor.https_response" title="Link to this definition">¶</a></dt>
<dd><p>HTTPS 에러 응답을 처리합니다.</p>
<p>동작은 <a class="reference internal" href="#urllib.request.HTTPErrorProcessor.http_response" title="urllib.request.HTTPErrorProcessor.http_response"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_response()</span></code></a>와 같습니다.</p>
</dd></dl>

</section>
<section id="examples">
<span id="urllib-request-examples"></span><h2>예<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h2>
<p>아래 예 외에도 <a class="reference internal" href="../howto/urllib2.html#urllib-howto"><span class="std std-ref">urllib 패키지를 사용하여 인터넷 리소스를 가져오는 방법</span></a>에는 더 많은 예가 나와 있습니다.</p>
<p>이 예제는 python.org 메인 페이지를 가져와서 첫 300바이트를 표시합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">300</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">b&#39;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n\n\n&lt;html</span>
<span class="go">xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n</span>
<span class="go">&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\n</span>
<span class="go">&lt;title&gt;Python Programming &#39;</span>
</pre></div>
</div>
<p>urlopen은 바이트열 객체를 반환함에 유의하십시오. 이는 urlopen이 HTTP 서버로부터 수신한 바이트 스트림의 인코딩을 자동으로 결정할 방법이 없기 때문입니다. 일반적으로, 프로그램은 일단 적절한 인코딩을 결정하거나 추측하면 반환된 바이트열 객체를 문자열로 디코딩합니다.</p>
<p>다음 W3C 문서 <a class="reference external" href="https://www.w3.org/International/O-charset">https://www.w3.org/International/O-charset</a>는 (X)HTML이나 XML 문서가 인코딩 정보를 지정할 수 있는 다양한 방법을 나열합니다.</p>
<p>python.org 웹 사이트는 메타 태그에 지정된 대로 <em>utf-8</em> 인코딩을 사용하므로, 바이트열 객체를 디코딩할 때도 이를 사용합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtm</span>
</pre></div>
</div>
<p><a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">컨텍스트 관리자</span></a> 방식을 사용하지 않고도 같은 결과를 얻을 수 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="go">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtm</span>
</pre></div>
</div>
<p>다음 예에서는, CGI의 표준 입력으로 데이터 스트림을 전송하고 반환되는 데이터를 읽습니다. 이 예제는 파이썬 설치가 SSL을 지원할 때만 작동함에 유의하십시오.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s1">&#39;https://localhost/cgi-bin/test.cgi&#39;</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">data</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;This data is passed to stdin of the CGI&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">Got Data: &quot;This data is passed to stdin of the CGI&quot;</span>
</pre></div>
</div>
<p>위 예제에서 사용한 샘플 CGI의 코드는 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Content-type: text/plain</span><span class="se">\n\n</span><span class="s1">Got Data: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>다음은 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>를 사용하여 <code class="docutils literal notranslate"><span class="pre">PUT</span></code> 요청을 수행하는 예입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">DATA</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;some data&#39;</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s1">&#39;http://localhost:8080&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">DATA</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;PUT&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">reason</span><span class="p">)</span>
</pre></div>
</div>
<p>기본 HTTP 인증 사용:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="c1"># Create an OpenerDirector with support for Basic HTTP Authentication...</span>
<span class="n">auth_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">HTTPBasicAuthHandler</span><span class="p">()</span>
<span class="n">auth_handler</span><span class="o">.</span><span class="n">add_password</span><span class="p">(</span><span class="n">realm</span><span class="o">=</span><span class="s1">&#39;PDQ Application&#39;</span><span class="p">,</span>
                          <span class="n">uri</span><span class="o">=</span><span class="s1">&#39;https://mahler:8092/site-updates.py&#39;</span><span class="p">,</span>
                          <span class="n">user</span><span class="o">=</span><span class="s1">&#39;klem&#39;</span><span class="p">,</span>
                          <span class="n">passwd</span><span class="o">=</span><span class="s1">&#39;kadidd!ehopper&#39;</span><span class="p">)</span>
<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">(</span><span class="n">auth_handler</span><span class="p">)</span>
<span class="c1"># ...and install it globally so it can be used with urlopen.</span>
<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">install_opener</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span>
<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/login.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#urllib.request.build_opener" title="urllib.request.build_opener"><code class="xref py py-func docutils literal notranslate"><span class="pre">build_opener()</span></code></a> provides many handlers by default, including a
<a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a>.  By default, <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> uses the environment
variables named <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;_proxy</span></code>, where <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;</span></code> is the URL scheme
involved.  For example, the <code class="xref std std-envvar docutils literal notranslate"><span class="pre">http_proxy</span></code> environment variable is read to
obtain the HTTP proxy’s URL.</p>
<p>This example replaces the default <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> with one that uses
programmatically supplied proxy URLs, and adds proxy authorization support with
<a class="reference internal" href="#urllib.request.ProxyBasicAuthHandler" title="urllib.request.ProxyBasicAuthHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyBasicAuthHandler</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">proxy_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">ProxyHandler</span><span class="p">({</span><span class="s1">&#39;http&#39;</span><span class="p">:</span> <span class="s1">&#39;http://www.example.com:3128/&#39;</span><span class="p">})</span>
<span class="n">proxy_auth_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">ProxyBasicAuthHandler</span><span class="p">()</span>
<span class="n">proxy_auth_handler</span><span class="o">.</span><span class="n">add_password</span><span class="p">(</span><span class="s1">&#39;realm&#39;</span><span class="p">,</span> <span class="s1">&#39;host&#39;</span><span class="p">,</span> <span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="s1">&#39;password&#39;</span><span class="p">)</span>

<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">(</span><span class="n">proxy_handler</span><span class="p">,</span> <span class="n">proxy_auth_handler</span><span class="p">)</span>
<span class="c1"># This time, rather than install the OpenerDirector, we use it directly:</span>
<span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/login.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>HTTP 헤더 추가하기:</p>
<p><a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 생성자에 <em>headers</em> 인자를 사용하십시오, 또는:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/&#39;</span><span class="p">)</span>
<span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Referer&#39;</span><span class="p">,</span> <span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span>
<span class="c1"># Customize the default User-Agent header value:</span>
<span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;User-Agent&#39;</span><span class="p">,</span> <span class="s1">&#39;urllib-example/0.1 (Contact: . . .)&#39;</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>는 모든 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>에 <em class="mailheader">User-Agent</em> 헤더를 자동으로 추가합니다. 이것을 바꾸려면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">()</span>
<span class="n">opener</span><span class="o">.</span><span class="n">addheaders</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;User-agent&#39;</span><span class="p">,</span> <span class="s1">&#39;Mozilla/5.0&#39;</span><span class="p">)]</span>
<span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>또한, <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>가 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>(또는 <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.open()</span></code></a>)으로 전달될 때 몇 가지 표준 헤더(<em class="mailheader">Content-Length</em>, <em class="mailheader">Content-Type</em> 및 <em class="mailheader">Host</em>)가 추가됨을 기억하십시오.</p>
<p id="urllib-examples">다음은 <code class="docutils literal notranslate"><span class="pre">GET</span></code> 메서드를 사용하여 파라미터가 포함된 URL을 가져오는 예제 세션입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">params</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;http://www.musi-cal.com/cgi-bin/query?</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">params</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>다음 예제는 대신 <code class="docutils literal notranslate"><span class="pre">POST</span></code> 메서드를 사용합니다. urlencode의 파라미터 출력이 데이터로 urlopen에 보내기 전에 바이트열로 인코딩됨에 유의하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s2">&quot;http://requestb.in/xrbl82xr&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>다음 예제는 명시적으로 지정된 HTTP 프락시를 사용하여 환경 설정을 대체합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proxies</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;http&#39;</span><span class="p">:</span> <span class="s1">&#39;http://proxy.example.com:8080/&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">FancyURLopener</span><span class="p">(</span><span class="n">proxies</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;http://www.python.org&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>다음 예제는 프락시를 전혀 사용하지 않도록 환경 설정을 대체합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">FancyURLopener</span><span class="p">({})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;http://www.python.org/&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
</section>
<section id="legacy-interface">
<h2>레거시 인터페이스<a class="headerlink" href="#legacy-interface" title="Link to this heading">¶</a></h2>
<p>다음 함수와 클래스는 파이썬 2 모듈 <code class="docutils literal notranslate"><span class="pre">urllib</span></code>(<code class="docutils literal notranslate"><span class="pre">urllib2</span></code>가 아니라)에서 이식됩니다. 나중에 언젠가 폐지될 수 있습니다.</p>
<dl class="py function">
<dt class="sig sig-object py" id="urllib.request.urlretrieve">
<span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">urlretrieve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reporthook</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlretrieve" title="Link to this definition">¶</a></dt>
<dd><p>Copy a network object denoted by a URL to a local file. If the URL
points to a local file, the object will not be copied unless filename is supplied.
Return a tuple <code class="docutils literal notranslate"><span class="pre">(filename,</span> <span class="pre">headers)</span></code> where <em>filename</em> is the
local file name under which the object can be found, and <em>headers</em> is whatever
the <code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code> method of the object returned by <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> returned (for
a remote object). Exceptions are the same as for <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>.</p>
<p>있다면, 두 번째 인자는 복사할 파일 위치를 지정합니다 (없으면, 위치는 생성된 이름을 가진 임시 파일이 됩니다). 있다면, 세 번째 인자는 네트워크 연결이 이루어질 때 한 번 호출되고 그 이후에 각 블록을 읽을 때마다 한 번씩 호출되는 콜러블입니다. 콜러블에는 세 개의 인자가 전달됩니다; 지금까지 전송된 블록 수, 바이트 단위의 블록 크기 및 파일의 전체 크기. 세 번째 인자는 가져오기 요청에 대한 응답으로 파일 크기를 반환하지 않는 구형 FTP 서버에서 <code class="docutils literal notranslate"><span class="pre">-1</span></code>일 수 있습니다.</p>
<p>다음 예는 가장 일반적인 사용 시나리오를 보여줍니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_filename</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlretrieve</span><span class="p">(</span><span class="s1">&#39;http://python.org/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">html</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">local_filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">html</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p><em>url</em>이 <code class="file docutils literal notranslate"><span class="pre">http:</span></code> 스킴 식별자를 사용하면, <code class="docutils literal notranslate"><span class="pre">POST</span></code> 요청을 지정하기 위해 선택적 <em>data</em> 인자가 제공될 수 있습니다 (일반적으로 요청형은 <code class="docutils literal notranslate"><span class="pre">GET</span></code>입니다). <em>data</em> 인자는 표준 <em class="mimetype">application/x-www-form-urlencoded</em> 형식의 바이트열 객체여야 합니다; <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 함수를 참조하십시오.</p>
<p><a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> will raise <a class="reference internal" href="urllib.error.html#urllib.error.ContentTooShortError" title="urllib.error.ContentTooShortError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ContentTooShortError</span></code></a> when it detects that
the amount of data available  was less than the expected amount (which is the
size reported by a  <em>Content-Length</em> header). This can occur, for example, when
the  download is interrupted.</p>
<p><em>Content-Length</em>는 하한값으로 취급됩니다: 읽을 데이터가 더 있으면, urlretrieve는 더 많은 데이터를 읽지만, 사용 가능한 데이터가 부족하면 예외가 발생합니다.</p>
<p>You can still retrieve the downloaded data in this case, it is stored in the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">content</span></code> attribute of the exception instance.</p>
<p><em>Content-Length</em> 헤더가 제공되지 않으면, urlretrieve는 다운로드 한 데이터의 크기를 확인할 수 없고, 그냥 반환합니다. 이 경우 다운로드가 성공했다고 가정해야 합니다.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.request.urlcleanup">
<span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">urlcleanup</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlcleanup" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a>에 대한 이전 호출로 남겨졌을 수 있는 임시 파일을 정리합니다.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.URLopener">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">URLopener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proxies</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">x509</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener" title="Link to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지됨.</span></p>
</div>
<p>URL을 열고 읽는 베이스 클래스. <code class="file docutils literal notranslate"><span class="pre">http:</span></code>, <code class="file docutils literal notranslate"><span class="pre">ftp:</span></code> 또는 <code class="file docutils literal notranslate"><span class="pre">file:</span></code> 이외의 스킴을 사용하여 객체 열기를 지원할 필요가 있지 않은 한, 아마도 <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a>를 사용하고 싶을 것입니다.</p>
<p>기본적으로, <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> 클래스는 <em class="mailheader">User-Agent</em> 헤더로 <code class="docutils literal notranslate"><span class="pre">urllib/VVV</span></code>를 전송합니다. 여기서 <em>VVV</em>는 <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> 버전 번호입니다. 응용 프로그램은 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a>나 <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a>를 서브 클래싱하고 클래스 어트리뷰트 <a class="reference internal" href="#urllib.request.URLopener.version" title="urllib.request.URLopener.version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">version</span></code></a>을 서브 클래스 정의에서 적절한 문자열 값으로 설정하여 자체 <em class="mailheader">User-Agent</em> 헤더를 정의할 수 있습니다.</p>
<p>선택적 <em>proxies</em> 매개 변수는 스킴 이름을 프락시 URL로 매핑하는 딕셔너리여야 합니다. 여기서 빈 딕셔너리는 프락시를 완전히 끕니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>이며, 이 경우 위의 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 정의에서 설명한 대로 환경 프락시 설정이 있으면 사용됩니다.</p>
<p><em>x509</em>로 수집된 추가 키워드 매개 변수는 <code class="file docutils literal notranslate"><span class="pre">https:</span></code> 스킴을 사용할 때 클라이언트의 인증에 사용될 수 있습니다. 키워드 <em>key_file</em>과 <em>cert_file</em>은 SSL 키와 인증서를 제공하기 위해 지원됩니다; 클라이언트 인증을 지원하려면 둘 다 필요합니다.</p>
<p>서버가 에러 코드를 반환하면 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> 객체는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 예외를 발생시킵니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.URLopener.open">
<span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullurl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.open" title="Link to this definition">¶</a></dt>
<dd><p>적절한 프로토콜을 사용하여 <em>fullurl</em>을 엽니다. 이 메서드는 캐시와 프락시 정보를 설정한 다음, 입력 인자로 적절한 open 메서드를 호출합니다. 스킴이 인식되지 않으면, <a class="reference internal" href="#urllib.request.URLopener.open_unknown" title="urllib.request.URLopener.open_unknown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open_unknown()</span></code></a>이 호출됩니다. <em>data</em> 인자는 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>의 <em>data</em> 인자와 같은 의미입니다.</p>
<p>이 메서드는 항상 <a class="reference internal" href="urllib.parse.html#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>를 사용하여 <em>fullurl</em>을 인용합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.URLopener.open_unknown">
<span class="sig-name descname"><span class="pre">open_unknown</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullurl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.open_unknown" title="Link to this definition">¶</a></dt>
<dd><p>알 수 없는 URL 유형을 여는 재정의 가능한 인터페이스.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.URLopener.retrieve">
<span class="sig-name descname"><span class="pre">retrieve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reporthook</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.retrieve" title="Link to this definition">¶</a></dt>
<dd><p><em>url</em>의 내용을 가져와서 <em>filename</em>에 배치합니다. 반환 값은 로컬 파일명과 응답 헤더를 포함하는 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.message.Message</span></code></a> 객체 (원격 URL의 경우) 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>(로컬 URL의 경우)으로 구성된 튜플입니다. 그러면 호출자는 <em>filename</em>의 내용을 열고 읽어야 합니다. <em>filename</em>이 제공되지 않고 URL이 로컬 파일을 참조하면, 입력 파일명이 반환됩니다. URL이 로컬이 아니고 <em>filename</em>이 제공되지 않으면, 파일 이름은 입력 URL의 마지막 경로 구성 요소의 접미사와 일치하는 접미사로 <a class="reference internal" href="tempfile.html#tempfile.mktemp" title="tempfile.mktemp"><code class="xref py py-func docutils literal notranslate"><span class="pre">tempfile.mktemp()</span></code></a> 한 출력입니다. <em>reporthook</em>이 제공되면, 세 개의 숫자 매개 변수를 받아들이는 함수여야 합니다: 청크 번호, 청크를 읽을 최대 크기 및 다운로드의 전체 크기 (알 수 없으면 -1). 처음에 한 번 호출되고 네트워크에서 각 데이터 청크를 읽은 후에 한 번씩 호출됩니다. 로컬 URL의 경우 <em>reporthook</em>은 무시됩니다.</p>
<p><em>url</em>이 <code class="file docutils literal notranslate"><span class="pre">http:</span></code> 스킴 식별자를 사용하면, <code class="docutils literal notranslate"><span class="pre">POST</span></code> 요청을 지정하기 위해 선택적 <em>data</em> 인자가 제공될 수 있습니다 (일반적으로 요청형은 <code class="docutils literal notranslate"><span class="pre">GET</span></code>입니다). <em>data</em> 인자는 표준 <em class="mimetype">application/x-www-form-urlencoded</em> 형식이어야 합니다; <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 함수를 참조하십시오.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.request.URLopener.version">
<span class="sig-name descname"><span class="pre">version</span></span><a class="headerlink" href="#urllib.request.URLopener.version" title="Link to this definition">¶</a></dt>
<dd><p>오프너 객체의 사용자 에이전트를 지정하는 변수. <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a>가 서버에 특정 사용자 에이전트임을 알리려면, 서브 클래스에서 클래스 변수로 설정하거나 생성자에서 베이스 생성자를 호출하기 전에 이를 설정하십시오.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.request.FancyURLopener">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.request.</span></span><span class="sig-name descname"><span class="pre">FancyURLopener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FancyURLopener" title="Link to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지됨.</span></p>
</div>
<p><a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a>는 다음 HTTP 응답 코드에 대한 기본 처리를 제공하는 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> 서브 클래스입니다: 301, 302, 303, 307 및 401. 위에 나열된 30x 응답 코드의 경우, 실제 URL을 가져오는 데 <em class="mailheader">Location</em> 헤더가 사용됩니다. 401 응답 코드(authentication required - 인증 필요)의 경우, 기본 HTTP 인증이 수행됩니다. 30x 응답 코드의 경우, 재귀는 <em>maxtries</em> 어트리뷰트 값에 의해 제한되며, 기본값은 10입니다.</p>
<p>For all other response codes, the method <a class="reference internal" href="#urllib.request.BaseHandler.http_error_default" title="urllib.request.BaseHandler.http_error_default"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_default()</span></code></a> is called
which you can override in subclasses to handle the error appropriately.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><span class="target" id="index-29"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2616.html"><strong>RFC 2616</strong></a>의 편지(letter)에 따르면, POST 요청에 대한 301과 302 응답은 사용자의 확인 없이 자동으로 리디렉션 되지 않아야 합니다. 실제로는, 브라우저들이 POST를 GET으로 변경하여 이러한 응답의 자동 리디렉션을 허용하고, <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a>는 이 동작을 재현합니다.</p>
</div>
<p>생성자의 매개 변수는 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a>의 매개 변수와 같습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>기본 인증을 수행할 때, <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> 인스턴스는 <a class="reference internal" href="#urllib.request.FancyURLopener.prompt_user_passwd" title="urllib.request.FancyURLopener.prompt_user_passwd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prompt_user_passwd()</span></code></a> 메서드를 호출합니다. 기본 구현은 사용자에게 제어 터미널에서 필요한 정보를 요청합니다. 필요하면 서브 클래스가 이 메서드를 재정의하여 더 적절한 동작을 지원할 수 있습니다.</p>
</div>
<p><a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> 클래스는 적절한 동작을 제공하기 위해 재정의되어야 하는 하나의 추가 메서드를 제공합니다:</p>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.request.FancyURLopener.prompt_user_passwd">
<span class="sig-name descname"><span class="pre">prompt_user_passwd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">realm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FancyURLopener.prompt_user_passwd" title="Link to this definition">¶</a></dt>
<dd><p>지정된 보안 영역(realm)의 지정된 호스트에서 사용자를 인증하는 데 필요한 정보를 반환합니다. 반환 값은 기본 인증에 사용될 수 있는 튜플 <code class="docutils literal notranslate"><span class="pre">(user,</span> <span class="pre">password)</span></code>여야 합니다.</p>
<p>구현은 터미널에서 이 정보를 요구합니다; 로컬 환경에서 적절한 상호 작용 모델을 사용하려면 응용 프로그램이 이 메서드를 재정의해야 합니다.</p>
</dd></dl>

</dd></dl>

</section>
<section id="urllib-request-restrictions">
<h2><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> 제약 사항<a class="headerlink" href="#urllib-request-restrictions" title="Link to this heading">¶</a></h2>
<ul id="index-9">
<li><p>현재, 다음과 같은 프로토콜만 지원됩니다: HTTP (버전 0.9와 1.0), FTP, 로컬 파일 및 데이터 URL.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>데이터 URL에 대한 지원이 추가되었습니다.</p>
</div>
</li>
<li><p><a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a>의 캐싱 기능은 누군가가 만료 시간 헤더의 적절한 처리를 해킹할 시간을 찾을 때까지 비활성화되었습니다.</p></li>
<li><p>특정 URL이 캐시에 있는지를 조회하는 함수가 있어야 합니다.</p></li>
<li><p>이전 버전과의 호환성을 위해, URL이 로컬 파일을 가리키는 것으로 보이지만 파일을 열 수 없으면, FTP 프로토콜을 사용하여 URL을 다시 해석합니다. 이로 인해 때때로 혼란스러운 에러 메시지가 발생할 수 있습니다.</p></li>
<li><p>The <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> and <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> functions can cause arbitrarily
long delays while waiting for a network connection to be set up.  This means
that it is difficult to build an interactive web client using these functions
without using threads.</p>
</li>
<li id="index-10"><p><a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>이나 <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a>가 반환한 데이터는 서버가 반환한 원시 데이터입니다. 바이너리 데이터 (가령 이미지), 평문 텍스트 또는 (예를 들어) HTML일 수 있습니다. HTTP 프로토콜은 응답 헤더에 유형 정보를 제공하는데, <em class="mailheader">Content-Type</em> 헤더를 통해 검사할 수 있습니다. 반환된 데이터가 HTML이면, <a class="reference internal" href="html.parser.html#module-html.parser" title="html.parser: A simple parser that can handle HTML and XHTML."><code class="xref py py-mod docutils literal notranslate"><span class="pre">html.parser</span></code></a> 모듈을 사용하여 구문 분석할 수 있습니다.</p>
</li>
<li id="index-11"><p>FTP 프로토콜을 처리하는 코드는 파일과 디렉터리를 구별할 수 없습니다. 이는 액세스 할 수 없는 파일을 가리키는 URL을 읽으려고 할 때 예기치 않은 동작을 일으킬 수 있습니다. URL이 <code class="docutils literal notranslate"><span class="pre">/</span></code>로 끝나면, 디렉터리를 참조하는 것으로 간주하고 그에 따라 처리됩니다. 그러나 파일을 읽으려는 시도가 550 에러를 일으키면 (URL을 찾을 수 없거나 액세스할 수 없다는 뜻인데, 종종 권한 문제입니다), URL이 디렉터리를 지정하지만, 후행 <code class="docutils literal notranslate"><span class="pre">/</span></code>를 붙이지 않은 경우를 처리하기 위해 경로가 디렉터리로 처리됩니다. 이는 읽기 권한이 액세스할 수 없도록 지정된 파일을 가져오려고 시도할 때 잘못된 결과를 만들 수 있도록 합니다; FTP 코드가 이를 읽으려고 시도하고, 550 에러로 실패한 다음, 읽을 수 없는 파일에 대해 디렉터리 리스팅을 수행합니다. 세밀한 제어가 필요하면, <a class="reference internal" href="ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a> 모듈 사용, <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> 서브 클래싱 또는 필요에 맞게 <em>_urlopener</em>를 변경하는 것을 고려하십시오.</p></li>
</ul>
</section>
</section>
<section id="module-urllib.response">
<span id="urllib-response-response-classes-used-by-urllib"></span><h1><a class="reference internal" href="#module-urllib.response" title="urllib.response: Response classes used by urllib."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code></a> — urllib가 사용하는 응답 클래스<a class="headerlink" href="#module-urllib.response" title="Link to this heading">¶</a></h1>
<p><a class="reference internal" href="#module-urllib.response" title="urllib.response: Response classes used by urllib."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code></a> 모듈은 <code class="docutils literal notranslate"><span class="pre">read()</span></code>와 <code class="docutils literal notranslate"><span class="pre">readline()</span></code>을 포함하여 최소한의 파일류 인터페이스를 정의하는 함수와 클래스를 정의합니다. 이 모듈에 의해 정의된 함수는 <a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> 모듈에 의해 내부적으로 사용됩니다. 일반적인 응답 객체는 <a class="reference internal" href="#urllib.response.addinfourl" title="urllib.response.addinfourl"><code class="xref py py-class docutils literal notranslate"><span class="pre">urllib.response.addinfourl</span></code></a> 인스턴스입니다:</p>
<dl class="py class">
<dt class="sig sig-object py" id="urllib.response.addinfourl">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.response.</span></span><span class="sig-name descname"><span class="pre">addinfourl</span></span><a class="headerlink" href="#urllib.response.addinfourl" title="Link to this definition">¶</a></dt>
<dd><dl class="py attribute">
<dt class="sig sig-object py" id="urllib.response.addinfourl.url">
<span class="sig-name descname"><span class="pre">url</span></span><a class="headerlink" href="#urllib.response.addinfourl.url" title="Link to this definition">¶</a></dt>
<dd><p>가져온 자원의 URL, 일반적으로 리디렉션을 따라갔는지 판별하는 데 사용됩니다.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.response.addinfourl.headers">
<span class="sig-name descname"><span class="pre">headers</span></span><a class="headerlink" href="#urllib.response.addinfourl.headers" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 인스턴스 형식으로 응답의 헤더를 반환합니다.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.response.addinfourl.status">
<span class="sig-name descname"><span class="pre">status</span></span><a class="headerlink" href="#urllib.response.addinfourl.status" title="Link to this definition">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
<p>서버가 반환한 상태 코드.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.response.addinfourl.geturl">
<span class="sig-name descname"><span class="pre">geturl</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.response.addinfourl.geturl" title="Link to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지됨: </span>폐지되었고 <a class="reference internal" href="#urllib.response.addinfourl.url" title="urllib.response.addinfourl.url"><code class="xref py py-attr docutils literal notranslate"><span class="pre">url</span></code></a>로 대체되었습니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.response.addinfourl.info">
<span class="sig-name descname"><span class="pre">info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.response.addinfourl.info" title="Link to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지됨: </span>폐지되었고 <a class="reference internal" href="#urllib.response.addinfourl.headers" title="urllib.response.addinfourl.headers"><code class="xref py py-attr docutils literal notranslate"><span class="pre">headers</span></code></a>로 대체되었습니다.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="urllib.response.addinfourl.code">
<span class="sig-name descname"><span class="pre">code</span></span><a class="headerlink" href="#urllib.response.addinfourl.code" title="Link to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지됨: </span>폐지되었고 <a class="reference internal" href="#urllib.response.addinfourl.status" title="urllib.response.addinfourl.status"><code class="xref py py-attr docutils literal notranslate"><span class="pre">status</span></code></a>로 대체되었습니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="urllib.response.addinfourl.getcode">
<span class="sig-name descname"><span class="pre">getcode</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.response.addinfourl.getcode" title="Link to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지됨: </span>폐지되었고 <a class="reference internal" href="#urllib.response.addinfourl.status" title="urllib.response.addinfourl.status"><code class="xref py py-attr docutils literal notranslate"><span class="pre">status</span></code></a>로 대체되었습니다.</p>
</div>
</dd></dl>

</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> — Extensible library for opening URLs</a><ul>
<li><a class="reference internal" href="#request-objects">Request 객체</a></li>
<li><a class="reference internal" href="#openerdirector-objects">OpenerDirector 객체</a></li>
<li><a class="reference internal" href="#basehandler-objects">BaseHandler 객체</a></li>
<li><a class="reference internal" href="#httpredirecthandler-objects">HTTPRedirectHandler 객체</a></li>
<li><a class="reference internal" href="#httpcookieprocessor-objects">HTTPCookieProcessor 객체</a></li>
<li><a class="reference internal" href="#proxyhandler-objects">ProxyHandler 객체</a></li>
<li><a class="reference internal" href="#httppasswordmgr-objects">HTTPPasswordMgr 객체</a></li>
<li><a class="reference internal" href="#httppasswordmgrwithpriorauth-objects">HTTPPasswordMgrWithPriorAuth 객체</a></li>
<li><a class="reference internal" href="#abstractbasicauthhandler-objects">AbstractBasicAuthHandler 객체</a></li>
<li><a class="reference internal" href="#httpbasicauthhandler-objects">HTTPBasicAuthHandler 객체</a></li>
<li><a class="reference internal" href="#proxybasicauthhandler-objects">ProxyBasicAuthHandler 객체</a></li>
<li><a class="reference internal" href="#abstractdigestauthhandler-objects">AbstractDigestAuthHandler 객체</a></li>
<li><a class="reference internal" href="#httpdigestauthhandler-objects">HTTPDigestAuthHandler 객체</a></li>
<li><a class="reference internal" href="#proxydigestauthhandler-objects">ProxyDigestAuthHandler 객체</a></li>
<li><a class="reference internal" href="#httphandler-objects">HTTPHandler 객체</a></li>
<li><a class="reference internal" href="#httpshandler-objects">HTTPSHandler 객체</a></li>
<li><a class="reference internal" href="#filehandler-objects">FileHandler 객체</a></li>
<li><a class="reference internal" href="#datahandler-objects">DataHandler 객체</a></li>
<li><a class="reference internal" href="#ftphandler-objects">FTPHandler 객체</a></li>
<li><a class="reference internal" href="#cacheftphandler-objects">CacheFTPHandler 객체</a></li>
<li><a class="reference internal" href="#unknownhandler-objects">UnknownHandler 객체</a></li>
<li><a class="reference internal" href="#httperrorprocessor-objects">HTTPErrorProcessor 객체</a></li>
<li><a class="reference internal" href="#examples">예</a></li>
<li><a class="reference internal" href="#legacy-interface">레거시 인터페이스</a></li>
<li><a class="reference internal" href="#urllib-request-restrictions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> 제약 사항</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-urllib.response"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code> — urllib가 사용하는 응답 클래스</a></li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="urllib.html"
                          title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code> — URL handling modules</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="urllib.parse.html"
                          title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code> — Parse URLs into components</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/urllib.request.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="사이드바 닫기">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="urllib.parse.html" title="urllib.parse — Parse URLs into components"
             >다음</a> |</li>
        <li class="right" >
          <a href="urllib.html" title="urllib — URL handling modules"
             >이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >인터넷 프로토콜과 지원</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> — Extensible library for opening URLs</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    저작권
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="/license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      최종 업데이트: Jun 09, 2024 (17:23 UTC)
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br />

    <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7 버전으로 생성되었습니다.
    </div>

    <script type="text/javascript" src="../_static/switchers.js"></script>
  </body>
</html>