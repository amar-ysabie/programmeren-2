<!DOCTYPE html>

<html lang="ko" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="코루틴과 태스크" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/asyncio-task.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="이 절에서는 코루틴과 태스크로 작업하기 위한 고급 asyncio API에 관해 설명합니다. 코루틴, 어웨이터블, 태스크 만들기, Task Cancellation, Task Groups, 잠자기, 동시에 태스크 실행하기, Eager Task Factory, 취소로부터 보호하기, 시간제한, 대기 프리미티브, 스레드에서 실행하기, 다른 스레드에서 예약하기,..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="이 절에서는 코루틴과 태스크로 작업하기 위한 고급 asyncio API에 관해 설명합니다. 코루틴, 어웨이터블, 태스크 만들기, Task Cancellation, Task Groups, 잠자기, 동시에 태스크 실행하기, Eager Task Factory, 취소로부터 보호하기, 시간제한, 대기 프리미티브, 스레드에서 실행하기, 다른 스레드에서 예약하기,..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>코루틴과 태스크 &#8212; Python 3.12.4 문서</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css%3Fv=80d5e7a1.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css%3Fv=bb723527.css" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css%3Fv=b20cc3f5.css" />
    
    <script src="../_static/documentation_options.js%3Fv=3050f571"></script>
    <script src="../_static/doctools.js%3Fv=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js%3Fv=dc90522c"></script>
    <script src="../_static/translations.js%3Fv=b5f768d8"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.12.4 문서에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="스트림" href="asyncio-stream.html" />
    <link rel="prev" title="Runners" href="asyncio-runner.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="../../../3/library/asyncio-task.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" />
                <input type="submit" value="이동"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="asyncio-task.html#">코루틴과 태스크</a><ul>
<li><a class="reference internal" href="asyncio-task.html#coroutines">코루틴</a></li>
<li><a class="reference internal" href="asyncio-task.html#awaitables">어웨이터블</a></li>
<li><a class="reference internal" href="asyncio-task.html#creating-tasks">태스크 만들기</a></li>
<li><a class="reference internal" href="asyncio-task.html#task-cancellation">Task Cancellation</a></li>
<li><a class="reference internal" href="asyncio-task.html#task-groups">Task Groups</a></li>
<li><a class="reference internal" href="asyncio-task.html#sleeping">잠자기</a></li>
<li><a class="reference internal" href="asyncio-task.html#running-tasks-concurrently">동시에 태스크 실행하기</a></li>
<li><a class="reference internal" href="asyncio-task.html#eager-task-factory">Eager Task Factory</a></li>
<li><a class="reference internal" href="asyncio-task.html#shielding-from-cancellation">취소로부터 보호하기</a></li>
<li><a class="reference internal" href="asyncio-task.html#timeouts">시간제한</a></li>
<li><a class="reference internal" href="asyncio-task.html#waiting-primitives">대기 프리미티브</a></li>
<li><a class="reference internal" href="asyncio-task.html#running-in-threads">스레드에서 실행하기</a></li>
<li><a class="reference internal" href="asyncio-task.html#scheduling-from-other-threads">다른 스레드에서 예약하기</a></li>
<li><a class="reference internal" href="asyncio-task.html#introspection">인트로스펙션</a></li>
<li><a class="reference internal" href="asyncio-task.html#task-object">Task 객체</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="asyncio-runner.html"
                          title="이전 장">Runners</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="asyncio-stream.html"
                          title="다음 장">스트림</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/asyncio-task.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-stream.html" title="스트림"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="asyncio-runner.html" title="Runners"
             accesskey="P">이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >네트워킹과 프로세스 간 통신</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> — Asynchronous I/O</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="asyncio-task.html">코루틴과 태스크</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="coroutines-and-tasks">
<h1>코루틴과 태스크<a class="headerlink" href="asyncio-task.html#coroutines-and-tasks" title="Link to this heading">¶</a></h1>
<p>이 절에서는 코루틴과 태스크로 작업하기 위한 고급 asyncio API에 관해 설명합니다.</p>
<nav class="contents local" id="id1">
<ul class="simple">
<li><p><a class="reference internal" href="asyncio-task.html#coroutines" id="id3">코루틴</a></p></li>
<li><p><a class="reference internal" href="asyncio-task.html#awaitables" id="id4">어웨이터블</a></p></li>
<li><p><a class="reference internal" href="asyncio-task.html#creating-tasks" id="id5">태스크 만들기</a></p></li>
<li><p><a class="reference internal" href="asyncio-task.html#task-cancellation" id="id6">Task Cancellation</a></p></li>
<li><p><a class="reference internal" href="asyncio-task.html#task-groups" id="id7">Task Groups</a></p></li>
<li><p><a class="reference internal" href="asyncio-task.html#sleeping" id="id8">잠자기</a></p></li>
<li><p><a class="reference internal" href="asyncio-task.html#running-tasks-concurrently" id="id9">동시에 태스크 실행하기</a></p></li>
<li><p><a class="reference internal" href="asyncio-task.html#eager-task-factory" id="id10">Eager Task Factory</a></p></li>
<li><p><a class="reference internal" href="asyncio-task.html#shielding-from-cancellation" id="id11">취소로부터 보호하기</a></p></li>
<li><p><a class="reference internal" href="asyncio-task.html#timeouts" id="id12">시간제한</a></p></li>
<li><p><a class="reference internal" href="asyncio-task.html#waiting-primitives" id="id13">대기 프리미티브</a></p></li>
<li><p><a class="reference internal" href="asyncio-task.html#running-in-threads" id="id14">스레드에서 실행하기</a></p></li>
<li><p><a class="reference internal" href="asyncio-task.html#scheduling-from-other-threads" id="id15">다른 스레드에서 예약하기</a></p></li>
<li><p><a class="reference internal" href="asyncio-task.html#introspection" id="id16">인트로스펙션</a></p></li>
<li><p><a class="reference internal" href="asyncio-task.html#task-object" id="id17">Task 객체</a></p></li>
</ul>
</nav>
<section id="coroutines">
<span id="coroutine"></span><h2><a class="toc-backref" href="asyncio-task.html#id3" role="doc-backlink">코루틴</a><a class="headerlink" href="asyncio-task.html#coroutines" title="Link to this heading">¶</a></h2>
<p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/asyncio/coroutines.py">Lib/asyncio/coroutines.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Coroutines</span></a> declared with the async/await syntax is the
preferred way of writing asyncio applications.  For example, the following
snippet of code prints “hello”, waits 1 second,
and then prints “world”:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
<span class="go">hello</span>
<span class="go">world</span>
</pre></div>
</div>
<p>단지 코루틴을 호출하는 것으로 실행되도록 예약하는 것은 아닙니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">main</span><span class="p">()</span>
<span class="go">&lt;coroutine object main at 0x1053bb7c8&gt;</span>
</pre></div>
</div>
<p>To actually run a coroutine, asyncio provides the following mechanisms:</p>
<ul>
<li><p>최상위 진입점 “main()” 함수를 실행하는 <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a> 함수 (위의 예를 보세요.)</p></li>
<li><p>코루틴을 기다리기. 다음 코드 조각은 1초를 기다린 후 “hello”를 인쇄한 다음 <em>또</em> 2초를 기다린 후 “world”를 인쇄합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">say_after</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">what</span><span class="p">):</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">what</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;started at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">await</span> <span class="n">say_after</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">say_after</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;finished at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<p>예상 출력:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">started</span> <span class="n">at</span> <span class="mi">17</span><span class="p">:</span><span class="mi">13</span><span class="p">:</span><span class="mi">52</span>
<span class="n">hello</span>
<span class="n">world</span>
<span class="n">finished</span> <span class="n">at</span> <span class="mi">17</span><span class="p">:</span><span class="mi">13</span><span class="p">:</span><span class="mi">55</span>
</pre></div>
</div>
</li>
<li><p>코루틴을 asyncio <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">태스크</span></code></a>로 동시에 실행하는 <a class="reference internal" href="asyncio-task.html#asyncio.create_task" title="asyncio.create_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_task()</span></code></a> 함수.</p>
<p>위의 예를 수정해서 두 개의 <code class="docutils literal notranslate"><span class="pre">say_after</span></code> 코루틴을 <em>동시에</em> 실행해 봅시다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">task1</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span>
        <span class="n">say_after</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">))</span>

    <span class="n">task2</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span>
        <span class="n">say_after</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;started at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Wait until both tasks are completed (should take</span>
    <span class="c1"># around 2 seconds.)</span>
    <span class="k">await</span> <span class="n">task1</span>
    <span class="k">await</span> <span class="n">task2</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;finished at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>예상 출력은 이제 코드 조각이 이전보다 1초 빠르게 실행되었음을 보여줍니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">started</span> <span class="n">at</span> <span class="mi">17</span><span class="p">:</span><span class="mi">14</span><span class="p">:</span><span class="mi">32</span>
<span class="n">hello</span>
<span class="n">world</span>
<span class="n">finished</span> <span class="n">at</span> <span class="mi">17</span><span class="p">:</span><span class="mi">14</span><span class="p">:</span><span class="mi">34</span>
</pre></div>
</div>
</li>
<li><p>The <a class="reference internal" href="asyncio-task.html#asyncio.TaskGroup" title="asyncio.TaskGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TaskGroup</span></code></a> class provides a more modern
alternative to <a class="reference internal" href="asyncio-task.html#asyncio.create_task" title="asyncio.create_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_task()</span></code></a>.
Using this API, the last example becomes:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">TaskGroup</span><span class="p">()</span> <span class="k">as</span> <span class="n">tg</span><span class="p">:</span>
        <span class="n">task1</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span>
            <span class="n">say_after</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">))</span>

        <span class="n">task2</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span>
            <span class="n">say_after</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;started at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># The await is implicit when the context manager exits.</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;finished at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The timing and output should be the same as for the previous version.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11: </span><a class="reference internal" href="asyncio-task.html#asyncio.TaskGroup" title="asyncio.TaskGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TaskGroup</span></code></a>.</p>
</div>
</li>
</ul>
</section>
<section id="awaitables">
<span id="asyncio-awaitables"></span><h2><a class="toc-backref" href="asyncio-task.html#id4" role="doc-backlink">어웨이터블</a><a class="headerlink" href="asyncio-task.html#awaitables" title="Link to this heading">¶</a></h2>
<p>우리는 객체가 <a class="reference internal" href="../reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식에서 사용될 수 있을 때 <strong>어웨이터블</strong> 객체라고 말합니다. 많은 asyncio API는 어웨이터블을 받아들이도록 설계되었습니다.</p>
<p><em>어웨이터블</em> 객체에는 세 가지 주요 유형이 있습니다: <strong>코루틴</strong>, <strong>태스크</strong> 및 <strong>퓨처</strong>.</p>
<p class="rubric">코루틴</p>
<p>파이썬 코루틴은 <em>어웨이터블</em>이므로 다른 코루틴에서 기다릴 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">nested</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">42</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Nothing happens if we just call &quot;nested()&quot;.</span>
    <span class="c1"># A coroutine object is created but not awaited,</span>
    <span class="c1"># so it *won&#39;t run at all*.</span>
    <span class="n">nested</span><span class="p">()</span>

    <span class="c1"># Let&#39;s do it differently now and await it:</span>
    <span class="nb">print</span><span class="p">(</span><span class="k">await</span> <span class="n">nested</span><span class="p">())</span>  <span class="c1"># will print &quot;42&quot;.</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">중요</p>
<p>이 설명서에서 “코루틴” 이라는 용어는 두 가지 밀접한 관련 개념에 사용될 수 있습니다:</p>
<ul class="simple">
<li><p><em>코루틴 함수</em>: <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 함수;</p></li>
<li><p><em>코루틴 객체</em>: <em>코루틴 함수</em>를 호출하여 반환된 객체.</p></li>
</ul>
</div>
<p class="rubric">태스크</p>
<p><em>태스크</em>는 코루틴을 <em>동시에</em> 예약하는 데 사용됩니다.</p>
<p>코루틴이 <a class="reference internal" href="asyncio-task.html#asyncio.create_task" title="asyncio.create_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_task()</span></code></a>와 같은 함수를 사용하여 <em>태스크</em>로 싸일 때 코루틴은 곧 실행되도록 자동으로 예약됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">nested</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">42</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Schedule nested() to run soon concurrently</span>
    <span class="c1"># with &quot;main()&quot;.</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">nested</span><span class="p">())</span>

    <span class="c1"># &quot;task&quot; can now be used to cancel &quot;nested()&quot;, or</span>
    <span class="c1"># can simply be awaited to wait until it is complete:</span>
    <span class="k">await</span> <span class="n">task</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<p class="rubric">퓨처</p>
<p><a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>는 비동기 연산의 <strong>최종 결과</strong>를 나타내는 특별한 <strong>저수준</strong> 어웨이터블 객체입니다.</p>
<p>Future 객체를 <em>기다릴</em> 때, 그것은 코루틴이 Future가 다른 곳에서 해결될 때까지 기다릴 것을 뜻합니다.</p>
<p>콜백 기반 코드를 async/await와 함께 사용하려면 asyncio의 Future 객체가 필요합니다.</p>
<p>일반적으로 응용 프로그램 수준 코드에서 Future 객체를 만들 <strong>필요는 없습니다</strong>.</p>
<p>때때로 라이브러리와 일부 asyncio API에 의해 노출되는 Future 객체를 기다릴 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">await</span> <span class="n">function_that_returns_a_future_object</span><span class="p">()</span>

    <span class="c1"># this is also valid:</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
        <span class="n">function_that_returns_a_future_object</span><span class="p">(),</span>
        <span class="n">some_python_coroutine</span><span class="p">()</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>Future 객체를 반환하는 저수준 함수의 좋은 예는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a>입니다.</p>
</section>
<section id="creating-tasks">
<h2><a class="toc-backref" href="asyncio-task.html#id5" role="doc-backlink">태스크 만들기</a><a class="headerlink" href="asyncio-task.html#creating-tasks" title="Link to this heading">¶</a></h2>
<p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/asyncio/tasks.py">Lib/asyncio/tasks.py</a></p>
<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="asyncio.create_task">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">create_task</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coro</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.create_task" title="Link to this definition">¶</a></dt>
<dd><p><em>coro</em> <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">코루틴</span></a>을 <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>로 감싸고 실행을 예약합니다. Task 객체를 반환합니다.</p>
<p><em>name</em>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면, <a class="reference internal" href="asyncio-task.html#asyncio.Task.set_name" title="asyncio.Task.set_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Task.set_name()</span></code></a>을 사용하여 태스크의 이름으로 설정됩니다.</p>
<p>An optional keyword-only <em>context</em> argument allows specifying a
custom <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> for the <em>coro</em> to run in.
The current context copy is created when no <em>context</em> is provided.</p>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_running_loop()</span></code></a>에 의해 반환된 루프에서 태스크가 실행되고, 현재 스레드에 실행 중인 루프가 없으면 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>가 발생합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="asyncio-task.html#asyncio.TaskGroup.create_task" title="asyncio.TaskGroup.create_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncio.TaskGroup.create_task()</span></code></a> is a new alternative
leveraging structural concurrency; it allows for waiting
for a group of related tasks with strong safety guarantees.</p>
</div>
<div class="admonition important">
<p class="admonition-title">중요</p>
<p>Save a reference to the result of this function, to avoid
a task disappearing mid-execution. The event loop only keeps
weak references to tasks. A task that isn’t referenced elsewhere
may get garbage collected at any time, even before it’s done.
For reliable “fire-and-forget” background tasks, gather them in
a collection:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">background_tasks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">some_coro</span><span class="p">(</span><span class="n">param</span><span class="o">=</span><span class="n">i</span><span class="p">))</span>

    <span class="c1"># Add task to the set. This creates a strong reference.</span>
    <span class="n">background_tasks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="c1"># To prevent keeping references to finished tasks forever,</span>
    <span class="c1"># make each task remove its own reference from the set after</span>
    <span class="c1"># completion:</span>
    <span class="n">task</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">background_tasks</span><span class="o">.</span><span class="n">discard</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>Added the <em>name</em> parameter.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>Added the <em>context</em> parameter.</p>
</div>
</dd></dl>

</section>
<section id="task-cancellation">
<h2><a class="toc-backref" href="asyncio-task.html#id6" role="doc-backlink">Task Cancellation</a><a class="headerlink" href="asyncio-task.html#task-cancellation" title="Link to this heading">¶</a></h2>
<p>Tasks can easily and safely be cancelled.
When a task is cancelled, <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.CancelledError</span></code></a> will be raised
in the task at the next opportunity.</p>
<p>It is recommended that coroutines use <code class="docutils literal notranslate"><span class="pre">try/finally</span></code> blocks to robustly
perform clean-up logic. In case <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.CancelledError</span></code></a>
is explicitly caught, it should generally be propagated when
clean-up is complete. <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.CancelledError</span></code></a> directly subclasses
<a class="reference internal" href="exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a> so most code will not need to be aware of it.</p>
<p>The asyncio components that enable structured concurrency, like
<a class="reference internal" href="asyncio-task.html#asyncio.TaskGroup" title="asyncio.TaskGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TaskGroup</span></code></a> and <a class="reference internal" href="asyncio-task.html#asyncio.timeout" title="asyncio.timeout"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.timeout()</span></code></a>,
are implemented using cancellation internally and might misbehave if
a coroutine swallows <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.CancelledError</span></code></a>. Similarly, user code
should not generally call <a class="reference internal" href="asyncio-task.html#asyncio.Task.uncancel" title="asyncio.Task.uncancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">uncancel</span></code></a>.
However, in cases when suppressing <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.CancelledError</span></code></a> is
truly desired, it is necessary to also call <code class="docutils literal notranslate"><span class="pre">uncancel()</span></code> to completely
remove the cancellation state.</p>
</section>
<section id="task-groups">
<span id="taskgroups"></span><h2><a class="toc-backref" href="asyncio-task.html#id7" role="doc-backlink">Task Groups</a><a class="headerlink" href="asyncio-task.html#task-groups" title="Link to this heading">¶</a></h2>
<p>Task groups combine a task creation API with a convenient
and reliable way to wait for all tasks in the group to finish.</p>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.TaskGroup">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">TaskGroup</span></span><a class="headerlink" href="asyncio-task.html#asyncio.TaskGroup" title="Link to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="../reference/datamodel.html#async-context-managers"><span class="std std-ref">asynchronous context manager</span></a>
holding a group of tasks.
Tasks can be added to the group using <a class="reference internal" href="asyncio-task.html#asyncio.create_task" title="asyncio.create_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_task()</span></code></a>.
All tasks are awaited when the context manager exits.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.TaskGroup.create_task">
<span class="sig-name descname"><span class="pre">create_task</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coro</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.TaskGroup.create_task" title="Link to this definition">¶</a></dt>
<dd><p>Create a task in this task group.
The signature matches that of <a class="reference internal" href="asyncio-task.html#asyncio.create_task" title="asyncio.create_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_task()</span></code></a>.</p>
</dd></dl>

</dd></dl>

<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">TaskGroup</span><span class="p">()</span> <span class="k">as</span> <span class="n">tg</span><span class="p">:</span>
        <span class="n">task1</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">some_coro</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
        <span class="n">task2</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">another_coro</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Both tasks have completed now: </span><span class="si">{</span><span class="n">task1</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">task2</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> statement will wait for all tasks in the group to finish.
While waiting, new tasks may still be added to the group
(for example, by passing <code class="docutils literal notranslate"><span class="pre">tg</span></code> into one of the coroutines
and calling <code class="docutils literal notranslate"><span class="pre">tg.create_task()</span></code> in that coroutine).
Once the last task has finished and the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block is exited,
no new tasks may be added to the group.</p>
<p>The first time any of the tasks belonging to the group fails
with an exception other than <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.CancelledError</span></code></a>,
the remaining tasks in the group are cancelled.
No further tasks can then be added to the group.
At this point, if the body of the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> statement is still active
(i.e., <a class="reference internal" href="../reference/datamodel.html#object.__aexit__" title="object.__aexit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code></a> hasn’t been called yet),
the task directly containing the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> statement is also cancelled.
The resulting <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.CancelledError</span></code></a> will interrupt an <code class="docutils literal notranslate"><span class="pre">await</span></code>,
but it will not bubble out of the containing <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> statement.</p>
<p>Once all tasks have finished, if any tasks have failed
with an exception other than <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.CancelledError</span></code></a>,
those exceptions are combined in an
<a class="reference internal" href="exceptions.html#ExceptionGroup" title="ExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> or <a class="reference internal" href="exceptions.html#BaseExceptionGroup" title="BaseExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseExceptionGroup</span></code></a>
(as appropriate; see their documentation)
which is then raised.</p>
<p>Two base exceptions are treated specially:
If any task fails with <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> or <a class="reference internal" href="exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a>,
the task group still cancels the remaining tasks and waits for them,
but then the initial <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> or <a class="reference internal" href="exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a>
is re-raised instead of <a class="reference internal" href="exceptions.html#ExceptionGroup" title="ExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> or <a class="reference internal" href="exceptions.html#BaseExceptionGroup" title="BaseExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseExceptionGroup</span></code></a>.</p>
<p>If the body of the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> statement exits with an exception
(so <a class="reference internal" href="../reference/datamodel.html#object.__aexit__" title="object.__aexit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code></a> is called with an exception set),
this is treated the same as if one of the tasks failed:
the remaining tasks are cancelled and then waited for,
and non-cancellation exceptions are grouped into an
exception group and raised.
The exception passed into <a class="reference internal" href="../reference/datamodel.html#object.__aexit__" title="object.__aexit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code></a>,
unless it is <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.CancelledError</span></code></a>,
is also included in the exception group.
The same special case is made for
<a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> and <a class="reference internal" href="exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a> as in the previous paragraph.</p>
</section>
<section id="sleeping">
<h2><a class="toc-backref" href="asyncio-task.html#id8" role="doc-backlink">잠자기</a><a class="headerlink" href="asyncio-task.html#sleeping" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="asyncio.sleep">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">sleep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delay</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.sleep" title="Link to this definition">¶</a></dt>
<dd><p><em>delay</em> 초 동안 블록합니다.</p>
<p><em>result</em>가 제공되면, 코루틴이 완료될 때 호출자에게 반환됩니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">sleep()</span></code>은 항상 현재 태스크를 일시 중단해서 다른 태스크를 실행할 수 있도록 합니다.</p>
<p>Setting the delay to 0 provides an optimized path to allow other
tasks to run. This can be used by long-running functions to avoid
blocking the event loop for the full duration of the function call.</p>
<p id="asyncio-example-sleep">5초 동안 현재 날짜를 매초 표시하는 코루틴의 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">display_date</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">5.0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">end_time</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">display_date</span><span class="p">())</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.10에서 변경: </span>Removed the <em>loop</em> parameter.</p>
</div>
</dd></dl>

</section>
<section id="running-tasks-concurrently">
<h2><a class="toc-backref" href="asyncio-task.html#id9" role="doc-backlink">동시에 태스크 실행하기</a><a class="headerlink" href="asyncio-task.html#running-tasks-concurrently" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="asyncio.gather">
<em class="property"><span class="pre">awaitable</span> </em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">gather</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">aws</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_exceptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.gather" title="Link to this definition">¶</a></dt>
<dd><p><em>aws</em> 시퀀스에 있는 <a class="reference internal" href="asyncio-task.html#asyncio-awaitables"><span class="std std-ref">어웨이터블 객체</span></a>를 <em>동시에</em> 실행합니다.</p>
<p><em>aws</em>에 있는 어웨이터블이 코루틴이면 자동으로 태스크로 예약됩니다.</p>
<p>모든 어웨이터블이 성공적으로 완료되면, 결과는 반환된 값들이 합쳐진 리스트입니다. 결괏값의 순서는 <em>aws</em>에 있는 어웨이터블의 순서와 일치합니다.</p>
<p><em>return_exceptions</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>(기본값)면, 첫 번째 발생한 예외가 <code class="docutils literal notranslate"><span class="pre">gather()</span></code>를 기다리는 태스크로 즉시 전파됩니다. <em>aws</em> 시퀀스의 다른 어웨이터블은 <strong>취소되지 않고</strong> 계속 실행됩니다.</p>
<p><em>return_exceptions</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>면, 예외는 성공적인 결과처럼 처리되고, 결과 리스트에 집계됩니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">gather()</span></code>가 <em>취소되면</em>, 모든 제출된 (아직 완료되지 않은) 어웨이터블도 <em>취소됩니다</em>.</p>
<p><em>aws</em> 시퀀스의 Task나 Future가 <em>취소되면</em>, 그것이 <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a>를 일으킨 것처럼 처리됩니다 – 이때 <code class="docutils literal notranslate"><span class="pre">gather()</span></code> 호출은 취소되지 <strong>않습니다</strong>. 이것은 제출된 태스크/퓨처 하나를 취소하는 것이 다른 태스크/퓨처를 취소하게 되는 것을 막기 위한 것입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>A new alternative to create and run tasks concurrently and
wait for their completion is <a class="reference internal" href="asyncio-task.html#asyncio.TaskGroup" title="asyncio.TaskGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TaskGroup</span></code></a>. <em>TaskGroup</em>
provides stronger safety guarantees than <em>gather</em> for scheduling a nesting of subtasks:
if a task (or a subtask, a task scheduled by a task)
raises an exception, <em>TaskGroup</em> will, while <em>gather</em> will not,
cancel the remaining scheduled tasks).</p>
</div>
<p id="asyncio-example-gather">예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Task </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: Compute factorial(</span><span class="si">{</span><span class="n">number</span><span class="si">}</span><span class="s2">), currently i=</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">*=</span> <span class="n">i</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Task </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: factorial(</span><span class="si">{</span><span class="n">number</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Schedule three calls *concurrently*:</span>
    <span class="n">L</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
        <span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
        <span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

<span class="c1"># Expected output:</span>
<span class="c1">#</span>
<span class="c1">#     Task A: Compute factorial(2), currently i=2...</span>
<span class="c1">#     Task B: Compute factorial(3), currently i=2...</span>
<span class="c1">#     Task C: Compute factorial(4), currently i=2...</span>
<span class="c1">#     Task A: factorial(2) = 2</span>
<span class="c1">#     Task B: Compute factorial(3), currently i=3...</span>
<span class="c1">#     Task C: Compute factorial(4), currently i=3...</span>
<span class="c1">#     Task B: factorial(3) = 6</span>
<span class="c1">#     Task C: Compute factorial(4), currently i=4...</span>
<span class="c1">#     Task C: factorial(4) = 24</span>
<span class="c1">#     [2, 6, 24]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>If <em>return_exceptions</em> is false, cancelling gather() after it
has been marked done won’t cancel any submitted awaitables.
For instance, gather can be marked done after propagating an
exception to the caller, therefore, calling <code class="docutils literal notranslate"><span class="pre">gather.cancel()</span></code>
after catching an exception (raised by one of the awaitables) from
gather won’t cancel any other awaitables.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>gather</em> 자체가 취소되면, <em>return_exceptions</em>와 관계없이 취소가 전파됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.10에서 변경: </span>Removed the <em>loop</em> parameter.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.10부터 폐지됨: </span>Deprecation warning is emitted if no positional arguments are provided
or not all positional arguments are Future-like objects
and there is no running event loop.</p>
</div>
</dd></dl>

</section>
<section id="eager-task-factory">
<span id="id2"></span><h2><a class="toc-backref" href="asyncio-task.html#id10" role="doc-backlink">Eager Task Factory</a><a class="headerlink" href="asyncio-task.html#eager-task-factory" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="asyncio.eager_task_factory">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">eager_task_factory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coro</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.eager_task_factory" title="Link to this definition">¶</a></dt>
<dd><p>A task factory for eager task execution.</p>
<p>When using this factory (via <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.set_task_factory" title="asyncio.loop.set_task_factory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.set_task_factory(asyncio.eager_task_factory)</span></code></a>),
coroutines begin execution synchronously during <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> construction.
Tasks are only scheduled on the event loop if they block.
This can be a performance improvement as the overhead of loop scheduling
is avoided for coroutines that complete synchronously.</p>
<p>A common example where this is beneficial is coroutines which employ
caching or memoization to avoid actual I/O when possible.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>Immediate execution of the coroutine is a semantic change.
If the coroutine returns or raises, the task is never scheduled
to the event loop. If the coroutine execution blocks, the task is
scheduled to the event loop. This change may introduce behavior
changes to existing applications. For example,
the application’s task execution order is likely to change.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.create_eager_task_factory">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">create_eager_task_factory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">custom_task_constructor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.create_eager_task_factory" title="Link to this definition">¶</a></dt>
<dd><p>Create an eager task factory, similar to <a class="reference internal" href="asyncio-task.html#asyncio.eager_task_factory" title="asyncio.eager_task_factory"><code class="xref py py-func docutils literal notranslate"><span class="pre">eager_task_factory()</span></code></a>,
using the provided <em>custom_task_constructor</em> when creating a new task instead
of the default <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>.</p>
<p><em>custom_task_constructor</em> must be a <em>callable</em> with the signature matching
the signature of <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task.__init__</span></code></a>.
The callable must return a <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a>-compatible object.</p>
<p>This function returns a <em>callable</em> intended to be used as a task factory of an
event loop via <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.set_task_factory" title="asyncio.loop.set_task_factory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.set_task_factory(factory)</span></code></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

</section>
<section id="shielding-from-cancellation">
<h2><a class="toc-backref" href="asyncio-task.html#id11" role="doc-backlink">취소로부터 보호하기</a><a class="headerlink" href="asyncio-task.html#shielding-from-cancellation" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="asyncio.shield">
<em class="property"><span class="pre">awaitable</span> </em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">shield</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.shield" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="asyncio-task.html#asyncio-awaitables"><span class="std std-ref">어웨이터블 객체</span></a>를 <a class="reference internal" href="asyncio-task.html#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">취소</span></code></a>로부터 보호합니다.</p>
<p><em>aw</em>가 코루틴이면 자동으로 태스크로 예약됩니다.</p>
<p>다음 문장:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">something</span><span class="p">())</span>
<span class="n">res</span> <span class="o">=</span> <span class="k">await</span> <span class="n">shield</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</pre></div>
</div>
<p>은 다음과 동등합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="k">await</span> <span class="n">something</span><span class="p">()</span>
</pre></div>
</div>
<p><em>단</em>, 그것을 포함하는 코루틴이 취소되면, <code class="docutils literal notranslate"><span class="pre">something()</span></code>에서 실행 중인 태스크는 취소되지 않는다는 것만 예외입니다. <code class="docutils literal notranslate"><span class="pre">something()</span></code>의 관점에서는, 취소가 일어나지 않았습니다. 호출자는 여전히 취소되었고, “await” 표현식은 여전히 <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a>를 발생시킵니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">something()</span></code>가 다른 수단(즉, 그 안에서 스스로)에 의해 취소되면, <code class="docutils literal notranslate"><span class="pre">shield()</span></code>도 취소됩니다.</p>
<p>취소를 완전히 무시하려면(권장되지 않습니다), 다음과 같이 <code class="docutils literal notranslate"><span class="pre">shield()</span></code> 함수를 try/except 절과 결합해야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">something</span><span class="p">())</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="k">await</span> <span class="n">shield</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
<span class="k">except</span> <span class="n">CancelledError</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">중요</p>
<p>Save a reference to tasks passed to this function, to avoid
a task disappearing mid-execution. The event loop only keeps
weak references to tasks. A task that isn’t referenced elsewhere
may get garbage collected at any time, even before it’s done.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.10에서 변경: </span>Removed the <em>loop</em> parameter.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.10부터 폐지됨: </span>Deprecation warning is emitted if <em>aw</em> is not Future-like object
and there is no running event loop.</p>
</div>
</dd></dl>

</section>
<section id="timeouts">
<h2><a class="toc-backref" href="asyncio-task.html#id12" role="doc-backlink">시간제한</a><a class="headerlink" href="asyncio-task.html#timeouts" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="asyncio.timeout">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">timeout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delay</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.timeout" title="Link to this definition">¶</a></dt>
<dd><p>Return an <a class="reference internal" href="../reference/datamodel.html#async-context-managers"><span class="std std-ref">asynchronous context manager</span></a>
that can be used to limit the amount of time spent waiting on
something.</p>
<p><em>delay</em> can either be <code class="docutils literal notranslate"><span class="pre">None</span></code>, or a float/int number of
seconds to wait. If <em>delay</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, no time limit will
be applied; this can be useful if the delay is unknown when
the context manager is created.</p>
<p>In either case, the context manager can be rescheduled after
creation using <a class="reference internal" href="asyncio-task.html#asyncio.Timeout.reschedule" title="asyncio.Timeout.reschedule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Timeout.reschedule()</span></code></a>.</p>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">long_running_task</span><span class="p">()</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">long_running_task</span></code> takes more than 10 seconds to complete,
the context manager will cancel the current task and handle
the resulting <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.CancelledError</span></code></a> internally, transforming it
into a <a class="reference internal" href="exceptions.html#TimeoutError" title="TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TimeoutError</span></code></a> which can be caught and handled.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>The <a class="reference internal" href="asyncio-task.html#asyncio.timeout" title="asyncio.timeout"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.timeout()</span></code></a> context manager is what transforms
the <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.CancelledError</span></code></a> into a <a class="reference internal" href="exceptions.html#TimeoutError" title="TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TimeoutError</span></code></a>,
which means the <a class="reference internal" href="exceptions.html#TimeoutError" title="TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TimeoutError</span></code></a> can only be caught
<em>outside</em> of the context manager.</p>
</div>
<p>Example of catching <a class="reference internal" href="exceptions.html#TimeoutError" title="TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TimeoutError</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="k">await</span> <span class="n">long_running_task</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">TimeoutError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The long operation timed out, but we&#39;ve handled it.&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This statement will run regardless.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The context manager produced by <a class="reference internal" href="asyncio-task.html#asyncio.timeout" title="asyncio.timeout"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.timeout()</span></code></a> can be
rescheduled to a different deadline and inspected.</p>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.Timeout">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">Timeout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">when</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Timeout" title="Link to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="../reference/datamodel.html#async-context-managers"><span class="std std-ref">asynchronous context manager</span></a>
for cancelling overdue coroutines.</p>
<p><code class="docutils literal notranslate"><span class="pre">when</span></code> should be an absolute time at which the context should time out,
as measured by the event loop’s clock:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">when</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the timeout will never trigger.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">when</span> <span class="pre">&lt;</span> <span class="pre">loop.time()</span></code>, the timeout will trigger on the next
iteration of the event loop.</p></li>
</ul>
<blockquote>
<div><dl class="py method">
<dt class="sig sig-object py" id="asyncio.Timeout.when">
<span class="sig-name descname"><span class="pre">when</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="functions.html#float" title="float"><span class="pre">float</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="constants.html#None" title="None"><span class="pre">None</span></a></span></span><a class="headerlink" href="asyncio-task.html#asyncio.Timeout.when" title="Link to this definition">¶</a></dt>
<dd><p>Return the current deadline, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if the current
deadline is not set.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Timeout.reschedule">
<span class="sig-name descname"><span class="pre">reschedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">when</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="functions.html#float" title="float"><span class="pre">float</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="constants.html#None" title="None"><span class="pre">None</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Timeout.reschedule" title="Link to this definition">¶</a></dt>
<dd><p>Reschedule the timeout.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Timeout.expired">
<span class="sig-name descname"><span class="pre">expired</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="functions.html#bool" title="bool"><span class="pre">bool</span></a></span></span><a class="headerlink" href="asyncio-task.html#asyncio.Timeout.expired" title="Link to this definition">¶</a></dt>
<dd><p>Return whether the context manager has exceeded its deadline
(expired).</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># We do not know the timeout when starting, so we pass ``None``.</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
            <span class="c1"># We know the timeout now, so we reschedule it.</span>
            <span class="n">new_deadline</span> <span class="o">=</span> <span class="n">get_running_loop</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mi">10</span>
            <span class="n">cm</span><span class="o">.</span><span class="n">reschedule</span><span class="p">(</span><span class="n">new_deadline</span><span class="p">)</span>

            <span class="k">await</span> <span class="n">long_running_task</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">TimeoutError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">if</span> <span class="n">cm</span><span class="o">.</span><span class="n">expired</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Looks like we haven&#39;t finished on time.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Timeout context managers can be safely nested.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.timeout_at">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">timeout_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">when</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.timeout_at" title="Link to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="asyncio-task.html#asyncio.timeout" title="asyncio.timeout"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.timeout()</span></code></a>, except <em>when</em> is the absolute time
to stop waiting, or <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">get_running_loop</span><span class="p">()</span>
    <span class="n">deadline</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mi">20</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">timeout_at</span><span class="p">(</span><span class="n">deadline</span><span class="p">):</span>
            <span class="k">await</span> <span class="n">long_running_task</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">TimeoutError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The long operation timed out, but we&#39;ve handled it.&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This statement will run regardless.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.wait_for">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">wait_for</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aw</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.wait_for" title="Link to this definition">¶</a></dt>
<dd><p><em>aw</em> <a class="reference internal" href="asyncio-task.html#asyncio-awaitables"><span class="std std-ref">어웨이터블</span></a>이 제한된 시간 내에 완료될 때까지 기다립니다.</p>
<p><em>aw</em>가 코루틴이면 자동으로 태스크로 예약됩니다.</p>
<p><em>timeout</em>은 <code class="docutils literal notranslate"><span class="pre">None</span></code> 또는 대기할 float 나 int 초 수입니다. <em>timeout</em>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면 퓨처가 완료될 때까지 블록합니다.</p>
<p>If a timeout occurs, it cancels the task and raises
<a class="reference internal" href="exceptions.html#TimeoutError" title="TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TimeoutError</span></code></a>.</p>
<p>태스크 <a class="reference internal" href="asyncio-task.html#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">취소</span></code></a>를 피하려면, <a class="reference internal" href="asyncio-task.html#asyncio.shield" title="asyncio.shield"><code class="xref py py-func docutils literal notranslate"><span class="pre">shield()</span></code></a>로 감싸십시오.</p>
<p>이 함수는 퓨처가 실제로 취소될 때까지 대기하므로, 총 대기 시간이 <em>timeout</em>을 초과할 수 있습니다. 취소하는 동안 예외가 발생하면, 전파됩니다.</p>
<p>대기가 취소되면, 퓨처 <em>aw</em>도 취소됩니다.</p>
<p id="asyncio-example-waitfor">예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">eternity</span><span class="p">():</span>
    <span class="c1"># Sleep for one hour</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3600</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;yay!&#39;</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Wait for at most 1 second</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">eternity</span><span class="p">(),</span> <span class="n">timeout</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TimeoutError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;timeout!&#39;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

<span class="c1"># Expected output:</span>
<span class="c1">#</span>
<span class="c1">#     timeout!</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>When <em>aw</em> is cancelled due to a timeout, <code class="docutils literal notranslate"><span class="pre">wait_for</span></code> waits
for <em>aw</em> to be cancelled.  Previously, it raised
<a class="reference internal" href="exceptions.html#TimeoutError" title="TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TimeoutError</span></code></a> immediately.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.10에서 변경: </span>Removed the <em>loop</em> parameter.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>Raises <a class="reference internal" href="exceptions.html#TimeoutError" title="TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TimeoutError</span></code></a> instead of <a class="reference internal" href="asyncio-exceptions.html#asyncio.TimeoutError" title="asyncio.TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.TimeoutError</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="waiting-primitives">
<h2><a class="toc-backref" href="asyncio-task.html#id13" role="doc-backlink">대기 프리미티브</a><a class="headerlink" href="asyncio-task.html#waiting-primitives" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="asyncio.wait">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">wait</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aws</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_when</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">ALL_COMPLETED</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.wait" title="Link to this definition">¶</a></dt>
<dd><p>Run <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a> and <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> instances in the <em>aws</em>
iterable concurrently and block until the condition specified
by <em>return_when</em>.</p>
<p><em>aws</em> 이터러블은 비어있을 수 없습니다.</p>
<p>두 집합의 태스크/퓨처를 반환합니다: <code class="docutils literal notranslate"><span class="pre">(done,</span> <span class="pre">pending)</span></code>.</p>
<p>사용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">done</span><span class="p">,</span> <span class="n">pending</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span>
</pre></div>
</div>
<p><em>timeout</em>(float나 int)을 지정하면, 반환하기 전에 대기할 최대 시간(초)을 제어할 수 있습니다.</p>
<p>Note that this function does not raise <a class="reference internal" href="exceptions.html#TimeoutError" title="TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TimeoutError</span></code></a>.
Futures or Tasks that aren’t done when the timeout occurs are simply
returned in the second set.</p>
<p><em>return_when</em>는 이 함수가 언제 반환해야 하는지 나타냅니다. 다음 상수 중 하나여야 합니다:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>상수</p></th>
<th class="head"><p>설명</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="py data">
<dt class="sig sig-object py" id="asyncio.FIRST_COMPLETED">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">FIRST_COMPLETED</span></span><a class="headerlink" href="asyncio-task.html#asyncio.FIRST_COMPLETED" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>퓨처가 하나라도 끝나거나 취소될 때 함수가 반환됩니다.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py data">
<dt class="sig sig-object py" id="asyncio.FIRST_EXCEPTION">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">FIRST_EXCEPTION</span></span><a class="headerlink" href="asyncio-task.html#asyncio.FIRST_EXCEPTION" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The function will return when any future finishes by raising an
exception. If no future raises an exception
then it is equivalent to <a class="reference internal" href="asyncio-task.html#asyncio.ALL_COMPLETED" title="asyncio.ALL_COMPLETED"><code class="xref py py-const docutils literal notranslate"><span class="pre">ALL_COMPLETED</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><dl class="py data">
<dt class="sig sig-object py" id="asyncio.ALL_COMPLETED">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">ALL_COMPLETED</span></span><a class="headerlink" href="asyncio-task.html#asyncio.ALL_COMPLETED" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>모든 퓨처가 끝나거나 취소되면 함수가 반환됩니다.</p></td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="asyncio-task.html#asyncio.wait_for" title="asyncio.wait_for"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_for()</span></code></a>와 달리, <code class="docutils literal notranslate"><span class="pre">wait()</span></code>는 시간 초과가 발생할 때 퓨처를 취소하지 않습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.10에서 변경: </span>Removed the <em>loop</em> parameter.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>Passing coroutine objects to <code class="docutils literal notranslate"><span class="pre">wait()</span></code> directly is forbidden.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span>Added support for generators yielding tasks.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.as_completed">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">as_completed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aws</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.as_completed" title="Link to this definition">¶</a></dt>
<dd><p><em>aws</em> 이터러블에 있는 <a class="reference internal" href="asyncio-task.html#asyncio-awaitables"><span class="std std-ref">어웨이터블 객체</span></a>를 동시에 실행합니다. 코루틴의 이터레이터를 반환합니다. 반환된 각 코루틴은 남아있는 어웨이터블의 이터러블에서 가장 빠른 다음 결과를 얻기 위해 어웨이트 할 수 있습니다.</p>
<p>Raises <a class="reference internal" href="exceptions.html#TimeoutError" title="TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TimeoutError</span></code></a> if the timeout occurs before
all Futures are done.</p>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">coro</span> <span class="ow">in</span> <span class="n">as_completed</span><span class="p">(</span><span class="n">aws</span><span class="p">):</span>
    <span class="n">earliest_result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">coro</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.10에서 변경: </span>Removed the <em>loop</em> parameter.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.10부터 폐지됨: </span>Deprecation warning is emitted if not all awaitable objects in the <em>aws</em>
iterable are Future-like objects and there is no running event loop.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span>Added support for generators yielding tasks.</p>
</div>
</dd></dl>

</section>
<section id="running-in-threads">
<h2><a class="toc-backref" href="asyncio-task.html#id14" role="doc-backlink">스레드에서 실행하기</a><a class="headerlink" href="asyncio-task.html#running-in-threads" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="asyncio.to_thread">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">to_thread</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.to_thread" title="Link to this definition">¶</a></dt>
<dd><p>별도의 스레드에서 <em>func</em> 함수를 비동기적으로 실행합니다.</p>
<p>이 함수에 제공된 모든 *args 와 **kwargs 는 <em>func</em>로 직접 전달됩니다. 또한, 현재 <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a>가 전파되어, 이벤트 루프 스레드의 컨텍스트 변수가 별도의 스레드에서 액세스 될 수 있습니다.</p>
<p><em>func</em>의 최종 결과를 얻기 위해 어웨이트 할 수 있는 코루틴을 반환합니다.</p>
<p>This coroutine function is primarily intended to be used for executing
IO-bound functions/methods that would otherwise block the event loop if
they were run in the main thread. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">blocking_io</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;start blocking_io at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Note that time.sleep() can be replaced with any blocking</span>
    <span class="c1"># IO-bound operation, such as file operations.</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;blocking_io complete at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;started main at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">to_thread</span><span class="p">(</span><span class="n">blocking_io</span><span class="p">),</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;finished main at </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

<span class="c1"># Expected output:</span>
<span class="c1">#</span>
<span class="c1"># started main at 19:50:53</span>
<span class="c1"># start blocking_io at 19:50:53</span>
<span class="c1"># blocking_io complete at 19:50:54</span>
<span class="c1"># finished main at 19:50:54</span>
</pre></div>
</div>
<p>Directly calling <code class="docutils literal notranslate"><span class="pre">blocking_io()</span></code> in any coroutine would block the event loop
for its duration, resulting in an additional 1 second of run time. Instead,
by using <code class="docutils literal notranslate"><span class="pre">asyncio.to_thread()</span></code>, we can run it in a separate thread without
blocking the event loop.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>Due to the <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a>, <code class="docutils literal notranslate"><span class="pre">asyncio.to_thread()</span></code> can typically only be used
to make IO-bound functions non-blocking. However, for extension modules
that release the GIL or alternative Python implementations that don’t
have one, <code class="docutils literal notranslate"><span class="pre">asyncio.to_thread()</span></code> can also be used for CPU-bound functions.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

</section>
<section id="scheduling-from-other-threads">
<h2><a class="toc-backref" href="asyncio-task.html#id15" role="doc-backlink">다른 스레드에서 예약하기</a><a class="headerlink" href="asyncio-task.html#scheduling-from-other-threads" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="asyncio.run_coroutine_threadsafe">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">run_coroutine_threadsafe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coro</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loop</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.run_coroutine_threadsafe" title="Link to this definition">¶</a></dt>
<dd><p>주어진 이벤트 루프에 코루틴을 제출합니다. 스레드 안전합니다.</p>
<p>다른 OS 스레드에서 결과를 기다리는 <a class="reference internal" href="concurrent.futures.html#concurrent.futures.Future" title="concurrent.futures.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.Future</span></code></a>를 반환합니다.</p>
<p>이 함수는 이벤트 루프가 실행 중인 스레드가 아닌, 다른 OS 스레드에서 호출하기 위한 것입니다. 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a coroutine</span>
<span class="n">coro</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Submit the coroutine to a given loop</span>
<span class="n">future</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">run_coroutine_threadsafe</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># Wait for the result with an optional timeout argument</span>
<span class="k">assert</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
</pre></div>
</div>
<p>코루틴에서 예외가 발생하면, 반환된 Future에 통지됩니다. 또한, 이벤트 루프에서 태스크를 취소하는 데 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">TimeoutError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The coroutine took too long, cancelling the task...&#39;</span><span class="p">)</span>
    <span class="n">future</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The coroutine raised an exception: </span><span class="si">{</span><span class="n">exc</span><span class="si">!r}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The coroutine returned: </span><span class="si">{</span><span class="n">result</span><span class="si">!r}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>설명서의 <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span class="std std-ref">동시성과 다중 스레드</span></a> 절을 참조하십시오.</p>
<p>다른 asyncio 함수와 달리, 이 함수는 <em>loop</em> 인자가 명시적으로 전달되어야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.1.</span></p>
</div>
</dd></dl>

</section>
<section id="introspection">
<h2><a class="toc-backref" href="asyncio-task.html#id16" role="doc-backlink">인트로스펙션</a><a class="headerlink" href="asyncio-task.html#introspection" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="asyncio.current_task">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">current_task</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.current_task" title="Link to this definition">¶</a></dt>
<dd><p>현재 실행 중인 <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> 인스턴스를 반환하거나 태스크가 실행되고 있지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
<p><em>loop</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, 현재 루프를 가져오는 데 <a class="reference internal" href="asyncio-eventloop.html#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_running_loop()</span></code></a>가 사용됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.all_tasks">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">all_tasks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.all_tasks" title="Link to this definition">¶</a></dt>
<dd><p>루프에 의해 실행되는 아직 완료되지 않은 <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> 객체 집합을 반환합니다.</p>
<p><em>loop</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, 현재 루프를 가져오는 데 <a class="reference internal" href="asyncio-eventloop.html#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_running_loop()</span></code></a>가 사용됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.iscoroutine">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">iscoroutine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.iscoroutine" title="Link to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>obj</em> is a coroutine object.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

</section>
<section id="task-object">
<h2><a class="toc-backref" href="asyncio-task.html#id17" role="doc-backlink">Task 객체</a><a class="headerlink" href="asyncio-task.html#task-object" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.Task">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">Task</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coro</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eager_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Task" title="Link to this definition">¶</a></dt>
<dd><p>파이썬 <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">코루틴</span></a>을 실행하는 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">퓨처류</span></code></a> 객체입니다. 스레드 안전하지 않습니다.</p>
<p>태스크는 이벤트 루프에서 코루틴을 실행하는 데 사용됩니다. 만약 코루틴이 Future를 기다리고 있다면, 태스크는 코루틴의 실행을 일시 중지하고 Future의 완료를 기다립니다. 퓨처가 <em>완료</em>되면, 감싸진 코루틴의 실행이 다시 시작됩니다.</p>
<p>이벤트 루프는 협업 스케줄링을 사용합니다: 이벤트 루프는 한 번에 하나의 Task를 실행합니다. Task가 Future의 완료를 기다리는 동안, 이벤트 루프는 다른 태스크, 콜백을 실행하거나 IO 연산을 수행합니다.</p>
<p>테스크를 만들려면 고수준 <a class="reference internal" href="asyncio-task.html#asyncio.create_task" title="asyncio.create_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_task()</span></code></a> 함수를 사용하거나, 저수준 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_task" title="asyncio.loop.create_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_task()</span></code></a> 나 <a class="reference internal" href="asyncio-future.html#asyncio.ensure_future" title="asyncio.ensure_future"><code class="xref py py-func docutils literal notranslate"><span class="pre">ensure_future()</span></code></a> 함수를 사용하십시오. 태스크의 인스턴스를 직접 만드는 것은 권장되지 않습니다.</p>
<p>실행 중인 Task를 취소하려면 <a class="reference internal" href="asyncio-task.html#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancel()</span></code></a> 메서드를 사용하십시오. 이를 호출하면 태스크가 감싼 코루틴으로 <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a> 예외를 던집니다. 코루틴이 취소 중에 Future 객체를 기다리고 있으면, Future 객체가 취소됩니다.</p>
<p><a class="reference internal" href="asyncio-task.html#asyncio.Task.cancelled" title="asyncio.Task.cancelled"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancelled()</span></code></a>는 태스크가 취소되었는지 확인하는 데 사용할 수 있습니다. 이 메서드는 감싼 코루틴이 <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a> 예외를 억제하지 않고 실제로 취소되었으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
<p><a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a>는 <a class="reference internal" href="asyncio-future.html#asyncio.Future.set_result" title="asyncio.Future.set_result"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.set_result()</span></code></a>와 <a class="reference internal" href="asyncio-future.html#asyncio.Future.set_exception" title="asyncio.Future.set_exception"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.set_exception()</span></code></a>을 제외한 모든 API를 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>에서 상속받습니다.</p>
<p>An optional keyword-only <em>context</em> argument allows specifying a
custom <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> for the <em>coro</em> to run in.
If no <em>context</em> is provided, the Task copies the current context
and later runs its coroutine in the copied context.</p>
<p>An optional keyword-only <em>eager_start</em> argument allows eagerly starting
the execution of the <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a> at task creation time.
If set to <code class="docutils literal notranslate"><span class="pre">True</span></code> and the event loop is running, the task will start
executing the coroutine immediately, until the first time the coroutine
blocks. If the coroutine returns or raises without blocking, the task
will be finished eagerly and will skip scheduling to the event loop.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><a class="reference internal" href="contextvars.html#module-contextvars" title="contextvars: Context Variables"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a> 모듈에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>Added the <em>name</em> parameter.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.10부터 폐지됨: </span>Deprecation warning is emitted if <em>loop</em> is not specified
and there is no running event loop.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>Added the <em>context</em> parameter.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span>Added the <em>eager_start</em> parameter.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Task.done">
<span class="sig-name descname"><span class="pre">done</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Task.done" title="Link to this definition">¶</a></dt>
<dd><p>Task가 <em>완료(done)</em>되었으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
<p>감싼 코루틴이 값을 반환하거나 예외를 일으키거나, Task가 취소되면 Task는 <em>완료(done)</em>됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Task.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Task.result" title="Link to this definition">¶</a></dt>
<dd><p>Task의 결과를 반환합니다.</p>
<p>Task가 <em>완료(done)</em>되었으면 감싼 코루틴의 결과가 반환됩니다 (또는 코루틴이 예외를 발생시켰으면 해당 예외가 다시 발생합니다).</p>
<p>태스크가 <em>취소(cancelled)</em>되었으면, 이 메서드는 <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a> 예외를 발생시킵니다.</p>
<p>태스크 결과를 아직 사용할 수 없으면, 이 메서드는 <a class="reference internal" href="asyncio-exceptions.html#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InvalidStateError</span></code></a> 예외를 발생시킵니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Task.exception">
<span class="sig-name descname"><span class="pre">exception</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Task.exception" title="Link to this definition">¶</a></dt>
<dd><p>Task의 예외를 반환합니다.</p>
<p>감싼 코루틴이 예외를 발생시키면, 그 예외가 반환됩니다. 감싼 코루틴이 정상적으로 반환되면, 이 메서드는 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
<p>태스크가 <em>취소(cancelled)</em>되었으면, 이 메서드는 <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a> 예외를 발생시킵니다.</p>
<p>태스크가 아직 <em>완료(done)</em>되지 않았으면, 이 메서드는 <a class="reference internal" href="asyncio-exceptions.html#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InvalidStateError</span></code></a> 예외를 발생시킵니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Task.add_done_callback">
<span class="sig-name descname"><span class="pre">add_done_callback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Task.add_done_callback" title="Link to this definition">¶</a></dt>
<dd><p>태스크가 <em>완료(done)</em>될 때 실행할 콜백을 추가합니다.</p>
<p>이 메서드는 저수준 콜백 기반 코드에서만 사용해야 합니다.</p>
<p>자세한 내용은 <a class="reference internal" href="asyncio-future.html#asyncio.Future.add_done_callback" title="asyncio.Future.add_done_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.add_done_callback()</span></code></a> 설명서를 참조하십시오.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Task.remove_done_callback">
<span class="sig-name descname"><span class="pre">remove_done_callback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">callback</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Task.remove_done_callback" title="Link to this definition">¶</a></dt>
<dd><p>콜백 목록에서 <em>callback</em>을 제거합니다.</p>
<p>이 메서드는 저수준 콜백 기반 코드에서만 사용해야 합니다.</p>
<p>자세한 내용은 <a class="reference internal" href="asyncio-future.html#asyncio.Future.remove_done_callback" title="asyncio.Future.remove_done_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.remove_done_callback()</span></code></a> 설명서를 참조하십시오.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Task.get_stack">
<span class="sig-name descname"><span class="pre">get_stack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Task.get_stack" title="Link to this definition">¶</a></dt>
<dd><p>이 Task의 스택 프레임 리스트를 돌려줍니다.</p>
<p>감싼 코루틴이 완료되지 않았으면, 일시 정지된 곳의 스택을 반환합니다. 코루틴이 성공적으로 완료되었거나 취소되었으면 빈 리스트가 반환됩니다. 코루틴이 예외로 종료되었으면, 이것은 트레이스백 프레임의 리스트를 반환합니다.</p>
<p>프레임은 항상 가장 오래된 것부터 순서대로 정렬됩니다.</p>
<p>일시 정지된 코루틴에서는 하나의 스택 프레임만 반환됩니다.</p>
<p>선택적 <em>limit</em> 인자는 반환할 최대 프레임 수를 설정합니다; 기본적으로 사용 가능한 모든 프레임이 반환됩니다. 반환되는 리스트의 순서는 스택과 트레이스백 중 어느 것이 반환되는지에 따라 다릅니다: 스택은 최신 프레임이 반환되지만, 트레이스백은 가장 오래된 프레임이 반환됩니다. (이는 traceback 모듈의 동작과 일치합니다.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Task.print_stack">
<span class="sig-name descname"><span class="pre">print_stack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Task.print_stack" title="Link to this definition">¶</a></dt>
<dd><p>이 Task의 스택이나 트레이스백을 인쇄합니다.</p>
<p>이것은 <a class="reference internal" href="asyncio-task.html#asyncio.Task.get_stack" title="asyncio.Task.get_stack"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_stack()</span></code></a>으로 얻은 프레임에 대해 traceback 모듈과 유사한 출력을 생성합니다.</p>
<p><em>limit</em> 인자는 <a class="reference internal" href="asyncio-task.html#asyncio.Task.get_stack" title="asyncio.Task.get_stack"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_stack()</span></code></a>에 직접 전달됩니다.</p>
<p>The <em>file</em> argument is an I/O stream to which the output
is written; by default output is written to <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Task.get_coro">
<span class="sig-name descname"><span class="pre">get_coro</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Task.get_coro" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>로 싸인 코루틴 객체를 반환합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>This will return <code class="docutils literal notranslate"><span class="pre">None</span></code> for Tasks which have already
completed eagerly. See the <a class="reference internal" href="asyncio-task.html#eager-task-factory"><span class="std std-ref">Eager Task Factory</span></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span>Newly added eager task execution means result may be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Task.get_context">
<span class="sig-name descname"><span class="pre">get_context</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Task.get_context" title="Link to this definition">¶</a></dt>
<dd><p>Return the <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> object
associated with the task.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Task.get_name">
<span class="sig-name descname"><span class="pre">get_name</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Task.get_name" title="Link to this definition">¶</a></dt>
<dd><p>Task의 이름을 반환합니다.</p>
<p>Task에 명시적으로 이름이 지정되지 않으면, 기본 asyncio Task 구현은 인스턴스화 중에 기본 이름을 생성합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Task.set_name">
<span class="sig-name descname"><span class="pre">set_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Task.set_name" title="Link to this definition">¶</a></dt>
<dd><p>Task의 이름을 설정합니다.</p>
<p><em>value</em> 인자는 모든 객체가 될 수 있으며, 문자열로 변환됩니다.</p>
<p>기본 Task 구현에서, 이름은 태스크 객체의 <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 출력에 표시됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Task.cancel">
<span class="sig-name descname"><span class="pre">cancel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Task.cancel" title="Link to this definition">¶</a></dt>
<dd><p>Task 취소를 요청합니다.</p>
<p>이벤트 루프의 다음 사이클에서 감싼 코루틴으로 <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a> 예외를 던져넣도록 합니다.</p>
<p>The coroutine then has a chance to clean up or even deny the
request by suppressing the exception with a <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> …
… <code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">CancelledError</span></code> … <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> block.
Therefore, unlike <a class="reference internal" href="asyncio-future.html#asyncio.Future.cancel" title="asyncio.Future.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.cancel()</span></code></a>, <a class="reference internal" href="asyncio-task.html#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Task.cancel()</span></code></a> does
not guarantee that the Task will be cancelled, although
suppressing cancellation completely is not common and is actively
discouraged.  Should the coroutine nevertheless decide to suppress
the cancellation, it needs to call <a class="reference internal" href="asyncio-task.html#asyncio.Task.uncancel" title="asyncio.Task.uncancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Task.uncancel()</span></code></a> in addition
to catching the exception.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>Added the <em>msg</em> parameter.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>The <code class="docutils literal notranslate"><span class="pre">msg</span></code> parameter is propagated from cancelled task to its awaiter.</p>
</div>
<p id="asyncio-example-task-cancel">다음 예는 코루틴이 취소 요청을 가로채는 방법을 보여줍니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">cancel_me</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cancel_me(): before sleep&#39;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Wait for 1 hour</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3600</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cancel_me(): cancel sleep&#39;</span><span class="p">)</span>
        <span class="k">raise</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cancel_me(): after sleep&#39;</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Create a &quot;cancel_me&quot; Task</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">cancel_me</span><span class="p">())</span>

    <span class="c1"># Wait for 1 second</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">task</span>
    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;main(): cancel_me is cancelled now&quot;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

<span class="c1"># Expected output:</span>
<span class="c1">#</span>
<span class="c1">#     cancel_me(): before sleep</span>
<span class="c1">#     cancel_me(): cancel sleep</span>
<span class="c1">#     cancel_me(): after sleep</span>
<span class="c1">#     main(): cancel_me is cancelled now</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Task.cancelled">
<span class="sig-name descname"><span class="pre">cancelled</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Task.cancelled" title="Link to this definition">¶</a></dt>
<dd><p>Task가 <em>취소(cancelled)</em>되었으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
<p>Task는 <a class="reference internal" href="asyncio-task.html#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancel()</span></code></a>로 취소가 요청되고 감싼 코루틴이 자신에게 전달된 <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a> 예외를 확산할 때 <em>최소(cancelled)</em>됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Task.uncancel">
<span class="sig-name descname"><span class="pre">uncancel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Task.uncancel" title="Link to this definition">¶</a></dt>
<dd><p>Decrement the count of cancellation requests to this Task.</p>
<p>Returns the remaining number of cancellation requests.</p>
<p>Note that once execution of a cancelled task completed, further
calls to <a class="reference internal" href="asyncio-task.html#asyncio.Task.uncancel" title="asyncio.Task.uncancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">uncancel()</span></code></a> are ineffective.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
<p>This method is used by asyncio’s internals and isn’t expected to be
used by end-user code.  In particular, if a Task gets successfully
uncancelled, this allows for elements of structured concurrency like
<a class="reference internal" href="asyncio-task.html#taskgroups"><span class="std std-ref">Task Groups</span></a> and <a class="reference internal" href="asyncio-task.html#asyncio.timeout" title="asyncio.timeout"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.timeout()</span></code></a> to continue running,
isolating cancellation to the respective structured block.
For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">make_request_with_timeout</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Structured block affected by the timeout:</span>
            <span class="k">await</span> <span class="n">make_request</span><span class="p">()</span>
            <span class="k">await</span> <span class="n">make_another_request</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">TimeoutError</span><span class="p">:</span>
        <span class="n">log</span><span class="p">(</span><span class="s2">&quot;There was a timeout&quot;</span><span class="p">)</span>
    <span class="c1"># Outer code not affected by the timeout:</span>
    <span class="k">await</span> <span class="n">unrelated_code</span><span class="p">()</span>
</pre></div>
</div>
<p>While the block with <code class="docutils literal notranslate"><span class="pre">make_request()</span></code> and <code class="docutils literal notranslate"><span class="pre">make_another_request()</span></code>
might get cancelled due to the timeout, <code class="docutils literal notranslate"><span class="pre">unrelated_code()</span></code> should
continue running even in case of the timeout.  This is implemented
with <a class="reference internal" href="asyncio-task.html#asyncio.Task.uncancel" title="asyncio.Task.uncancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">uncancel()</span></code></a>.  <a class="reference internal" href="asyncio-task.html#asyncio.TaskGroup" title="asyncio.TaskGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">TaskGroup</span></code></a> context managers use
<a class="reference internal" href="asyncio-task.html#asyncio.Task.uncancel" title="asyncio.Task.uncancel"><code class="xref py py-func docutils literal notranslate"><span class="pre">uncancel()</span></code></a> in a similar fashion.</p>
<p>If end-user code is, for some reason, suppressing cancellation by
catching <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a>, it needs to call this method to remove
the cancellation state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Task.cancelling">
<span class="sig-name descname"><span class="pre">cancelling</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="asyncio-task.html#asyncio.Task.cancelling" title="Link to this definition">¶</a></dt>
<dd><p>Return the number of pending cancellation requests to this Task, i.e.,
the number of calls to <a class="reference internal" href="asyncio-task.html#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancel()</span></code></a> less the number of
<a class="reference internal" href="asyncio-task.html#asyncio.Task.uncancel" title="asyncio.Task.uncancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">uncancel()</span></code></a> calls.</p>
<p>Note that if this number is greater than zero but the Task is
still executing, <a class="reference internal" href="asyncio-task.html#asyncio.Task.cancelled" title="asyncio.Task.cancelled"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancelled()</span></code></a> will still return <code class="docutils literal notranslate"><span class="pre">False</span></code>.
This is because this number can be lowered by calling <a class="reference internal" href="asyncio-task.html#asyncio.Task.uncancel" title="asyncio.Task.uncancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">uncancel()</span></code></a>,
which can lead to the task not being cancelled after all if the
cancellation requests go down to zero.</p>
<p>This method is used by asyncio’s internals and isn’t expected to be
used by end-user code.  See <a class="reference internal" href="asyncio-task.html#asyncio.Task.uncancel" title="asyncio.Task.uncancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">uncancel()</span></code></a> for more details.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="asyncio-task.html#">코루틴과 태스크</a><ul>
<li><a class="reference internal" href="asyncio-task.html#coroutines">코루틴</a></li>
<li><a class="reference internal" href="asyncio-task.html#awaitables">어웨이터블</a></li>
<li><a class="reference internal" href="asyncio-task.html#creating-tasks">태스크 만들기</a></li>
<li><a class="reference internal" href="asyncio-task.html#task-cancellation">Task Cancellation</a></li>
<li><a class="reference internal" href="asyncio-task.html#task-groups">Task Groups</a></li>
<li><a class="reference internal" href="asyncio-task.html#sleeping">잠자기</a></li>
<li><a class="reference internal" href="asyncio-task.html#running-tasks-concurrently">동시에 태스크 실행하기</a></li>
<li><a class="reference internal" href="asyncio-task.html#eager-task-factory">Eager Task Factory</a></li>
<li><a class="reference internal" href="asyncio-task.html#shielding-from-cancellation">취소로부터 보호하기</a></li>
<li><a class="reference internal" href="asyncio-task.html#timeouts">시간제한</a></li>
<li><a class="reference internal" href="asyncio-task.html#waiting-primitives">대기 프리미티브</a></li>
<li><a class="reference internal" href="asyncio-task.html#running-in-threads">스레드에서 실행하기</a></li>
<li><a class="reference internal" href="asyncio-task.html#scheduling-from-other-threads">다른 스레드에서 예약하기</a></li>
<li><a class="reference internal" href="asyncio-task.html#introspection">인트로스펙션</a></li>
<li><a class="reference internal" href="asyncio-task.html#task-object">Task 객체</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="asyncio-runner.html"
                          title="이전 장">Runners</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="asyncio-stream.html"
                          title="다음 장">스트림</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/asyncio-task.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="사이드바 닫기">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-stream.html" title="스트림"
             >다음</a> |</li>
        <li class="right" >
          <a href="asyncio-runner.html" title="Runners"
             >이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >네트워킹과 프로세스 간 통신</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> — Asynchronous I/O</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="asyncio-task.html">코루틴과 태스크</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    저작권
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="../../../license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      최종 업데이트: Jun 09, 2024 (17:23 UTC)
    
      <a href="../../../bugs.html">Found a bug</a>?
    
    <br />

    <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7 버전으로 생성되었습니다.
    </div>

    <script type="text/javascript" src="../_static/switchers.js"></script>
  </body>
</html>