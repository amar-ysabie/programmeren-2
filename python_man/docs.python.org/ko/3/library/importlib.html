<!DOCTYPE html>

<html lang="ko" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="importlib — import의 구현" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/importlib.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="소스 코드: Lib/importlib/__init__.py 소개: The purpose of the importlib package is three-fold. One is to provide the implementation of the import statement (and thus, by extension, the__import__() functi..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="소스 코드: Lib/importlib/__init__.py 소개: The purpose of the importlib package is three-fold. One is to provide the implementation of the import statement (and thus, by extension, the__import__() functi..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>importlib — import의 구현 &#8212; Python 3.12.4 문서</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css%3Fv=80d5e7a1.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css%3Fv=bb723527.css" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css%3Fv=b20cc3f5.css" />
    
    <script src="../_static/documentation_options.js%3Fv=3050f571"></script>
    <script src="../_static/doctools.js%3Fv=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js%3Fv=dc90522c"></script>
    <script src="../_static/translations.js%3Fv=b5f768d8"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.12.4 문서에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="importlib.resources – Package resource reading, opening and access" href="importlib.resources.html" />
    <link rel="prev" title="runpy — Locating and executing Python modules" href="runpy.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="../../../3/library/importlib.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" />
                <input type="submit" value="이동"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="importlib.html#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code>의 구현</a><ul>
<li><a class="reference internal" href="importlib.html#introduction">소개</a></li>
<li><a class="reference internal" href="importlib.html#functions">함수</a></li>
<li><a class="reference internal" href="importlib.html#module-importlib.abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code> – import와 관련된 추상 베이스 클래스</a></li>
<li><a class="reference internal" href="importlib.html#module-importlib.machinery"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code> – 임포터와 경로 훅</a></li>
<li><a class="reference internal" href="importlib.html#module-importlib.util"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code> – 임포터를 위한 유틸리티 코드</a></li>
<li><a class="reference internal" href="importlib.html#examples">예</a><ul>
<li><a class="reference internal" href="importlib.html#importing-programmatically">프로그래밍 방식으로 임포트 하기</a></li>
<li><a class="reference internal" href="importlib.html#checking-if-a-module-can-be-imported">모듈을 임포트 할 수 있는지 확인하기</a></li>
<li><a class="reference internal" href="importlib.html#importing-a-source-file-directly">소스 파일을 직접 임포트 하기</a></li>
<li><a class="reference internal" href="importlib.html#implementing-lazy-imports">Implementing lazy imports</a></li>
<li><a class="reference internal" href="importlib.html#setting-up-an-importer">임포터 설정하기</a></li>
<li><a class="reference internal" href="importlib.html#approximating-importlib-import-module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code> 근사하기</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="runpy.html"
                          title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code> — Locating and executing Python modules</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="importlib.resources.html"
                          title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code> – Package resource reading, opening and access</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/importlib.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="importlib.resources.html" title="importlib.resources – Package resource reading, opening and access"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="runpy — Locating and executing Python modules"
             accesskey="P">이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" accesskey="U">모듈 임포트 하기</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="importlib.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code>의 구현</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-importlib">
<span id="importlib-the-implementation-of-import"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code>의 구현<a class="headerlink" href="importlib.html#module-importlib" title="Link to this heading">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.1.</span></p>
</div>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/importlib/__init__.py">Lib/importlib/__init__.py</a></p>
<hr class="docutils" />
<section id="introduction">
<h2>소개<a class="headerlink" href="importlib.html#introduction" title="Link to this heading">¶</a></h2>
<p>The purpose of the <a class="reference internal" href="importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> package is three-fold.</p>
<p>One is to provide the
implementation of the <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> statement (and thus, by extension, the
<a class="reference internal" href="functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> function) in Python source code. This provides an
implementation of <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> which is portable to any Python
interpreter. This also provides an implementation which is easier to
comprehend than one implemented in a programming language other than Python.</p>
<p>둘째, <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>를 구현하는 구성 요소가 이 패키지에서 노출되어, 사용자가 임포트 프로세스에 참여하기 위해 자신의 사용자 지정 객체(일반적으로 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">임포터</span></a>라고 합니다)를 쉽게 만들 수 있도록 합니다.</p>
<p>Three, the package contains modules exposing additional functionality for
managing aspects of Python packages:</p>
<ul class="simple">
<li><p><a class="reference internal" href="importlib.metadata.html#module-importlib.metadata" title="importlib.metadata: Accessing package metadata"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.metadata</span></code></a> presents access to metadata from third-party
distributions.</p></li>
<li><p><a class="reference internal" href="importlib.resources.html#module-importlib.resources" title="importlib.resources: Package resource reading, opening, and access"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code></a> provides routines for accessing non-code
“resources” from Python packages.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><a class="reference internal" href="../reference/simple_stmts.html#import"><span class="std std-ref">임포트(import) 문</span></a></dt><dd><p><a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문의 언어 레퍼런스.</p>
</dd>
<dt><a class="reference external" href="https://www.python.org/doc/essays/packages/">패키지 명세</a></dt><dd><p>패키지의 원래 명세. 이 문서를 작성한 이후로 일부 의미가 변경되었습니다 (예를 들어 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 기반으로 하는 리디렉션).</p>
</dd>
<dt><a class="reference internal" href="importlib.html#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수</dt><dd><p><a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문은 이 함수의 편의 문법입니다.</p>
</dd>
<dt><a class="reference internal" href="sys_path_init.html#sys-path-init"><span class="std std-ref">The initialization of the sys.path module search path</span></a></dt><dd><p>The initialization of <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>.</p>
</dd>
<dt><span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0235/"><strong>PEP 235</strong></a></dt><dd><p>대소 문자를 구분하지 않는 플랫폼에서의 임포트</p>
</dd>
<dt><span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0263/"><strong>PEP 263</strong></a></dt><dd><p>파이썬 소스 코드 인코딩 정의</p>
</dd>
<dt><span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a></dt><dd><p>새로운 임포트 훅</p>
</dd>
<dt><span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0328/"><strong>PEP 328</strong></a></dt><dd><p>임포트: 다중 줄과 절대/상대</p>
</dd>
<dt><span class="target" id="index-4"></span><a class="pep reference external" href="https://peps.python.org/pep-0366/"><strong>PEP 366</strong></a></dt><dd><p>메인 모듈 명시적 상대 임포트</p>
</dd>
<dt><span class="target" id="index-5"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a></dt><dd><p>묵시적 이름 공간 패키지</p>
</dd>
<dt><span class="target" id="index-6"></span><a class="pep reference external" href="https://peps.python.org/pep-0451/"><strong>PEP 451</strong></a></dt><dd><p>임포트 시스템을 위한 ModuleSpec 형</p>
</dd>
<dt><span class="target" id="index-7"></span><a class="pep reference external" href="https://peps.python.org/pep-0488/"><strong>PEP 488</strong></a></dt><dd><p>PYO 파일 제거</p>
</dd>
<dt><span class="target" id="index-8"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a></dt><dd><p>다단계 확장 모듈 초기화</p>
</dd>
<dt><span class="target" id="index-9"></span><a class="pep reference external" href="https://peps.python.org/pep-0552/"><strong>PEP 552</strong></a></dt><dd><p>결정론적 pyc</p>
</dd>
<dt><span class="target" id="index-10"></span><a class="pep reference external" href="https://peps.python.org/pep-3120/"><strong>PEP 3120</strong></a></dt><dd><p>UTF-8을 기본 소스 인코딩으로 사용하기</p>
</dd>
<dt><span class="target" id="index-11"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a></dt><dd><p>PYC 저장소 디렉터리</p>
</dd>
</dl>
</div>
</section>
<section id="functions">
<h2>함수<a class="headerlink" href="importlib.html#functions" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="importlib.__import__">
<span class="sig-prename descclassname"><span class="pre">importlib.</span></span><span class="sig-name descname"><span class="pre">__import__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fromlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.__import__" title="Link to this definition">¶</a></dt>
<dd><p>내장 <a class="reference internal" href="functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수의 구현.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>프로그래밍 방식으로 모듈을 임포트 하려면 이 함수 대신 <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a>을 사용해야 합니다.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.import_module">
<span class="sig-prename descclassname"><span class="pre">importlib.</span></span><span class="sig-name descname"><span class="pre">import_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">package</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.import_module" title="Link to this definition">¶</a></dt>
<dd><p>모듈을 임포트 합니다. <em>name</em> 인자는 절대나 상대적인 항으로 임포트 할 모듈을 지정합니다 (예를 들어 <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>나 <code class="docutils literal notranslate"><span class="pre">..mod</span></code>). 이름이 상대적인 항으로 지정되면, <em>package</em> 인자는 패키지 이름을 결정하기 위한 앵커 역할을 하는 패키지 이름으로 설정해야 합니다 (예를 들어 <code class="docutils literal notranslate"><span class="pre">import_module('..mod',</span> <span class="pre">'pkg.subpkg')</span></code>는 <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>를 임포트 합니다).</p>
<p><a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> 함수는 <a class="reference internal" href="importlib.html#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.__import__()</span></code></a> 주위를 감싸는 단순화 래퍼 역할을 합니다. 이는 함수의 모든 의미가 <a class="reference internal" href="importlib.html#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.__import__()</span></code></a>에서 파생됨을 뜻합니다. 이 두 함수의 가장 중요한 차이점은 <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a>이 지정된 패키지나 모듈(예를 들어 <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>)을 반환하는 반면, <a class="reference internal" href="functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>는 최상위 패키지나 모듈(예를 들어 <code class="docutils literal notranslate"><span class="pre">pkg</span></code>)을 반환한다는 것입니다.</p>
<p>인터프리터가 실행을 시작한 이후 만들어진 모듈(예를 들어, 파이썬 소스 파일을 만들면)을 동적으로 임포트 하는 경우, 임포트 시스템에서 새 모듈을 알 수 있도록 <a class="reference internal" href="importlib.html#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">invalidate_caches()</span></code></a>를 호출해야 할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>부모 패키지는 자동으로 임포트 됩니다.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.invalidate_caches">
<span class="sig-prename descclassname"><span class="pre">importlib.</span></span><span class="sig-name descname"><span class="pre">invalidate_caches</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.invalidate_caches" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>에 저장된 파인더의 내부 캐시를 무효로 합니다. 파인더가 <code class="docutils literal notranslate"><span class="pre">invalidate_caches()</span></code>를 구현하면 무효화를 수행하기 위해 호출됩니다. 모든 파인더가 새로운 모듈의 존재를 알 수 있도록 프로그램이 실행되는 동안 모듈이 만들어진/설치된 경우 이 함수를 호출해야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.10에서 변경: </span>Namespace packages created/installed in a different <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>
location after the same namespace was already imported are noticed.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.reload">
<span class="sig-prename descclassname"><span class="pre">importlib.</span></span><span class="sig-name descname"><span class="pre">reload</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.reload" title="Link to this definition">¶</a></dt>
<dd><p>이전에 임포트 한 <em>module</em>을 다시 로드합니다. 인자는 모듈 객체여야 해서, 이전에 성공적으로 임포트 됐어야 합니다. 외부 편집기를 사용하여 모듈 소스 파일을 편집했고 파이썬 인터프리터를 떠나지 않고 새 버전을 시험해보고 싶을 때 유용합니다. 반환 값은 모듈 객체입니다 (재 임포트로 인해 다른 객체가 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 배치되면 다를 수 있습니다).</p>
<p><a class="reference internal" href="importlib.html#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a>가 실행될 때:</p>
<ul class="simple">
<li><p>파이썬 모듈의 코드가 다시 컴파일되고 모듈 수준 코드가 다시 실행되어, 원래 모듈을 로드한 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>를 재사용하여 모듈 딕셔너리에 있는 이름에 연결되는 새로운 객체 집합을 정의합니다. 확장 모듈의 <code class="docutils literal notranslate"><span class="pre">init</span></code> 함수는 두 번째에는 호출되지 않습니다.</p></li>
<li><p>파이썬의 다른 모든 객체와 마찬가지로 이전 객체는 참조 횟수가 0으로 떨어진 후에만 자원이 회수됩니다.</p></li>
<li><p>모듈 이름 공간의 이름은 새로운 객체나 변경된 객체를 가리키도록 갱신됩니다.</p></li>
<li><p>이전 객체에 대한 다른 참조(가령 모듈 외부의 이름)는 새 객체를 참조하기 위해 다시 연결되지 않으며 필요하다면 그들이 등장하는 각 이름 공간에서 갱신되어야 합니다.</p></li>
</ul>
<p>다른 여러 가지 경고가 있습니다:</p>
<p>모듈을 다시 로드할 때, 그것의 (모듈의 전역 변수를 포함하는) 딕셔너리가 유지됩니다. 이름을 재정의하면 이전 정의를 대체해서, 일반적으로 문제가 되지 않습니다. 새 버전의 모듈이 이전 버전이 정의한 이름을 정의하지 않으면, 이전 정의가 그대로 남습니다. 이 기능은 객체의 전역 테이블이나 캐시를 유지한다면 모듈의 이점으로 사용될 수 있습니다 — <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 문으로 테이블의 존재를 검사하고 필요하다면 초기화를 건너뛸 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">cache</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p>일반적으로 내장이나 동적으로 로드된 모듈을 다시 로드하는 것은 그리 유용하지 않습니다. <a class="reference internal" href="sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>, <a class="reference internal" href="__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a>, <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 및 기타 주요 모듈을 다시 로드하지 않는 것이 좋습니다. 많은 경우 확장 모듈은 두 번 이상 초기화되도록 설계되지 않았으며, 다시 로드할 때 임의의 방식으로 실패할 수 있습니다.</p>
<p>모듈이 <a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> … <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> …를 사용하여 다른 모듈에서 객체를 임포트 하면, 다른 모듈에 대해 <a class="reference internal" href="importlib.html#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a>를 호출해도 그것에서 임포트 한 객체를 재정의하지 않습니다 — 이것을 피하는 한 가지 방법은 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code> 문을 다시 실행하는 것입니다, 다른 방법은 대신 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code>와 정규화된 이름(<em>module.name</em>)을 사용하는 것입니다.</p>
<p>모듈이 클래스의 인스턴스를 인스턴스 화하면, 클래스를 정의하는 모듈을 다시 로드해도 인스턴스의 메서드 정의에는 영향을 미치지 않습니다 — 이전 클래스 정의를 계속 사용합니다. 파생 클래스의 경우도 마찬가지입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> is raised when the module being reloaded lacks
a <a class="reference internal" href="importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="module-importlib.abc">
<span id="importlib-abc-abstract-base-classes-related-to-import"></span><h2><a class="reference internal" href="importlib.html#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> – import와 관련된 추상 베이스 클래스<a class="headerlink" href="importlib.html#module-importlib.abc" title="Link to this heading">¶</a></h2>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/importlib/abc.py">Lib/importlib/abc.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="importlib.html#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> 모듈에는 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>에서 사용하는 모든 핵심 추상 베이스 클래스가 포함되어 있습니다. 핵심 ABC 구현에 도움이 되도록 핵심 추상 베이스 클래스의 일부 서브 클래스도 제공됩니다.</p>
<p>ABC 계층:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">object</span>
 <span class="o">+--</span> <span class="n">MetaPathFinder</span>
 <span class="o">+--</span> <span class="n">PathEntryFinder</span>
 <span class="o">+--</span> <span class="n">Loader</span>
      <span class="o">+--</span> <span class="n">ResourceLoader</span> <span class="o">--------+</span>
      <span class="o">+--</span> <span class="n">InspectLoader</span>          <span class="o">|</span>
           <span class="o">+--</span> <span class="n">ExecutionLoader</span> <span class="o">--+</span>
                                 <span class="o">+--</span> <span class="n">FileLoader</span>
                                 <span class="o">+--</span> <span class="n">SourceLoader</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.MetaPathFinder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">MetaPathFinder</span></span><a class="headerlink" href="importlib.html#importlib.abc.MetaPathFinder" title="Link to this definition">¶</a></dt>
<dd><p>An abstract base class representing a <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.10에서 변경: </span>No longer a subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">Finder</span></code>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.MetaPathFinder.find_spec">
<span class="sig-name descname"><span class="pre">find_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.MetaPathFinder.find_spec" title="Link to this definition">¶</a></dt>
<dd><p>지정된 모듈의 <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">스펙</span></a>을 찾는 추상 메서드. 최상위 임포트 인 경우, <em>path</em>는 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. 그렇지 않으면, 이것은 서브 패키지나 모듈의 검색이 되고, <em>path</em>는 부모 패키지의 <a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> 값입니다. 스펙을 찾을 수 없으면, <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다. 전달될 때, <code class="docutils literal notranslate"><span class="pre">target</span></code>은 파인더가 반환할 스펙에 대해 더 정교하게 추측하기 위해 사용할 수 있는 모듈 객체입니다. <a class="reference internal" href="importlib.html#importlib.util.spec_from_loader" title="importlib.util.spec_from_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.spec_from_loader()</span></code></a>는 구상 <code class="docutils literal notranslate"><span class="pre">MetaPathFinders</span></code>를 구현하는 데 유용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.MetaPathFinder.invalidate_caches">
<span class="sig-name descname"><span class="pre">invalidate_caches</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.MetaPathFinder.invalidate_caches" title="Link to this definition">¶</a></dt>
<dd><p>호출될 때, 파인더가 사용하는 내부 캐시를 무효로 해야 하는 선택적 메서드. <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>에서 모든 파인더의 캐시를 무효로 할 때 <a class="reference internal" href="importlib.html#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.invalidate_caches()</span></code></a>에서 사용합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>Returns <code class="docutils literal notranslate"><span class="pre">None</span></code> when called instead of <a class="reference internal" href="constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.PathEntryFinder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">PathEntryFinder</span></span><a class="headerlink" href="importlib.html#importlib.abc.PathEntryFinder" title="Link to this definition">¶</a></dt>
<dd><p>An abstract base class representing a <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a>.  Though
it bears some similarities to <a class="reference internal" href="importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaPathFinder</span></code></a>, <code class="docutils literal notranslate"><span class="pre">PathEntryFinder</span></code>
is meant for use only within the path-based import subsystem provided
by <a class="reference internal" href="importlib.html#importlib.machinery.PathFinder" title="importlib.machinery.PathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.10에서 변경: </span>No longer a subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">Finder</span></code>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.PathEntryFinder.find_spec">
<span class="sig-name descname"><span class="pre">find_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.PathEntryFinder.find_spec" title="Link to this definition">¶</a></dt>
<dd><p>지정된 모듈의 <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">스펙</span></a>을 찾는 추상 메서드. 파인더는 할당된 <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">경로 엔트리</span></a> 내에서만 모듈을 검색합니다. 스펙을 찾을 수 없으면, <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다. 전달될 때, <code class="docutils literal notranslate"><span class="pre">target</span></code>은 파인더가 반환할 스펙에 대해 더 정교하게 추측하기 위해 사용할 수 있는 모듈 객체입니다. <a class="reference internal" href="importlib.html#importlib.util.spec_from_loader" title="importlib.util.spec_from_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.spec_from_loader()</span></code></a>는 구상 <code class="docutils literal notranslate"><span class="pre">PathEntryFinders</span></code>를 구현하는 데 유용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.PathEntryFinder.invalidate_caches">
<span class="sig-name descname"><span class="pre">invalidate_caches</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.PathEntryFinder.invalidate_caches" title="Link to this definition">¶</a></dt>
<dd><p>An optional method which, when called, should invalidate any internal
cache used by the finder. Used by
<a class="reference internal" href="importlib.html#importlib.machinery.PathFinder.invalidate_caches" title="importlib.machinery.PathFinder.invalidate_caches"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder.invalidate_caches()</span></code></a>
when invalidating the caches of all cached finders.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.Loader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">Loader</span></span><a class="headerlink" href="importlib.html#importlib.abc.Loader" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>의 추상 베이스 클래스. 로더에 대한 정확한 정의는 <span class="target" id="index-39"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a>를 참조하십시오.</p>
<p>Loaders that wish to support resource reading should implement a
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_resource_reader()</span></code> method as specified by
<a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.ResourceReader" title="importlib.resources.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.ResourceReader</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>Introduced the optional <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_resource_reader()</span></code> method.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Loader.create_module">
<span class="sig-name descname"><span class="pre">create_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.Loader.create_module" title="Link to this definition">¶</a></dt>
<dd><p>모듈을 임포트 할 때 사용할 모듈 객체를 반환하는 메서드. 이 메서드는 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환해서 기본 모듈 생성 시맨틱이 적용되어야 함을 나타낼 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>This method is no longer optional when
<a class="reference internal" href="importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> is defined.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Loader.exec_module">
<span class="sig-name descname"><span class="pre">exec_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.Loader.exec_module" title="Link to this definition">¶</a></dt>
<dd><p>An abstract method that executes the module in its own namespace
when a module is imported or reloaded.  The module should already
be initialized when <a class="reference internal" href="importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> is called.  When this method exists,
<a class="reference internal" href="importlib.html#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> must be defined.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="importlib.html#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> must also be defined.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Loader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.Loader.load_module" title="Link to this definition">¶</a></dt>
<dd><p>A legacy method for loading a module.  If the module cannot be
loaded, <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> is raised, otherwise the loaded module is
returned.</p>
<p>If the requested module already exists in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, that
module should be used and reloaded.
Otherwise the loader should create a new module and insert it into
<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> before any loading begins, to prevent recursion
from the import.  If the loader inserted a module and the load fails, it
must be removed by the loader from <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>; modules already
in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> before the loader began execution should be left
alone.</p>
<p>The loader should set several attributes on the module
(note that some of these attributes can change when a module is
reloaded):</p>
<ul class="simple">
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></dt><dd><p>The module’s fully qualified name.
It is <code class="docutils literal notranslate"><span class="pre">'__main__'</span></code> for an executed module.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a></dt><dd><p>The location the <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> used to load the module.
For example, for modules loaded from a .py file this is the filename.
It is not set on all modules (e.g. built-in modules).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#cached__" title="__cached__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code></a></dt><dd><p>The filename of a compiled version of the module’s code.
It is not set on all modules (e.g. built-in modules).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a></dt><dd><p>The list of locations where the package’s submodules will be found.
Most of the time this is a single directory.
The import system passes this attribute to <code class="docutils literal notranslate"><span class="pre">__import__()</span></code> and to finders
in the same way as <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> but just for the package.
It is not set on non-package modules so it can be used
as an indicator that the module is a package.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a></dt><dd><p>The fully qualified name of the package the module is in (or the
empty string for a top-level module).
If the module is a package then this is the same as <a class="reference internal" href="../reference/import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a></dt><dd><p>The <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> used to load the module.</p>
</dd>
</dl>
</li>
</ul>
<p><a class="reference internal" href="importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>을 사용할 수 있으면 이전 버전과 호환되는 기능이 제공됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>Raise <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> when called instead of
<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.  Functionality provided when
<a class="reference internal" href="importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> is available.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지됨: </span>The recommended API for loading a module is <a class="reference internal" href="importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>
(and <a class="reference internal" href="importlib.html#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>).  Loaders should implement it instead of
<a class="reference internal" href="importlib.html#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code></a>.  The import machinery takes care of all the
other responsibilities of <a class="reference internal" href="importlib.html#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code></a> when
<a class="reference internal" href="importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> is implemented.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.ResourceLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">ResourceLoader</span></span><a class="headerlink" href="importlib.html#importlib.abc.ResourceLoader" title="Link to this definition">¶</a></dt>
<dd><p>스토리지 백 엔드에서 임의의 리소스를 로드하기 위한 선택적 <span class="target" id="index-40"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> 프로토콜을 구현하는 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>의 추상 베이스 클래스.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.7부터 폐지됨: </span>This ABC is deprecated in favour of supporting resource loading
through <a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.ResourceReader" title="importlib.resources.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.ResourceReader</span></code></a>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.ResourceLoader.get_data">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">get_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.ResourceLoader.get_data" title="Link to this definition">¶</a></dt>
<dd><p><em>path</em>에 있는 데이터를 바이트열로 반환하는 추상 메서드. 임의의 데이터를 저장할 수 있는 파일류 스토리지 백 엔드가 있는 로더는 이 추상 메서드를 구현하여 저장된 데이터에 직접 액세스하도록 할 수 있습니다. <em>path</em>를 찾을 수 없으면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생합니다. <em>path</em>는 모듈의 <a class="reference internal" href="../reference/import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> 어트리뷰트나 패키지의 <a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a>에서 온 항목을 사용하여 구성될 것으로 기대됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">InspectLoader</span></span><a class="headerlink" href="importlib.html#importlib.abc.InspectLoader" title="Link to this definition">¶</a></dt>
<dd><p>모듈을 검사(inspect)하는 로더를 위한 선택적 <span class="target" id="index-41"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> 프로토콜을 구현하는 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>의 추상 베이스 클래스.</p>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.get_code">
<span class="sig-name descname"><span class="pre">get_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.InspectLoader.get_code" title="Link to this definition">¶</a></dt>
<dd><p>모듈에 대한 코드 객체나, 모듈에 코드 객체가 없으면 (예를 들어, 내장 모듈이 이런 경우입니다) <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. 로더가 요청한 모듈을 찾을 수 없으면 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>가 발생합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 메서드에는 기본 구현이 있지만, 가능하다면 성능을 위해 재정의하는 것이 좋습니다.</p>
</div>
<div class="versionchanged" id="index-15">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>더는 추상적이지 않고 구상 구현이 제공됩니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.get_source">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">get_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.InspectLoader.get_source" title="Link to this definition">¶</a></dt>
<dd><p>모듈의 소스를 반환하는 추상 메서드. 인식된 모든 줄 구분자를 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 문자로 변환하는 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">유니버설 줄 넘김</span></a>을 사용하여 텍스트 문자열로 반환됩니다. 사용 가능한 소스가 없으면 (예를 들어, 내장 모듈) <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. 로더가 지정된 모듈을 찾을 수 없으면 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.is_package">
<span class="sig-name descname"><span class="pre">is_package</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.InspectLoader.is_package" title="Link to this definition">¶</a></dt>
<dd><p>An optional method to return a true value if the module is a package, a
false value otherwise. <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> is raised if the
<a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> cannot find the module.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.source_to_code">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">source_to_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'&lt;string&gt;'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.InspectLoader.source_to_code" title="Link to this definition">¶</a></dt>
<dd><p>파이썬 소스에서 코드 객체를 만듭니다.</p>
<p><em>data</em> 인자는 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 함수가 지원하는 것은 무엇이든 될 수 있습니다 (즉 문자열이나 바이트열). <em>path</em> 인자는 소스 코드가 온 곳의 “경로”여야 하며, 추상 개념(예를 들어 zip 파일에서의 위치)일 수 있습니다.</p>
<p>후속 코드 객체를 사용하면 <code class="docutils literal notranslate"><span class="pre">exec(code,</span> <span class="pre">module.__dict__)</span></code>를 실행하여 그 코드를 모듈에서 실행할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>메서드를 정적(static)으로 만들었습니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.exec_module">
<span class="sig-name descname"><span class="pre">exec_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.InspectLoader.exec_module" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a>의 구현.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.InspectLoader.load_module" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.load_module()</span></code></a>의 구현.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지됨: </span>대신 <a class="reference internal" href="importlib.html#importlib.abc.InspectLoader.exec_module" title="importlib.abc.InspectLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.ExecutionLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">ExecutionLoader</span></span><a class="headerlink" href="importlib.html#importlib.abc.ExecutionLoader" title="Link to this definition">¶</a></dt>
<dd><p>구현될 때, 모듈이 스크립트로 실행되도록 돕는 <a class="reference internal" href="importlib.html#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">InspectLoader</span></code></a>에서 상속되는 추상 베이스 클래스. ABC는 선택적 <span class="target" id="index-42"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> 프로토콜을 표현합니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.ExecutionLoader.get_filename">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">get_filename</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.ExecutionLoader.get_filename" title="Link to this definition">¶</a></dt>
<dd><p>지정된 모듈의 <a class="reference internal" href="../reference/import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> 값을 반환하는 추상 메서드. 사용 가능한 경로가 없으면 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>가 발생합니다.</p>
<p>소스 코드를 사용할 수 있으면, 메서드는 모듈을 로드하는 데 바이트 코드를 사용했는지와 관계없이 소스 파일의 경로를 반환해야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.FileLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">FileLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.FileLoader" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResourceLoader</span></code></a>와 <a class="reference internal" href="importlib.html#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExecutionLoader</span></code></a>를 상속하고 <a class="reference internal" href="importlib.html#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResourceLoader.get_data()</span></code></a>와 <a class="reference internal" href="importlib.html#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a>의 구상 구현을 제공하는 추상 베이스 클래스.</p>
<p><em>fullname</em> 인자는 로더가 처리해야 하는 모듈의 완전히 결정된(resolved) 이름입니다. <em>path</em> 인자는 모듈의 파일 경로입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.abc.FileLoader.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="importlib.html#importlib.abc.FileLoader.name" title="Link to this definition">¶</a></dt>
<dd><p>로더가 처리할 수 있는 모듈의 이름.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.abc.FileLoader.path">
<span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="importlib.html#importlib.abc.FileLoader.path" title="Link to this definition">¶</a></dt>
<dd><p>모듈 파일의 경로.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.FileLoader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.FileLoader.load_module" title="Link to this definition">¶</a></dt>
<dd><p>super의 <code class="docutils literal notranslate"><span class="pre">load_module()</span></code>을 호출합니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지됨: </span>대신 <a class="reference internal" href="importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.FileLoader.get_filename">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">get_filename</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.FileLoader.get_filename" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.abc.FileLoader.path" title="importlib.abc.FileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.FileLoader.get_data">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">get_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.FileLoader.get_data" title="Link to this definition">¶</a></dt>
<dd><p><em>path</em>를 바이너리 파일로 읽고 그것의 바이트열을 반환합니다.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">SourceLoader</span></span><a class="headerlink" href="importlib.html#importlib.abc.SourceLoader" title="Link to this definition">¶</a></dt>
<dd><p>소스 (및 선택적으로 바이트 코드) 파일 로드를 구현하기 위한 추상 베이스 클래스. 이 클래스는 <a class="reference internal" href="importlib.html#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResourceLoader</span></code></a>와 <a class="reference internal" href="importlib.html#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExecutionLoader</span></code></a>를 모두 상속하며, 다음을 구현해야 합니다:</p>
<ul class="simple">
<li><p><a class="reference internal" href="importlib.html#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResourceLoader.get_data()</span></code></a></p></li>
<li><dl class="simple">
<dt><a class="reference internal" href="importlib.html#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a></dt><dd><p>소스 파일의 경로만 반환해야 합니다; 소스 없는 로딩은 지원되지 않습니다.</p>
</dd>
</dl>
</li>
</ul>
<p>이 클래스에 의해 정의된 추상 메서드는 선택적 바이트 코드 파일 지원을 추가하는 것입니다. 이러한 선택적 메서드를 구현하지 않으면 (또는 그들이 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시키도록 하면) 로더가 소스 코드에 대해서만 작동하도록 만듭니다. 메서드를 구현하면 로더가 소스*와* 바이트 코드 파일 모두에 대해 작동하게 할 수 있습니다; 바이트 코드만 제공되는 <em>소스 없는</em> 로드는 허용하지 않습니다. 바이트 코드 파일은 파이썬 컴파일러의 구문 분석 단계를 제거하여 로딩 속도를 높이기 위한 최적화라서, 바이트 코드 전용 API는 노출되지 않습니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.path_stats">
<span class="sig-name descname"><span class="pre">path_stats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.SourceLoader.path_stats" title="Link to this definition">¶</a></dt>
<dd><p>지정된 경로에 대한 메타 데이터를 포함하는 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>를 반환하는 선택적 추상 메서드. 지원되는 딕셔너리 키는 다음과 같습니다:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'mtime'</span></code> (필수): 소스 코드의 수정 시간을 나타내는 정수나 부동 소수점 숫자;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'size'</span></code> (선택): 바이트 단위의 소스 코드의 크기.</p></li>
</ul>
<p>향후 확장을 위해, 딕셔너리의 다른 키는 무시됩니다. 경로를 처리할 수 없으면, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.path_mtime">
<span class="sig-name descname"><span class="pre">path_mtime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.SourceLoader.path_mtime" title="Link to this definition">¶</a></dt>
<dd><p>지정된 경로의 수정 시간을 반환하는 선택적 추상 메서드.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지됨: </span>이 메서드는 폐지되었고 <a class="reference internal" href="importlib.html#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">path_stats()</span></code></a>로 대체되었습니다. 구현할 필요는 없지만, 호환성을 위해 여전히 제공됩니다. 경로를 처리할 수 없으면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>를 발생시킵니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.set_data">
<span class="sig-name descname"><span class="pre">set_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.SourceLoader.set_data" title="Link to this definition">¶</a></dt>
<dd><p>지정된 바이트열을 파일 경로에 쓰는 선택적 추상 메서드. 존재하지 않는 중간 디렉터리는 자동으로 만들어집니다.</p>
<p>When writing to the path fails because the path is read-only
(<a class="reference internal" href="errno.html#errno.EACCES" title="errno.EACCES"><code class="xref py py-const docutils literal notranslate"><span class="pre">errno.EACCES</span></code></a>/<a class="reference internal" href="exceptions.html#PermissionError" title="PermissionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PermissionError</span></code></a>), do not propagate the
exception.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>호출할 때 더는 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시키지 않습니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.get_code">
<span class="sig-name descname"><span class="pre">get_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.SourceLoader.get_code" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.abc.InspectLoader.get_code" title="importlib.abc.InspectLoader.get_code"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.get_code()</span></code></a>의 구상 구현.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.exec_module">
<span class="sig-name descname"><span class="pre">exec_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.SourceLoader.exec_module" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a>의 구상 구현.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.SourceLoader.load_module" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.load_module()</span></code></a>의 구상 구현.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지됨: </span>대신 <a class="reference internal" href="importlib.html#importlib.abc.SourceLoader.exec_module" title="importlib.abc.SourceLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.get_source">
<span class="sig-name descname"><span class="pre">get_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.SourceLoader.get_source" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.get_source()</span></code></a>의 구상 구현.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.is_package">
<span class="sig-name descname"><span class="pre">is_package</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.SourceLoader.is_package" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.is_package()</span></code></a>의 구상 구현. (<a class="reference internal" href="importlib.html#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a>에서 제공되는) 파일 경로가 파일 확장자를 제거했을 때 <code class="docutils literal notranslate"><span class="pre">__init__</span></code>라는 이름의 파일이고 <em>동시에</em> 모듈 이름 자체가 <code class="docutils literal notranslate"><span class="pre">__init__</span></code>로 끝나지 않으면 모듈은 패키지로 결정됩니다.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.ResourceReader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">ResourceReader</span></span><a class="headerlink" href="importlib.html#importlib.abc.ResourceReader" title="Link to this definition">¶</a></dt>
<dd><p><em>Superseded by TraversableResources</em></p>
<p><em>리소스(resources)</em>를 읽을 수 있는 기능을 제공하는 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">추상 베이스 클래스</span></a>.</p>
<p>이 ABC의 관점에서, <em>리소스(resource)</em>는 패키지 내에 제공되는 바이너리 아티팩트(artifact)입니다. 일반적으로 이것은 패키지의 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 파일 옆에 있는 데이터 파일 같은 것입니다. 이 클래스의 목적은 이러한 데이터 파일에 대한 액세스를 추상화하여 패키지와 해당 데이터 파일이 예를 들어 zip 파일에 있는지 파일 시스템에 저장되어 있는지가 중요하지 않도록 만드는 것입니다.</p>
<p>이 클래스의 모든 메서드에서, <em>resource</em> 인자는 개념적으로 단지 파일 이름을 나타내는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>가 될 것으로 기대됩니다. 이는 <em>resource</em> 인자에 서브 디렉터리 경로가 포함되지 않아야 함을 의미합니다. 판독기(reader)가 읽으려는 패키지의 위치가 “디렉터리”의 역할을 하기 때문입니다. 따라서 디렉터리와 파일 이름에 대한 은유는 각각 패키지와 리소스입니다. 이것은 또한 이 클래스의 인스턴스가 (잠재적으로 여러 패키지나 모듈을 나타내는 대신) 특정 패키지와 직접적으로 연관될 것으로 기대되는 이유입니다.</p>
<p>리소스 읽기를 지원하려는 로더는 이 ABC의 인터페이스를 구현하는 객체를 반환하는 <code class="docutils literal notranslate"><span class="pre">get_resource_reader(fullname)</span></code>이라는 메서드를 제공해야 합니다. fullname으로 지정된 모듈이 패키지가 아니면, 이 메서드는 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환해야 합니다. 이 ABC와 호환되는 객체는 지정된 모듈이 패키지일 때만 반환해야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">버전 3.12에서 폐지되었습니다, 버전 3.14에서 제거됩니다.: </span>Use <a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.TraversableResources" title="importlib.resources.abc.TraversableResources"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.TraversableResources</span></code></a> instead.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.ResourceReader.open_resource">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">open_resource</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">resource</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.ResourceReader.open_resource" title="Link to this definition">¶</a></dt>
<dd><p><em>resource</em>의 바이너리 읽기를 위해 열린 <a class="reference internal" href="../glossary.html#term-file-like-object"><span class="xref std std-term">파일류 객체</span></a>를 반환합니다.</p>
<p>리소스를 찾을 수 없으면, <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a> 가 발생합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.ResourceReader.resource_path">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">resource_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">resource</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.ResourceReader.resource_path" title="Link to this definition">¶</a></dt>
<dd><p><em>resource</em>에 대한 파일 시스템 경로를 반환합니다.</p>
<p>리소스가 파일 시스템에 구체적으로 존재하지 않으면, <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a> 가 발생합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.ResourceReader.is_resource">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">is_resource</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.ResourceReader.is_resource" title="Link to this definition">¶</a></dt>
<dd><p>명명된 <em>name</em>을 리소스로 간주하면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다. <em>name</em>이 없으면, <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a> 가 발생합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.ResourceReader.contents">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">contents</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.ResourceReader.contents" title="Link to this definition">¶</a></dt>
<dd><p>패키지 내용에 대한 문자열의 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">이터러블</span></a>을 반환합니다. 이터레이터가 반환한 모든 이름이 실제 리소스일 필요는 없음에 유의하십시오, 예를 들어 <a class="reference internal" href="importlib.html#importlib.abc.ResourceReader.is_resource" title="importlib.abc.ResourceReader.is_resource"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_resource()</span></code></a>가 거짓인 이름을 반환하는 것이 허용됩니다.</p>
<p>리소스가 아닌 이름이 반환되도록 하는 것은 패키지와 그것의 리소스가 저장되는 방법이 사전에 알려졌고 리소스가 아닌 이름이 유용한 상황을 허용하기 위함입니다. 예를 들어, 패키지와 리소스가 파일 시스템에 저장되어있는 것으로 알려졌을 때 해당 서브 디렉터리 이름을 직접 사용할 수 있도록 서브 디렉터리 이름 반환이 허용됩니다.</p>
<p>추상 메서드는 항목이 없는 이터러블을 반환합니다.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.Traversable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">Traversable</span></span><a class="headerlink" href="importlib.html#importlib.abc.Traversable" title="Link to this definition">¶</a></dt>
<dd><p>An object with a subset of <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> methods suitable for
traversing directories and opening files.</p>
<p>For a representation of the object on the file-system, use
<a class="reference internal" href="importlib.resources.html#importlib.resources.as_file" title="importlib.resources.as_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.resources.as_file()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">버전 3.12에서 폐지되었습니다, 버전 3.14에서 제거됩니다.: </span>Use <a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.Traversable" title="importlib.resources.abc.Traversable"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.Traversable</span></code></a> instead.</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.abc.Traversable.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="importlib.html#importlib.abc.Traversable.name" title="Link to this definition">¶</a></dt>
<dd><p>Abstract. The base name of this object without any parent references.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Traversable.iterdir">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">iterdir</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.Traversable.iterdir" title="Link to this definition">¶</a></dt>
<dd><p>Yield <code class="docutils literal notranslate"><span class="pre">Traversable</span></code> objects in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Traversable.is_dir">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">is_dir</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.Traversable.is_dir" title="Link to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">self</span></code> is a directory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Traversable.is_file">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">is_file</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.Traversable.is_file" title="Link to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">self</span></code> is a file.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Traversable.joinpath">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">joinpath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">child</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.Traversable.joinpath" title="Link to this definition">¶</a></dt>
<dd><p>Return Traversable child in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Traversable.__truediv__">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">child</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.Traversable.__truediv__" title="Link to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">Traversable</span></code> child in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Traversable.open">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'r'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.Traversable.open" title="Link to this definition">¶</a></dt>
<dd><p><em>mode</em> may be ‘r’ or ‘rb’ to open as text or binary. Return a handle
suitable for reading (same as <a class="reference internal" href="pathlib.html#pathlib.Path.open" title="pathlib.Path.open"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pathlib.Path.open</span></code></a>).</p>
<p>When opening as text, accepts encoding parameters such as those
accepted by <a class="reference internal" href="io.html#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-attr docutils literal notranslate"><span class="pre">io.TextIOWrapper</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Traversable.read_bytes">
<span class="sig-name descname"><span class="pre">read_bytes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.Traversable.read_bytes" title="Link to this definition">¶</a></dt>
<dd><p>Read contents of <code class="docutils literal notranslate"><span class="pre">self</span></code> as bytes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Traversable.read_text">
<span class="sig-name descname"><span class="pre">read_text</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.Traversable.read_text" title="Link to this definition">¶</a></dt>
<dd><p>Read contents of <code class="docutils literal notranslate"><span class="pre">self</span></code> as text.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.TraversableResources">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">TraversableResources</span></span><a class="headerlink" href="importlib.html#importlib.abc.TraversableResources" title="Link to this definition">¶</a></dt>
<dd><p>An abstract base class for resource readers capable of serving
the <a class="reference internal" href="importlib.resources.html#importlib.resources.files" title="importlib.resources.files"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.resources.files()</span></code></a> interface. Subclasses
<a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.ResourceReader" title="importlib.resources.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.ResourceReader</span></code></a> and provides
concrete implementations of the <a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.ResourceReader" title="importlib.resources.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.ResourceReader</span></code></a>’s
abstract methods. Therefore, any loader supplying
<a class="reference internal" href="importlib.html#importlib.abc.TraversableResources" title="importlib.abc.TraversableResources"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.TraversableResources</span></code></a> also supplies ResourceReader.</p>
<p>Loaders that wish to support resource reading are expected to
implement this interface.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">버전 3.12에서 폐지되었습니다, 버전 3.14에서 제거됩니다.: </span>Use <a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.TraversableResources" title="importlib.resources.abc.TraversableResources"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.TraversableResources</span></code></a> instead.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.TraversableResources.files">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">files</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.abc.TraversableResources.files" title="Link to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.Traversable" title="importlib.resources.abc.Traversable"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.Traversable</span></code></a> object for the loaded
package.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-importlib.machinery">
<span id="importlib-machinery-importers-and-path-hooks"></span><h2><a class="reference internal" href="importlib.html#module-importlib.machinery" title="importlib.machinery: Importers and path hooks"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code></a> – 임포터와 경로 훅<a class="headerlink" href="importlib.html#module-importlib.machinery" title="Link to this heading">¶</a></h2>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/importlib/machinery.py">Lib/importlib/machinery.py</a></p>
<hr class="docutils" />
<p>이 모듈에는 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>가 모듈을 찾고 로드하는 데 도움이 되는 다양한 객체가 포함되어 있습니다.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.SOURCE_SUFFIXES">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">SOURCE_SUFFIXES</span></span><a class="headerlink" href="importlib.html#importlib.machinery.SOURCE_SUFFIXES" title="Link to this definition">¶</a></dt>
<dd><p>소스 모듈로 인식되는 파일 접미사를 나타내는 문자열 리스트.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.DEBUG_BYTECODE_SUFFIXES">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">DEBUG_BYTECODE_SUFFIXES</span></span><a class="headerlink" href="importlib.html#importlib.machinery.DEBUG_BYTECODE_SUFFIXES" title="Link to this definition">¶</a></dt>
<dd><p>최적화되지 않은 바이트 코드 모듈의 파일 접미사를 나타내는 문자열 리스트.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.5부터 폐지됨: </span>대신 <a class="reference internal" href="importlib.html#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BYTECODE_SUFFIXES</span></code></a>를 사용하십시오.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">OPTIMIZED_BYTECODE_SUFFIXES</span></span><a class="headerlink" href="importlib.html#importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES" title="Link to this definition">¶</a></dt>
<dd><p>최적화된 바이트 코드 모듈의 파일 접미사를 나타내는 문자열 리스트.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.5부터 폐지됨: </span>대신 <a class="reference internal" href="importlib.html#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BYTECODE_SUFFIXES</span></code></a>를 사용하십시오.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.BYTECODE_SUFFIXES">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">BYTECODE_SUFFIXES</span></span><a class="headerlink" href="importlib.html#importlib.machinery.BYTECODE_SUFFIXES" title="Link to this definition">¶</a></dt>
<dd><p>바이트 코드 모듈로 인식되는 파일 접미사를 나타내는 문자열 리스트 (앞의 점을 포함합니다).</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이 값은 더는 <code class="docutils literal notranslate"><span class="pre">__debug__</span></code>에 의존하지 않습니다.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.EXTENSION_SUFFIXES">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">EXTENSION_SUFFIXES</span></span><a class="headerlink" href="importlib.html#importlib.machinery.EXTENSION_SUFFIXES" title="Link to this definition">¶</a></dt>
<dd><p>확장 모듈로 인식되는 파일 접미사를 나타내는 문자열 리스트.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.machinery.all_suffixes">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">all_suffixes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.all_suffixes" title="Link to this definition">¶</a></dt>
<dd><p>표준 임포트 절차가 인식하는 모듈의 모든 파일 접미사를 나타내는 문자열의 결합한 리스트를 반환합니다. 이것은 모듈 종류에 대한 세부 정보 없이 파일 시스템 경로가 잠재적으로 모듈을 참조하는지를 알아야 하는 코드(예를 들어, <a class="reference internal" href="inspect.html#inspect.getmodulename" title="inspect.getmodulename"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getmodulename()</span></code></a>)를 위한 도우미입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.BuiltinImporter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">BuiltinImporter</span></span><a class="headerlink" href="importlib.html#importlib.machinery.BuiltinImporter" title="Link to this definition">¶</a></dt>
<dd><p>내장 모듈용 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">임포터</span></a>. 알려진 모든 내장 모듈은 <a class="reference internal" href="sys.html#sys.builtin_module_names" title="sys.builtin_module_names"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.builtin_module_names</span></code></a>에 나열되어 있습니다. 이 클래스는 <a class="reference internal" href="importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a>와 <a class="reference internal" href="importlib.html#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a> ABC를 구현합니다.</p>
<p>이 클래스는 인스턴스 화의 필요성을 완화하기 위해 클래스 메서드만 정의합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><span class="target" id="index-43"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a>의 일부로, 내장 임포터는 이제 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.create_module()</span></code>과 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code>을 구현합니다.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.FrozenImporter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">FrozenImporter</span></span><a class="headerlink" href="importlib.html#importlib.machinery.FrozenImporter" title="Link to this definition">¶</a></dt>
<dd><p>프로즌(frozen) 모듈용 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">임포터</span></a>. 이 클래스는 <a class="reference internal" href="importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a>와 <a class="reference internal" href="importlib.html#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a> ABC를 구현합니다.</p>
<p>이 클래스는 인스턴스 화의 필요성을 완화하기 위해 클래스 메서드만 정의합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.create_module()</span></code>과 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code> 메서드를 얻었습니다.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.WindowsRegistryFinder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">WindowsRegistryFinder</span></span><a class="headerlink" href="importlib.html#importlib.machinery.WindowsRegistryFinder" title="Link to this definition">¶</a></dt>
<dd><p>윈도우 레지스트리에 선언된 모듈용 <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">파인더</span></a>. 이 클래스는 <a class="reference internal" href="importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> ABC를 구현합니다.</p>
<p>이 클래스는 인스턴스 화의 필요성을 완화하기 위해 클래스 메서드만 정의합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.6부터 폐지됨: </span>대신 <a class="reference internal" href="site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 구성을 사용하십시오. 이후 버전의 파이썬은 기본적으로 이 파인더를 활성화하지 않을 수 있습니다.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.PathFinder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">PathFinder</span></span><a class="headerlink" href="importlib.html#importlib.machinery.PathFinder" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>와 패키지 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트용 <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">파인더</span></a>. 이 클래스는 <a class="reference internal" href="importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> ABC를 구현합니다.</p>
<p>이 클래스는 인스턴스 화의 필요성을 완화하기 위해 클래스 메서드만 정의합니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.PathFinder.find_spec">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.PathFinder.find_spec" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 또는, 정의되었다면, <em>path</em>에서 <em>fullname</em>에 의해 지정된 모듈에 대한 <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">스펙</span></a>을 찾으려고 시도하는 클래스 메서드. 검색된 각 경로 엔트리에 대해, <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>가 확인됩니다. 거짓이 아닌 객체를 찾으면 검색 중인 모듈을 찾기 위한 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a>로 사용됩니다. <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>에 엔트리가 없으면, <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>에서 경로 엔트리를 위한 파인더를 검색하고, 발견되면, 모듈에 대해 조회되는 것과 동시에 <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>에 저장됩니다. 파인더가 아예 발견되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 캐시에 저장되고 반환됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>현재 작업 디렉터리 – 빈 문자열로 표현됩니다 – 가 더는 유효하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환되지만 <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>에 값이 캐시 되지는 않습니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.PathFinder.invalidate_caches">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">invalidate_caches</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.PathFinder.invalidate_caches" title="Link to this definition">¶</a></dt>
<dd><p>메서드를 정의하는 <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>에 저장된 모든 파인더에 대해 <a class="reference internal" href="importlib.html#importlib.abc.PathEntryFinder.invalidate_caches" title="importlib.abc.PathEntryFinder.invalidate_caches"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder.invalidate_caches()</span></code></a>를 호출합니다. <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>에 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정된 엔트리가 삭제됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>에서 <code class="docutils literal notranslate"><span class="pre">None</span></code>의 엔트리가 삭제됩니다.</p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">''</span></code>(즉 빈 문자열)에 대해서는 현재 작업 디렉터리로 <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>의 객체를 호출합니다.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.FileFinder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">FileFinder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">loader_details</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.FileFinder" title="Link to this definition">¶</a></dt>
<dd><p>파일 시스템에서의 결과를 캐시 하는 <a class="reference internal" href="importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> 의 구상 구현.</p>
<p><em>path</em> 인자는 파인더가 검색을 담당하는 디렉터리입니다.</p>
<p><em>loader_details</em> 인자는 각각 로더와 로더가 인식하는 파일 접미사의 시퀀스를 포함하는 가변 개수의 2개 항목 튜플입니다. 로더는 모듈 이름과 찾은 파일의 경로로 구성되는 두 인자를 받아들이는 콜러블일 것으로 기대됩니다.</p>
<p>파인더는 필요에 따라 디렉터리 내용을 캐시 하여, 각 모듈 검색에서 stat 호출을 수행하여 캐시가 시효가 지나지 않았는지 확인합니다. 캐시 만료는 파일 시스템의 운영 체제 상태 정보의 세분성에 의존하기 때문에, 모듈 검색, 새 파일 생성 및 새 파일이 나타내는 모듈 검색의 잠재적 경쟁 조건이 있습니다. stat 호출의 세분성 이하로 연산이 아주 빠르게 수행되면, 모듈 검색이 실패합니다. 이를 방지하려면, 모듈을 동적으로 만들 때, <a class="reference internal" href="importlib.html#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.invalidate_caches()</span></code></a>를 호출해야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.FileFinder.path">
<span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="importlib.html#importlib.machinery.FileFinder.path" title="Link to this definition">¶</a></dt>
<dd><p>파인더가 검색할 경로.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.FileFinder.find_spec">
<span class="sig-name descname"><span class="pre">find_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.FileFinder.find_spec" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a> 내에서 <em>fullname</em>을 처리할 스펙을 찾으려고 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.FileFinder.invalidate_caches">
<span class="sig-name descname"><span class="pre">invalidate_caches</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.FileFinder.invalidate_caches" title="Link to this definition">¶</a></dt>
<dd><p>내부 캐시를 지웁니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.FileFinder.path_hook">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">path_hook</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">loader_details</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.FileFinder.path_hook" title="Link to this definition">¶</a></dt>
<dd><p>A class method which returns a closure for use on <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>.
An instance of <a class="reference internal" href="importlib.html#importlib.machinery.FileFinder" title="importlib.machinery.FileFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileFinder</span></code></a> is returned by the closure using the
path argument given to the closure directly and <em>loader_details</em>
indirectly.</p>
<p>클로저에 대한 인자가 기존 디렉터리가 아니면, <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>가 발생합니다.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">SourceFileLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.SourceFileLoader" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.FileLoader</span></code></a>를 서브 클래싱하고 다른 메서드의 구상 구현을 제공하는 <a class="reference internal" href="importlib.html#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader</span></code></a>의 구상 구현.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="importlib.html#importlib.machinery.SourceFileLoader.name" title="Link to this definition">¶</a></dt>
<dd><p>이 로더가 처리할 모듈의 이름.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.path">
<span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="importlib.html#importlib.machinery.SourceFileLoader.path" title="Link to this definition">¶</a></dt>
<dd><p>소스 파일의 경로.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.is_package">
<span class="sig-name descname"><span class="pre">is_package</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.SourceFileLoader.is_package" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.machinery.SourceFileLoader.path" title="importlib.machinery.SourceFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>가 패키지에 대한 것으로 드러나면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.path_stats">
<span class="sig-name descname"><span class="pre">path_stats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.SourceFileLoader.path_stats" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.path_stats()</span></code></a>의 구상 구현.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.set_data">
<span class="sig-name descname"><span class="pre">set_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.SourceFileLoader.set_data" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.abc.SourceLoader.set_data" title="importlib.abc.SourceLoader.set_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.set_data()</span></code></a>의 구상 구현.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.SourceFileLoader.load_module" title="Link to this definition">¶</a></dt>
<dd><p>로드할 모듈 이름을 지정하는 것이 선택적인 <a class="reference internal" href="importlib.html#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a>의 구상 구현.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.6부터 폐지됨: </span>대신 <a class="reference internal" href="importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">SourcelessFileLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.SourcelessFileLoader" title="Link to this definition">¶</a></dt>
<dd><p>바이트 코드 파일을 (즉, 소스 코드 파일 없이) 임포트 할 수 있는 <a class="reference internal" href="importlib.html#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.FileLoader</span></code></a>의 구상 구현.</p>
<p>바이트 코드 파일(그래서 소스 코드 파일이 아닌)을 직접 사용하면 모든 파이썬 구현이나 바이트 코드 형식을 변경하는 새 버전의 파이썬에서 모듈을 사용할 수 없게 됨에 유의하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="importlib.html#importlib.machinery.SourcelessFileLoader.name" title="Link to this definition">¶</a></dt>
<dd><p>로더가 처리할 모듈의 이름.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.path">
<span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="importlib.html#importlib.machinery.SourcelessFileLoader.path" title="Link to this definition">¶</a></dt>
<dd><p>바이트 코드 파일의 경로.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.is_package">
<span class="sig-name descname"><span class="pre">is_package</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.SourcelessFileLoader.is_package" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>를 기반으로 모듈이 패키지인지 판단합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.get_code">
<span class="sig-name descname"><span class="pre">get_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.SourcelessFileLoader.get_code" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>에서 만들어진 <a class="reference internal" href="importlib.html#importlib.machinery.SourcelessFileLoader.name" title="importlib.machinery.SourcelessFileLoader.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a>의 코드 객체를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.get_source">
<span class="sig-name descname"><span class="pre">get_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.SourcelessFileLoader.get_source" title="Link to this definition">¶</a></dt>
<dd><p>이 로더가 사용될 때는 바이트 코드 파일에 소스가 없어서 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.SourcelessFileLoader.load_module" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>로드할 모듈 이름을 지정하는 것이 선택적인 <a class="reference internal" href="importlib.html#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a>의 구상 구현.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.6부터 폐지됨: </span>대신 <a class="reference internal" href="importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">ExtensionFileLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.ExtensionFileLoader" title="Link to this definition">¶</a></dt>
<dd><p>확장 모듈을 위한 <a class="reference internal" href="importlib.html#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ExecutionLoader</span></code></a>의 구상 구현.</p>
<p><em>fullname</em> 인자는 로더가 지원할 모듈의 이름을 지정합니다. <em>path</em> 인자는 확장 모듈 파일의 경로입니다.</p>
<p>Note that, by default, importing an extension module will fail
in subinterpreters if it doesn’t implement multi-phase init
(see <span class="target" id="index-18"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a>), even if it would otherwise import successfully.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span>Multi-phase init is now required for use in subinterpreters.</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="importlib.html#importlib.machinery.ExtensionFileLoader.name" title="Link to this definition">¶</a></dt>
<dd><p>로더가 지원하는 모듈의 이름.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.path">
<span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="importlib.html#importlib.machinery.ExtensionFileLoader.path" title="Link to this definition">¶</a></dt>
<dd><p>확장 모듈의 경로.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.create_module">
<span class="sig-name descname"><span class="pre">create_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.ExtensionFileLoader.create_module" title="Link to this definition">¶</a></dt>
<dd><p><span class="target" id="index-44"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a>에 따라 지정된 명세에서 모듈 객체를 만듭니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.exec_module">
<span class="sig-name descname"><span class="pre">exec_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.ExtensionFileLoader.exec_module" title="Link to this definition">¶</a></dt>
<dd><p><span class="target" id="index-45"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a>에 따라 주어진 모듈 객체를 초기화합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.is_package">
<span class="sig-name descname"><span class="pre">is_package</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.ExtensionFileLoader.is_package" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.machinery.EXTENSION_SUFFIXES" title="importlib.machinery.EXTENSION_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">EXTENSION_SUFFIXES</span></code></a>에 기반해서 파일 경로가 패키지의 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 모듈을 가리키면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.get_code">
<span class="sig-name descname"><span class="pre">get_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.ExtensionFileLoader.get_code" title="Link to this definition">¶</a></dt>
<dd><p>확장 모듈에는 코드 객체가 없어서 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.get_source">
<span class="sig-name descname"><span class="pre">get_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.ExtensionFileLoader.get_source" title="Link to this definition">¶</a></dt>
<dd><p>확장 모듈에는 소스 코드가 없어서 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.get_filename">
<span class="sig-name descname"><span class="pre">get_filename</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.ExtensionFileLoader.get_filename" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="importlib.html#importlib.machinery.ExtensionFileLoader.path" title="importlib.machinery.ExtensionFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.NamespaceLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">NamespaceLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_finder</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.NamespaceLoader" title="Link to this definition">¶</a></dt>
<dd><p>A concrete implementation of <a class="reference internal" href="importlib.html#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a> for
namespace packages.  This is an alias for a private class and is only made
public for introspecting the <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> attribute on namespace
packages:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">importlib.machinery</span> <span class="kn">import</span> <span class="n">NamespaceLoader</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">my_namespace</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">my_namespace</span><span class="o">.</span><span class="n">__loader__</span><span class="p">,</span> <span class="n">NamespaceLoader</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">importlib.abc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">my_namespace</span><span class="o">.</span><span class="n">__loader__</span><span class="p">,</span> <span class="n">importlib</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Loader</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">ModuleSpec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loader</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loader_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_package</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.machinery.ModuleSpec" title="Link to this definition">¶</a></dt>
<dd><p>A specification for a module’s import-system-related state.  This is
typically exposed as the module’s <a class="reference internal" href="../reference/import.html#spec__" title="__spec__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__</span></code></a> attribute.  In the
descriptions below, the names in parentheses give the corresponding
attribute available directly on the module object,
e.g. <code class="docutils literal notranslate"><span class="pre">module.__spec__.origin</span> <span class="pre">==</span> <span class="pre">module.__file__</span></code>.  Note, however, that
while the <em>values</em> are usually equivalent, they can differ since there is
no synchronization between the two objects.  For example, it is possible to update
the module’s <a class="reference internal" href="../reference/import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> at runtime and this will not be automatically
reflected in the module’s <code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__.origin</span></code>, and vice versa.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="importlib.html#importlib.machinery.ModuleSpec.name" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>(<a class="reference internal" href="../reference/import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>)</p>
<p>The module’s fully qualified name.
The <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> should always set this attribute to a non-empty string.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.loader">
<span class="sig-name descname"><span class="pre">loader</span></span><a class="headerlink" href="importlib.html#importlib.machinery.ModuleSpec.loader" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>(<a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a>)</p>
<p>The <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> used to load the module.
The <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> should always set this attribute.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.origin">
<span class="sig-name descname"><span class="pre">origin</span></span><a class="headerlink" href="importlib.html#importlib.machinery.ModuleSpec.origin" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>(<a class="reference internal" href="../reference/import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a>)</p>
<p>The location the <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> should use to load the module.
For example, for modules loaded from a .py file this is the filename.
The <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> should always set this attribute to a meaningful value
for the <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> to use.  In the uncommon case that there is not one
(like for namespace packages), it should be set to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.submodule_search_locations">
<span class="sig-name descname"><span class="pre">submodule_search_locations</span></span><a class="headerlink" href="importlib.html#importlib.machinery.ModuleSpec.submodule_search_locations" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>(<a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a>)</p>
<p>The list of locations where the package’s submodules will be found.
Most of the time this is a single directory.
The <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> should set this attribute to a list, even an empty one, to indicate
to the import system that the module is a package.  It should be set to <code class="docutils literal notranslate"><span class="pre">None</span></code> for
non-package modules.  It is set automatically later to a special object for
namespace packages.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.loader_state">
<span class="sig-name descname"><span class="pre">loader_state</span></span><a class="headerlink" href="importlib.html#importlib.machinery.ModuleSpec.loader_state" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>The <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> may set this attribute to an object containing additional,
module-specific data to use when loading the module.  Otherwise it should be
set to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.cached">
<span class="sig-name descname"><span class="pre">cached</span></span><a class="headerlink" href="importlib.html#importlib.machinery.ModuleSpec.cached" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>(<a class="reference internal" href="../reference/import.html#cached__" title="__cached__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code></a>)</p>
<p>The filename of a compiled version of the module’s code.
The <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> should always set this attribute but it may be <code class="docutils literal notranslate"><span class="pre">None</span></code>
for modules that do not need compiled code stored.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.parent">
<span class="sig-name descname"><span class="pre">parent</span></span><a class="headerlink" href="importlib.html#importlib.machinery.ModuleSpec.parent" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>(<a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>)</p>
<p>(Read-only) The fully qualified name of the package the module is in (or the
empty string for a top-level module).
If the module is a package then this is the same as <a class="reference internal" href="importlib.html#importlib.machinery.ModuleSpec.name" title="importlib.machinery.ModuleSpec.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.has_location">
<span class="sig-name descname"><span class="pre">has_location</span></span><a class="headerlink" href="importlib.html#importlib.machinery.ModuleSpec.has_location" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">True</span></code> if the spec’s <a class="reference internal" href="importlib.html#importlib.machinery.ModuleSpec.origin" title="importlib.machinery.ModuleSpec.origin"><code class="xref py py-attr docutils literal notranslate"><span class="pre">origin</span></code></a> refers to a loadable location,</dt><dd><p><code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.  This value impacts how <a class="reference internal" href="importlib.html#importlib.machinery.ModuleSpec.origin" title="importlib.machinery.ModuleSpec.origin"><code class="xref py py-attr docutils literal notranslate"><span class="pre">origin</span></code></a> is interpreted
and how the module’s <a class="reference internal" href="../reference/import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> is populated.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-importlib.util">
<span id="importlib-util-utility-code-for-importers"></span><h2><a class="reference internal" href="importlib.html#module-importlib.util" title="importlib.util: Utility code for importers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code></a> – 임포터를 위한 유틸리티 코드<a class="headerlink" href="importlib.html#module-importlib.util" title="Link to this heading">¶</a></h2>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/importlib/util.py">Lib/importlib/util.py</a></p>
<hr class="docutils" />
<p>이 모듈에는 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">임포터</span></a> 구성에 도움이 되는 다양한 객체가 포함되어 있습니다.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.util.MAGIC_NUMBER">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">MAGIC_NUMBER</span></span><a class="headerlink" href="importlib.html#importlib.util.MAGIC_NUMBER" title="Link to this definition">¶</a></dt>
<dd><p>바이트 코드 버전 번호를 나타내는 바이트열. 바이트 코드의 로드/쓰기에 도움이 필요하면 <a class="reference internal" href="importlib.html#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader</span></code></a>를 고려하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.cache_from_source">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">cache_from_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debug_override</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.util.cache_from_source" title="Link to this definition">¶</a></dt>
<dd><p>소스 <em>path</em>와 연관된 바이트 컴파일된 파일의 <span class="target" id="index-46"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a>/<span class="target" id="index-47"></span><a class="pep reference external" href="https://peps.python.org/pep-0488/"><strong>PEP 488</strong></a> 경로를 반환합니다. 예를 들어, <em>path</em>가 <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>이면 반환값은 파이썬 3.2의 경우 <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>입니다. <code class="docutils literal notranslate"><span class="pre">cpython-32</span></code> 문자열은 현재 매직 태그에서 온 것입니다 (<code class="xref py py-func docutils literal notranslate"><span class="pre">get_tag()</span></code>를 참조하십시오; <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.implementation.cache_tag</span></code>가 정의되지 않으면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 가 발생합니다).</p>
<p><em>optimization</em> 매개 변수는 바이트 코드 파일의 최적화 수준을 지정하는 데 사용됩니다. 빈 문자열은 최적화하지 않음을 나타내므로, <em>optimization</em>이 <code class="docutils literal notranslate"><span class="pre">''</span></code> 인 <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>는 바이트 코드 경로가 <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>가 됩니다. <code class="docutils literal notranslate"><span class="pre">None</span></code>은 인터프리터의 최적화 수준이 사용되도록 합니다. 다른 값의 문자열 표현은 사용되므로, <em>optimization</em>이 <code class="docutils literal notranslate"><span class="pre">2</span></code>인 <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>는 바이트 코드 경로가 <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc</span></code>가 됩니다. <em>optimization</em>의 문자열 표현은 영숫자만 가능하며, 그렇지 않으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p><em>debug_override</em> 매개 변수는 폐지되었고 <code class="docutils literal notranslate"><span class="pre">__debug__</span></code>의 시스템값을 대체하는 데 사용할 수 있습니다. <code class="docutils literal notranslate"><span class="pre">True</span></code> 값은 <em>optimization</em>을 빈 문자열로 설정하는 것과 등등합니다. <code class="docutils literal notranslate"><span class="pre">False</span></code> 값은 <em>optimization</em>을 <code class="docutils literal notranslate"><span class="pre">1</span></code>로 설정하는 것과 같습니다. <em>debug_override</em>와 <em>optimization</em>이 모두 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><em>optimization</em> 매개 변수가 추가되었고 <em>debug_override</em> 매개 변수는 폐지되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.source_from_cache">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">source_from_cache</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.util.source_from_cache" title="Link to this definition">¶</a></dt>
<dd><p><em>path</em>에 <span class="target" id="index-48"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a> 파일 이름이 주어지면, 연관된 소스 코드 파일 경로를 반환합니다. 예를 들어, <em>path</em>가 <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>이면 반환된 경로는 <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>입니다. <em>path</em>는 존재할 필요는 없지만, <span class="target" id="index-49"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a>이나 <span class="target" id="index-50"></span><a class="pep reference external" href="https://peps.python.org/pep-0488/"><strong>PEP 488</strong></a> 형식을 준수하지 않으면, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.implementation.cache_tag</span></code>가 정의되지 않으면, <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 가 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.decode_source">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">decode_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_bytes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.util.decode_source" title="Link to this definition">¶</a></dt>
<dd><p>소스 코드를 나타내는 주어진 바이트열을 디코딩하고 유니버설 줄 넘김이 적용된 문자열로 반환합니다 (<a class="reference internal" href="importlib.html#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader.get_source()</span></code></a>에 필요한 대로).</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.resolve_name">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">resolve_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">package</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.util.resolve_name" title="Link to this definition">¶</a></dt>
<dd><p>상대 모듈 이름을 절대 이름으로 결정합니다.</p>
<p><strong>name</strong> 선두에 점이 없으면, <strong>name</strong>이 단순히 반환됩니다. 이를 통해 <strong>package</strong> 인자가 필요한지 확인하지 않고 <code class="docutils literal notranslate"><span class="pre">importlib.util.resolve_name('sys',</span> <span class="pre">__spec__.parent)</span></code>와 같은 사용이 가능합니다.</p>
<p><a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> is raised if <strong>name</strong> is a relative module name but
<strong>package</strong> is a false value (e.g. <code class="docutils literal notranslate"><span class="pre">None</span></code> or the empty string).
<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> is also raised if a relative name would escape its
containing package (e.g. requesting <code class="docutils literal notranslate"><span class="pre">..bacon</span></code> from within the <code class="docutils literal notranslate"><span class="pre">spam</span></code>
package).</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>import 문과의 일관성을 개선하기 위해, 잘못된 상대 임포트 시도에 대해 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.find_spec">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">find_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">package</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.util.find_spec" title="Link to this definition">¶</a></dt>
<dd><p>Find the <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> for a module, optionally relative to
the specified <strong>package</strong> name. If the module is in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>,
then <code class="docutils literal notranslate"><span class="pre">sys.modules[name].__spec__</span></code> is returned (unless the spec would be
<code class="docutils literal notranslate"><span class="pre">None</span></code> or is not set, in which case <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised).
Otherwise a search using <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> is done. <code class="docutils literal notranslate"><span class="pre">None</span></code> is
returned if no spec is found.</p>
<p><strong>name</strong>이 서브 모듈에 관한 것이면 (점을 포함하면), 부모 모듈은 자동으로 임포트 됩니다.</p>
<p><strong>name</strong>과 <strong>package</strong>는 <code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code>과 같게 작동합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><strong>package</strong>가 실제로 패키지가 아니면 (즉 <a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> 어트리뷰트가 없으면) <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.module_from_spec">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">module_from_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.util.module_from_spec" title="Link to this definition">¶</a></dt>
<dd><p><strong>spec</strong>과 <a class="reference internal" href="importlib.html#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spec.loader.create_module</span></code></a>을 기반으로 새 모듈을 만듭니다.</p>
<p><a class="reference internal" href="importlib.html#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spec.loader.create_module</span></code></a>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환하지 않으면, 어떤 기존 어트리뷰트도 재설정되지 않습니다. 또한 <strong>spec</strong>에 액세스하거나 모듈에서 어트리뷰트를 설정하는 동안 트리거 되면 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>가 발생하지 않습니다.</p>
<p><strong>spec</strong>은 모듈에서 가능한 많은 임포트 제어 어트리뷰트를 설정하는 데 사용되므로 새 모듈을 작성하는 데 <a class="reference internal" href="types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a>을 사용하는 것보다 이 함수가 선호됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.spec_from_loader">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">spec_from_loader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loader</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_package</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.util.spec_from_loader" title="Link to this definition">¶</a></dt>
<dd><p>A factory function for creating a <a class="reference internal" href="importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a>
instance based on a loader.  The parameters have the same meaning as they do
for ModuleSpec.  The function uses available <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> APIs, such as
<code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.is_package()</span></code>, to fill in any missing
information on the spec.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.spec_from_file_location">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">spec_from_file_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">location</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">submodule_search_locations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.util.spec_from_file_location" title="Link to this definition">¶</a></dt>
<dd><p>A factory function for creating a <a class="reference internal" href="importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a>
instance based on the path to a file.  Missing information will be filled in
on the spec by making use of loader APIs and by the implication that the
module will be file-based.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.source_hash">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">source_hash</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_bytes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.util.source_hash" title="Link to this definition">¶</a></dt>
<dd><p><em>source_bytes</em>의 해시를 바이트열로 반환합니다. 해시 기반 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일은 해당 소스 파일 내용의 <a class="reference internal" href="importlib.html#importlib.util.source_hash" title="importlib.util.source_hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">source_hash()</span></code></a>를 헤더에 포함합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util._incompatible_extension_module_restrictions">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">_incompatible_extension_module_restrictions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disable_check</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.util._incompatible_extension_module_restrictions" title="Link to this definition">¶</a></dt>
<dd><p>A context manager that can temporarily skip the compatibility check
for extension modules.  By default the check is enabled and will fail
when a single-phase init module is imported in a subinterpreter.
It will also fail for a multi-phase init module that doesn’t
explicitly support a per-interpreter GIL, when imported
in an interpreter with its own GIL.</p>
<p>Note that this function is meant to accommodate an unusual case;
one which is likely to eventually go away.  There’s is a pretty good
chance this is not what you were looking for.</p>
<p>You can get the same effect as this function by implementing the
basic interface of multi-phase init (<span class="target" id="index-26"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a>) and lying about
support for multiple interpreters (or per-interpreter GIL).</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>Using this function to disable the check can lead to
unexpected behavior and even crashes.  It should only be used during
extension module development.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.util.LazyLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">LazyLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loader</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.util.LazyLoader" title="Link to this definition">¶</a></dt>
<dd><p>모듈이 어트리뷰트에 액세스할 때까지 모듈 로더의 실행을 연기하는 클래스.</p>
<p>This class <strong>only</strong> works with loaders that define
<a class="reference internal" href="importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> as control over what module type
is used for the module is required. For those same reasons, the loader’s
<a class="reference internal" href="importlib.html#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> method must return <code class="docutils literal notranslate"><span class="pre">None</span></code> or a
type for which its <code class="docutils literal notranslate"><span class="pre">__class__</span></code> attribute can be mutated along with not
using <a class="reference internal" href="../glossary.html#term-__slots__"><span class="xref std std-term">slots</span></a>. Finally, modules which substitute the object
placed into <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> will not work as there is no way to properly
replace the module references throughout the interpreter safely;
<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised if such a substitution is detected.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>시작 시간이 중요한 프로젝트의 경우, 이 클래스를 사용하면 사용하지 않을 모듈을 로드하는 데 드는 비용을 최소화할 수 있습니다. 시작 시간이 핵심이 아닌 프로젝트의 경우 로딩이 지연되는 동안 만들어진, 따라서 문맥을 벗어난 에러 메시지 때문에, 이 클래스를 사용하지 말 것을 <strong>강하게</strong> 권고합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="importlib.html#importlib.machinery.BuiltinImporter" title="importlib.machinery.BuiltinImporter"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.BuiltinImporter</span></code></a>와 <a class="reference internal" href="importlib.html#importlib.machinery.ExtensionFileLoader" title="importlib.machinery.ExtensionFileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ExtensionFileLoader</span></code></a> 에 대한 호환성 경고를 제거하고, <a class="reference internal" href="importlib.html#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>을 호출하기 시작했습니다.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.util.LazyLoader.factory">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">factory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loader</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="importlib.html#importlib.util.LazyLoader.factory" title="Link to this definition">¶</a></dt>
<dd><p>A class method which returns a callable that creates a lazy loader. This
is meant to be used in situations where the loader is passed by class
instead of by instance.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">suffixes</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span>
<span class="n">loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SourceFileLoader</span>
<span class="n">lazy_loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">LazyLoader</span><span class="o">.</span><span class="n">factory</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
<span class="n">finder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">FileFinder</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="p">(</span><span class="n">lazy_loader</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="examples">
<span id="importlib-examples"></span><h2>예<a class="headerlink" href="importlib.html#examples" title="Link to this heading">¶</a></h2>
<section id="importing-programmatically">
<h3>프로그래밍 방식으로 임포트 하기<a class="headerlink" href="importlib.html#importing-programmatically" title="Link to this heading">¶</a></h3>
<p>프로그래밍 방식으로 모듈을 임포트 하려면, <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>을 사용하십시오.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib</span>

<span class="n">itertools</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;itertools&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="checking-if-a-module-can-be-imported">
<h3>모듈을 임포트 할 수 있는지 확인하기<a class="headerlink" href="importlib.html#checking-if-a-module-can-be-imported" title="Link to this heading">¶</a></h3>
<p>If you need to find out if a module can be imported without actually doing the
import, then you should use <a class="reference internal" href="importlib.html#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a>.</p>
<p>Note that if <code class="docutils literal notranslate"><span class="pre">name</span></code> is a submodule (contains a dot),
<a class="reference internal" href="importlib.html#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a> will import the parent module.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes.</span>
<span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;itertools&#39;</span>

<span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> already in sys.modules&quot;</span><span class="p">)</span>
<span class="k">elif</span> <span class="p">(</span><span class="n">spec</span> <span class="o">:=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># If you chose to perform the actual import ...</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> has been imported&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;can&#39;t find the </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> module&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="importing-a-source-file-directly">
<h3>소스 파일을 직접 임포트 하기<a class="headerlink" href="importlib.html#importing-a-source-file-directly" title="Link to this heading">¶</a></h3>
<p>To import a Python source file directly, use the following recipe:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes.</span>
<span class="kn">import</span> <span class="nn">tokenize</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">tokenize</span><span class="o">.</span><span class="vm">__file__</span>
<span class="n">module_name</span> <span class="o">=</span> <span class="n">tokenize</span><span class="o">.</span><span class="vm">__name__</span>

<span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">spec_from_file_location</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
<span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
<span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="implementing-lazy-imports">
<h3>Implementing lazy imports<a class="headerlink" href="importlib.html#implementing-lazy-imports" title="Link to this heading">¶</a></h3>
<p>The example below shows how to implement lazy imports:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">lazy_import</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">LazyLoader</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="o">=</span> <span class="n">loader</span>
<span class="gp">... </span>    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
<span class="gp">... </span>    <span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">module</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lazy_typing</span> <span class="o">=</span> <span class="n">lazy_import</span><span class="p">(</span><span class="s2">&quot;typing&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#lazy_typing is a real module object,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#but it is not loaded in memory yet.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lazy_typing</span><span class="o">.</span><span class="n">TYPE_CHECKING</span>
<span class="go">False</span>
</pre></div>
</div>
</section>
<section id="setting-up-an-importer">
<h3>임포터 설정하기<a class="headerlink" href="importlib.html#setting-up-an-importer" title="Link to this heading">¶</a></h3>
<p>For deep customizations of import, you typically want to implement an
<a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>. This means managing both the <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> and <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>
side of things. For finders there are two flavours to choose from depending on
your needs: a <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a> or a <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a>. The
former is what you would put on <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> while the latter is what
you create using a <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">path entry hook</span></a> on <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> which works
with <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> entries to potentially create a finder. This example will
show you how to register your own importers so that import will use them (for
creating an importer for yourself, read the documentation for the appropriate
classes defined within this package):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.machinery</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes only.</span>
<span class="n">SpamMetaPathFinder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">PathFinder</span>
<span class="n">SpamPathEntryFinder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">FileFinder</span>
<span class="n">loader_details</span> <span class="o">=</span> <span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SourceFileLoader</span><span class="p">,</span>
                  <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span><span class="p">)</span>

<span class="c1"># Setting up a meta path finder.</span>
<span class="c1"># Make sure to put the finder in the proper location in the list in terms of</span>
<span class="c1"># priority.</span>
<span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SpamMetaPathFinder</span><span class="p">)</span>

<span class="c1"># Setting up a path entry finder.</span>
<span class="c1"># Make sure to put the path hook in the proper location in the list in terms</span>
<span class="c1"># of priority.</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SpamPathEntryFinder</span><span class="o">.</span><span class="n">path_hook</span><span class="p">(</span><span class="n">loader_details</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="approximating-importlib-import-module">
<h3><a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 근사하기<a class="headerlink" href="importlib.html#approximating-importlib-import-module" title="Link to this heading">¶</a></h3>
<p>Import itself is implemented in Python code, making it possible to
expose most of the import machinery through importlib. The following
helps illustrate the various APIs that importlib exposes by providing an
approximate implementation of
<a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">import_module</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An approximate implementation of import.&quot;&quot;&quot;</span>
    <span class="n">absolute_name</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">resolve_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">absolute_name</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">path</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">absolute_name</span><span class="p">:</span>
        <span class="n">parent_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">child_name</span> <span class="o">=</span> <span class="n">absolute_name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">parent_module</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="n">parent_name</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">parent_module</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">submodule_search_locations</span>
    <span class="k">for</span> <span class="n">finder</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">absolute_name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;No module named </span><span class="si">{</span><span class="n">absolute_name</span><span class="si">!r}</span><span class="s1">&#39;</span>
        <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">absolute_name</span><span class="p">)</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">absolute_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">parent_module</span><span class="p">,</span> <span class="n">child_name</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">module</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="importlib.html#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code>의 구현</a><ul>
<li><a class="reference internal" href="importlib.html#introduction">소개</a></li>
<li><a class="reference internal" href="importlib.html#functions">함수</a></li>
<li><a class="reference internal" href="importlib.html#module-importlib.abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code> – import와 관련된 추상 베이스 클래스</a></li>
<li><a class="reference internal" href="importlib.html#module-importlib.machinery"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code> – 임포터와 경로 훅</a></li>
<li><a class="reference internal" href="importlib.html#module-importlib.util"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code> – 임포터를 위한 유틸리티 코드</a></li>
<li><a class="reference internal" href="importlib.html#examples">예</a><ul>
<li><a class="reference internal" href="importlib.html#importing-programmatically">프로그래밍 방식으로 임포트 하기</a></li>
<li><a class="reference internal" href="importlib.html#checking-if-a-module-can-be-imported">모듈을 임포트 할 수 있는지 확인하기</a></li>
<li><a class="reference internal" href="importlib.html#importing-a-source-file-directly">소스 파일을 직접 임포트 하기</a></li>
<li><a class="reference internal" href="importlib.html#implementing-lazy-imports">Implementing lazy imports</a></li>
<li><a class="reference internal" href="importlib.html#setting-up-an-importer">임포터 설정하기</a></li>
<li><a class="reference internal" href="importlib.html#approximating-importlib-import-module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code> 근사하기</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="runpy.html"
                          title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code> — Locating and executing Python modules</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="importlib.resources.html"
                          title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code> – Package resource reading, opening and access</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/importlib.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="사이드바 닫기">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="importlib.resources.html" title="importlib.resources – Package resource reading, opening and access"
             >다음</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="runpy — Locating and executing Python modules"
             >이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" >모듈 임포트 하기</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="importlib.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code>의 구현</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    저작권
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="../../../license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      최종 업데이트: Jun 09, 2024 (17:23 UTC)
    
      <a href="../../../bugs.html">Found a bug</a>?
    
    <br />

    <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7 버전으로 생성되었습니다.
    </div>

    <script type="text/javascript" src="../_static/switchers.js"></script>
  </body>
</html>