<!DOCTYPE html>

<html lang="ko" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="5. 임포트 시스템" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/reference/import.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="한 모듈 에 있는 파이썬 코드는 임포팅 이라는 프로세스를 통해 다른 모듈에 있는 코드들에 대한 접근권을 얻습니다. import 문은 임포트 절차를 일으키는 가장 흔한 방법이지만, 유일한 방법은 아닙니다. importlib.import_module() 같은 함수나 내장__import__() 도 임포트 절차를 일으키는데 사용될 수 있습니다. import ..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="한 모듈 에 있는 파이썬 코드는 임포팅 이라는 프로세스를 통해 다른 모듈에 있는 코드들에 대한 접근권을 얻습니다. import 문은 임포트 절차를 일으키는 가장 흔한 방법이지만, 유일한 방법은 아닙니다. importlib.import_module() 같은 함수나 내장__import__() 도 임포트 절차를 일으키는데 사용될 수 있습니다. import ..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>5. 임포트 시스템 &#8212; Python 3.12.4 문서</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css%3Fv=80d5e7a1.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css%3Fv=bb723527.css" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css%3Fv=b20cc3f5.css" />
    
    <script src="../_static/documentation_options.js%3Fv=3050f571"></script>
    <script src="../_static/doctools.js%3Fv=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js%3Fv=dc90522c"></script>
    <script src="../_static/translations.js%3Fv=b5f768d8"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.12.4 문서에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="6. 표현식" href="expressions.html" />
    <link rel="prev" title="4. 실행 모델" href="executionmodel.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="../../../3/reference/import.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" />
                <input type="submit" value="이동"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="import.html#">5. 임포트 시스템</a><ul>
<li><a class="reference internal" href="import.html#importlib">5.1. <code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a></li>
<li><a class="reference internal" href="import.html#packages">5.2. 패키지(package)</a><ul>
<li><a class="reference internal" href="import.html#regular-packages">5.2.1. 정규 패키지</a></li>
<li><a class="reference internal" href="import.html#namespace-packages">5.2.2. 이름 공간 패키지</a></li>
</ul>
</li>
<li><a class="reference internal" href="import.html#searching">5.3. 검색</a><ul>
<li><a class="reference internal" href="import.html#the-module-cache">5.3.1. 모듈 캐시</a></li>
<li><a class="reference internal" href="import.html#finders-and-loaders">5.3.2. 파인더(finder)와 로더(loader)</a></li>
<li><a class="reference internal" href="import.html#import-hooks">5.3.3. 임포트 훅(import hooks)</a></li>
<li><a class="reference internal" href="import.html#the-meta-path">5.3.4. 메타 경로(meta path)</a></li>
</ul>
</li>
<li><a class="reference internal" href="import.html#loading">5.4. 로딩(loading)</a><ul>
<li><a class="reference internal" href="import.html#loaders">5.4.1. 로더</a></li>
<li><a class="reference internal" href="import.html#submodules">5.4.2. 서브 모듈</a></li>
<li><a class="reference internal" href="import.html#module-spec">5.4.3. 모듈 스펙</a></li>
<li><a class="reference internal" href="import.html#import-related-module-attributes">5.4.4. 임포트 관련 모듈 어트리뷰트</a></li>
<li><a class="reference internal" href="import.html#module-path">5.4.5. module.__path__</a></li>
<li><a class="reference internal" href="import.html#module-reprs">5.4.6. 모듈 repr</a></li>
<li><a class="reference internal" href="import.html#cached-bytecode-invalidation">5.4.7. 캐시된 바이트 코드 무효화</a></li>
</ul>
</li>
<li><a class="reference internal" href="import.html#the-path-based-finder">5.5. 경로 기반 파인더</a><ul>
<li><a class="reference internal" href="import.html#path-entry-finders">5.5.1. 경로 엔트리 파인더</a></li>
<li><a class="reference internal" href="import.html#path-entry-finder-protocol">5.5.2. 경로 엔트리 파인더 프로토콜</a></li>
</ul>
</li>
<li><a class="reference internal" href="import.html#replacing-the-standard-import-system">5.6. 표준 임포트 시스템 교체하기</a></li>
<li><a class="reference internal" href="import.html#package-relative-imports">5.7. 패키지 상대 임포트</a></li>
<li><a class="reference internal" href="import.html#special-considerations-for-main">5.8. __main__ 에 대한 특별한 고려</a><ul>
<li><a class="reference internal" href="import.html#main-spec">5.8.1. __main__.__spec__</a></li>
</ul>
</li>
<li><a class="reference internal" href="import.html#references">5.9. 참고문헌</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="executionmodel.html"
                          title="이전 장"><span class="section-number">4. </span>실행 모델</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="expressions.html"
                          title="다음 장"><span class="section-number">6. </span>표현식</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/import.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. 표현식"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 실행 모델"
             accesskey="P">이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 언어 레퍼런스</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="import.html"><span class="section-number">5. </span>임포트 시스템</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="the-import-system">
<span id="importsystem"></span><h1><span class="section-number">5. </span>임포트 시스템<a class="headerlink" href="import.html#the-import-system" title="Link to this heading">¶</a></h1>
<p id="index-0">한 <a class="reference internal" href="../glossary.html#term-module"><span class="xref std std-term">모듈</span></a> 에 있는 파이썬 코드는 <a class="reference internal" href="../glossary.html#term-importing"><span class="xref std std-term">임포팅</span></a> 이라는 프로세스를 통해 다른 모듈에 있는 코드들에 대한 접근권을 얻습니다. <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문은 임포트 절차를 일으키는 가장 흔한 방법이지만, 유일한 방법은 아닙니다. <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 같은 함수나 내장 <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 도 임포트 절차를 일으키는데 사용될 수 있습니다.</p>
<p><a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문은 두 가지 연산을 합친 것입니다; 먼저 이름이 가리키는 모듈을 찾은 후에, 그 검색의 결과를 지역 스코프의 이름에 연결합니다. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 문의 검색 연산은 적절한 인자들로 <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수를 호출하는 것으로 정의됩니다. <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 의 반환 값은 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 문의 이름 연결 연산을 수행하는 데 사용됩니다. 이 이름 연결 연산의 정확한 세부사항에 대해서는 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 문을 보세요.</p>
<p><a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 의 직접 호출은 모듈을 찾고, 발견된다면, 모듈을 만드는 연산만을 수행합니다. 부모 패키지를 임포트하거나 여러 캐시(<a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 를 포함합니다)를 갱신하는 것과 같은 부수적인 효과들이 일어날 수 있기는 하지만, 오직 <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문만이 이름 연결 연산을 수행합니다.</p>
<p><a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문이 실행될 때, 표준 내장 <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 가 호출됩니다. 임포트 시스템을 호출하는 다른 메커니즘 (<a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 같은)은 <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 를 사용하지 않고 임포트 개념을 구현하기 위한 자신의 방법을 사용할 수 있습니다.</p>
<p>모듈이 처음 임포트 될 때, 파이썬은 모듈을 검색하고, 발견된다면, 모듈 객체를 만들고 <a class="footnote-reference brackets" href="import.html#fnmo" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>, 초기화합니다. 만약 그 이름의 모듈을 발견할 수 없다면, <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> 를 일으킵니다. 파이썬은 임포트 절차가 호출될 때 이름 붙여진 모듈을 찾는 다양한 전략을 구현합니다. 이 전략들은 다음 섹션에서 설명하는 여러 가지 훅을 통해 수정되고 확장될 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>임포트 시스템은 <span class="target" id="index-40"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> 의 두 번째 단계를 완전히 구현하도록 개정되었습니다. 이제 묵시적인 임포트 절차는 없습니다 - 전체 임포트 시스템이 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 을 통해 노출됩니다. 여기에 더해, 네이티브(native) 이름 공간 패키지의 지원이 구현되었습니다 (<span class="target" id="index-41"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> 을 보세요).</p>
</div>
<section id="importlib">
<h2><span class="section-number">5.1. </span><a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a><a class="headerlink" href="import.html#importlib" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 모듈은 임포트 시스템과 상호 작용하기 위한 풍부한 API를 제공합니다. 예를 들어, <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 는 임포트 절차를 구동하는 데 있어 내장 <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 에 비해 권장되고, 더 간단한 API를 제공합니다. 더 상세한 내용은 <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 라이브러리 설명서를 참조하십시오.</p>
</section>
<section id="packages">
<h2><span class="section-number">5.2. </span>패키지(package)<a class="headerlink" href="import.html#packages" title="Link to this heading">¶</a></h2>
<p id="index-3">파이썬은 한 가지 종류의 모듈 객체만 갖고 있고, 모든 모듈은 모듈이 파이썬이나 C나 그 밖의 다른 어떤 방법으로 구현되었는지와 상관없이 이 형입니다. 모듈을 조직화하고 이름 계층구조를 제공하기 위해, 파이썬은 <a class="reference internal" href="../glossary.html#term-package"><span class="xref std std-term">패키지</span></a> 라는 개념을 갖고 있습니다.</p>
<p>패키지를 파일 시스템에 있는 디렉터리라고 생각할 수 있지만, 패키지와 모듈이 파일시스템으로부터 올 필요는 없으므로 이 비유를 너무 문자 그대로 해석하지 말아야 합니다. 이 문서의 목적상, 디렉터리와 파일이라는 비유를 사용할 것입니다. 파일 시스템 디렉터리처럼, 패키지는 계층적으로 조직화하고, 패키지는 보통 모듈뿐만 아니라 서브 패키지도 포함할 수 있습니다.</p>
<p>모든 패키지가 모듈이라는 것을 기억하는 것이 중요합니다. 하지만 모든 모듈이 패키지인 것은 아닙니다. 다른 식으로 표현하면, 패키지는 특별한 종류의 모듈입니다. 구체적으로, <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트를 포함하는 모든 모듈은 패키지로 취급됩니다.</p>
<p>All modules have a name.  Subpackage names are separated from their parent
package name by a dot, akin to Python’s standard attribute access syntax.  Thus
you might have a package called <a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a>, which in turn has a subpackage
called <a class="reference internal" href="../library/email.mime.html#module-email.mime" title="email.mime: Build MIME messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.mime</span></code></a> and a module within that subpackage called
<a class="reference internal" href="../library/email.mime.html#module-email.mime.text" title="email.mime.text"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.mime.text</span></code></a>.</p>
<section id="regular-packages">
<h3><span class="section-number">5.2.1. </span>정규 패키지<a class="headerlink" href="import.html#regular-packages" title="Link to this heading">¶</a></h3>
<p id="index-4">파이썬은 두 가지 종류의 패키지를 정의합니다, <a class="reference internal" href="../glossary.html#term-regular-package"><span class="xref std std-term">정규 패키지</span></a> 와 <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">이름 공간 패키지</span></a>. 정규 패키지는 파이썬 3.2와 그 이전에 존재하던 전통적인 패키지입니다. 정규 패키지는 보통 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 파일을 가진 디렉터리로 구현됩니다. 정규 패키지가 임포트될 때, 이 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 파일이 묵시적으로 실행되고, 그것이 정의하는 객체들이 패키지의 이름 공간의 이름들도 연결됩니다. <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 파일은 다른 모듈들이 가질 수 있는 것과 같은 파이썬 코드를 포함할 수 있고, 파이썬은 임포트될 때 모듈에 몇 가지 어트리뷰트를 추가합니다.</p>
<p>예를 들어, 다음과 같은 파일시스템 배치는 최상위 <code class="docutils literal notranslate"><span class="pre">parent</span></code> 패키지와 세 개의 서브 패키지를 정의합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">parent</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">one</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">two</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">three</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">parent.one</span></code> 을 임포트하면 <code class="docutils literal notranslate"><span class="pre">parent/__init__.py</span></code> 과 <code class="docutils literal notranslate"><span class="pre">parent/one/__init__.py</span></code> 을 묵시적으로 실행합니다. 뒤이은 <code class="docutils literal notranslate"><span class="pre">parent.two</span></code> 와 <code class="docutils literal notranslate"><span class="pre">parent.three</span></code> 의 임포트는 각각 <code class="docutils literal notranslate"><span class="pre">parent/two/__init__.py</span></code> 와 <code class="docutils literal notranslate"><span class="pre">parent/three/__init__.py</span></code> 를 실행합니다.</p>
</section>
<section id="namespace-packages">
<h3><span class="section-number">5.2.2. </span>이름 공간 패키지<a class="headerlink" href="import.html#namespace-packages" title="Link to this heading">¶</a></h3>
<p id="index-5">이름 공간 패키지는 여러 가지 <a class="reference internal" href="../glossary.html#term-portion"><span class="xref std std-term">포션</span></a> 들의 복합체인데, 각 포션들은 부모 패키지의 서브 패키지로 이바지합니다. 포션들은 파일시스템의 다른 위치에 놓일 수 있습니다. 포션들은 zip 파일이나 네트워크나 파이썬이 임포트 할 때 검색하는 어떤 다른 장소에서 발견될 수 있습니다. 이름 공간 패키지는 파일시스템의 객체와 직접적인 상관관계가 있을 수도 있고 그렇지 않을 수도 있습니다; 구체적인 형태가 없는 가상 모듈일 수도 있습니다.</p>
<p>이름 공간 패키지는 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트로 일반적인 리스트를 사용하지 않습니다. 대신에 특별한 이터러블 형을 사용하는데, 그 패키지 내의 다음 임포트 시도에서 그것의 부모 패키지(또는 최상위 패키지의 경우 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>) 의 경로가 변했으면 패키지 포션에 대한 새 검색을 자동으로 수행하게 됩니다.</p>
<p>이름 공간 패키지의 경우, <code class="docutils literal notranslate"><span class="pre">parent/__init__.py</span></code> 파일이 없습니다. 사실, 임포트 검색 동안 여러 개의 <code class="docutils literal notranslate"><span class="pre">parent</span></code> 디렉터리가 발견될 수 있고, 각각의 것은 다른 포션들에 의해 제공됩니다. 그래서 <code class="docutils literal notranslate"><span class="pre">parent/one</span></code> 은 물리적으로 <code class="docutils literal notranslate"><span class="pre">parent/two</span></code> 옆에 위치하지 않을 수 있습니다. 이 경우, 파이썬은 자신 또는 서브 패키지 중 어느 하나가 임포트 될 때마다 최상위 <code class="docutils literal notranslate"><span class="pre">parent</span></code> 패키지를 위한 이름 공간 패키지를 만듭니다.</p>
<p>이름 공간 패키지의 규격은 <span class="target" id="index-42"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> 을 참조하세요.</p>
</section>
</section>
<section id="searching">
<h2><span class="section-number">5.3. </span>검색<a class="headerlink" href="import.html#searching" title="Link to this heading">¶</a></h2>
<p>검색을 시작하기 위해, 파이썬은 임포트될 모듈(또는 패키지, 하지만 이 논의에서 차이점은 중요하지 않다)의 완전히 <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">정규화된 이름</span></a> 을 필요로 합니다. 이 이름은 <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문으로 제공된 여러 인자나, <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 나 <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수로 전달된 매개변수들로부터 옵니다.</p>
<p>이 이름은 임포트 검색의 여러 단계에서 사용되는데, 서브 모듈로 가는 점으로 구분된 경로일 수 있습니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>. 이 경우에, 파이썬은 먼저 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 를, 그다음에 <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> 를, 마지막으로 <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> 를 임포트하려고 시도합니다. 만약 중간 임포트가 어느 하나라도 실패한다면 <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> 가 발생합니다.</p>
<section id="the-module-cache">
<h3><span class="section-number">5.3.1. </span>모듈 캐시<a class="headerlink" href="import.html#the-module-cache" title="Link to this heading">¶</a></h3>
<p id="index-7">임포트 검색 도중 처음으로 검사되는 장소는 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 입니다. 이 매핑은 중간 경로들을 포함해서 전에 임포트 된 모든 모듈의 캐시로 기능합니다. 그래서 만약 <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> 가 앞서 임포트 되었다면, <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 는 <code class="docutils literal notranslate"><span class="pre">foo</span></code>, <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code>, <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> 항목들을 포함합니다. 각 키에 대응하는 값들은 모듈 객체입니다.</p>
<p>임포트하는 동안, 모듈 이름을 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에서 찾고, 만약 있다면 해당 값이 임포트를 만족하는 모듈이고, 프로세스는 완료됩니다. 하지만 값이 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a>  를 일으킵니다. 만약 모듈 이름이 없다면, 파이썬은 모듈 검색을 계속 진행합니다.</p>
<p><a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 은 쓰기가 허락됩니다. 키를 삭제해도 해당 모듈을 파괴하지는 않지만(다른 모듈들이 아직 그 모듈에 대한 참조를 유지하고 있을 수 있으므로), 해당 이름의 모듈에 대한 캐시를 무효화해서, 다음 임포트때 파이썬으로 하여금 그 모듈을 다시 찾도록 만듭니다. 키에는 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 대입할 수도 있는데, 다음 임포트 때 <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> 가 일어나도록 만듭니다.</p>
<p>모듈 객체에 대한 참조를 유지한다면, <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 의 캐시 항목을 무효로 한 후 다시 임포트하면 두 모듈 객체는 같은 것이 아니게 됨에 주의해야 합니다. 반면에 <a class="reference internal" href="../library/importlib.html#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.reload()</span></code></a> 는 같은 모듈 객체를 재사용하고, 간단하게 모듈의 코드를 다시 실행해서 모듈의 내용을 다시 초기화합니다.</p>
</section>
<section id="finders-and-loaders">
<span id="id2"></span><h3><span class="section-number">5.3.2. </span>파인더(finder)와 로더(loader)<a class="headerlink" href="import.html#finders-and-loaders" title="Link to this heading">¶</a></h3>
<p id="index-8">모듈이 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에서 발견되지 않으면, 모듈을 찾아서 로드하기 위해 파이썬의 임포트 프로토콜이 구동됩니다. 이 프로토콜은 두 개의 개념적 객체들로 구성되어 있습니다, <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">파인더</span></a> 와 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>. 파인더의 일은 자신이 알고 있는 전략을 사용해, 주어진 이름의 모듈을 찾을 수 있는지 결정하는 것입니다. 두 인터페이스 모두를 구현한 객체들을 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">임포터</span></a>라고 부릅니다 - 요청한 모듈을 로딩할 수 있다고 판단할 때 자신을 돌려줍니다.</p>
<p>파이썬은 여러 가지 기본 파인더들과 임포터들을 포함하고 있습니다. 첫 번째 것은 내장 모듈들의 위치를 찾을 수 있고, 두 번째 것은 프로즌 모듈(frozen module)의 위치를 찾을 수 있고, 세 번째 것은 모듈을 <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">임포트 경로</span></a> 에서 검색합니다. <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">임포트 경로</span></a> 는 파일 시스템의 경로나 zip 파일을 가리키는 위치들의 목록입니다. 그것은 URL로 식별될 수 있는 것들처럼, 위치가 지정될 수 있는 자원들을 검색하도록 확장될 수 있습니다.</p>
<p>임포트 절차는 확장 가능해서, 모듈 검색의 범위를 확대하기 위해 새 파인더를 추가할 수 있습니다.</p>
<p>파인더는 실제로 모듈을 로드하지는 않습니다. 주어진 이름의 모듈을 찾으면 임포트와 관련된 정보들을 요약한 <em class="dfn">모듈 스펙 (module spec)</em> 을 돌려주는데, 임포트 절차는 모듈을 로딩할 때 이것을 사용하게 됩니다.</p>
<p>다음 섹션은 파인더와 로더의 프로토콜에 대해 좀 더 자세히 설명하는데, 임포트 절차를 확장하기 위해 어떻게 새로운 것들을 만들고 등록하는지를 포함합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>이전 버전의 파이썬에서, 파인더가 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a> 를 직접 돌려주었지만, 이제는 로더를 <em>포함하고</em> 있는 모듈 스펙을 돌려줍니다. 임포트 도중 로더가 아직 사용되기는 하지만 그 역할은 축소되었습니다.</p>
</div>
</section>
<section id="import-hooks">
<h3><span class="section-number">5.3.3. </span>임포트 훅(import hooks)<a class="headerlink" href="import.html#import-hooks" title="Link to this heading">¶</a></h3>
<p id="index-9">임포트 절차는 확장할 수 있도록 설계되었습니다; 일차적인 메커니즘은 <em>임포트 훅(import hook)</em> 입니다. 두 가지 종류의 임포트 훅이 있습니다: <em>메타 훅(meta hook)</em> 과 <em>임포트 경로 훅(import path hook)</em>.</p>
<p>메타 훅은 임포트 처리의 처음에, <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 캐시 조회를 제외한 다른 임포트 처리들이 시작되기 전에 호출됩니다. 이것은 메타 훅이 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 처리, 프로즌 모듈, 내장 모듈들을 재정의할 수 있게 합니다. 다음에 설명하듯이, 메타 훅은 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 에 새 파인더 객체를 추가하는 방법으로 등록할 수 있습니다.</p>
<p>임포트 경로 훅은 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> (혹은 <code class="docutils literal notranslate"><span class="pre">package.__path__</span></code>) 처리 일부로, 관련된 경로 항목을 만나는 시점에 호출됩니다. 다음에 설명하듯이, 임포트 경로 훅은 <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 에 새 콜러블을 추가하는 방법으로 등록할 수 있습니다.</p>
</section>
<section id="the-meta-path">
<h3><span class="section-number">5.3.4. </span>메타 경로(meta path)<a class="headerlink" href="import.html#the-meta-path" title="Link to this heading">¶</a></h3>
<p id="index-10">주어진 이름의 모듈을 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에서 찾을 수 없을 때, 파이썬은 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 를 검색하는데, 메타 경로 파인더 객체들의 목록을 포함하고 있습니다. 이 파인더들이 주어진 이름의 모듈을 처리하는 방법을 알고 있는지 확인하도록 요청합니다. 메타 경로 파인더들은 <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 라는 이름의 메서드를 구현해야만 하는데, 세 개의 인자를 받아들입니다: 이름, 임포트 경로, (생략 가능한) 타깃(target) 모듈. 메타 경로 파인더는 주어진 이름의 모듈을 처리할 수 있는지를 결정하기 위해 어떤 전략이건 사용할 수 있습니다.</p>
<p>만약 메타 경로 파인더가 주어진 이름의 모듈을 처리하는 법을 안다면, 스펙 객체를 돌려줍니다. 그럴 수 없다면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 돌려줍니다. 만약 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 처리가 스펙을 돌려주지 못하고 목록의 끝에 도달하면, <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> 를 일으킵니다. 발생하는 다른 예외들은 그냥 확산시키고, 임포트 프로세스를 중단합니다.</p>
<p>메타 경로 파인더의 <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 메서드는 두 개나 세 개의 인자로 호출됩니다. 첫 번째 인자는 모듈의 완전히 정규화된 이름(fully qualified name)입니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>. 두 번째 인자는 모듈 검색에 사용할 경로 엔트리입니다. 최상위 모듈이 경우 두 번째 인자는 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이지만, 서브 모듈이나 서브 패키지의 경우 두 번째 인자는 부모 패키지의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트 값입니다. 만약 적절한 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트를 참조할 수 없으면 <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> 를 일으킵니다. 세 번째 인자는 이미 존재하는 모듈 객체인데, 뒤에서 로딩할 대상이 됩니다. 임포트 시스템은 다시 로드(reload)할 때만 타깃을 전달합니다.</p>
<p>메타 경로는 한 번의 임포트 요청에 대해 여러 번 탐색 될 수 있습니다. 예를 들어, 대상 모듈들이 아무것도 캐싱 되지 않았다고 할 때, <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> 를 임포트 하려면, 먼저 각 메타 경로 파인더 (<code class="docutils literal notranslate"><span class="pre">mpf</span></code>)들에 대해 <code class="docutils literal notranslate"><span class="pre">mpf.find_spec(&quot;foo&quot;,</span> <span class="pre">None,</span> <span class="pre">None)</span></code> 를 호출해서 최상위 임포트를 수행합니다. <code class="docutils literal notranslate"><span class="pre">foo</span></code> 가 임포트 된 후에, 메타 경로를 두 번째 탐색해서 <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> 를 임포트 하는데, <code class="docutils literal notranslate"><span class="pre">mpf.find_spec(&quot;foo.bar&quot;,</span> <span class="pre">foo.__path__,</span> <span class="pre">None)</span></code> 를 호출합니다. 일단 <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> 가 임포트 되면, 마지막 탐색은 <code class="docutils literal notranslate"><span class="pre">mpf.find_spec(&quot;foo.bar.baz&quot;,</span> <span class="pre">foo.bar.__path__,</span> <span class="pre">None)</span></code> 를 호출합니다.</p>
<p>어떤 메타 경로 파인더들은 오직 최상위 임포트만 지원합니다. 이런 임포터들은 두 번째 인자로 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 아닌 것이 오면 항상 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 돌려줍니다.</p>
<p>파이썬의 기본 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 는 세 개의 메타 경로 파인더를 갖고 있습니다. 하나는 내장 모듈을 임포트하는 법을 알고, 하나는 프로즌 모듈을 임포트하는 법을 알고, 하나는 <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">임포트 경로</span></a> 에서 모듈을 임포트하는 법을 압니다(즉 <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">경로 기반 파인더</span></a>).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>The <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> method of meta path
finders replaced <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code>, which
is now deprecated.  While it will continue to work without change, the
import machinery will try it only if the finder does not implement
<a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.10에서 변경: </span>Use of <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code> by the import system
now raises <a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code> has been removed.
Use <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> instead.</p>
</div>
</section>
</section>
<section id="loading">
<h2><span class="section-number">5.4. </span>로딩(loading)<a class="headerlink" href="import.html#loading" title="Link to this heading">¶</a></h2>
<p>모듈 스펙이 발견되면, 임포트 절차는 모듈을 로딩할 때 그것(그것이 가진 로더도)을 사용합니다. 여기에 임포트의 로딩 과정 동안 일어나는 일에 대한 대략적인 그림이 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">,</span> <span class="s1">&#39;create_module&#39;</span><span class="p">):</span>
    <span class="c1"># It is assumed &#39;exec_module&#39; will also be defined on the loader.</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">create_module</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">ModuleType</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># The import-related module attributes get set here:</span>
<span class="n">_init_module_attrs</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span>

<span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># unsupported</span>
    <span class="k">raise</span> <span class="ne">ImportError</span>
<span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># namespace package</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
<span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">,</span> <span class="s1">&#39;exec_module&#39;</span><span class="p">):</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">raise</span>
<span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
</pre></div>
</div>
<p>다음과 같은 세부 사항에 주의해야 합니다:</p>
<ul class="simple">
<li><p>만약 주어진 이름의 모듈이 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 있다면, 임포트는 이미 그걸 돌려줄 겁니다.</p></li>
<li><p>로더가 모듈을 실행하기 전에 모듈은 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 자리를 잡습니다. 이것은 필수적인데 모듈이 (직접적 혹은 간접적으로) 자신을 임포트 할 수 있기 때문입니다; 먼저 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 추가함으로써 최악의 상황에 제한 없는 재귀(recursion)를 방지하고, 최선의 상황에 여러 번 로딩되는 것을 막습니다.</p></li>
<li><p>로딩이 실패하면, 실패한 모듈(오직 실패한 모듈만)은 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에서 삭제됩니다. <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 캐시에 이미 있는 모듈과 부수적 효과로 성공적으로 로딩된 모듈들은 캐시에 남아있어야만 합니다. 이는 실패한 모듈조차 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 남아있게 되는 리로딩과 대비됩니다.</p></li>
<li><p>모듈이 만들어졌지만, 아직 실행되기 전에, <a class="reference internal" href="import.html#import-mod-attrs"><span class="std std-ref">뒤의 섹션</span></a> 에서 요약되듯이, 임포트 절차는 임포트 관련 모듈 어트리뷰트들을 설정합니다(위의 의사 코드 예에서 “_init_module_attrs”).</p></li>
<li><p>모듈 실행은 로딩에서 모듈의 이름 공간이 채워지는 결정적 순간입니다. 실행은 전적으로 로더에 위임되는데, 로더가 어떤 것이 어떻게 채워져야 하는지 결정합니다.</p></li>
<li><p>로딩 동안 만들어지고 exec_module() 로 전달되는 모듈은 임포트의 끝에 반환되는 것이 아닐 수 있습니다 <a class="footnote-reference brackets" href="import.html#fnlo" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>임포트 시스템이 기초 공사에 대한 로더의 책임을 들고 갔습니다. 이것들은 전에는 <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> 메서드에서 수행되었습니다.</p>
</div>
<section id="loaders">
<h3><span class="section-number">5.4.1. </span>로더<a class="headerlink" href="import.html#loaders" title="Link to this heading">¶</a></h3>
<p>모듈 로더는 로딩의 결정적인 기능을 제공합니다: 모듈 실행. 임포트 절차는 하나의 인자로 <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> 메서드를 호출하는데, 실행할 모듈 객체가 전달됩니다. <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> 이 돌려주는 값은 무시됩니다.</p>
<p>로더는 다음과 같은 요구 조건들을 만족해야 합니다:</p>
<ul class="simple">
<li><p>만약 모듈이 파이썬 모듈(내장 모듈이나 동적으로 로딩되는 확장이 아니라)이면, 로더는 모듈의 코드를 모듈의 전역 이름 공간(<code class="docutils literal notranslate"><span class="pre">module.__dict__</span></code>)에서 실행해야 합니다.</p></li>
<li><p>만약 로더가 모듈을 실행하지 못하면, <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 를 일으켜야 합니다. 하지만 <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> 동안 발생하는 다른 예외도 전파됩니다.</p></li>
</ul>
<p>많은 경우에, 파인더와 로더는 같은 객체입니다; 그런 경우 <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 메서드는 로더가 <code class="docutils literal notranslate"><span class="pre">self</span></code> 로 설정된 스펙을 돌려줍니다.</p>
<p>모듈 로더는 <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> 메서드를 구현함으로써 로딩하는 동안 모듈 객체를 만드는 일에 개입할 수 있습니다. 하나의 인자, 모듈 스펙, 을 받아들이고 로딩 중 사용할 모듈 객체를 돌려줍니다. <code class="docutils literal notranslate"><span class="pre">create_module()</span></code> 은 모듈 객체의 어트리뷰트를 설정할 필요는 없습니다. 만약 메서드가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 돌려주면, 임포트 절차는 새 모듈을 스스로 만듭니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4: </span>로더의 <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> 메서드.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code></a> 메서드는 <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> 로 대체되었고, 임포트 절차가 로딩의 공통 코드(boilerplate)에 대한 책임을 집니다.</p>
<p>이미 존재하는 로더들과의 호환을 위해, 임포트 절차는 <code class="docutils literal notranslate"><span class="pre">load_module()</span></code> 메서드가 존재하고, <code class="docutils literal notranslate"><span class="pre">exec_module()</span></code> 을 구현하지 않았으면 <code class="docutils literal notranslate"><span class="pre">load_module()</span></code> 을 사용합니다. 하지만 <code class="docutils literal notranslate"><span class="pre">load_module()</span></code> 은 폐지되었습니다. 로더는 대신 <code class="docutils literal notranslate"><span class="pre">exec_module()</span></code> 를 구현해야 합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">load_module()</span></code> 메서드는 모듈을 실행하는 것 외에 위에서 언급한 모든 공통(boilerplate) 로딩 기능을 구현해야만 합니다. 같은 제약들이 모두 적용되는데, 추가적인 설명을 붙여보면:</p>
<ul class="simple">
<li><p>만약 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 주어진 이름의 모듈 객체가 이미 존재하면, 로더는 반드시 그 객체를 사용해야 합니다. (그렇지 않으면, <a class="reference internal" href="../library/importlib.html#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.reload()</span></code></a> 이 올바로 동작하지 않게 됩니다.) 만약 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 주어진 이름의 모듈이 없으면, 로더는 새 모듈객체를 만들고 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 추가해야 합니다.</p></li>
<li><p>제한 없는 재귀와 여러 번 로딩되는 것을 방지하기 위해, 로더가 모듈 코드를 실행하기 전에 모듈이 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 존재해야 합니다.</p></li>
<li><p>만약 로딩이 실패하면, 로더는 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 삽입한 모듈들을 제거해야 하는데, 실패한 모듈만을 제거해야 하고, 로더가 그 모듈을 직접 명시적으로 로드한 경우에만 그래야 합니다.</p></li>
</ul>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><code class="docutils literal notranslate"><span class="pre">exec_module()</span></code> 이 정의되었지만 <code class="docutils literal notranslate"><span class="pre">create_module()</span></code> 이 정의되지 않으면 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> 이 발생합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><code class="docutils literal notranslate"><span class="pre">exec_module()</span></code> 이 정의되었지만 <code class="docutils literal notranslate"><span class="pre">create_module()</span></code> 이 정의되지 않으면 <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 를 일으킵니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.10에서 변경: </span>Use of <code class="docutils literal notranslate"><span class="pre">load_module()</span></code> will raise <a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a>.</p>
</div>
</section>
<section id="submodules">
<h3><span class="section-number">5.4.2. </span>서브 모듈<a class="headerlink" href="import.html#submodules" title="Link to this heading">¶</a></h3>
<p>어떤 메커니즘으로든 (예를 들어, <code class="docutils literal notranslate"><span class="pre">importlib</span></code> API들, <code class="docutils literal notranslate"><span class="pre">import</span></code> 나 <code class="docutils literal notranslate"><span class="pre">import-from</span></code> 문, 내장 <code class="docutils literal notranslate"><span class="pre">__import__()</span></code>) 서브 모듈이 로드될 때, 서브 모듈 객체로의 연결은 부모 모듈의 이름 공간에 이루어집니다. 예를 들어, 패키지 <code class="docutils literal notranslate"><span class="pre">spam</span></code> 이 서브 모듈 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 를 가지면, <code class="docutils literal notranslate"><span class="pre">spam.foo</span></code> 를 임포트 한 후에는 <code class="docutils literal notranslate"><span class="pre">spam</span></code> 이 서브 모듈에 연결된 어트리뷰트 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 를 갖게 됩니다. 다음과 같은 디렉터리 구조로 되어 있다고 합시다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">spam</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">foo</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>and <code class="docutils literal notranslate"><span class="pre">spam/__init__.py</span></code> has the following line in it:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">.foo</span> <span class="kn">import</span> <span class="n">Foo</span>
</pre></div>
</div>
<p>then executing the following puts name bindings for <code class="docutils literal notranslate"><span class="pre">foo</span></code> and <code class="docutils literal notranslate"><span class="pre">Foo</span></code> in the
<code class="docutils literal notranslate"><span class="pre">spam</span></code> module:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">spam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="n">foo</span>
<span class="go">&lt;module &#39;spam.foo&#39; from &#39;/tmp/imports/spam/foo.py&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="n">Foo</span>
<span class="go">&lt;class &#39;spam.foo.Foo&#39;&gt;</span>
</pre></div>
</div>
<p>파이썬의 익숙한 이름 연결 규칙에서 볼 때 의외의 결과로 보일 수 있습니다. 하지만 실제로는 임포트 시스템의 근본적인 기능입니다. 불변의 규칙은 이렇습니다: 만약 <code class="docutils literal notranslate"><span class="pre">sys.modules['spam']</span></code> 과 <code class="docutils literal notranslate"><span class="pre">sys.modules['spam.foo']</span></code> 가 있다면 (위의 임포트 이후의 상태가 그러합니다), 뒤에 있는 것은 반드시 앞에 있는 것의 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 어트리뷰트가 되어야 합니다.</p>
</section>
<section id="module-spec">
<h3><span class="section-number">5.4.3. </span>모듈 스펙<a class="headerlink" href="import.html#module-spec" title="Link to this heading">¶</a></h3>
<p>임포트 절차는 임포트 동안 각 모듈에 대한 다양한 정보들을 사용합니다, 특히 로딩 전에. 대부분 정보는 모든 모듈의 공통이다. 모듈 스펙의 목적은 이 임포트 관련 정보를 모듈별로 요약하는 것입니다.</p>
<p>임포트 동안 스펙을 사용하면 상태가 임포트 시스템의 구성 요소들로 전달될 수 있습니다, 예를 들어 모듈 스펙을 만드는 파인더와 그것을 실행하는 로더 간에. 가장 중요한 것은, 임포트 절차가 로딩의 공통 연산(boilerplate operation)을 수행할 수 있도록 하는 것입니다. 모듈 스펙이 없다면 로더가 모든 책임을 지게 됩니다.</p>
<p>모듈의 스펙은 모듈 객체의 <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> 어트리뷰트로 노출됩니다. 모듈 스펙의 내용에 대한 세부 사항은 <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a> 을 보세요.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</section>
<section id="import-related-module-attributes">
<span id="import-mod-attrs"></span><h3><span class="section-number">5.4.4. </span>임포트 관련 모듈 어트리뷰트<a class="headerlink" href="import.html#import-related-module-attributes" title="Link to this heading">¶</a></h3>
<p>임포트 절차는 로딩하는 동안 로더가 모듈을 실행하기 전에 모듈의 스팩에 기초해서 각 모듈 객체에 이 어트리뷰트들을 채워 넣습니다.</p>
<p>It is <strong>strongly</strong> recommended that you rely on <a class="reference internal" href="import.html#spec__" title="__spec__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__</span></code></a> and
its attributes instead of any of the other individual attributes
listed below.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="name__">
<span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="import.html#name__" title="Link to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">__name__</span></code> attribute must be set to the fully qualified name of
the module.  This name is used to uniquely identify the module in
the import system.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="loader__">
<span class="sig-name descname"><span class="pre">__loader__</span></span><a class="headerlink" href="import.html#loader__" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">__loader__</span></code> 어트리뷰트는 모듈을 로드할 때 임포트 절차가 사용한 로더 객체로 설정되어야 합니다. 이것은 주로 인트로스펙션(introspection)을 위한 것이지만, 추가적인 로더에 국한된 기능들을 위한 것이기도 합니다, 예를 들어 로더와 결합한 데이터를 얻는 것이 있습니다.</p>
<p>It is <strong>strongly</strong> recommended that you rely on <a class="reference internal" href="import.html#spec__" title="__spec__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__</span></code></a>
instead of this attribute.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span>The value of <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> is expected to be the same as
<code class="docutils literal notranslate"><span class="pre">__spec__.loader</span></code>.  The use of <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> is deprecated and slated
for removal in Python 3.14.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="package__">
<span class="sig-name descname"><span class="pre">__package__</span></span><a class="headerlink" href="import.html#package__" title="Link to this definition">¶</a></dt>
<dd><p>The module’s <code class="docutils literal notranslate"><span class="pre">__package__</span></code> attribute may be set.  Its value must
be a string, but it can be the same value as its <code class="docutils literal notranslate"><span class="pre">__name__</span></code>.  When
the module is a package, its <code class="docutils literal notranslate"><span class="pre">__package__</span></code> value should be set to
its <code class="docutils literal notranslate"><span class="pre">__name__</span></code>.  When the module is not a package, <code class="docutils literal notranslate"><span class="pre">__package__</span></code>
should be set to the empty string for top-level modules, or for
submodules, to the parent package’s name.  See <span class="target" id="index-11"></span><a class="pep reference external" href="https://peps.python.org/pep-0366/"><strong>PEP 366</strong></a> for further
details.</p>
<p>This attribute is used instead of <code class="docutils literal notranslate"><span class="pre">__name__</span></code> to calculate explicit
relative imports for main modules, as defined in <span class="target" id="index-12"></span><a class="pep reference external" href="https://peps.python.org/pep-0366/"><strong>PEP 366</strong></a>.</p>
<p>It is <strong>strongly</strong> recommended that you rely on <a class="reference internal" href="import.html#spec__" title="__spec__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__</span></code></a>
instead of this attribute.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><code class="docutils literal notranslate"><span class="pre">__package__</span></code> 의 값이 <code class="docutils literal notranslate"><span class="pre">__spec__.parent</span></code> 과 같을 것으로 기대됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.10에서 변경: </span><a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a> is raised if import falls back to
<code class="docutils literal notranslate"><span class="pre">__package__</span></code> instead of
<a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec.parent" title="importlib.machinery.ModuleSpec.parent"><code class="xref py py-attr docutils literal notranslate"><span class="pre">parent</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span>Raise <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> instead of <a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a>
when falling back to <code class="docutils literal notranslate"><span class="pre">__package__</span></code>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="spec__">
<span class="sig-name descname"><span class="pre">__spec__</span></span><a class="headerlink" href="import.html#spec__" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">__spec__</span></code> 어트리뷰트는 모듈을 임포트 할 때 사용한 모듈 스펙으로 설정되어야 합니다. <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> 을 적절히 설정하는 것은 <a class="reference internal" href="toplevel_components.html#programs"><span class="std std-ref">인터프리터가 구동되는 동안 초기화되는 모듈들</span></a> 에도 마찬가지로 적용됩니다. 한가지 예외는 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 인데, 어떤 경우에 <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> 이 <a class="reference internal" href="import.html#main-spec"><span class="std std-ref">어떤 경우에 None 으로 설정됩니다</span></a>.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">__spec__.parent</span></code> is not set, <code class="docutils literal notranslate"><span class="pre">__package__</span></code> is used as
a fallback.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><code class="docutils literal notranslate"><span class="pre">__package__</span></code> 가 정의되지 않으면, 대체물로 <code class="docutils literal notranslate"><span class="pre">__spec__.parent</span></code> 가 사용됩니다.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="path__">
<span class="sig-name descname"><span class="pre">__path__</span></span><a class="headerlink" href="import.html#path__" title="Link to this definition">¶</a></dt>
<dd><p>모듈이 패키지면 (정규 또는 이름 공간), 모듈 객체의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트가 반드시 설정되어야 합니다. 값은 이터러블이어야 하는데, <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 가 더는 의미가 없으면 빈 이터러블일 수 있습니다. 만약 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 가 비어있지 않다면, 탐색할 때 문자열을 제공해야 합니다. <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 의 의미에 관한 자세한 내용은 <a class="reference internal" href="import.html#package-path-rules"><span class="std std-ref">아래에</span></a> 나옵니다.</p>
<p>패키지가 아닌 모듈은 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트가 없어야 합니다.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="file__">
<span class="sig-name descname"><span class="pre">__file__</span></span><a class="headerlink" href="import.html#file__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cached__">
<span class="sig-name descname"><span class="pre">__cached__</span></span><a class="headerlink" href="import.html#cached__" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">__file__</span></code> is optional (if set, value must be a string). It indicates
the pathname of the file from which the module was loaded (if
loaded from a file), or the pathname of the shared library file
for extension modules loaded dynamically from a shared library.
It might be missing for certain types of modules, such as C
modules that are statically linked into the interpreter, and the
import system may opt to leave it unset if it has no semantic
meaning (e.g. a module loaded from a database).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">__file__</span></code> is set then the <code class="docutils literal notranslate"><span class="pre">__cached__</span></code> attribute might also
be set,  which is the path to any compiled version of
the code (e.g. byte-compiled file). The file does not need to exist
to set this attribute; the path can simply point to where the
compiled file would exist (see <span class="target" id="index-13"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a>).</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">__cached__</span></code> may be set even if <code class="docutils literal notranslate"><span class="pre">__file__</span></code> is not
set.  However, that scenario is quite atypical.  Ultimately, the
loader is what makes use of the module spec provided by the finder
(from which <code class="docutils literal notranslate"><span class="pre">__file__</span></code> and <code class="docutils literal notranslate"><span class="pre">__cached__</span></code> are derived).  So
if a loader can load from a cached module but otherwise does not load
from a file, that atypical scenario may be appropriate.</p>
<p>It is <strong>strongly</strong> recommended that you rely on <a class="reference internal" href="import.html#spec__" title="__spec__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__</span></code></a>
instead of <code class="docutils literal notranslate"><span class="pre">__cached__</span></code>.</p>
</dd></dl>

</section>
<section id="module-path">
<span id="package-path-rules"></span><h3><span class="section-number">5.4.5. </span>module.__path__<a class="headerlink" href="import.html#module-path" title="Link to this heading">¶</a></h3>
<p>정의에 따르면, 모듈에 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트가 있으면, 이 모듈은 패키지입니다.</p>
<p>패키지의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트는 서브 패키지를 로딩할 때 사용합니다. 임포트 절차 내에서, 임포트하는 동안 모듈을 검색할 위치들의 목록을 제공한다는 점에서 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 와 같은 기능을 갖습니다. 하지만 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 는 보통 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 보다 제약 조건이 많습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">__path__</span></code> 는 문자열의 이터러블이지만, 비어있을 수 있습니다. <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 과 같은 규칙이 패키지의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 에도 적용되고, 패키지의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 를 탐색하는 동안 <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> (아래에서 설명한다)에게 의견을 묻습니다.</p>
<p>패키지의 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 파일은 패키지의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트를 설정하거나 변경할 수 있고, 이것이 <span class="target" id="index-43"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> 이전에 이름 공간 패키지를 구현하는 방법으로 사용됐습니다. <span class="target" id="index-44"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> 의 도입으로 인해, 이름 공간 패키지가 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 조작 코드만을 포함하는 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 파일을 제공할 필요가 없어졌습니다; 임포트 절차가 자동으로 이름 공간 패키지를 위한 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 를 설정합니다.</p>
</section>
<section id="module-reprs">
<h3><span class="section-number">5.4.6. </span>모듈 repr<a class="headerlink" href="import.html#module-reprs" title="Link to this heading">¶</a></h3>
<p>기본적으로, 모든 모듈은 사용할만한 repr 을 갖고 있습니다. 하지만 위의 어트리뷰트들과 모듈 스펙에 있는 것들에 따라, 모듈 객체의 repr 을 좀 더 명시적으로 제어할 수 있습니다.</p>
<p>모듈이 스펙(<code class="docutils literal notranslate"><span class="pre">__spec__</span></code>)을 가지면, 임포트 절차는 그것으로부터 repr 을 만들려고 시도합니다. 그것이 실패하거나 스펙이 없으면, 임포트 시스템은 모듈에서 제공되는 것들로 기본 repr 을 구성합니다. <code class="docutils literal notranslate"><span class="pre">module.__name__</span></code>, <code class="docutils literal notranslate"><span class="pre">module.__file__</span></code>, <code class="docutils literal notranslate"><span class="pre">module.__loader__</span></code> 을 repr 의 입력으로 사용하려고 시도하는데, 빠진 정보는 기본값으로 채웁니다.</p>
<p>사용되고 있는 정확한 규칙은 이렇습니다:</p>
<ul class="simple">
<li><p>모듈이 <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> 어트리뷰트를 가지면, 스펙에 있는 정보로 repr 을 생성합니다. “name”, “loader”, “origin”, “has_location” 어트리뷰트들이 사용됩니다.</p></li>
<li><p>모듈이 <code class="docutils literal notranslate"><span class="pre">__file__</span></code> 어트리뷰트를 가지면, 모듈의 repr 의 일부로 사용됩니다.</p></li>
<li><p>모듈이 <code class="docutils literal notranslate"><span class="pre">__file__</span></code> 어트리뷰트를 갖지 않지만 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 아닌 <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> 를 가지면, 로더의 repr 이 모듈의 repr 의 일부로 사용됩니다.</p></li>
<li><p>그렇지 않으면, repr 에 모듈의 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 을 사용합니다.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span>Use of <code class="xref py py-meth docutils literal notranslate"><span class="pre">module_repr()</span></code>, having been deprecated since Python 3.4, was
removed in Python 3.12 and is no longer called during the resolution of a
module’s repr.</p>
</div>
</section>
<section id="cached-bytecode-invalidation">
<span id="pyc-invalidation"></span><h3><span class="section-number">5.4.7. </span>캐시된 바이트 코드 무효화<a class="headerlink" href="import.html#cached-bytecode-invalidation" title="Link to this heading">¶</a></h3>
<p>파이썬이 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일로부터 캐시 된 바이트 코드를 로드하기 전에, 캐시가 최신 버전인지 소스 <code class="docutils literal notranslate"><span class="pre">.py</span></code> 파일과 비교합니다. 기본적으로, 파이썬은 소스의 최종 수정 타임스탬프와 크기를 캐시 파일을 만들 때 함께 저장해서 이 작업을 수행합니다. 실행시간에, 임포트 시스템은 캐시 파일에 저장된 메타 데이터를 소스의 메타 데이터와 대조하여 캐시 파일의 유효성을 검사합니다.</p>
<p>파이썬은 또한 “해시 기반” 캐시 파일을 지원하는데, 캐시 파일은 메타 데이터 대신에 소스 파일의 내용 해시를 저장합니다. 해시 기반 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일에는 두 가지 변종이 있습니다: 검사형(checked)과 비검사형(unchecked). 검사형 해시 기반 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일의 경우, 파이썬은 소스 파일을 해시하고 결과 해시를 캐시 파일의 해시와 비교하여 캐시 파일의 유효성을 검사합니다. 검사형 해시 기반 캐시 파일이 유효하지 않은 것으로 판명되면, 파이썬은 캐시 파일을 다시 생성하고 새로운 검사형 해시 기반 캐시 파일을 만듭니다. 비검사형 해시 기반 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일의 경우, 파이썬은 단순히 캐시 파일이 존재할 경우 유효하다고 가정합니다. 해시 기반 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일 유효성 검사 동작은 <a class="reference internal" href="../using/cmdline.html#cmdoption-check-hash-based-pycs"><code class="xref std std-option docutils literal notranslate"><span class="pre">--check-hash-based-pycs</span></code></a> 플래그로 재정의될 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>해시 기반 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일을 추가했습니다. 이전에는, 파이썬은 바이트 코드 캐시의 타임스탬프 기반 무효화만 지원했습니다.</p>
</div>
</section>
</section>
<section id="the-path-based-finder">
<h2><span class="section-number">5.5. </span>경로 기반 파인더<a class="headerlink" href="import.html#the-path-based-finder" title="Link to this heading">¶</a></h2>
<p id="index-16">앞에서 언급했듯이, 파이썬은 여러 기본 메타 경로 파인더들을 갖고 있습니다. 이 중 하나는, <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">경로 기반 파인더</span></a> (<a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder" title="importlib.machinery.PathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathFinder</span></code></a>) 로 불리는데, <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">경로 엔트리</span></a> 들의 목록을 담고 있는 <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">임포트 경로</span></a> 를 검색합니다. 각 경로 엔트리는 모듈을 찾을 곳을 가리킵니다.</p>
<p>경로 기반 파인더 자신은 뭔가를 임포트하는 법에 대해서는 아는 것이 없습니다. 대신에, 각 경로 엔트리를 탐색하면서, 각각을 구체적인 경로 엔트리를 다루는 법을 아는 경로 엔트리 파인더와 관련시킵니다.</p>
<p>경로 엔트리 파인더의 기본 집합은 파일 시스템에서 모듈을 찾는데 필요한 모든 개념을 구현하는데, 파이썬 소스 코드(<code class="docutils literal notranslate"><span class="pre">.py</span></code> 파일들), 파이썬 바이트 코드(<code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일들), 공유 라이브러리(예를 들어 <code class="docutils literal notranslate"><span class="pre">.so</span></code> 파일들)와 같은 특수 파일형들을 처리합니다. 표준라이브러리의 <a class="reference internal" href="../library/zipimport.html#module-zipimport" title="zipimport: Support for importing Python modules from ZIP archives."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipimport</span></code></a> 모듈의 지원을 받으면, 기본 경로 엔트리 파인더는 이 모든 파일(공유 라이브러리를 제외한 것들)을 zip 파일들로부터 로딩합니다.</p>
<p>경로 엔트리가 파일 시스템의 위치로 제한될 필요는 없습니다. URL이나 데이터베이스 조회나 문자열로 지정될 수 있는 어떤 위치도 가능합니다.</p>
<p>경로 기반 파인더는 검색 가능한 경로 엔트리의 유형을 확장하고 커스터마이즈할 수 있도록 하는 추가의 훅과 프로토콜을 제공합니다. 예를 들어, 네트워크 URL을 경로 엔트리로 지원하고 싶다면, 웹에서 모듈을 찾는 HTTP 개념을 구현하는 훅을 작성할 수 있습니다. 이 훅 (콜러블)은 아래에서 설명하는 프로토콜을 지원하는 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a> 를 돌려주는데, 웹에 있는 모듈을 위한 로더를 얻는 데 사용됩니다.</p>
<p>경고의 글: 이 섹션과 앞에 나온 것들은 모두 파인더라는 용어를 사용하는데, <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">메타 경로 파인더</span></a> 와 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a> 라는 용어를 사용해서 구분합니다. 이 두 종류의 파인더는 매우 유사해서 비슷한 프로토콜을 지원하고 임포트 절차에서 비슷한 방식으로 기능합니다. 하지만 이것들이 미묘하게 다르다는 것을 기억하는 것이 중요합니다. 특히, 메타 경로 파인더는 임포트 절차의 처음에 개입하는데, <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 탐색을 통해 들어옵니다.</p>
<p>반면에, 경로 엔트리 파인더는 경로 기반 파인더의 구현 상세인데, 사실 경로 기반 파인더가 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 로 부터 제거되면, 경로 엔트리 파인더의 개념은 일절 호출되지 않습니다.</p>
<section id="path-entry-finders">
<h3><span class="section-number">5.5.1. </span>경로 엔트리 파인더<a class="headerlink" href="import.html#path-entry-finders" title="Link to this heading">¶</a></h3>
<p id="index-17"><a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">경로 기반 파인더</span></a> 는 위치가 문자열 <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">경로 엔트리</span></a> 로 지정된 파이썬 모듈과 패키지를 찾고 로드하는 책임을 집니다. 대부분의 경로 엔트리는 파일 시스템의 위치를 가리키지만, 이것으로 한정될 필요는 없습니다.</p>
<p>메타 경로 파인더로서, <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">경로 기반 파인더</span></a> 는 앞에서 설명한 <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 프로토콜을 구현합니다. 하지만 모듈이 <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">임포트 경로</span></a> 에서 어떻게 발견되고 로드되는지는 커스터마이즈하는데 사용될 수 있는 추가의 훅을 제공합니다.</p>
<p><a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">경로 기반 파인더</span></a> 는 세 개의 변수를 사용합니다, <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>, <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>, <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>. 패키지 객체의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트 또한 사용된다. 이것들은 임포트 절차를 커스터마이즈할 수 있는 추가의 방법을 제공합니다.</p>
<p><a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> contains a list of strings providing search locations for
modules and packages.  It is initialized from the <span class="target" id="index-18"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPATH</span></code></a>
environment variable and various other installation- and
implementation-specific defaults.  Entries in <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> can name
directories on the file system, zip files, and potentially other “locations”
(see the <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> module) that should be searched for modules, such as
URLs, or database queries.  Only strings should be present on
<a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>; all other data types are ignored.</p>
<p><a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">경로 기반 파인더</span></a> 는 <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">메타 경로 파인더</span></a> 이기 때문에, 앞에서 설명했듯이 임포트 절차는 경로 기반 파인더의 <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 메서드를 호출하는 것으로 <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">임포트 경로</span></a> 검색을 시작합니다. <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 에 제공되는 <code class="docutils literal notranslate"><span class="pre">path</span></code> 인자는 탐색할 문자열 경로들의 리스트입니다 - 보통 패키지 내에서 임포트 하면 패키지의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트. <code class="docutils literal notranslate"><span class="pre">path</span></code> 인자가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, 최상위 임포트를 뜻하고 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 가 사용됩니다.</p>
<p>The path based finder iterates over every entry in the search path, and
for each of these, looks for an appropriate <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a>
(<a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathEntryFinder</span></code></a>) for the
path entry.  Because this can be an expensive operation (e.g. there may be
<code class="docutils literal notranslate"><span class="pre">stat()</span></code> call overheads for this search), the path based finder maintains
a cache mapping path entries to path entry finders.  This cache is maintained
in <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> (despite the name, this cache actually
stores finder objects rather than being limited to <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a> objects).
In this way, the expensive search for a particular <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">path entry</span></a>
location’s <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> need only be done once.  User code is
free to remove cache entries from <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> forcing
the path based finder to perform the path entry search again.</p>
<p>경로 엔트리가 캐시에 없으면, 경로 기반 파인더는 <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 에 있는 모든 콜러블들을 탐색합니다. 이 목록의 각 <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">경로 엔트리 훅</span></a> 은 검색할 경로 엔트리 인자 한 개를 사용해서 호출됩니다. 이 콜러블은 경로 엔트리를 다룰 수 있는 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a> 를 돌려주거나, <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 를 발생시킬 수 있습니다. <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 는 경로 기반 파인더가 어떤 훅이 주어진 <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">경로 엔트리</span></a> 를 위한 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a> 를 발견할 수 없음을 알리는 데 사용합니다. 이 예외는 무시되고 <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">임포트 경로</span></a> 탐색은 계속됩니다. 훅은 문자열이나 바이트열을 기대해야 합니다; 바이트열의 인코딩은 훅이 결정하고(예를 들어, 파일 시스템 인코딩이나 UTF-8 이나 그 밖의 다른 것일 수 있습니다), 만약 훅이 인자를 디코딩할 수 없으면 <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 를 일으켜야 합니다.</p>
<p>만약 <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 탐색이 아무런 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a> 를 돌려주지 못하면, 경로 기반 파인더의 <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 메서드는 <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 에 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 저장하고(이 경로 엔트리를 위한 파인더가 없음을 가리키기 위해), <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 돌려줘서 이 <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">메타 경로 파인더</span></a> 가 모듈을 찾을 수 없음을 알립니다.</p>
<p>만약 <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 에 있는 어느 하나의 <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">경로 엔트리 훅</span></a> 콜러블이 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a> 를 <em>돌려주면</em>, 파인더에 모듈 스펙을 요청하기 위해 다음에 나오는 프로토콜이 사용됩니다. 모듈 스펙은 모듈을 로딩할 때 사용됩니다.</p>
<p>현재 작업 디렉터리(current working directory) – 빈 문자열로 표현된다 – 는 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 에 있는 다른 엔트리들과 약간 다르게 취급됩니다. 첫째로, 현재 작업 디렉터리가 존재하지 않음이 발견되면 <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 에는 아무런 값도 저장되지 않습니다. 둘째로, 현재 작업 디렉터리는 각 모듈 조회 때마다 다시 확인됩니다. 셋째로, <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 에 사용되는 경로와 <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder.find_spec()</span></code></a> 가 돌려주는 경로는 빈 문자열이 아니라 실제 현재 작업 디렉터리가 됩니다.</p>
</section>
<section id="path-entry-finder-protocol">
<h3><span class="section-number">5.5.2. </span>경로 엔트리 파인더 프로토콜<a class="headerlink" href="import.html#path-entry-finder-protocol" title="Link to this heading">¶</a></h3>
<p>모듈과 초기화된 패키지의 임포트를 지원하고 이름 공간 패키지에 포션으로 이바지하기 위해, 경로 엔트리 파인더는 <a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 메서드를 구현해야 합니다.</p>
<p><a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 은 두 개의 인자를 받아들입니다: 임포트 할 모듈의 완전히 정규화된 이름과 (생략 가능한) 타깃 모듈. <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code> 은 값이 완전히 채워진 모듈의 스펙을 돌려줍니다. 이 스펙은 항상 “loader” 가 설정됩니다(한가지 예외가 있습니다).</p>
<p>To indicate to the import machinery that the spec represents a namespace
<a class="reference internal" href="../glossary.html#term-portion"><span class="xref std std-term">portion</span></a>, the path entry finder sets <code class="docutils literal notranslate"><span class="pre">submodule_search_locations</span></code> to
a list containing the portion.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> replaced
<code class="xref py py-meth docutils literal notranslate"><span class="pre">find_loader()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code>, both of which
are now deprecated, but will be used if <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code> is not defined.</p>
<p>예전의 경로 엔트리 파인더는 <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code> 대신에 이 두 개의 폐지된 메서드들을 구현할 수 있습니다. 이 메서드들은 과거 호환성 때문에 아직도 사용됩니다. 하지만, <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code> 이 경로 엔트리 파인더에 구현되면, 예전 메서드들은 무시됩니다.</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_loader()</span></code> takes one argument, the
fully qualified name of the module being imported.  <code class="docutils literal notranslate"><span class="pre">find_loader()</span></code>
returns a 2-tuple where the first item is the loader and the second item
is a namespace <a class="reference internal" href="../glossary.html#term-portion"><span class="xref std std-term">portion</span></a>.</p>
<p>임포트 프로토콜의 다른 구현들과의 과거 호환성을 위해, 많은 경로 엔트리 파인더들은 메타 경로 파인더가 지원하는 것과 같고 전통적인 <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> 메서드 또한 지원합니다. 하지만 경로 엔트리 파인더 <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> 메서드는 결코 <code class="docutils literal notranslate"><span class="pre">path</span></code> 인자로 호출되지 않습니다 (그것들은 경로 훅의 최초 호출 때 적절한 경로 정보를 기록해둘 것으로 기대됩니다).</p>
<p>경로 엔트리 파인더의 <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> 메서드는 경로 엔트리 파인더가 이름 공간 패키지에 포션으로 이바지하는 것을 허락하지 않기 때문에 폐지되었습니다. 만약 경로 엔트리 파인더에 <code class="docutils literal notranslate"><span class="pre">find_loader()</span></code> 와 <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> 이 모두 존재하면, 임포트 시스템은 항상 <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> 대신 <code class="docutils literal notranslate"><span class="pre">find_loader()</span></code> 를 호출합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.10에서 변경: </span>Calls to <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">find_loader()</span></code> by the import
system will raise <a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span><code class="docutils literal notranslate"><span class="pre">find_module()</span></code> and <code class="docutils literal notranslate"><span class="pre">find_loader()</span></code> have been removed.</p>
</div>
</section>
</section>
<section id="replacing-the-standard-import-system">
<h2><span class="section-number">5.6. </span>표준 임포트 시스템 교체하기<a class="headerlink" href="import.html#replacing-the-standard-import-system" title="Link to this heading">¶</a></h2>
<p>임포트 시스템 전체를 교체하기 위한 가장 신뢰성 있는 메커니즘은 <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 의 기본값들을 모두 삭제하고, 새로 만든 메타 경로 훅들로 채우는 것입니다.</p>
<p>만약 임포트 시스템을 액세스하는 다른 API들에 영향을 주지 않고, 단지 임포트 문의 동작만을 변경해도 좋다면, 내장 <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수를 교체하는 것으로 충분할 수도 있습니다. 이 기법은 특정 모듈 내에서의 임포트 문의 동작만을 변경하도록 모듈 수준에서 적용될 수도 있습니다.</p>
<p>메타 경로의 앞쪽에 있는 훅에서 어떤 모듈의 임포트를 선택적으로 막으려면(표준 임포트 시스템을 완전히 비활성화하는 대신), <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 에서 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 돌려주는 대신, <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> 를 일으키는 것으로 충분합니다. 전자는 메타 경로 검색을 계속해야 한다는 것을 지시하는 반면, 예외를 일으키면 즉시 종료시킵니다.</p>
</section>
<section id="package-relative-imports">
<span id="relativeimports"></span><h2><span class="section-number">5.7. </span>패키지 상대 임포트<a class="headerlink" href="import.html#package-relative-imports" title="Link to this heading">¶</a></h2>
<p>상대 임포트는 선행 점을 사용합니다. 단일 선행 점은 현재 패키지에서 시작하는 상대 임포트를 나타냅니다. 두 개 이상의 선행 점은 현재 패키지의 부모(들)에 대한 상대 임포트를 나타내며, 첫 번째 점 다음의 점 하나당 하나의 수준을 나타냅니다. 예를 들어, 다음과 같은 패키지 배치가 제공될 때:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">package</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">subpackage1</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
        <span class="n">moduleX</span><span class="o">.</span><span class="n">py</span>
        <span class="n">moduleY</span><span class="o">.</span><span class="n">py</span>
    <span class="n">subpackage2</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
        <span class="n">moduleZ</span><span class="o">.</span><span class="n">py</span>
    <span class="n">moduleA</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">subpackage1/moduleX.py</span></code>나 <code class="docutils literal notranslate"><span class="pre">subpackage1/__init__.py</span></code> 모두에서, 다음은 유효한 상대 임포트입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">.moduleY</span> <span class="kn">import</span> <span class="n">spam</span>
<span class="kn">from</span> <span class="nn">.moduleY</span> <span class="kn">import</span> <span class="n">spam</span> <span class="k">as</span> <span class="n">ham</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">moduleY</span>
<span class="kn">from</span> <span class="nn">..subpackage1</span> <span class="kn">import</span> <span class="n">moduleY</span>
<span class="kn">from</span> <span class="nn">..subpackage2.moduleZ</span> <span class="kn">import</span> <span class="n">eggs</span>
<span class="kn">from</span> <span class="nn">..moduleA</span> <span class="kn">import</span> <span class="n">foo</span>
</pre></div>
</div>
<p>절대 임포트는 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">&lt;&gt;</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">&lt;&gt;</span> <span class="pre">import</span> <span class="pre">&lt;&gt;</span></code> 문법을 사용할 수 있지만, 상대 임포트는 두 번째 형식만 사용할 수 있습니다; 그 이유는:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">XXX.YYY.ZZZ</span>
</pre></div>
</div>
<p>가 <code class="docutils literal notranslate"><span class="pre">XXX.YYY.ZZZ</span></code>를 사용할 수 있는 표현식으로 노출하지만, .moduleY는 유효한 표현식이 아니기 때문입니다.</p>
</section>
<section id="special-considerations-for-main">
<span id="import-dunder-main"></span><h2><span class="section-number">5.8. </span>__main__ 에 대한 특별한 고려<a class="headerlink" href="import.html#special-considerations-for-main" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 모듈은 파이썬의 임포트 시스템에서 특별한 경우입니다. <a class="reference internal" href="toplevel_components.html#programs"><span class="std std-ref">다른 곳에서</span></a> 언급했듯이, <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 모듈은 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 와 <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 처럼 인터프리터 시작 때 직접 초기화됩니다. 하지만, 이 두 개와는 다르게, 이것은 엄밀하게 내장 모듈로 취급되지 않습니다. 이것은 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 이 초기화되는 방식이 인터프리터를 실행할 때 주는 플래그와 다른 옵션들에 영향을 받기 때문입니다.</p>
<section id="main-spec">
<span id="id4"></span><h3><span class="section-number">5.8.1. </span>__main__.__spec__<a class="headerlink" href="import.html#main-spec" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 이 어떻게 초기화되는지에 따라, <code class="docutils literal notranslate"><span class="pre">__main__.__spec__</span></code> 은 적절히 설정되기도 하고 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정되기도 합니다.</p>
<p>파이썬이 <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> 옵션으로 시작하면, <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> 은 해당하는 모듈이나 패키지의 모듈 스팩으로 설정됩니다. 또한 <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> 은 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 모듈이 디렉터리나 zip 파일이나 다른 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 엔트리를 실행하는 일부로 로드될 때 그 내용이 채워집니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#using-on-interface-options"><span class="std std-ref">나머지 경우</span></a> 에는 <code class="docutils literal notranslate"><span class="pre">__main__.__spec__</span></code> 은 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정되는데, <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 을 채우는데 사용된 코드가 임포트 가능한 모듈에 직접 대응하지 않기 때문입니다:</p>
<ul class="simple">
<li><p>대화형 프롬프트</p></li>
<li><p><a class="reference internal" href="../using/cmdline.html#cmdoption-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">-c</span></code></a> 옵션</p></li>
<li><p>표준 입력으로 실행</p></li>
<li><p>소스 파일이나 바이트 코드 파일로부터 직접 실행</p></li>
</ul>
<p>마지막 경우에 <code class="docutils literal notranslate"><span class="pre">__main__.__spec__</span></code> 이 항상 <code class="docutils literal notranslate"><span class="pre">None</span></code> 임에 주의해야 합니다. 설사 그 파일이 기술적으로 모듈로 임포트 될 수 있어도 그렇습니다. <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 에 올바른 모듈 메타데이터가 필요하다면 <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> 스위치를 사용해야 합니다.</p>
<p>또한 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 이 임포트 가능한 모듈에 대응되고, <code class="docutils literal notranslate"><span class="pre">__main__.__spec__</span></code> 이 적절히 설정되었다 하더라도, 이 둘은 여전히 <em>다른</em> 모듈로 취급됨에 주의해야 합니다. 이것은 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">&quot;__main__&quot;:</span></code> 검사로 둘러싸인 블록이 모듈이 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 이름 공간을 채울 때만 실행되고, 일반적인 임포트 때는 실행되지 않는다는 사실 때문입니다.</p>
</section>
</section>
<section id="references">
<h2><span class="section-number">5.9. </span>참고문헌<a class="headerlink" href="import.html#references" title="Link to this heading">¶</a></h2>
<p>임포트 절차는 파이썬의 초창기부터 상당히 변해왔습니다. 문서를 작성한 이후에 약간의 세부사항이 변경되었기는 하지만, 최초의 <a class="reference external" href="https://www.python.org/doc/essays/packages/">패키지 규격</a> 은 아직 읽을 수 있도록 남아있습니다.</p>
<p><a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 의 최초 규격은 <span class="target" id="index-45"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> 이고, 뒤이은 확장은 <span class="target" id="index-46"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> 입니다.</p>
<p><span class="target" id="index-21"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> introduced <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">namespace packages</span></a> for
Python 3.3.  <span class="target" id="index-22"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> also introduced the <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_loader()</span></code> protocol as an
alternative to <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code>.</p>
<p><span class="target" id="index-47"></span><a class="pep reference external" href="https://peps.python.org/pep-0366/"><strong>PEP 366</strong></a> 은 메인 모듈에서의 명시적인 상태 임포트를 위한 <code class="docutils literal notranslate"><span class="pre">__package__</span></code> 어트리뷰트의 추가에 관해 설명하고 있습니다.</p>
<p><span class="target" id="index-48"></span><a class="pep reference external" href="https://peps.python.org/pep-0328/"><strong>PEP 328</strong></a> 은 절대와 명시적인 상대 임포트들 도입하고 <span class="target" id="index-49"></span><a class="pep reference external" href="https://peps.python.org/pep-0366/"><strong>PEP 366</strong></a> 이 결국 <code class="docutils literal notranslate"><span class="pre">__package__</span></code> 를 지정하게 되는 개념을 초기에 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 으로 제안했습니다.</p>
<p><span class="target" id="index-50"></span><a class="pep reference external" href="https://peps.python.org/pep-0338/"><strong>PEP 338</strong></a> 은 모듈을 스크립트로 실행하는 것을 정의합니다.</p>
<p><span class="target" id="index-51"></span><a class="pep reference external" href="https://peps.python.org/pep-0451/"><strong>PEP 451</strong></a> 은 스팩 객체에 모듈별 임포트 상태를 요약하는 것을 추가합니다. 로더들에 주어졌던 대부분의 공통 코드 책임들을 임포트 절차로 옮기기도 했습니다. 이 변경은 임포트 시스템의 여러 API 들을 폐지하도록 만들었고, 파인더와 로더에 새 메서드들을 추가하기도 했습니다.</p>
<p class="rubric">각주</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fnmo" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="import.html#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> 을 보세요.</p>
</aside>
<aside class="footnote brackets" id="fnlo" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="import.html#id3">2</a><span class="fn-bracket">]</span></span>
<p>importlib 구현은 반환 값을 직접 사용하지 않습니다. 대신에, <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에서 모듈 이름을 조회해서 모듈을 얻습니다. 이것의 간접적인 효과는 임포트되는 모듈이 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 있는 자신을 바꿀 수 있다는 것입니다. 이것은 구현 상세 동작이고 다른 파이썬 구현에서 동작한다고 보장되지 않습니다.</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="import.html#">5. 임포트 시스템</a><ul>
<li><a class="reference internal" href="import.html#importlib">5.1. <code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a></li>
<li><a class="reference internal" href="import.html#packages">5.2. 패키지(package)</a><ul>
<li><a class="reference internal" href="import.html#regular-packages">5.2.1. 정규 패키지</a></li>
<li><a class="reference internal" href="import.html#namespace-packages">5.2.2. 이름 공간 패키지</a></li>
</ul>
</li>
<li><a class="reference internal" href="import.html#searching">5.3. 검색</a><ul>
<li><a class="reference internal" href="import.html#the-module-cache">5.3.1. 모듈 캐시</a></li>
<li><a class="reference internal" href="import.html#finders-and-loaders">5.3.2. 파인더(finder)와 로더(loader)</a></li>
<li><a class="reference internal" href="import.html#import-hooks">5.3.3. 임포트 훅(import hooks)</a></li>
<li><a class="reference internal" href="import.html#the-meta-path">5.3.4. 메타 경로(meta path)</a></li>
</ul>
</li>
<li><a class="reference internal" href="import.html#loading">5.4. 로딩(loading)</a><ul>
<li><a class="reference internal" href="import.html#loaders">5.4.1. 로더</a></li>
<li><a class="reference internal" href="import.html#submodules">5.4.2. 서브 모듈</a></li>
<li><a class="reference internal" href="import.html#module-spec">5.4.3. 모듈 스펙</a></li>
<li><a class="reference internal" href="import.html#import-related-module-attributes">5.4.4. 임포트 관련 모듈 어트리뷰트</a></li>
<li><a class="reference internal" href="import.html#module-path">5.4.5. module.__path__</a></li>
<li><a class="reference internal" href="import.html#module-reprs">5.4.6. 모듈 repr</a></li>
<li><a class="reference internal" href="import.html#cached-bytecode-invalidation">5.4.7. 캐시된 바이트 코드 무효화</a></li>
</ul>
</li>
<li><a class="reference internal" href="import.html#the-path-based-finder">5.5. 경로 기반 파인더</a><ul>
<li><a class="reference internal" href="import.html#path-entry-finders">5.5.1. 경로 엔트리 파인더</a></li>
<li><a class="reference internal" href="import.html#path-entry-finder-protocol">5.5.2. 경로 엔트리 파인더 프로토콜</a></li>
</ul>
</li>
<li><a class="reference internal" href="import.html#replacing-the-standard-import-system">5.6. 표준 임포트 시스템 교체하기</a></li>
<li><a class="reference internal" href="import.html#package-relative-imports">5.7. 패키지 상대 임포트</a></li>
<li><a class="reference internal" href="import.html#special-considerations-for-main">5.8. __main__ 에 대한 특별한 고려</a><ul>
<li><a class="reference internal" href="import.html#main-spec">5.8.1. __main__.__spec__</a></li>
</ul>
</li>
<li><a class="reference internal" href="import.html#references">5.9. 참고문헌</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="executionmodel.html"
                          title="이전 장"><span class="section-number">4. </span>실행 모델</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="expressions.html"
                          title="다음 장"><span class="section-number">6. </span>표현식</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/import.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="사이드바 닫기">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. 표현식"
             >다음</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 실행 모델"
             >이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 언어 레퍼런스</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="import.html"><span class="section-number">5. </span>임포트 시스템</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    저작권
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="../../../license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      최종 업데이트: Jun 09, 2024 (17:23 UTC)
    
      <a href="../../../bugs.html">Found a bug</a>?
    
    <br />

    <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7 버전으로 생성되었습니다.
    </div>

    <script type="text/javascript" src="../_static/switchers.js"></script>
  </body>
</html>