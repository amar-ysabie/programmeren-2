<!DOCTYPE html>

<html lang="ko" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="3. 데이터 모델" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/reference/datamodel.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="객체, 값, 형: 객체 (Objects) 는 파이썬이 데이터(data)를 추상화한 것(abstraction)입니다. 파이썬 프로그램의 모든 데이터는 객체나 객체 간의 관계로 표현됩니다. (폰 노이만(Von Neumann)의 “프로그램 내장식 컴퓨터(stored program computer)” 모델을 따르고, 또 그 관점에서 코드 역시 객체로 표현됩니..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="객체, 값, 형: 객체 (Objects) 는 파이썬이 데이터(data)를 추상화한 것(abstraction)입니다. 파이썬 프로그램의 모든 데이터는 객체나 객체 간의 관계로 표현됩니다. (폰 노이만(Von Neumann)의 “프로그램 내장식 컴퓨터(stored program computer)” 모델을 따르고, 또 그 관점에서 코드 역시 객체로 표현됩니..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>3. 데이터 모델 &#8212; Python 3.12.4 문서</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css%3Fv=80d5e7a1.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css%3Fv=bb723527.css" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css%3Fv=b20cc3f5.css" />
    
    <script src="../_static/documentation_options.js%3Fv=3050f571"></script>
    <script src="../_static/doctools.js%3Fv=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js%3Fv=dc90522c"></script>
    <script src="../_static/translations.js%3Fv=b5f768d8"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.12.4 문서에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="4. 실행 모델" href="executionmodel.html" />
    <link rel="prev" title="2. 어휘 분석" href="lexical_analysis.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="../../../3/reference/datamodel.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" />
                <input type="submit" value="이동"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="datamodel.html#">3. 데이터 모델</a><ul>
<li><a class="reference internal" href="datamodel.html#objects-values-and-types">3.1. 객체, 값, 형</a></li>
<li><a class="reference internal" href="datamodel.html#the-standard-type-hierarchy">3.2. 표준형 계층</a><ul>
<li><a class="reference internal" href="datamodel.html#none">3.2.1. None</a></li>
<li><a class="reference internal" href="datamodel.html#notimplemented">3.2.2. NotImplemented</a></li>
<li><a class="reference internal" href="datamodel.html#ellipsis">3.2.3. Ellipsis</a></li>
<li><a class="reference internal" href="datamodel.html#numbers-number">3.2.4. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a><ul>
<li><a class="reference internal" href="datamodel.html#numbers-integral">3.2.4.1. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a></li>
<li><a class="reference internal" href="datamodel.html#numbers-real-float">3.2.4.2. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>)</a></li>
<li><a class="reference internal" href="datamodel.html#numbers-complex-complex">3.2.4.3. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code> (<code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#sequences">3.2.5. 시퀀스들</a><ul>
<li><a class="reference internal" href="datamodel.html#immutable-sequences">3.2.5.1. 불변 시퀀스</a></li>
<li><a class="reference internal" href="datamodel.html#mutable-sequences">3.2.5.2. 가변 시퀀스</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#set-types">3.2.6. 집합 형들(Set types)</a></li>
<li><a class="reference internal" href="datamodel.html#mappings">3.2.7. 매핑(Mappings)</a><ul>
<li><a class="reference internal" href="datamodel.html#dictionaries">3.2.7.1. 딕셔너리(Dictionaries)</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#callable-types">3.2.8. 콜러블(Callable types)</a><ul>
<li><a class="reference internal" href="datamodel.html#user-defined-functions">3.2.8.1. 사용자 정의 함수</a><ul>
<li><a class="reference internal" href="datamodel.html#special-read-only-attributes">3.2.8.1.1. Special read-only attributes</a></li>
<li><a class="reference internal" href="datamodel.html#special-writable-attributes">3.2.8.1.2. Special writable attributes</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#instance-methods">3.2.8.2. 인스턴스 메서드(Instance methods)</a></li>
<li><a class="reference internal" href="datamodel.html#generator-functions">3.2.8.3. 제너레이터 함수(Generator functions)</a></li>
<li><a class="reference internal" href="datamodel.html#coroutine-functions">3.2.8.4. 코루틴 함수(Coroutine functions)</a></li>
<li><a class="reference internal" href="datamodel.html#asynchronous-generator-functions">3.2.8.5. 비동기 제너레이터 함수(Asynchronous generator functions)</a></li>
<li><a class="reference internal" href="datamodel.html#built-in-functions">3.2.8.6. 내장 함수(Built-in functions)</a></li>
<li><a class="reference internal" href="datamodel.html#built-in-methods">3.2.8.7. 내장 메서드(Built-in methods)</a></li>
<li><a class="reference internal" href="datamodel.html#classes">3.2.8.8. 클래스(Classes)</a></li>
<li><a class="reference internal" href="datamodel.html#class-instances">3.2.8.9. 클래스 인스턴스(Class Instances)</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#modules">3.2.9. 모듈(Modules)</a></li>
<li><a class="reference internal" href="datamodel.html#custom-classes">3.2.10. 사용자 정의 클래스(Custom classes)</a></li>
<li><a class="reference internal" href="datamodel.html#id3">3.2.11. 클래스 인스턴스(Class instances)</a></li>
<li><a class="reference internal" href="datamodel.html#i-o-objects-also-known-as-file-objects">3.2.12. I/O 객체 (파일 객체라고도 알려져 있습니다)</a></li>
<li><a class="reference internal" href="datamodel.html#internal-types">3.2.13. 내부 형(Internal types)</a><ul>
<li><a class="reference internal" href="datamodel.html#code-objects">3.2.13.1. 코드 객체(Code objects)</a><ul>
<li><a class="reference internal" href="datamodel.html#index-58">3.2.13.1.1. Special read-only attributes</a></li>
<li><a class="reference internal" href="datamodel.html#methods-on-code-objects">3.2.13.1.2. Methods on code objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#frame-objects">3.2.13.2. 프레임 객체(Frame objects)</a><ul>
<li><a class="reference internal" href="datamodel.html#index-64">3.2.13.2.1. Special read-only attributes</a></li>
<li><a class="reference internal" href="datamodel.html#index-65">3.2.13.2.2. Special writable attributes</a></li>
<li><a class="reference internal" href="datamodel.html#frame-object-methods">3.2.13.2.3. Frame object methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#traceback-objects">3.2.13.3. 트레이스백 객체(Traceback objects)</a></li>
<li><a class="reference internal" href="datamodel.html#slice-objects">3.2.13.4. 슬라이스 객체(Slice objects)</a></li>
<li><a class="reference internal" href="datamodel.html#static-method-objects">3.2.13.5. 스태틱 메서드 객체(Static method objects)</a></li>
<li><a class="reference internal" href="datamodel.html#class-method-objects">3.2.13.6. 클래스 메서드 객체(Class method objects)</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#special-method-names">3.3. 특수 메서드 이름들</a><ul>
<li><a class="reference internal" href="datamodel.html#basic-customization">3.3.1. 기본적인 커스터마이제이션</a></li>
<li><a class="reference internal" href="datamodel.html#customizing-attribute-access">3.3.2. 어트리뷰트 액세스 커스터마이제이션</a><ul>
<li><a class="reference internal" href="datamodel.html#customizing-module-attribute-access">3.3.2.1. 모듈 어트리뷰트 액세스 커스터마이제이션</a></li>
<li><a class="reference internal" href="datamodel.html#implementing-descriptors">3.3.2.2. 디스크립터 구현하기</a></li>
<li><a class="reference internal" href="datamodel.html#invoking-descriptors">3.3.2.3. 디스크립터 호출하기</a></li>
<li><a class="reference internal" href="datamodel.html#slots">3.3.2.4. __slots__</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#customizing-class-creation">3.3.3. 클래스 생성 커스터마이제이션</a><ul>
<li><a class="reference internal" href="datamodel.html#metaclasses">3.3.3.1. 메타 클래스</a></li>
<li><a class="reference internal" href="datamodel.html#resolving-mro-entries">3.3.3.2. MRO 항목 결정하기</a></li>
<li><a class="reference internal" href="datamodel.html#determining-the-appropriate-metaclass">3.3.3.3. 적절한 메타 클래스 선택하기</a></li>
<li><a class="reference internal" href="datamodel.html#preparing-the-class-namespace">3.3.3.4. 클래스 이름 공간 준비하기</a></li>
<li><a class="reference internal" href="datamodel.html#executing-the-class-body">3.3.3.5. 클래스 바디 실행하기</a></li>
<li><a class="reference internal" href="datamodel.html#creating-the-class-object">3.3.3.6. 클래스 객체 만들기</a></li>
<li><a class="reference internal" href="datamodel.html#uses-for-metaclasses">3.3.3.7. 메타 클래스의 용도</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#customizing-instance-and-subclass-checks">3.3.4. 인스턴스 및 서브 클래스 검사 커스터마이제이션</a></li>
<li><a class="reference internal" href="datamodel.html#emulating-generic-types">3.3.5. 제네릭 형 흉내 내기</a><ul>
<li><a class="reference internal" href="datamodel.html#the-purpose-of-class-getitem">3.3.5.1. The purpose of <em>__class_getitem__</em></a></li>
<li><a class="reference internal" href="datamodel.html#class-getitem-versus-getitem">3.3.5.2. <em>__class_getitem__</em> versus <em>__getitem__</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#emulating-callable-objects">3.3.6. 콜러블 객체 흉내 내기</a></li>
<li><a class="reference internal" href="datamodel.html#emulating-container-types">3.3.7. 컨테이너형 흉내 내기</a></li>
<li><a class="reference internal" href="datamodel.html#emulating-numeric-types">3.3.8. 숫자 형 흉내 내기</a></li>
<li><a class="reference internal" href="datamodel.html#with-statement-context-managers">3.3.9. with 문 컨텍스트 관리자</a></li>
<li><a class="reference internal" href="datamodel.html#customizing-positional-arguments-in-class-pattern-matching">3.3.10. Customizing positional arguments in class pattern matching</a></li>
<li><a class="reference internal" href="datamodel.html#emulating-buffer-types">3.3.11. Emulating buffer types</a></li>
<li><a class="reference internal" href="datamodel.html#special-method-lookup">3.3.12. 특수 메서드 조회</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#coroutines">3.4. 코루틴(Coroutines)</a><ul>
<li><a class="reference internal" href="datamodel.html#awaitable-objects">3.4.1. 어웨이터블 객체(Awaitable Objects)</a></li>
<li><a class="reference internal" href="datamodel.html#coroutine-objects">3.4.2. 코루틴 객체(Coroutine Objects)</a></li>
<li><a class="reference internal" href="datamodel.html#asynchronous-iterators">3.4.3. 비동기 이터레이터(Asynchronous Iterators)</a></li>
<li><a class="reference internal" href="datamodel.html#asynchronous-context-managers">3.4.4. 비동기 컨텍스트 관리자</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="lexical_analysis.html"
                          title="이전 장"><span class="section-number">2. </span>어휘 분석</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="executionmodel.html"
                          title="다음 장"><span class="section-number">4. </span>실행 모델</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/datamodel.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 실행 모델"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. 어휘 분석"
             accesskey="P">이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 언어 레퍼런스</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="datamodel.html"><span class="section-number">3. </span>데이터 모델</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="data-model">
<span id="datamodel"></span><h1><span class="section-number">3. </span>데이터 모델<a class="headerlink" href="datamodel.html#data-model" title="Link to this heading">¶</a></h1>
<section id="objects-values-and-types">
<span id="objects"></span><h2><span class="section-number">3.1. </span>객체, 값, 형<a class="headerlink" href="datamodel.html#objects-values-and-types" title="Link to this heading">¶</a></h2>
<p id="index-0"><em class="dfn">객체 (Objects)</em>는 파이썬이 데이터(data)를 추상화한 것(abstraction)입니다. 파이썬 프로그램의 모든 데이터는 객체나 객체 간의 관계로 표현됩니다. (폰 노이만(Von Neumann)의 “프로그램 내장식 컴퓨터(stored program computer)” 모델을 따르고, 또 그 관점에서 코드 역시 객체로 표현됩니다.)</p>
<span class="target" id="index-1"></span><p>Every object has an identity, a type and a value.  An object’s <em>identity</em> never
changes once it has been created; you may think of it as the object’s address in
memory.  The <a class="reference internal" href="expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> operator compares the identity of two objects; the
<a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> function returns an integer representing its identity.</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> CPython 의 경우, <code class="docutils literal notranslate"><span class="pre">id(x)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span></code> 가 저장된 메모리의 주소입니다.</p>
</div>
<p>객체의 형은 객체가 지원하는 연산들을 정의하고 (예를 들어, “길이를 갖고 있나?”) 그 형의 객체들이 가질 수 있는 가능한 값들을 정의합니다. <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 함수는 객체의 형(이것 역시 객체다)을 돌려줍니다. 아이덴티티와 마찬가지로, 객체의 <em class="dfn">형 (type)</em> 역시 변경되지 않습니다. <a class="footnote-reference brackets" href="datamodel.html#id17" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
<p>어떤 객체들의 <em>값</em> 은 변경할 수 있습니다. 값을 변경할 수 있는 객체들을 <em>가변(mutable)</em> 이라고 합니다. 일단 만들어진 후에 값을 변경할 수 없는 객체들을 <em>불변(immutable)</em> 이라고 합니다. (가변 객체에 대한 참조를 저장하고 있는 불변 컨테이너의 값은 가변 객체의 값이 변할 때 변경된다고 볼 수도 있습니다; 하지만 저장하고 있는 객체들의 집합이 바뀔 수 없으므로 컨테이너는 여전히 불변이라고 여겨집니다. 따라서 불변성은 엄밀하게는 변경 불가능한 값을 갖는 것과는 다릅니다. 좀 더 미묘합니다.) 객체의 가변성(mutability)은 그것의 형에 의해 결정됩니다; 예를 들어 숫자, 문자열, 튜플(tuple)은 불변이지만, 딕셔너리(dictionary) 와 리스트(list)는 가변입니다.</p>
<p id="index-2">객체는 결코 명시적으로 파괴되지 않습니다; 더 참조되지 않을 때(unreachable) 가비지 수거(garbage collect)됩니다. 구현이 가비지 수거를 지연시키거나 아예 생략하는 것이 허락됩니다 — 아직 참조되는 객체들을 수거하지 않는 이상 가비지 수거가 어떤 식으로 구현되는지는 구현의 품질 문제입니다.</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> CPython 은 현재 참조 횟수 계산(reference-counting) 방식을 사용하는데, (선택 사항으로) 순환적으로 연결된 가비지의 지연된 감지가 추가됩니다. 이 방법으로 대부분 객체를 참조가 제거되자마자 수거할 수 있습니다. 하지만 순환 참조가 있는 가비지들을 수거한다는 보장은 없습니다. 순환적 가비지 수거의 제어에 관한 정보는 <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> 모듈 문서를 참조하면 됩니다. 다른 구현들은 다른 식으로 동작하고, CPython 도 변경될 수 있습니다. 참조가 제거될 때 즉각적으로 파이널리제이션(finalization)되는 것에 의존하지 말아야 합니다 (그래서 항상 파일을 명시적으로 닫아주어야 합니다).</p>
</div>
<p>Note that the use of the implementation’s tracing or debugging facilities may
keep objects alive that would normally be collectable. Also note that catching
an exception with a <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>…<a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> statement may keep
objects alive.</p>
<p>Some objects contain references to “external” resources such as open files or
windows.  It is understood that these resources are freed when the object is
garbage-collected, but since garbage collection is not guaranteed to happen,
such objects also provide an explicit way to release the external resource,
usually a <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> method. Programs are strongly recommended to explicitly
close such objects.  The <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>…<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> statement
and the <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> statement provide convenient ways to do this.</p>
<p id="index-3">어떤 객체들은 다른 객체에 대한 참조를 포함하고 있습니다. 이런 것들을 <em>컨테이너(container)</em> 라고 부릅니다. 튜플, 리스트, 딕셔너리등이 컨테이너의 예입니다. 이 참조들은 컨테이너의 값의 일부입니다. 대부분은, 우리가 컨테이너의 값을 논할 때는, 들어있는 객체들의 아이덴티티 보다는 값을 따집니다. 하지만, 컨테이너의 가변성에 대해 논할 때는 직접 가진 객체들의 아이덴티티만을 따집니다. 그래서, (튜플 같은) 불변 컨테이너가 가변 객체로의 참조를 하고 있다면, 그 가변 객체가 변경되면 컨테이너의 값도 변경됩니다.</p>
<p>형은 거의 모든 측면에서 객체가 동작하는 방법에 영향을 줍니다. 객체의 아이덴티디가 갖는 중요성조차도 어떤 면에서는 영향을 받습니다: 불변형의 경우, 새 값을 만드는 연산은 실제로는 이미 존재하는 객체 중에서 같은 형과 값을 갖는 것을 돌려줄 수 있습니다. 반면에 가변 객체에서는 이런 것이 허용되지 않습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1;</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">1</span></code> 후에, <code class="docutils literal notranslate"><span class="pre">a</span></code> 와 <code class="docutils literal notranslate"><span class="pre">b</span></code> 는 값 1을 갖는 같은 객체일 수도 있고, 아닐 수도 있습니다. 하지만 <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">[];</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code> 후에, <code class="docutils literal notranslate"><span class="pre">c</span></code> 와 <code class="docutils literal notranslate"><span class="pre">d</span></code> 는 두 개의 서로 다르고, 독립적이고, 새로 만들어진 빈 리스트임이 보장됩니다. (<code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code> 는 객은 객체를 <code class="docutils literal notranslate"><span class="pre">c</span></code> 와 <code class="docutils literal notranslate"><span class="pre">d</span></code> 에 대입합니다.)</p>
</section>
<section id="the-standard-type-hierarchy">
<span id="types"></span><h2><span class="section-number">3.2. </span>표준형 계층<a class="headerlink" href="datamodel.html#the-standard-type-hierarchy" title="Link to this heading">¶</a></h2>
<p id="index-4">아래에 파이썬에 내장된 형들의 목록이 있습니다. (구현에 따라 C 나 자바나 다른 언어로 작성된) 확장 모듈들은 추가의 형을 정의할 수 있습니다. 파이썬의 미래 버전 역시 형 계층에 형을 더할 수 있는데 (예를 들어, 유리수, 효율적으로 저장된 정수 배열 등등), 표준 라이브러리를 통해 추가될 가능성이 더 크기는 합니다.</p>
<p id="index-5">아래에 나오는 몇몇 형에 대한 설명은 ‘특수 어트리뷰트(special attribute)’ 를 나열하는 문단을 포함합니다. 이것들은 구현에 접근할 방법을 제공하는데, 일반적인 사용을 위한 것이 아닙니다. 정의는 앞으로 변경될 수 있습니다.</p>
<section id="none">
<h3><span class="section-number">3.2.1. </span>None<a class="headerlink" href="datamodel.html#none" title="Link to this heading">¶</a></h3>
<p id="index-6">이 형은 하나의 값만을 갖습니다. 이 값을 갖는 하나의 객체가 존재합니다. 이 객체에는 내장된 이름 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 통해 접근합니다. 여러 가지 상황에서 값의 부재를 알리는 데 사용됩니다. 예를 들어, 명시적으로 뭔가를 돌려주지 않는 함수의 반환 값입니다. 논리값은 거짓입니다.</p>
</section>
<section id="notimplemented">
<h3><span class="section-number">3.2.2. </span>NotImplemented<a class="headerlink" href="datamodel.html#notimplemented" title="Link to this heading">¶</a></h3>
<p id="index-7">This type has a single value.  There is a single object with this value. This
object is accessed through the built-in name <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>. Numeric methods
and rich comparison methods should return this value if they do not implement the
operation for the operands provided.  (The interpreter will then try the
reflected operation, or some other fallback, depending on the operator.)  It
should not be evaluated in a boolean context.</p>
<p>더 자세한 내용은 <a class="reference internal" href="../library/numbers.html#implementing-the-arithmetic-operations"><span class="std std-ref">산술 연산 구현</span></a> 을 참고하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>Evaluating <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> in a boolean context is deprecated. While
it currently evaluates as true, it will emit a <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>.
It will raise a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> in a future version of Python.</p>
</div>
</section>
<section id="ellipsis">
<h3><span class="section-number">3.2.3. </span>Ellipsis<a class="headerlink" href="datamodel.html#ellipsis" title="Link to this heading">¶</a></h3>
<p id="index-8">이 형은 하나의 값만을 갖습니다. 이 값을 갖는 하나의 객체가 존재합니다. 이 객체에는 리터럴 <code class="docutils literal notranslate"><span class="pre">...</span></code> 이나 내장된 이름 <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code> 을 통해 접근합니다. 논리값은 참입니다.</p>
</section>
<section id="numbers-number">
<h3><span class="section-number">3.2.4. </span><a class="reference internal" href="../library/numbers.html#numbers.Number" title="numbers.Number"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a><a class="headerlink" href="datamodel.html#numbers-number" title="Link to this heading">¶</a></h3>
<p id="index-9">이것들은 숫자 리터럴에 의해 만들어지고, 산술 연산과 내장 산술 함수들이 결과로 돌려줍니다. 숫자 객체는 불변입니다; 한 번 값이 만들어지면 절대 변하지 않습니다. 파이썬의 숫자는 당연히 수학적인 숫자들과 밀접하게 관련되어 있습니다, 하지만 컴퓨터의 숫자 표현상의 제약을 받고 있습니다.</p>
<p>The string representations of the numeric classes, computed by
<a class="reference internal" href="datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> and <a class="reference internal" href="datamodel.html#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a>, have the following
properties:</p>
<ul class="simple">
<li><p>클래스 생성자에 전달될 때 원래 숫자 값을 가진 객체를 생성하는 유효한 숫자 리터럴 입니다.</p></li>
<li><p>가능하면, 표현은 10진법입니다.</p></li>
<li><p>소수점 앞의 단일 0을 제외하고, 선행 0은 표시되지 않습니다.</p></li>
<li><p>소수점 뒤의 단일 0을 제외하고, 후행 0은 표시되지 않습니다.</p></li>
<li><p>부호는 숫자가 음수일 때만 표시됩니다.</p></li>
</ul>
<p>파이썬은 정수, 실수, 복소수를 구분합니다:</p>
<section id="numbers-integral">
<h4><span class="section-number">3.2.4.1. </span><a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a><a class="headerlink" href="datamodel.html#numbers-integral" title="Link to this heading">¶</a></h4>
<p id="index-10">이것들은 수학적인 정수 집합(양과 음)에 속하는 요소들을 나타냅니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p id="index-11">정수 표현 규칙은 음수가 포함된 시프트와 마스크 연산에 가장 의미 있는 해석을 제공하기 위한 것입니다.</p>
</div>
<p>두 가지 종류의 정수가 있습니다:</p>
<dl>
<dt>정수 (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>)</dt><dd><p>이것은 (가상) 메모리가 허락하는 한, 제약 없는 범위의 숫자를 표현합니다. 시프트(shift)와 마스크(mask) 연산이 목적일 때는 이진 표현이 가정되고, 음수는 일종의 2의 보수(2’s complement)로 표현되는데, 부호 비트가 왼쪽으로 무한히 확장된 것과 같은 효과를 줍니다.</p>
</dd>
<dt>불린 (<a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>)</dt><dd><p id="index-12">이것은 논리값 거짓과 참을 나타냅니다. <code class="docutils literal notranslate"><span class="pre">False</span></code> 와 <code class="docutils literal notranslate"><span class="pre">True</span></code> 두 객체만 불린 형 객체입니다. 불린 형은 int 형의 자식형(subtype)이고, 대부분 상황에서 각기 0과1처럼 동작합니다. 예외는 문자열로 변환되는 경우인데, 각기 문자열 <code class="docutils literal notranslate"><span class="pre">&quot;False&quot;</span></code> 와 <code class="docutils literal notranslate"><span class="pre">&quot;True&quot;</span></code> 가 반환됩니다.</p>
</dd>
</dl>
</section>
<section id="numbers-real-float">
<h4><span class="section-number">3.2.4.2. </span><a class="reference internal" href="../library/numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code></a> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>)<a class="headerlink" href="datamodel.html#numbers-real-float" title="Link to this heading">¶</a></h4>
<p id="index-13">이것들은 기계 수준의 배정도(double precision) 부동 소수점 수를 나타냅니다. 허락되는 값의 범위와 오버플로의 처리에 관해서는 하부 기계의 설계(와 C 나 자바 구현)에 따르는 수밖에 없습니다. 파이썬은 단정도(single precision) 부동 소수점 수를 지원하지 않습니다; 이것들을 사용하는 이유가 되는 프로세서와 메모리의 절감은 파이썬에서 객체를 사용하는데 들어가는 비용과 상쇄되어 미미해집니다. 그 때문에 두 가지 종류의 부동 소수점 수로 언어를 복잡하게 만들만한 가치가 없습니다.</p>
</section>
<section id="numbers-complex-complex">
<h4><span class="section-number">3.2.4.3. </span><a class="reference internal" href="../library/numbers.html#numbers.Complex" title="numbers.Complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code></a> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>)<a class="headerlink" href="datamodel.html#numbers-complex-complex" title="Link to this heading">¶</a></h4>
<p id="index-14">이것들은 기계 수준 배정도 부동 소수점 수의 쌍으로 복소수를 나타냅니다. 부동 소수점 수와 한계와 문제점을 공유합니다. 복소수 <code class="docutils literal notranslate"><span class="pre">z</span></code> 의 실수부와 허수부는, 읽기 전용 어트리뷰트 <code class="docutils literal notranslate"><span class="pre">z.real</span></code> 와 <code class="docutils literal notranslate"><span class="pre">z.imag</span></code> 로 꺼낼 수 있습니다.</p>
</section>
</section>
<section id="sequences">
<h3><span class="section-number">3.2.5. </span>시퀀스들<a class="headerlink" href="datamodel.html#sequences" title="Link to this heading">¶</a></h3>
<p id="index-15">These represent finite ordered sets indexed by non-negative numbers. The
built-in function <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> returns the number of items of a sequence. When
the length of a sequence is <em>n</em>, the index set contains the numbers 0, 1,
…, <em>n</em>-1.  Item <em>i</em> of sequence <em>a</em> is selected by <code class="docutils literal notranslate"><span class="pre">a[i]</span></code>. Some sequences,
including built-in sequences, interpret negative subscripts by adding the
sequence length. For example, <code class="docutils literal notranslate"><span class="pre">a[-2]</span></code> equals <code class="docutils literal notranslate"><span class="pre">a[n-2]</span></code>, the second to last
item of sequence a with length <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p id="index-16">Sequences also support slicing: <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> selects all items with index <em>k</em> such
that <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>k</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em>.  When used as an expression, a slice is a
sequence of the same type. The comment above about negative indexes also applies
to negative slice positions.</p>
<p>어떤 시퀀스는 세 번째 “스텝(step)” 매개변수를 사용하는 “확장 슬라이싱(extended slicing)”도 지원합니다: <code class="docutils literal notranslate"><span class="pre">a[i:j:k]</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code>, <em>n</em> <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> <code class="docutils literal notranslate"><span class="pre">0</span></code>, <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>x</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em> 를 만족하는 모든 항목 <em>x</em> 를 선택합니다.</p>
<p>시퀀스는 불변성에 따라 구분됩니다</p>
<section id="immutable-sequences">
<h4><span class="section-number">3.2.5.1. </span>불변 시퀀스<a class="headerlink" href="datamodel.html#immutable-sequences" title="Link to this heading">¶</a></h4>
<p id="index-17">불변 시퀀스 형의 객체는 일단 만들어진 후에는 변경될 수 없습니다. (만약 다른 객체로의 참조를 포함하면, 그 객체는 가변일 수 있고, 변경될 수 있습니다; 하지만, 불변 객체로부터 참조되는 객체의 집합 자체는 변경될 수 없습니다.)</p>
<p>다음과 같은 형들은 불변 시퀀스입니다:</p>
<dl id="index-18">
<dt>문자열(Strings)</dt><dd><p id="index-19">A string is a sequence of values that represent Unicode code points.
All the code points in the range <code class="docutils literal notranslate"><span class="pre">U+0000</span> <span class="pre">-</span> <span class="pre">U+10FFFF</span></code> can be
represented in a string.  Python doesn’t have a <span class="c-expr sig sig-inline c"><span class="kt">char</span></span> type;
instead, every code point in the string is represented as a string
object with length <code class="docutils literal notranslate"><span class="pre">1</span></code>.  The built-in function <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a>
converts a code point from its string form to an integer in the
range <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code>; <a class="reference internal" href="../library/functions.html#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a> converts an integer in the range
<code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code> to the corresponding length <code class="docutils literal notranslate"><span class="pre">1</span></code> string object.
<a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> can be used to convert a <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> to
<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> using the given text encoding, and
<a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> can be used to achieve the opposite.</p>
</dd>
<dt>튜플(Tuples)</dt><dd><p id="index-20">튜플의 항목은 임의의 파이썬 객체입니다. 두 개 이상의 항목으로 구성되는 튜플은 콤마로 분리된 표현식의 목록으로 만들 수 있습니다. 하나의 항목으로 구성된 튜플(싱글턴,singleton)은 표현식에 콤마를 붙여서 만들 수 있습니다(괄호로 표현식을 묶을 수 있으므로, 표현식 만으로는 튜플을 만들지 않습니다). 빈 튜플은 한 쌍의 빈 괄호로 만들 수 있습니다.</p>
</dd>
<dt>바이트열(Bytes)</dt><dd><p id="index-21">바이트열(bytes) 객체는 불변 배열입니다. 항목은 8-비트 바이트인데, 0 &lt;= x &lt; 256 범위의 정수로 표현됩니다. 바이트 객체를 만들 때는 바이트열 리터럴(<code class="docutils literal notranslate"><span class="pre">b'abc'</span></code> 와 같은) 과 내장 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes()</span></code></a> 생성자(constructor)를 사용할 수 있습니다. 또한, 바이트열 객체는 <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> 메서드를 통해 문자열로 디코딩될 수 있습니다.</p>
</dd>
</dl>
</section>
<section id="mutable-sequences">
<h4><span class="section-number">3.2.5.2. </span>가변 시퀀스<a class="headerlink" href="datamodel.html#mutable-sequences" title="Link to this heading">¶</a></h4>
<p id="index-22">가변 시퀀스는 만들어진 후에 변경될 수 있습니다. 서브스크립션(subscription)과 슬라이싱은 대입문과 <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> (삭제) 문의 대상으로 사용될 수 있습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p id="index-24"><span id="index-23"></span>The <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> and <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> module provide
additional examples of mutable sequence types.</p>
</div>
<p>현재 두 개의 내장 가변 시퀀스형이 있습니다:</p>
<dl>
<dt>리스트(Lists)</dt><dd><p id="index-25">리스트의 항목은 임의의 파이썬 객체입니다. 리스트는 콤마로 분리된 표현식을 대괄호 안에 넣어서 만들 수 있습니다. (길이 0이나 1의 리스트를 만드는데 별도의 규칙이 필요 없습니다.)</p>
</dd>
<dt>바이트 배열(Byte Arrays)</dt><dd><p id="index-26">바이트 배열(bytearray) 객체는 가변 배열입니다. 내장 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a> 생성자로 만들어집니다. 가변이라는 것(그래서 해싱 불가능하다는 것)을 제외하고, 바이트 배열은 불변 바이트열( <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>) 객체와 같은 인터페이스와 기능을 제공합니다.</p>
</dd>
</dl>
</section>
</section>
<section id="set-types">
<h3><span class="section-number">3.2.6. </span>집합 형들(Set types)<a class="headerlink" href="datamodel.html#set-types" title="Link to this heading">¶</a></h3>
<p id="index-27">이것들은 중복 없는 불변 객체들의 순서 없고 유한한 집합을 나타냅니다. 인덱싱할 수 없습니다. 하지만 이터레이트할 수 있고, 내장 함수 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 은 집합 안에 있는 항목들의 개수를 돌려줍니다. 집합의 일반적인 용도는 빠른 멤버십 검사(fast membership testing), 시퀀스에서 중복된 항목 제거, 교집합(intersection), 합집합(union), 차집합(difference), 대칭차집합(symmetric difference)과 같은 집합 연산을 계산하는 것입니다.</p>
<p>집합의 원소들에는 딕셔너리 키와 같은 불변성 규칙이 적용됩니다. 숫자 형의 경우는 숫자 비교에 관한 일반 원칙이 적용된다는 점에 주의해야 합니다: 만약 두 숫자가 같다고 비교되면(예를 들어, <code class="docutils literal notranslate"><span class="pre">1</span></code> 과 <code class="docutils literal notranslate"><span class="pre">1.0</span></code>), 그중 하나만 집합에 들어갈 수 있습니다.</p>
<p>현재 두 개의 내장 집합 형이 있습니다:</p>
<dl>
<dt>집합(Sets)</dt><dd><p id="index-28">이것들은 가변 집합을 나타냅니다. 내장 <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal notranslate"><span class="pre">set()</span></code></a> 생성자로 만들 수 있고, <code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code> 같은 메서드들을 사용해서 나중에 수정할 수 있습니다.</p>
</dd>
<dt>불변 집합(Frozen sets)</dt><dd><p id="index-29">이것들은 불변 집합을 나타냅니다. 내장 <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-func docutils literal notranslate"><span class="pre">frozenset()</span></code></a> 생성자로 만들 수 있습니다. 불변 집합(frozenset)은 불변이고 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a> 하므로, 다른 집합의 원소나, 딕셔너리의 키로 사용될 수 있습니다.</p>
</dd>
</dl>
</section>
<section id="mappings">
<h3><span class="section-number">3.2.7. </span>매핑(Mappings)<a class="headerlink" href="datamodel.html#mappings" title="Link to this heading">¶</a></h3>
<p id="index-30">이것들은 임의의 인덱스 집합으로 인덱싱되는 객체들의 유한한 집합을 나타냅니다. 인덱스 표기법(subscript notation) <code class="docutils literal notranslate"><span class="pre">a[k]</span></code> 는 매핑 <code class="docutils literal notranslate"><span class="pre">a</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">k</span></code> 로 인덱스 되는 항목을 선택합니다; 이것은 표현식에 사용될 수도 있고, 대입이나 <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> 문장의 대상이 될 수도 있습니다. 내장 함수 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 은 매핑에 포함된 항목들의 개수를 돌려줍니다.</p>
<p>현재 한 개의 내장 매핑 형이 있습니다:</p>
<section id="dictionaries">
<h4><span class="section-number">3.2.7.1. </span>딕셔너리(Dictionaries)<a class="headerlink" href="datamodel.html#dictionaries" title="Link to this heading">¶</a></h4>
<p id="index-31">이것들은 거의 임의의 인덱스 집합으로 인덱싱되는 객체들의 유한한 집합을 나타냅니다. 키로 사용할 수 없는 것들은 리스트, 딕셔너리나 그 외의 가변형 중에서 아이덴티티가 아니라 값으로 비교되는 것들뿐입니다. 딕셔너리의 효율적인 구현이, 키의 해시값이 도중에 변경되지 않고 계속 같은 값으로 유지되도록 요구하고 있기 때문입니다. 키로 사용되는 숫자 형의 경우는 숫자 비교에 관한 일반 원칙이 적용됩니다: 만약 두 숫자가 같다고 비교되면(예를 들어, <code class="docutils literal notranslate"><span class="pre">1</span></code> 과 <code class="docutils literal notranslate"><span class="pre">1.0</span></code>), 둘 다 같은 딕셔너리 항목을 인덱싱하는데 사용될 수 있습니다.</p>
<p>딕셔너리는 삽입 순서를 유지합니다, 키가 딕셔너리에 순차적으로 추가된 순서와 같은 순서로 생성됨을 뜻합니다. 기존 키를 교체해도 순서는 변경되지 않지만, 키를 제거했다가 다시 삽입하면 이전 위치를 유지하는 대신 끝에 추가됩니다.</p>
<p>딕셔너리는 가변입니다; <code class="docutils literal notranslate"><span class="pre">{...}</span></code> 표기법으로 만들 수 있습니다 (<a class="reference internal" href="expressions.html#dict"><span class="std std-ref">딕셔너리 디스플레이</span></a> 섹션을 참고하십시오).</p>
<p id="index-32">확장 모듈 <a class="reference internal" href="../library/dbm.html#module-dbm.ndbm" title="dbm.ndbm: The New Database Manager (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.ndbm</span></code></a> 과 <a class="reference internal" href="../library/dbm.html#module-dbm.gnu" title="dbm.gnu: GNU database manager (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.gnu</span></code></a> 는 추가의 매핑 형을 제공하는데, <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 모듈 역시 마찬가지입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>딕셔너리는 3.6 이전의 파이썬 버전에서 삽입 순서를 유지하지 않았습니다. CPython 3.6에서, 삽입 순서가 유지되었지만, 그 시점에는 언어 보증이 아니라 구현 세부 사항으로 간주하였습니다.</p>
</div>
</section>
</section>
<section id="callable-types">
<h3><span class="section-number">3.2.8. </span>콜러블(Callable types)<a class="headerlink" href="datamodel.html#callable-types" title="Link to this heading">¶</a></h3>
<p id="index-33">이것들은 함수 호출 연산(<a class="reference internal" href="expressions.html#calls"><span class="std std-ref">호출</span></a> 섹션 참고)이 적용될 수 있는 형들입니다:</p>
<section id="user-defined-functions">
<span id="user-defined-funcs"></span><h4><span class="section-number">3.2.8.1. </span>사용자 정의 함수<a class="headerlink" href="datamodel.html#user-defined-functions" title="Link to this heading">¶</a></h4>
<p id="index-34">사용자 정의 함수 객체는 함수 정의를 통해 만들어집니다 (<a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a> 섹션 참고). 함수의 형식 매개변수(formal parameter) 목록과 같은 개수의 항목을 포함하는 인자(argument) 목록으로 호출되어야 합니다.</p>
<section id="special-read-only-attributes">
<h5><span class="section-number">3.2.8.1.1. </span>Special read-only attributes<a class="headerlink" href="datamodel.html#special-read-only-attributes" title="Link to this heading">¶</a></h5>
<table class="docutils align-default" id="index-35">
<thead>
<tr class="row-odd"><th class="head"><p>어트리뷰트</p></th>
<th class="head"><p>의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__globals__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__globals__</span></span><a class="headerlink" href="datamodel.html#function.__globals__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>A reference to the <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a> that holds the function’s
<a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">global variables</span></a> – the global namespace of the module
in which the function was defined.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__closure__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__closure__</span></span><a class="headerlink" href="datamodel.html#function.__closure__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p><code class="docutils literal notranslate"><span class="pre">None</span></code> or a <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of cells that contain bindings for the
function’s free variables.</p>
<p>셀 객체는 <code class="docutils literal notranslate"><span class="pre">cell_contents</span></code> 어트리뷰트를 가지고 있습니다. 셀의 값을 읽을 뿐만 아니라 값을 설정하는 데도 사용할 수 있습니다.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="special-writable-attributes">
<h5><span class="section-number">3.2.8.1.2. </span>Special writable attributes<a class="headerlink" href="datamodel.html#special-writable-attributes" title="Link to this heading">¶</a></h5>
<p id="index-36">Most of these attributes check the type of the assigned value:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>어트리뷰트</p></th>
<th class="head"><p>의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__doc__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__doc__</span></span><a class="headerlink" href="datamodel.html#function.__doc__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The function’s documentation string, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if unavailable.
Not inherited by subclasses.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__name__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="datamodel.html#function.__name__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The function’s name.
See also: <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span> <span class="pre">attributes</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__qualname__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__qualname__</span></span><a class="headerlink" href="datamodel.html#function.__qualname__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The function’s <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">qualified name</span></a>.
See also: <a class="reference internal" href="../library/stdtypes.html#definition.__qualname__" title="definition.__qualname__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__qualname__</span> <span class="pre">attributes</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__module__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__module__</span></span><a class="headerlink" href="datamodel.html#function.__module__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>함수가 정의된 모듈의 이름 또는 (없는 경우) <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__defaults__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__defaults__</span></span><a class="headerlink" href="datamodel.html#function.__defaults__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing default <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameter</span></a> values
for those parameters that have defaults,
or <code class="docutils literal notranslate"><span class="pre">None</span></code> if no parameters have a default value.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__code__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__code__</span></span><a class="headerlink" href="datamodel.html#function.__code__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The <a class="reference internal" href="datamodel.html#code-objects"><span class="std std-ref">code object</span></a> representing
the compiled function body.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__dict__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__dict__</span></span><a class="headerlink" href="datamodel.html#function.__dict__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The namespace supporting arbitrary function attributes.
See also: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span> <span class="pre">attributes</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__annotations__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__annotations__</span></span><a class="headerlink" href="datamodel.html#function.__annotations__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>A <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a> containing annotations of
<a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameters</span></a>.
The keys of the dictionary are the parameter names,
and <code class="docutils literal notranslate"><span class="pre">'return'</span></code> for the return annotation, if provided.
See also: <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Annotations Best Practices</span></a>.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__kwdefaults__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__kwdefaults__</span></span><a class="headerlink" href="datamodel.html#function.__kwdefaults__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>A <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a> containing defaults for keyword-only
<a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameters</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__type_params__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__type_params__</span></span><a class="headerlink" href="datamodel.html#function.__type_params__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the <a class="reference internal" href="compound_stmts.html#type-params"><span class="std std-ref">type parameters</span></a> of
a <a class="reference internal" href="compound_stmts.html#generic-functions"><span class="std std-ref">generic function</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</td>
</tr>
</tbody>
</table>
<p>Function objects also support getting and setting arbitrary attributes, which
can be used, for example, to attach metadata to functions.  Regular attribute
dot-notation is used to get and set such attributes.</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> CPython’s current implementation only supports function attributes
on user-defined functions. Function attributes on
<a class="reference internal" href="datamodel.html#builtin-functions"><span class="std std-ref">built-in functions</span></a> may be supported in the
future.</p>
</div>
<p>Additional information about a function’s definition can be retrieved from its
<a class="reference internal" href="datamodel.html#code-objects"><span class="std std-ref">code object</span></a>
(accessible via the <a class="reference internal" href="datamodel.html#function.__code__" title="function.__code__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__code__</span></code></a> attribute).</p>
</section>
</section>
<section id="instance-methods">
<span id="id2"></span><h4><span class="section-number">3.2.8.2. </span>인스턴스 메서드(Instance methods)<a class="headerlink" href="datamodel.html#instance-methods" title="Link to this heading">¶</a></h4>
<p id="index-37">인스턴스 메서드는 클래스, 클래스 인스턴스와 모든 콜러블 객체 (보통 사용자 정의 함수)을 결합합니다.</p>
<p id="index-38">Special read-only attributes:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="method.__self__">
<span class="sig-prename descclassname"><span class="pre">method.</span></span><span class="sig-name descname"><span class="pre">__self__</span></span><a class="headerlink" href="datamodel.html#method.__self__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>Refers to the class instance object to which the method is
<a class="reference internal" href="datamodel.html#method-binding"><span class="std std-ref">bound</span></a></p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="method.__func__">
<span class="sig-prename descclassname"><span class="pre">method.</span></span><span class="sig-name descname"><span class="pre">__func__</span></span><a class="headerlink" href="datamodel.html#method.__func__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>Refers to the original <a class="reference internal" href="datamodel.html#user-defined-funcs"><span class="std std-ref">function object</span></a></p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="method.__doc__">
<span class="sig-prename descclassname"><span class="pre">method.</span></span><span class="sig-name descname"><span class="pre">__doc__</span></span><a class="headerlink" href="datamodel.html#method.__doc__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The method’s documentation
(same as <a class="reference internal" href="datamodel.html#function.__doc__" title="function.__doc__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method.__func__.__doc__</span></code></a>).
A <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">string</span></code></a> if the original function had a docstring, else
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="method.__name__">
<span class="sig-prename descclassname"><span class="pre">method.</span></span><span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="datamodel.html#method.__name__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The name of the method
(same as <a class="reference internal" href="datamodel.html#function.__name__" title="function.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method.__func__.__name__</span></code></a>)</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="method.__module__">
<span class="sig-prename descclassname"><span class="pre">method.</span></span><span class="sig-name descname"><span class="pre">__module__</span></span><a class="headerlink" href="datamodel.html#method.__module__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The name of the module the method was defined in, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if
unavailable.</p></td>
</tr>
</tbody>
</table>
<p>Methods also support accessing (but not setting) the arbitrary function
attributes on the underlying <a class="reference internal" href="datamodel.html#user-defined-funcs"><span class="std std-ref">function object</span></a>.</p>
<p>User-defined method objects may be created when getting an attribute of a
class (perhaps via an instance of that class), if that attribute is a
user-defined <a class="reference internal" href="datamodel.html#user-defined-funcs"><span class="std std-ref">function object</span></a> or a
<a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></a> object.</p>
<p id="method-binding">When an instance method object is created by retrieving a user-defined
<a class="reference internal" href="datamodel.html#user-defined-funcs"><span class="std std-ref">function object</span></a> from a class via one of its
instances, its <a class="reference internal" href="datamodel.html#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a> attribute is the instance, and the
method object is said to be <em>bound</em>.  The new method’s <a class="reference internal" href="datamodel.html#method.__func__" title="method.__func__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code></a>
attribute is the original function object.</p>
<p>When an instance method object is created by retrieving a <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></a>
object from a class or instance, its <a class="reference internal" href="datamodel.html#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a> attribute is the
class itself, and its <a class="reference internal" href="datamodel.html#method.__func__" title="method.__func__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code></a> attribute is the function object
underlying the class method.</p>
<p>When an instance method object is called, the underlying function
(<a class="reference internal" href="datamodel.html#method.__func__" title="method.__func__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code></a>) is called, inserting the class instance
(<a class="reference internal" href="datamodel.html#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a>) in front of the argument list.  For instance, when
<code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> is a class which contains a definition for a function
<code class="xref py py-meth docutils literal notranslate"><span class="pre">f()</span></code>, and <code class="docutils literal notranslate"><span class="pre">x</span></code> is an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, calling <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> is
equivalent to calling <code class="docutils literal notranslate"><span class="pre">C.f(x,</span> <span class="pre">1)</span></code>.</p>
<p>When an instance method object is derived from a <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></a> object, the
“class instance” stored in <a class="reference internal" href="datamodel.html#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a> will actually be the class
itself, so that calling either <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> or <code class="docutils literal notranslate"><span class="pre">C.f(1)</span></code> is equivalent to
calling <code class="docutils literal notranslate"><span class="pre">f(C,1)</span></code> where <code class="docutils literal notranslate"><span class="pre">f</span></code> is the underlying function.</p>
<p>Note that the transformation from <a class="reference internal" href="datamodel.html#user-defined-funcs"><span class="std std-ref">function object</span></a>
to instance method
object happens each time the attribute is retrieved from the instance.  In
some cases, a fruitful optimization is to assign the attribute to a local
variable and call that local variable. Also notice that this
transformation only happens for user-defined functions; other callable
objects (and all non-callable objects) are retrieved without
transformation.  It is also important to note that user-defined functions
which are attributes of a class instance are not converted to bound
methods; this <em>only</em> happens when the function is an attribute of the
class.</p>
</section>
<section id="generator-functions">
<h4><span class="section-number">3.2.8.3. </span>제너레이터 함수(Generator functions)<a class="headerlink" href="datamodel.html#generator-functions" title="Link to this heading">¶</a></h4>
<p id="index-39">A function or method which uses the <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> statement (see section
<a class="reference internal" href="simple_stmts.html#yield"><span class="std std-ref">yield 문</span></a>) is called a <em class="dfn">generator function</em>.  Such a function, when
called, always returns an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> object which can be used to
execute the body of the function:  calling the iterator’s
<a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterator.__next__()</span></code></a> method will cause the function to execute until
it provides a value using the <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> statement.  When the
function executes a <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> statement or falls off the end, a
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception is raised and the iterator will have
reached the end of the set of values to be returned.</p>
</section>
<section id="coroutine-functions">
<h4><span class="section-number">3.2.8.4. </span>코루틴 함수(Coroutine functions)<a class="headerlink" href="datamodel.html#coroutine-functions" title="Link to this heading">¶</a></h4>
<p id="index-40"><a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 를 사용해서 정의되는 함수나 메서드를 <em class="dfn">코루틴 함수 (coroutine function)</em> 라고 부릅니다. 이런 함수를 호출하면 <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">코루틴</span></a> 객체를 돌려줍니다. <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식을 비롯해, <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 와 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 문을 사용할 수 있습니다. <a class="reference internal" href="datamodel.html#coroutine-objects"><span class="std std-ref">코루틴 객체(Coroutine Objects)</span></a> 섹션을 참조하십시오.</p>
</section>
<section id="asynchronous-generator-functions">
<h4><span class="section-number">3.2.8.5. </span>비동기 제너레이터 함수(Asynchronous generator functions)<a class="headerlink" href="datamodel.html#asynchronous-generator-functions" title="Link to this heading">¶</a></h4>
<p id="index-41">A function or method which is defined using <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> and
which uses the <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> statement is called a
<em class="dfn">asynchronous generator function</em>.  Such a function, when called,
returns an <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> object which can be used in an
<a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> statement to execute the body of the function.</p>
<p>Calling the asynchronous iterator’s
<a class="reference internal" href="datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aiterator.__anext__</span></code></a> method
will return an <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> which when awaited
will execute until it provides a value using the <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>
expression.  When the function executes an empty <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>
statement or falls off the end, a <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> exception
is raised and the asynchronous iterator will have reached the end of
the set of values to be yielded.</p>
</section>
<section id="built-in-functions">
<span id="builtin-functions"></span><h4><span class="section-number">3.2.8.6. </span>내장 함수(Built-in functions)<a class="headerlink" href="datamodel.html#built-in-functions" title="Link to this heading">¶</a></h4>
<p id="index-42">A built-in function object is a wrapper around a C function.  Examples of
built-in functions are <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> and <a class="reference internal" href="../library/math.html#math.sin" title="math.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.sin()</span></code></a> (<a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> is a
standard built-in module). The number and type of the arguments are
determined by the C function. Special read-only attributes:</p>
<ul class="simple">
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> is the function’s documentation string, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if
unavailable. See <a class="reference internal" href="datamodel.html#function.__doc__" title="function.__doc__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">function.__doc__</span></code></a>.</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code> is the function’s name. See <a class="reference internal" href="datamodel.html#function.__name__" title="function.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">function.__name__</span></code></a>.</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> (but see the next item).</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> is the name of
the module the function was defined in or <code class="docutils literal notranslate"><span class="pre">None</span></code> if unavailable.
See <a class="reference internal" href="datamodel.html#function.__module__" title="function.__module__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">function.__module__</span></code></a>.</p></li>
</ul>
</section>
<section id="built-in-methods">
<span id="builtin-methods"></span><h4><span class="section-number">3.2.8.7. </span>내장 메서드(Built-in methods)<a class="headerlink" href="datamodel.html#built-in-methods" title="Link to this heading">¶</a></h4>
<p id="index-43">This is really a different disguise of a built-in function, this time containing
an object passed to the C function as an implicit extra argument.  An example of
a built-in method is <code class="docutils literal notranslate"><span class="pre">alist.append()</span></code>, assuming <em>alist</em> is a list object. In
this case, the special read-only attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> is set to the object
denoted by <em>alist</em>. (The attribute has the same semantics as it does with
<a class="reference internal" href="datamodel.html#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">other</span> <span class="pre">instance</span> <span class="pre">methods</span></code></a>.)</p>
</section>
<section id="classes">
<h4><span class="section-number">3.2.8.8. </span>클래스(Classes)<a class="headerlink" href="datamodel.html#classes" title="Link to this heading">¶</a></h4>
<p>Classes are callable.  These objects normally act as factories for new
instances of themselves, but variations are possible for class types that
override <a class="reference internal" href="datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a>.  The arguments of the call are passed to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code> and, in the typical case, to <a class="reference internal" href="datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> to
initialize the new instance.</p>
</section>
<section id="class-instances">
<h4><span class="section-number">3.2.8.9. </span>클래스 인스턴스(Class Instances)<a class="headerlink" href="datamodel.html#class-instances" title="Link to this heading">¶</a></h4>
<p>Instances of arbitrary classes can be made callable by defining a
<a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> method in their class.</p>
</section>
</section>
<section id="modules">
<h3><span class="section-number">3.2.9. </span>모듈(Modules)<a class="headerlink" href="datamodel.html#modules" title="Link to this heading">¶</a></h3>
<p id="index-44">Modules are a basic organizational unit of Python code, and are created by
the <a class="reference internal" href="import.html#importsystem"><span class="std std-ref">import system</span></a> as invoked either by the
<a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> statement, or by calling
functions such as <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> and built-in
<a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>.  A module object has a namespace implemented by a
<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a> object (this is the dictionary referenced by the
<a class="reference internal" href="datamodel.html#function.__globals__" title="function.__globals__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__globals__</span></code></a>
attribute of functions defined in the module).  Attribute references are
translated to lookups in this dictionary, e.g., <code class="docutils literal notranslate"><span class="pre">m.x</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">m.__dict__[&quot;x&quot;]</span></code>. A module object does not contain the code object used
to initialize the module (since it isn’t needed once the initialization is
done).</p>
<p>어트리뷰트 대입은 모듈의 이름 공간 딕셔너리를 갱신합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">m.x</span> <span class="pre">=</span> <span class="pre">1</span></code> 은 <code class="docutils literal notranslate"><span class="pre">m.__dict__[&quot;x&quot;]</span> <span class="pre">=</span> <span class="pre">1</span></code> 과 같습니다.</p>
<p id="index-45">Predefined (writable) attributes:</p>
<blockquote>
<div><dl class="simple">
<dt><a class="reference internal" href="import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></dt><dd><p>The module’s name.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></dt><dd><p>The module’s documentation string, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if
unavailable.</p>
</dd>
<dt><a class="reference internal" href="import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a></dt><dd><p>The pathname of the file from which the
module was loaded, if it was loaded from a file.
The <a class="reference internal" href="import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a>
attribute may be missing for certain types of modules, such as C modules
that are statically linked into the interpreter.  For extension modules
loaded dynamically from a shared library, it’s the pathname of the shared
library file.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></dt><dd><p>A dictionary containing
<a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">variable annotations</span></a> collected during
module body execution.  For best practices on working
with <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code>, please see <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Annotations Best Practices</span></a>.</p>
</dd>
</dl>
</div></blockquote>
<p id="index-46">특수 읽기 전용 어트리뷰트들: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 는 딕셔너리로 표현되는 모듈의 이름 공간입니다.</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> CPython 이 모듈 딕셔너리를 비우는 방법 때문에, 딕셔너리에 대한 참조가 남아있더라도, 모듈이 스코프를 벗어나면 모듈 딕셔너리는 비워집니다. 이것을 피하려면, 딕셔너리를 복사하거나 딕셔너리를 직접 이용하는 동안은 모듈을 잡아두어야 합니다.</p>
</div>
</section>
<section id="custom-classes">
<h3><span class="section-number">3.2.10. </span>사용자 정의 클래스(Custom classes)<a class="headerlink" href="datamodel.html#custom-classes" title="Link to this heading">¶</a></h3>
<p>Custom class types are typically created by class definitions (see section
<a class="reference internal" href="compound_stmts.html#class"><span class="std std-ref">클래스 정의</span></a>).  A class has a namespace implemented by a dictionary object.
Class attribute references are translated to lookups in this dictionary, e.g.,
<code class="docutils literal notranslate"><span class="pre">C.x</span></code> is translated to <code class="docutils literal notranslate"><span class="pre">C.__dict__[&quot;x&quot;]</span></code> (although there are a number of
hooks which allow for other means of locating attributes). When the attribute
name is not found there, the attribute search continues in the base classes.
This search of the base classes uses the C3 method resolution order which
behaves correctly even in the presence of ‘diamond’ inheritance structures
where there are multiple inheritance paths leading back to a common ancestor.
Additional details on the C3 MRO used by Python can be found at
<a class="reference internal" href="../howto/mro.html#python-2-3-mro"><span class="std std-ref">The Python 2.3 Method Resolution Order</span></a>.</p>
<p id="index-47">When a class attribute reference (for class <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, say) would yield a
class method object, it is transformed into an instance method object whose
<a class="reference internal" href="datamodel.html#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a> attribute is <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>.
When it would yield a <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">staticmethod</span></code></a> object,
it is transformed into the object wrapped by the static method
object. See section <a class="reference internal" href="datamodel.html#descriptors"><span class="std std-ref">디스크립터 구현하기</span></a> for another way in which attributes
retrieved from a class may differ from those actually contained in its
<a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>.</p>
<p id="index-48">클래스 어트리뷰트 대입은 클래스의 딕셔너리를 갱신할 뿐, 어떤 경우도 부모 클래스의 딕셔너리를 건드리지는 않습니다.</p>
<p id="index-49">클래스 객체는 클래스 인스턴스를 돌려주도록(아래를 보십시오) 호출될 수 있습니다(위를 보십시오).</p>
<p id="index-50">특수 어트리뷰트들(Special attributes):</p>
<blockquote>
<div><dl class="simple">
<dt><a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></dt><dd><p>The class name.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code></dt><dd><p>The name of the module in which the class was defined.</p>
</dd>
<dt><a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a></dt><dd><p>The dictionary containing the class’s namespace.</p>
</dd>
<dt><a class="reference internal" href="../library/stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code></a></dt><dd><p>A tuple containing the base classes, in the order of
their occurrence in the base class list.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></dt><dd><p>The class’s documentation string, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if undefined.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></dt><dd><p>A dictionary containing
<a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">variable annotations</span></a>
collected during class body execution.  For best practices on
working with <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code>, please see
<a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Annotations Best Practices</span></a>.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__type_params__</span></code></dt><dd><p>A tuple containing the <a class="reference internal" href="compound_stmts.html#type-params"><span class="std std-ref">type parameters</span></a> of
a <a class="reference internal" href="compound_stmts.html#generic-classes"><span class="std std-ref">generic class</span></a>.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="id3">
<h3><span class="section-number">3.2.11. </span>클래스 인스턴스(Class instances)<a class="headerlink" href="datamodel.html#id3" title="Link to this heading">¶</a></h3>
<p id="index-51">A class instance is created by calling a class object (see above).  A class
instance has a namespace implemented as a dictionary which is the first place
in which attribute references are searched.  When an attribute is not found
there, and the instance’s class has an attribute by that name, the search
continues with the class attributes.  If a class attribute is found that is a
user-defined function object, it is transformed into an instance method
object whose <a class="reference internal" href="datamodel.html#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a> attribute is the instance.  Static method and
class method objects are also transformed; see above under “Classes”.  See
section <a class="reference internal" href="datamodel.html#descriptors"><span class="std std-ref">디스크립터 구현하기</span></a> for another way in which attributes of a class
retrieved via its instances may differ from the objects actually stored in
the class’s <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>.  If no class attribute is found, and the
object’s class has a <a class="reference internal" href="datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> method, that is called to satisfy
the lookup.</p>
<p id="index-52">Attribute assignments and deletions update the instance’s dictionary, never a
class’s dictionary.  If the class has a <a class="reference internal" href="datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> or
<a class="reference internal" href="datamodel.html#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code></a> method, this is called instead of updating the instance
dictionary directly.</p>
<p id="index-53">어떤 특별한 이름들의 메서드들을 가지면, 클래스 인스턴스는 숫자, 시퀀스, 매핑인 척할 수 있습니다. <a class="reference internal" href="datamodel.html#specialnames"><span class="std std-ref">특수 메서드 이름들</span></a> 섹션을 보십시오.</p>
<p id="index-54">특수 어트리뷰트들: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 는 어트리뷰트 딕셔너리입니다; <a class="reference internal" href="../library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> 는 인스턴스의 클래스입니다.</p>
</section>
<section id="i-o-objects-also-known-as-file-objects">
<h3><span class="section-number">3.2.12. </span>I/O 객체 (파일 객체라고도 알려져 있습니다)<a class="headerlink" href="datamodel.html#i-o-objects-also-known-as-file-objects" title="Link to this heading">¶</a></h3>
<p id="index-55"><a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a> 는 열린 파일을 나타냅니다. 파일 객체를 만드는 여러 가지 단축법이 있습니다: <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 내장 함수, <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.popen()</span></code></a>, <a class="reference internal" href="../library/os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fdopen()</span></code></a> 과 소켓 객체의 <a class="reference internal" href="../library/socket.html#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a> 메서드 (그리고, 아마도 확장 모듈들이 제공하는 다른 함수들이나 메서드들).</p>
<p><code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> 는 인터프리터의 표준 입력, 출력, 에러 스트림으로 초기화된 파일 객체들입니다; 모두 텍스트 모드로 열려서 <a class="reference internal" href="../library/io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a> 추상 클래스에 의해 정의된 인터페이스를 따릅니다.</p>
</section>
<section id="internal-types">
<h3><span class="section-number">3.2.13. </span>내부 형(Internal types)<a class="headerlink" href="datamodel.html#internal-types" title="Link to this heading">¶</a></h3>
<p id="index-56">인터프리터가 내부적으로 사용하는 몇몇 형들은 사용자에게 노출됩니다. 인터프리터의 미래 버전에서 이들의 정의는 변경될 수 있지만, 완전함을 위해 여기서 언급합니다.</p>
<section id="code-objects">
<span id="id4"></span><h4><span class="section-number">3.2.13.1. </span>코드 객체(Code objects)<a class="headerlink" href="datamodel.html#code-objects" title="Link to this heading">¶</a></h4>
<p id="index-57">코드 객체는 <em>바이트로 컴파일된(byte-compiled)</em> 실행 가능한 파이썬 코드를 나타내는데, 그냥 <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">바이트 코드</span></a> 라고도 부릅니다. 코드 객체와 함수 객체 간에는 차이가 있습니다; 함수 객체는 함수의 전역 공간(globals) (함수가 정의된 모듈)을 명시적으로 참조하고 있지만, 코드 객체는 어떤 문맥(context)도 갖고 있지 않습니다; 또한 기본 인자값들이 함수 객체에 저장되어 있지만 코드 객체에는 들어있지 않습니다 (실행 시간에 계산되는 값들을 나타내기 때문입니다). 함수 객체와는 달리, 코드 객체는 불변이고 가변 객체들에 대한 어떤 참조도 (직접 혹은 간접적으로도) 갖고 있지 않습니다.</p>
<section id="index-58">
<span id="id5"></span><h5><span class="section-number">3.2.13.1.1. </span>Special read-only attributes<a class="headerlink" href="datamodel.html#index-58" title="Link to this heading">¶</a></h5>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_name">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_name</span></span><a class="headerlink" href="datamodel.html#codeobject.co_name" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The function name</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_qualname">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_qualname</span></span><a class="headerlink" href="datamodel.html#codeobject.co_qualname" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The fully qualified function name</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_argcount">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_argcount</span></span><a class="headerlink" href="datamodel.html#codeobject.co_argcount" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The total number of positional <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameters</span></a>
(including positional-only parameters and parameters with default values)
that the function has</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_posonlyargcount">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_posonlyargcount</span></span><a class="headerlink" href="datamodel.html#codeobject.co_posonlyargcount" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The number of positional-only <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameters</span></a>
(including arguments with default values) that the function has</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_kwonlyargcount">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_kwonlyargcount</span></span><a class="headerlink" href="datamodel.html#codeobject.co_kwonlyargcount" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The number of keyword-only <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameters</span></a>
(including arguments with default values) that the function has</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_nlocals">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_nlocals</span></span><a class="headerlink" href="datamodel.html#codeobject.co_nlocals" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The number of <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">local variables</span></a> used by the function
(including parameters)</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_varnames">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_varnames</span></span><a class="headerlink" href="datamodel.html#codeobject.co_varnames" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the names of the local variables in the
function (starting with the parameter names)</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_cellvars">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_cellvars</span></span><a class="headerlink" href="datamodel.html#codeobject.co_cellvars" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the names of <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">local variables</span></a>
that are referenced by nested functions inside the function</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_freevars">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_freevars</span></span><a class="headerlink" href="datamodel.html#codeobject.co_freevars" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the names of free variables in the function</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_code">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_code</span></span><a class="headerlink" href="datamodel.html#codeobject.co_code" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>A string representing the sequence of <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> instructions in
the function</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_consts">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_consts</span></span><a class="headerlink" href="datamodel.html#codeobject.co_consts" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the literals used by the <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> in
the function</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_names">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_names</span></span><a class="headerlink" href="datamodel.html#codeobject.co_names" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the names used by the <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> in
the function</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_filename">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_filename</span></span><a class="headerlink" href="datamodel.html#codeobject.co_filename" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The name of the file from which the code was compiled</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_firstlineno">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_firstlineno</span></span><a class="headerlink" href="datamodel.html#codeobject.co_firstlineno" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The line number of the first line of the function</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_lnotab">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_lnotab</span></span><a class="headerlink" href="datamodel.html#codeobject.co_lnotab" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>A string encoding the mapping from <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> offsets to line
numbers. For details, see the source code of the interpreter.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.12부터 폐지됨: </span>This attribute of code objects is deprecated, and may be removed in
Python 3.14.</p>
</div>
</td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_stacksize">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_stacksize</span></span><a class="headerlink" href="datamodel.html#codeobject.co_stacksize" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The required stack size of the code object</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_flags">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_flags</span></span><a class="headerlink" href="datamodel.html#codeobject.co_flags" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>An <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">integer</span></code></a> encoding a number of flags for the
interpreter.</p></td>
</tr>
</tbody>
</table>
<p id="index-59">The following flag bits are defined for <a class="reference internal" href="datamodel.html#codeobject.co_flags" title="codeobject.co_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code></a>:
bit <code class="docutils literal notranslate"><span class="pre">0x04</span></code> is set if
the function uses the <code class="docutils literal notranslate"><span class="pre">*arguments</span></code> syntax to accept an arbitrary number of
positional arguments; bit <code class="docutils literal notranslate"><span class="pre">0x08</span></code> is set if the function uses the
<code class="docutils literal notranslate"><span class="pre">**keywords</span></code> syntax to accept arbitrary keyword arguments; bit <code class="docutils literal notranslate"><span class="pre">0x20</span></code> is set
if the function is a generator. See <a class="reference internal" href="../library/inspect.html#inspect-module-co-flags"><span class="std std-ref">코드 객체 비트 플래그</span></a> for details
on the semantics of each flags that might be present.</p>
<p>Future feature declarations (<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code>) also use bits
in <a class="reference internal" href="datamodel.html#codeobject.co_flags" title="codeobject.co_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code></a> to indicate whether a code object was compiled with a
particular feature enabled: bit <code class="docutils literal notranslate"><span class="pre">0x2000</span></code> is set if the function was compiled
with future division enabled; bits <code class="docutils literal notranslate"><span class="pre">0x10</span></code> and <code class="docutils literal notranslate"><span class="pre">0x1000</span></code> were used in earlier
versions of Python.</p>
<p>Other bits in <a class="reference internal" href="datamodel.html#codeobject.co_flags" title="codeobject.co_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code></a> are reserved for internal use.</p>
<p id="index-60">If a code object represents a function, the first item in
<a class="reference internal" href="datamodel.html#codeobject.co_consts" title="codeobject.co_consts"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_consts</span></code></a> is
the documentation string of the function, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if undefined.</p>
</section>
<section id="methods-on-code-objects">
<h5><span class="section-number">3.2.13.1.2. </span>Methods on code objects<a class="headerlink" href="datamodel.html#methods-on-code-objects" title="Link to this heading">¶</a></h5>
<dl class="py method">
<dt class="sig sig-object py" id="codeobject.co_positions">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_positions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#codeobject.co_positions" title="Link to this definition">¶</a></dt>
<dd><p>Returns an iterable over the source code positions of each <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>
instruction in the code object.</p>
<p>The iterator returns <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>s containing the <code class="docutils literal notranslate"><span class="pre">(start_line,</span> <span class="pre">end_line,</span>
<span class="pre">start_column,</span> <span class="pre">end_column)</span></code>. The <em>i-th</em> tuple corresponds to the
position of the source code that compiled to the <em>i-th</em> code unit.
Column information is 0-indexed utf-8 byte offsets on the given source
line.</p>
<p>This positional information can be missing. A non-exhaustive lists of
cases where this may happen:</p>
<ul class="simple">
<li><p>Running the interpreter with <a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span></code></a> <code class="docutils literal notranslate"><span class="pre">no_debug_ranges</span></code>.</p></li>
<li><p>Loading a pyc file compiled while using <a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span></code></a> <code class="docutils literal notranslate"><span class="pre">no_debug_ranges</span></code>.</p></li>
<li><p>Position tuples corresponding to artificial instructions.</p></li>
<li><p>Line and column numbers that can’t be represented due to
implementation specific limitations.</p></li>
</ul>
<p>When this occurs, some or all of the tuple elements can be
<a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>This feature requires storing column positions in code objects which may
result in a small increase of disk usage of compiled Python files or
interpreter memory usage. To avoid storing the extra information and/or
deactivate printing the extra traceback information, the
<a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span></code></a> <code class="docutils literal notranslate"><span class="pre">no_debug_ranges</span></code> command line flag or the <span class="target" id="index-61"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONNODEBUGRANGES"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONNODEBUGRANGES</span></code></a>
environment variable can be used.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codeobject.co_lines">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_lines</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#codeobject.co_lines" title="Link to this definition">¶</a></dt>
<dd><p>Returns an iterator that yields information about successive ranges of
<a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>s. Each item yielded is a <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">end,</span> <span class="pre">lineno)</span></code>
<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code> (an <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) represents the offset (inclusive) of the start
of the <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> range</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">end</span></code> (an <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) represents the offset (exclusive) of the end of
the <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> range</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lineno</span></code> is an <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> representing the line number of the
<a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> range, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if the bytecodes in the given range
have no line number</p></li>
</ul>
<p>The items yielded will have the following properties:</p>
<ul class="simple">
<li><p>The first range yielded will have a <code class="docutils literal notranslate"><span class="pre">start</span></code> of 0.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">end)</span></code> ranges will be non-decreasing and consecutive. That
is, for any pair of <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>s, the <code class="docutils literal notranslate"><span class="pre">start</span></code> of the second will be
equal to the <code class="docutils literal notranslate"><span class="pre">end</span></code> of the first.</p></li>
<li><p>No range will be backwards: <code class="docutils literal notranslate"><span class="pre">end</span> <span class="pre">&gt;=</span> <span class="pre">start</span></code> for all triples.</p></li>
<li><p>The last <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> yielded will have <code class="docutils literal notranslate"><span class="pre">end</span></code> equal to the size of the
<a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>.</p></li>
</ul>
<p>Zero-width ranges, where <code class="docutils literal notranslate"><span class="pre">start</span> <span class="pre">==</span> <span class="pre">end</span></code>, are allowed. Zero-width ranges
are used for lines that are present in the source code, but have been
eliminated by the <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> compiler.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-62"></span><a class="pep reference external" href="https://peps.python.org/pep-0626/"><strong>PEP 626</strong></a> - Precise line numbers for debugging and other tools.</dt><dd><p>The PEP that introduced the <code class="xref py py-meth docutils literal notranslate"><span class="pre">co_lines()</span></code> method.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codeobject.replace">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#codeobject.replace" title="Link to this definition">¶</a></dt>
<dd><p>Return a copy of the code object with new values for the specified fields.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

</section>
</section>
<section id="frame-objects">
<span id="id6"></span><h4><span class="section-number">3.2.13.2. </span>프레임 객체(Frame objects)<a class="headerlink" href="datamodel.html#frame-objects" title="Link to this heading">¶</a></h4>
<p id="index-63">Frame objects represent execution frames.  They may occur in
<a class="reference internal" href="datamodel.html#traceback-objects"><span class="std std-ref">traceback objects</span></a>,
and are also passed to registered trace functions.</p>
<section id="index-64">
<span id="id7"></span><h5><span class="section-number">3.2.13.2.1. </span>Special read-only attributes<a class="headerlink" href="datamodel.html#index-64" title="Link to this heading">¶</a></h5>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_back">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_back</span></span><a class="headerlink" href="datamodel.html#frame.f_back" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>Points to the previous stack frame (towards the caller),
or <code class="docutils literal notranslate"><span class="pre">None</span></code> if this is the bottom stack frame</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_code">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_code</span></span><a class="headerlink" href="datamodel.html#frame.f_code" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The <a class="reference internal" href="datamodel.html#code-objects"><span class="std std-ref">code object</span></a> being executed in this frame.
Accessing this attribute raises an <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">auditing event</span></a>
<code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> with arguments <code class="docutils literal notranslate"><span class="pre">obj</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;f_code&quot;</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_locals">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_locals</span></span><a class="headerlink" href="datamodel.html#frame.f_locals" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The dictionary used by the frame to look up
<a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">local variables</span></a></p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_globals">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_globals</span></span><a class="headerlink" href="datamodel.html#frame.f_globals" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The dictionary used by the frame to look up
<a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">global variables</span></a></p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_builtins">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_builtins</span></span><a class="headerlink" href="datamodel.html#frame.f_builtins" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The dictionary used by the frame to look up
<a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">built-in (intrinsic) names</span></a></p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_lasti">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_lasti</span></span><a class="headerlink" href="datamodel.html#frame.f_lasti" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The “precise instruction” of the frame object
(this is an index into the <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> string of the
<a class="reference internal" href="datamodel.html#code-objects"><span class="std std-ref">code object</span></a>)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="index-65">
<span id="id8"></span><h5><span class="section-number">3.2.13.2.2. </span>Special writable attributes<a class="headerlink" href="datamodel.html#index-65" title="Link to this heading">¶</a></h5>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_trace">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_trace</span></span><a class="headerlink" href="datamodel.html#frame.f_trace" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>If not <code class="docutils literal notranslate"><span class="pre">None</span></code>, this is a function called for various events during
code execution (this is used by debuggers). Normally an event is
triggered for each new source line (see <a class="reference internal" href="datamodel.html#frame.f_trace_lines" title="frame.f_trace_lines"><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_lines</span></code></a>).</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_trace_lines">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_trace_lines</span></span><a class="headerlink" href="datamodel.html#frame.f_trace_lines" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>Set this attribute to <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> to disable triggering a tracing
event for each source line.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_trace_opcodes">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_trace_opcodes</span></span><a class="headerlink" href="datamodel.html#frame.f_trace_opcodes" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>Set this attribute to <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> to allow per-opcode events to be
requested. Note that this may lead to
undefined interpreter behaviour if exceptions raised by the trace
function escape to the function being traced.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_lineno">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_lineno</span></span><a class="headerlink" href="datamodel.html#frame.f_lineno" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>The current line number of the frame – writing to this
from within a trace function jumps to the given line (only for the bottom-most
frame).  A debugger can implement a Jump command (aka Set Next Statement)
by writing to this attribute.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="frame-object-methods">
<h5><span class="section-number">3.2.13.2.3. </span>Frame object methods<a class="headerlink" href="datamodel.html#frame-object-methods" title="Link to this heading">¶</a></h5>
<p>프레임 객체는 한가지 메서드를 지원합니다:</p>
<dl class="py method">
<dt class="sig sig-object py" id="frame.clear">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#frame.clear" title="Link to this definition">¶</a></dt>
<dd><p>This method clears all references to <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">local variables</span></a> held by the
frame.  Also, if the frame belonged to a <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>, the generator
is finalized.  This helps break reference cycles involving frame
objects (for example when catching an <a class="reference internal" href="../library/exceptions.html#bltin-exceptions"><span class="std std-ref">exception</span></a>
and storing its <a class="reference internal" href="datamodel.html#traceback-objects"><span class="std std-ref">traceback</span></a> for later use).</p>
<p>만약 프레임이 현재 실행 중이면 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 예외가 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

</section>
</section>
<section id="traceback-objects">
<span id="id9"></span><h4><span class="section-number">3.2.13.3. </span>트레이스백 객체(Traceback objects)<a class="headerlink" href="datamodel.html#traceback-objects" title="Link to this heading">¶</a></h4>
<p id="index-66">Traceback objects represent the stack trace of an <a class="reference internal" href="../tutorial/errors.html#tut-errors"><span class="std std-ref">exception</span></a>.
A traceback object
is implicitly created when an exception occurs, and may also be explicitly
created by calling <a class="reference internal" href="../library/types.html#types.TracebackType" title="types.TracebackType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.TracebackType</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>Traceback objects can now be explicitly instantiated from Python code.</p>
</div>
<p>For implicitly created tracebacks, when the search for an exception handler
unwinds the execution stack, at each unwound level a traceback object is
inserted in front of the current traceback.  When an exception handler is
entered, the stack trace is made available to the program. (See section
<a class="reference internal" href="compound_stmts.html#try"><span class="std std-ref">try 문</span></a>.) It is accessible as the third item of the
tuple returned by <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>, and as the
<a class="reference internal" href="../library/exceptions.html#BaseException.__traceback__" title="BaseException.__traceback__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__traceback__</span></code></a> attribute
of the caught exception.</p>
<p>When the program contains no suitable
handler, the stack trace is written (nicely formatted) to the standard error
stream; if the interpreter is interactive, it is also made available to the user
as <a class="reference internal" href="../library/sys.html#sys.last_traceback" title="sys.last_traceback"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.last_traceback</span></code></a>.</p>
<p>For explicitly created tracebacks, it is up to the creator of the traceback
to determine how the <a class="reference internal" href="datamodel.html#traceback.tb_next" title="traceback.tb_next"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_next</span></code></a> attributes should be linked to
form a full stack trace.</p>
<p id="index-67">Special read-only attributes:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="traceback.tb_frame">
<span class="sig-prename descclassname"><span class="pre">traceback.</span></span><span class="sig-name descname"><span class="pre">tb_frame</span></span><a class="headerlink" href="datamodel.html#traceback.tb_frame" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>Points to the execution <a class="reference internal" href="datamodel.html#frame-objects"><span class="std std-ref">frame</span></a> of the current
level.</p>
<p>Accessing this attribute raises an
<a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> with arguments
<code class="docutils literal notranslate"><span class="pre">obj</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;tb_frame&quot;</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="traceback.tb_lineno">
<span class="sig-prename descclassname"><span class="pre">traceback.</span></span><span class="sig-name descname"><span class="pre">tb_lineno</span></span><a class="headerlink" href="datamodel.html#traceback.tb_lineno" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>Gives the line number where the exception occurred</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="traceback.tb_lasti">
<span class="sig-prename descclassname"><span class="pre">traceback.</span></span><span class="sig-name descname"><span class="pre">tb_lasti</span></span><a class="headerlink" href="datamodel.html#traceback.tb_lasti" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>Indicates the “precise instruction”.</p></td>
</tr>
</tbody>
</table>
<p>The line number and last instruction in the traceback may differ from the
line number of its <a class="reference internal" href="datamodel.html#frame-objects"><span class="std std-ref">frame object</span></a> if the exception
occurred in a
<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> statement with no matching except clause or with a
<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> clause.</p>
<dl class="py attribute" id="index-68">
<dt class="sig sig-object py" id="traceback.tb_next">
<span class="sig-prename descclassname"><span class="pre">traceback.</span></span><span class="sig-name descname"><span class="pre">tb_next</span></span><a class="headerlink" href="datamodel.html#traceback.tb_next" title="Link to this definition">¶</a></dt>
<dd><p>The special writable attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_next</span></code> is the next level in the
stack trace (towards the frame where the exception occurred), or <code class="docutils literal notranslate"><span class="pre">None</span></code> if
there is no next level.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>This attribute is now writable</p>
</div>
</dd></dl>

</section>
<section id="slice-objects">
<h4><span class="section-number">3.2.13.4. </span>슬라이스 객체(Slice objects)<a class="headerlink" href="datamodel.html#slice-objects" title="Link to this heading">¶</a></h4>
<p id="index-69">Slice objects are used to represent slices for
<a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>
methods.  They are also created by the built-in <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a> function.</p>
<p id="index-70">특수 읽기 전용 어트리뷰트들: <a class="reference internal" href="../library/functions.html#slice.start" title="slice.start"><code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code></a> 는 하한(lower bound) 입니다; <a class="reference internal" href="../library/functions.html#slice.stop" title="slice.stop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code></a> 은 상한(upper bound) 입니다; <a class="reference internal" href="../library/functions.html#slice.step" title="slice.step"><code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code></a> 은 스텝 값입니다; 각 값은 생략될 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다. 이 어트리뷰트들은 임의의 형이 될 수 있습니다.</p>
<p>슬라이스 객체는 하나의 메서드를 지원합니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="slice.indices">
<span class="sig-prename descclassname"><span class="pre">slice.</span></span><span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#slice.indices" title="Link to this definition">¶</a></dt>
<dd><p>이 메서드는 하나의 정수 인자 <em>length</em> 를 받아서 슬라이스 객체가 길이 <em>length</em> 인 시퀀스에 적용되었을 때 그 슬라이스에 대한 정보를 계산합니다. 세 개의 정수로 구성된 튜플을 돌려줍니다: 이것들은 각각 <em>start</em> 와 <em>stop</em> 인덱스와, <em>step</em> 또는 슬라이스의 스트라이드(stride) 길이입니다. 생략되었거나 범위를 벗어난 인덱스들은 일반적인 슬라이스와 같은 방법으로 다뤄집니다.</p>
</dd></dl>

</section>
<section id="static-method-objects">
<h4><span class="section-number">3.2.13.5. </span>스태틱 메서드 객체(Static method objects)<a class="headerlink" href="datamodel.html#static-method-objects" title="Link to this heading">¶</a></h4>
<p>Static method objects provide a way of defeating the transformation of function
objects to method objects described above. A static method object is a wrapper
around any other object, usually a user-defined method object. When a static
method object is retrieved from a class or a class instance, the object actually
returned is the wrapped object, which is not subject to any further
transformation. Static method objects are also callable. Static method
objects are created by the built-in <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> constructor.</p>
</section>
<section id="class-method-objects">
<h4><span class="section-number">3.2.13.6. </span>클래스 메서드 객체(Class method objects)<a class="headerlink" href="datamodel.html#class-method-objects" title="Link to this heading">¶</a></h4>
<p>A class method object, like a static method object, is a wrapper around another
object that alters the way in which that object is retrieved from classes and
class instances. The behaviour of class method objects upon such retrieval is
described above, under <a class="reference internal" href="datamodel.html#instance-methods"><span class="std std-ref">“instance methods”</span></a>. Class method objects are created
by the built-in <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> constructor.</p>
</section>
</section>
</section>
<section id="special-method-names">
<span id="specialnames"></span><h2><span class="section-number">3.3. </span>특수 메서드 이름들<a class="headerlink" href="datamodel.html#special-method-names" title="Link to this heading">¶</a></h2>
<p id="index-71">A class can implement certain operations that are invoked by special syntax
(such as arithmetic operations or subscripting and slicing) by defining methods
with special names. This is Python’s approach to <em class="dfn">operator overloading</em>,
allowing classes to define their own behavior with respect to language
operators.  For instance, if a class defines a method named
<a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>,
and <code class="docutils literal notranslate"><span class="pre">x</span></code> is an instance of this class, then <code class="docutils literal notranslate"><span class="pre">x[i]</span></code> is roughly equivalent
to <code class="docutils literal notranslate"><span class="pre">type(x).__getitem__(x,</span> <span class="pre">i)</span></code>.  Except where mentioned, attempts to execute an
operation raise an exception when no appropriate method is defined (typically
<a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> or <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>).</p>
<p>Setting a special method to <code class="docutils literal notranslate"><span class="pre">None</span></code> indicates that the corresponding
operation is not available.  For example, if a class sets
<a class="reference internal" href="datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the class is not iterable, so calling
<a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> on its instances will raise a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> (without
falling back to <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>). <a class="footnote-reference brackets" href="datamodel.html#id18" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p>
<p>내장형을 흉내 내는 클래스를 구현할 때, 모방은 모형화하는 객체에 말이 되는 수준까지만 구현하는 것이 중요합니다. 예를 들어, 어떤 시퀀스는 개별 항목들을 꺼내는 것만으로도 잘 동작할 수 있습니다. 하지만 슬라이스를 꺼내는 것은 말이 안 될 수 있습니다. (이런 한가지 예는 W3C의 Document Object Model의 <code class="xref py py-class docutils literal notranslate"><span class="pre">NodeList</span></code> 인터페이스입니다.)</p>
<section id="basic-customization">
<span id="customization"></span><h3><span class="section-number">3.3.1. </span>기본적인 커스터마이제이션<a class="headerlink" href="datamodel.html#basic-customization" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="object.__new__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__new__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__new__" title="Link to this definition">¶</a></dt>
<dd><p id="index-72">클래스 <em>cls</em> 의 새 인스턴스를 만들기 위해 호출됩니다. <a class="reference internal" href="datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 는 스태틱 메서드입니다 (그렇게 선언하지 않아도 되는 특별한 경우입니다)인데, 첫 번째 인자로 만들려고 하는 인스턴스의 클래스가 전달됩니다. 나머지 인자들은 객체 생성자 표현(클래스 호출)에 전달된 것들입니다. <a class="reference internal" href="datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 의 반환 값은 새 객체 인스턴스이어야 합니다 (보통 <em>cls</em> 의 인스턴스).</p>
<p>Typical implementations create a new instance of the class by invoking the
superclass’s <a class="reference internal" href="datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> method using <code class="docutils literal notranslate"><span class="pre">super().__new__(cls[,</span> <span class="pre">...])</span></code>
with appropriate arguments and then modifying the newly created instance
as necessary before returning it.</p>
<p>If <a class="reference internal" href="datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> is invoked during object construction and it returns an
instance of <em>cls</em>, then the new instance’s <a class="reference internal" href="datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> method
will be invoked like <code class="docutils literal notranslate"><span class="pre">__init__(self[,</span> <span class="pre">...])</span></code>, where <em>self</em> is the new instance
and the remaining arguments are the same as were passed to the object constructor.</p>
<p>만약 <a class="reference internal" href="datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 가 <em>cls</em> 의 인스턴스를 돌려주지 않으면, 새 인스턴스의 <a class="reference internal" href="datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 는 호출되지 않습니다.</p>
<p><a class="reference internal" href="datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 는 주로 불변형(int, str, tuple과 같은)의 서브 클래스가 인스턴스 생성을 커스터마이즈할 수 있도록 하는 데 사용됩니다. 또한, 사용자 정의 메타 클래스에서 클래스 생성을 커스터마이즈하기 위해 자주 사용됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__init__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__init__" title="Link to this definition">¶</a></dt>
<dd><p id="index-73">(<a class="reference internal" href="datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 에 의해) 인스턴스가 만들어진 후에, 하지만 호출자에게 돌려주기 전에 호출됩니다. 인자들은 클래스 생성자 표현으로 전달된 것들입니다. 만약 베이스 클래스가 <a class="reference internal" href="datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드를 갖고 있다면, 서브 클래스의 <a class="reference internal" href="datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드는, 있다면, 인스턴스에서 베이스 클래스가 차지하는 부분이 올바르게 초기화됨을 확실히 하기 위해 명시적으로 호출해주어야 합니다; 예를 들어: <code class="docutils literal notranslate"><span class="pre">super().__init__([args...])</span></code>.</p>
<p>객체를 만드는데 <a class="reference internal" href="datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 와 <a class="reference internal" href="datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 가 협력하고 있으므로 (<a class="reference internal" href="datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 는 만들고, <a class="reference internal" href="datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 는 그것을 커스터마이즈합니다), <a class="reference internal" href="datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이외의 값을 돌려주면 실행시간에 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으킵니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__del__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__del__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__del__" title="Link to this definition">¶</a></dt>
<dd><p id="index-74">인스턴스가 파괴되기 직전에 호출됩니다. 파이널라이저 또는 (부적절하게) 파괴자라고 불립니다. 만약 베이스 클래스가 <a class="reference internal" href="datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드를 갖고 있다면, 자식 클래스의 <a class="reference internal" href="datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드는, 정의되어 있다면, 인스턴스에서 베이스 클래스가 차지하는 부분을 적절하게 삭제하기 위해, 명시적으로 베이스 클래스의 메서드를 호출해야 합니다.</p>
<p>(권장하지는 않지만!) <a class="reference internal" href="datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드는 인스턴스에 대한 새로운 참조를 만듦으로써 인스턴스의 파괴를 지연시킬 수 있습니다. 이것을 객체 <em>부활</em> 이라고 부릅니다. 부활한 객체가 파괴될 때 <a class="reference internal" href="datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 이 두 번째로 호출될지는 구현에 따라 다릅니다; 현재 <a class="reference internal" href="../glossary.html#term-CPython"><span class="xref std std-term">CPython</span></a> 구현은 오직 한 번만 호출합니다.</p>
<p>인터프리터가 종료할 때 아직 남아있는 객체들에 대해서는 <a class="reference internal" href="datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드의 호출이 보장되지 않습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> 는 직접 <code class="docutils literal notranslate"><span class="pre">x.__del__()</span></code> 를 호출하지 않습니다 — 앞에 있는 것은 <code class="docutils literal notranslate"><span class="pre">x</span></code> 의 참조 횟수(reference count)를 하나 감소시키고, 뒤에 있는 것은 <code class="docutils literal notranslate"><span class="pre">x</span></code> 의 참조 횟수가 0 이 될 때 호출됩니다.</p>
</div>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> It is possible for a reference cycle to prevent the reference count
of an object from going to zero.  In this case, the cycle will be
later detected and deleted by the <a class="reference internal" href="../glossary.html#term-garbage-collection"><span class="xref std std-term">cyclic garbage collector</span></a>.  A common cause of reference cycles is when
an exception has been caught in a local variable.  The frame’s
locals then reference the exception, which references its own
traceback, which references the locals of all frames caught in the
traceback.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> 모듈에 대한 문서.</p>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p><a class="reference internal" href="datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 이 호출되는 불안정한 상황 때문에, 이것이 실행 중에 발생시키는 예외는 무시되고, 대신에 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> 로 경고가 출력됩니다. 특히:</p>
<ul class="simple">
<li><p><a class="reference internal" href="datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 은 (임의의 스레드에서) 임의의 코드가 실행되는 동안 호출될 수 있습니다. <a class="reference internal" href="datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 이 록을 얻어야 하거나 다른 블로킹 자원을 호출하면, <a class="reference internal" href="datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 을 실행하기 위해 중단된 코드가 자원을 이미 차지했을 수 있으므로 교착 상태에 빠질 수 있습니다.</p></li>
<li><p><a class="reference internal" href="datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 은 인터프리터를 종료할 때 실행될 수 있습니다. 결과적으로, 액세스해야 하는 전역 변수(다른 모듈 포함)가 이미 삭제되었거나 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정되었을 수 있습니다. 파이썬은 이름이 하나의 밑줄로 시작하는 전역 객체가 다른 전역 객체들보다 먼저 삭제됨을 보장합니다; 이것은, 만약 그 전역 객체들에 대한 다른 참조가 존재하지 않는다면, <a class="reference internal" href="datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드가 호출되는 시점에, 임포트된 모듈들이 남아있도록 확실히 하는 데 도움이 될 수 있습니다.</p></li>
</ul>
</div>
<span class="target" id="index-75"></span></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__repr__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__repr__" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 내장 함수에 의해 호출되어 객체의 “형식적인(official)” 문자열 표현을 계산합니다. 만약 가능하다면, 이것은 같은 (적절한 환경이 주어질 때) 값을 갖는 객체를 새로 만들 수 있는 올바른 파이썬 표현식처럼 보여야 합니다. 가능하지 않다면, <code class="docutils literal notranslate"><span class="pre">&lt;...쓸모있는</span> <span class="pre">설명...&gt;</span></code> 형태의 문자열을 돌려줘야 합니다. 반환 값은 반드시 문자열이어야 합니다. 만약 클래스가 <a class="reference internal" href="datamodel.html#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> 없이 <a class="reference internal" href="datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 만 정의한다면, <a class="reference internal" href="datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 은 그 클래스 인스턴스의 “비형식적인(informal)” 문자열 표현이 요구될 때 사용될 수 있습니다.</p>
<p>이것은 디버깅에 사용되기 때문에, 표현이 풍부한 정보를 담고 모호하지 않게 하는 것이 중요합니다.</p>
<span class="target" id="index-76"></span></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__str__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__str__" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str(object)</span></code></a> 와 내장 함수 <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a>, <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 에 의해 호출되어 객체의 “비형식적인(informal)” 또는 보기 좋게 인쇄 가능한 문자열 표현을 계산합니다. 반환 값은 반드시 <a class="reference internal" href="../library/stdtypes.html#textseq"><span class="std std-ref">문자열</span></a> 객체여야 합니다.</p>
<p>이 메서드는 <a class="reference internal" href="datamodel.html#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> 이 올바른 파이썬 표현식을 돌려줄 것이라고 기대되지 않는다는 점에서 <a class="reference internal" href="datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a> 과 다릅니다: 더 편리하고 간결한 표현이 사용될 수 있습니다.</p>
<p>내장형 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 에 정의된 기본 구현은 <a class="reference internal" href="datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a> 을 호출합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__bytes__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__bytes__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__bytes__" title="Link to this definition">¶</a></dt>
<dd><p id="index-77"><a class="reference internal" href="../library/functions.html#func-bytes"><span class="std std-ref">bytes</span></a> 에 의해 호출되어 객체의 바이트열 표현을 계산합니다. 반환 값은 반드시 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체여야 합니다.</p>
<span class="target" id="index-78"></span></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__format__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__format__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_spec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__format__" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 내장 함수, 확대하면, <a class="reference internal" href="lexical_analysis.html#f-strings"><span class="std std-ref">포맷 문자열 리터럴(formatted string literals)</span></a> 의 계산과 <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 메서드에 의해 호출되어, 객체의 “포맷된” 문자열 표현을 만들어냅니다. <em>format_spec</em> 인자는 요구되는 포맷 옵션들을 포함하는 문자열입니다. <em>format_spec</em> 인자의 해석은 <a class="reference internal" href="datamodel.html#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a> 을 구현하는 형에 달려있으나, 대부분 클래스는 포매팅을 내향형들의 하나로 위임하거나, 비슷한 포맷 옵션 문법을 사용합니다.</p>
<p>표준 포매팅 문법에 대해서는 <a class="reference internal" href="../library/string.html#formatspec"><span class="std std-ref">포맷 명세 미니 언어</span></a> 를 참고하면 됩니다.</p>
<p>반환 값은 반드시 문자열이어야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">object</span></code> 의 __format__ 메서드 자신은, 빈 문자열이 아닌 인자가 전달되면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 발생시킵니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이제 <code class="docutils literal notranslate"><span class="pre">object.__format__(x,</span> <span class="pre">'')</span></code> 는 <code class="docutils literal notranslate"><span class="pre">format(str(x),</span> <span class="pre">'')</span></code> 가 아니라 <code class="docutils literal notranslate"><span class="pre">str(x)</span></code> 와 동등합니다.</p>
</div>
</dd></dl>

<dl class="py method" id="richcmpfuncs">
<dt class="sig sig-object py" id="object.__lt__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__lt__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__lt__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__le__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__le__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__le__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__eq__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__eq__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ne__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ne__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__ne__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__gt__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__gt__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__gt__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ge__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ge__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__ge__" title="Link to this definition">¶</a></dt>
<dd><p id="index-79">이것들은 소위 “풍부한 비교(rich comparison)” 메서드입니다. 연산자 기호와 메서드 이름 간의 관계는 다음과 같습니다: <code class="docutils literal notranslate"><span class="pre">x&lt;y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__lt__(y)</span></code> 를 호출합니다, <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__le__(y)</span></code> 를 호출합니다, <code class="docutils literal notranslate"><span class="pre">x==y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__eq__(y)</span></code> 를 호출합니다, <code class="docutils literal notranslate"><span class="pre">x!=y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__ne__(y)</span></code> 를 호출합니다, <code class="docutils literal notranslate"><span class="pre">x&gt;y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__gt__(y)</span></code> 를 호출합니다, <code class="docutils literal notranslate"><span class="pre">x&gt;=y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__ge__(y)</span></code> 를 호출합니다.</p>
<p>A rich comparison method may return the singleton <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> if it does
not implement the operation for a given pair of arguments. By convention,
<code class="docutils literal notranslate"><span class="pre">False</span></code> and <code class="docutils literal notranslate"><span class="pre">True</span></code> are returned for a successful comparison. However, these
methods can return any value, so if the comparison operator is used in a Boolean
context (e.g., in the condition of an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement), Python will call
<a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a> on the value to determine if the result is true or false.</p>
<p>By default, <code class="docutils literal notranslate"><span class="pre">object</span></code> implements <a class="reference internal" href="datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> by using <code class="docutils literal notranslate"><span class="pre">is</span></code>, returning
<a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> in the case of a false comparison:
<code class="docutils literal notranslate"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span> <span class="pre">else</span> <span class="pre">NotImplemented</span></code>. For <a class="reference internal" href="datamodel.html#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a>, by default it
delegates to <a class="reference internal" href="datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> and inverts the result unless it is
<code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code>.  There are no other implied relationships among the
comparison operators or default implementations; for example, the truth of
<code class="docutils literal notranslate"><span class="pre">(x&lt;y</span> <span class="pre">or</span> <span class="pre">x==y)</span></code> does not imply <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code>. To automatically generate ordering
operations from a single root operation, see <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.total_ordering()</span></code></a>.</p>
<p>사용자 정의 비교 연산자를 지원하고 딕셔너리 키로 사용될 수 있는 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a> 객체를 만드는 것에 관한 몇 가지 중요한 내용이 <a class="reference internal" href="datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 에 관한 문단에 나옵니다.</p>
<p>There are no swapped-argument versions of these methods (to be used when the
left argument does not support the operation but the right argument does);
rather, <a class="reference internal" href="datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> and <a class="reference internal" href="datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> are each other’s reflection,
<a class="reference internal" href="datamodel.html#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a> and <a class="reference internal" href="datamodel.html#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a> are each other’s reflection, and
<a class="reference internal" href="datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> and <a class="reference internal" href="datamodel.html#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> are their own reflection.
If the operands are of different types, and the right operand’s type is
a direct or indirect subclass of the left operand’s type,
the reflected method of the right operand has priority, otherwise
the left operand’s method has priority.  Virtual subclassing is
not considered.</p>
<p>When no appropriate method returns any value other than <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>, the
<code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">!=</span></code> operators will fall back to <code class="docutils literal notranslate"><span class="pre">is</span></code> and <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code>, respectively.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__hash__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__hash__" title="Link to this definition">¶</a></dt>
<dd><p id="index-80">Called by built-in function <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> and for operations on members of
hashed collections including <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>, and
<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.  The <code class="docutils literal notranslate"><span class="pre">__hash__()</span></code> method should return an integer. The only required
property is that objects which compare equal have the same hash value; it is
advised to mix together the hash values of the components of the object that
also play a part in comparison of objects by packing them into a tuple and
hashing the tuple. Example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nick</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 는 객체가 정의한 <a class="reference internal" href="datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드가 돌려주는 값을 <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> 의 크기로 자릅니다(truncate). 이것은 보통 64-bit 빌드에서는 8바이트고, 32-bit 빌드에서는 4바이트입니다. 만약 객체의 <a class="reference internal" href="datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 가 서로 다른 비트 크기를 갖는 빌드들 사이에서 함께 사용되어야 한다면, 모든 지원할 빌드들에서의 폭을 검사해야 합니다. 이렇게 하는 쉬운 방법은 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-c</span> <span class="pre">&quot;import</span> <span class="pre">sys;</span> <span class="pre">print(sys.hash_info.width)&quot;</span></code> 입니다.</p>
</div>
<p>If a class does not define an <a class="reference internal" href="datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> method it should not define a
<a class="reference internal" href="datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> operation either; if it defines <a class="reference internal" href="datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> but not
<a class="reference internal" href="datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, its instances will not be usable as items in hashable
collections.  If a class defines mutable objects and implements an
<a class="reference internal" href="datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> method, it should not implement <a class="reference internal" href="datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, since the
implementation of <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> collections requires that a key’s hash value is
immutable (if the object’s hash value changes, it will be in the wrong hash
bucket).</p>
<p>사용자 정의 클래스는 기본적으로 <a class="reference internal" href="datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 와 <a class="reference internal" href="datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드를 갖습니다; 모든 객체는 (자기 자신을 제외하고) 같지 않다고 비교되고, <code class="docutils literal notranslate"><span class="pre">x.__hash__()</span></code> 는 적절한 값을 돌려주어, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> 일 때 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">hash(x)</span> <span class="pre">==</span> <span class="pre">hash(y)</span></code> 가 동시에 성립할 수 있도록 합니다.</p>
<p><a class="reference internal" href="datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 재정의하고 <a class="reference internal" href="datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 를 정의하지 않는 클래스는 <a class="reference internal" href="datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정됩니다. 클래스의 <a class="reference internal" href="datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, 클래스의 인스턴스는 프로그램이 해시값을 얻으려 시도할 때 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으키고, <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code> 로 검사할 때 해시 가능하지 않다고 올바로 감지됩니다.</p>
<p>만약 <a class="reference internal" href="datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 재정의하는 클래스가 부모 클래스로부터 <a class="reference internal" href="datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 의 구현을 물려받고 싶으면 인터프리터에게 명시적으로 이렇게 지정해주어야 합니다: <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">&lt;ParentClass&gt;.__hash__</span></code>.</p>
<p>만약 <a class="reference internal" href="datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 재정의하지 않는 클래스가 해시 지원을 멈추고 싶으면, 클래스 정의에 <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> 을 포함해야 합니다. 자신의 <a class="reference internal" href="datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 을 정의한 후에 직접 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으키는 경우는 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code> 호출이 해시 가능하다고 잘못 인식합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>기본적으로, str과 bytes 객체들의 <a class="reference internal" href="datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 값은 예측할 수 없는 난수값으로 “솔트되어(salted)” 있습니다. 개별 파이썬 프로세스 내에서는 변하지 않는 값으로 유지되지만, 파이썬을 반복적으로 실행할 때는 예측할 수 없게 됩니다.</p>
<p>This is intended to provide protection against a denial-of-service caused
by carefully chosen inputs that exploit the worst case performance of a
dict insertion, <em>O</em>(<em>n</em><sup>2</sup>) complexity.  See
<a class="reference external" href="http://ocert.org/advisories/ocert-2011-003.html">http://ocert.org/advisories/ocert-2011-003.html</a> for details.</p>
<p>해시값의 변경은 집합의 이터레이션 순서에 영향을 줍니다, 파이썬은 이 순서에 대해 어떤 보장도 하지 않습니다 (그리고 보통 32-bit 와 64-bit 빌드 사이에서도 다릅니다).</p>
<p><span class="target" id="index-120"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a> 를 참고하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>해시 난수 화는 기본적으로 활성화됩니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__bool__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__bool__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__bool__" title="Link to this definition">¶</a></dt>
<dd><p id="index-82">Called to implement truth value testing and the built-in operation
<code class="docutils literal notranslate"><span class="pre">bool()</span></code>; should return <code class="docutils literal notranslate"><span class="pre">False</span></code> or <code class="docutils literal notranslate"><span class="pre">True</span></code>.  When this method is not
defined, <a class="reference internal" href="datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> is called, if it is defined, and the object is
considered true if its result is nonzero.  If a class defines neither
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code> nor <code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code>, all its instances are considered
true.</p>
</dd></dl>

</section>
<section id="customizing-attribute-access">
<span id="attribute-access"></span><h3><span class="section-number">3.3.2. </span>어트리뷰트 액세스 커스터마이제이션<a class="headerlink" href="datamodel.html#customizing-attribute-access" title="Link to this heading">¶</a></h3>
<p>클래스 인스턴스의 어트리뷰트 참조(읽기, 대입하기, <code class="docutils literal notranslate"><span class="pre">x.name</span></code> 을 삭제하기)의 의미를 변경하기 위해 다음과 같은 메서드들이 정의될 수 있습니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__getattr__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__getattr__" title="Link to this definition">¶</a></dt>
<dd><p>기본 어트리뷰트 액세스가 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 로 실패할 때 호출됩니다 (<em>name</em> 이 인스턴스 어트리뷰트 또는 <code class="docutils literal notranslate"><span class="pre">self</span></code> 의 클래스 트리에 있는 어트리뷰트가 아니라서 <a class="reference internal" href="datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 가 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 일으키거나; <em>name</em> 프로퍼티의 <a class="reference internal" href="datamodel.html#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> 이 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 일으킬 때). 이 메서드는 (계산된) 어트리뷰트 값을 반환하거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 예외를 일으켜야 합니다.</p>
<p>일반적인 메커니즘을 통해 어트리뷰트가 발견되면 <a class="reference internal" href="datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 이 호출되지 않음에 주의해야 합니다 (이것은 <a class="reference internal" href="datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 과 <a class="reference internal" href="datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 간의 의도된 비대칭입니다). 이렇게 하는 이유는 효율 때문이기도 하고, 그렇게 하지 않으면 <a class="reference internal" href="datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 가 인스턴스의 다른 어트리뷰트에 접근할 방법이 없기 때문이기도 합니다. 적어도 인스턴스 변수의 경우, 어떤 값도 인스턴스 어트리뷰트 딕셔너리에 넣지 않음으로써 (대신에 그것들을 다른 객체에 넣습니다) 완전한 제어인 것처럼 조작할 수 있습니다. 어트리뷰트 액세스를 실제로 완전히 조작하는 방법에 대해서는 아래에 나오는 <a class="reference internal" href="datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 에서 다룹니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__getattribute__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getattribute__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__getattribute__" title="Link to this definition">¶</a></dt>
<dd><p>클래스 인스턴스의 어트리뷰트 액세스를 구현하기 위해 조건 없이 호출됩니다. 만약 클래스가 <a class="reference internal" href="datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 도 함께 구현하면, <a class="reference internal" href="datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 가 명시적으로 호출하거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 일으키지 않는 이상 <cite>__getattr__</cite> 는 호출되지 않습니다. 이 메서드는 어트리뷰트의 (계산된) 값을 돌려주거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 예외를 일으켜야 합니다. 이 메서드에서 무한 재귀(infinite recursion)가 발생하는 것을 막기 위해, 구현은 언제나 필요한 어트리뷰트에 접근하기 위해 같은 이름의 베이스 클래스의 메서드를 호출해야 합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">object.__getattribute__(self,</span> <span class="pre">name)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>This method may still be bypassed when looking up special methods as the
result of implicit invocation via language syntax or
<a class="reference internal" href="datamodel.html#builtin-functions"><span class="std std-ref">built-in functions</span></a>.
See <a class="reference internal" href="datamodel.html#special-lookup"><span class="std std-ref">특수 메서드 조회</span></a>.</p>
</div>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">obj</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>으로 <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code>을 발생시킵니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__setattr__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__setattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__setattr__" title="Link to this definition">¶</a></dt>
<dd><p>어트리뷰트 대입이 시도될 때 호출됩니다. 일반적인 메커니즘(즉 인스턴스 딕셔너리에 값을 저장하는 것) 대신에 이것이 호출됩니다. <em>name</em> 은 어트리뷰트 이름이고, <em>value</em> 는 그것에 대입하려는 값입니다.</p>
<p><a class="reference internal" href="datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 에서 인스턴스 어트리뷰트에 대입하려고 할 때는, 같은 이름의 베이스 클래스의 메서드를 호출해야 합니다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">object.__setattr__(self,</span> <span class="pre">name,</span> <span class="pre">value)</span></code></p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">obj</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">value</span></code>로 <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">object.__setattr__</span></code>을 발생시킵니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__delattr__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__delattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__delattr__" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 과 비슷하지만 어트리뷰트를 대입하는 대신에 삭제합니다. 이것은 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">obj.name</span></code> 이 객체에 의미가 있는 경우에만 구현되어야 합니다.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">obj</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>으로 <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">object.__delattr__</span></code>을 발생시킵니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__dir__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__dir__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__dir__" title="Link to this definition">¶</a></dt>
<dd><p>Called when <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> is called on the object. An iterable must be
returned. <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> converts the returned iterable to a list and sorts it.</p>
</dd></dl>

<section id="customizing-module-attribute-access">
<h4><span class="section-number">3.3.2.1. </span>모듈 어트리뷰트 액세스 커스터마이제이션<a class="headerlink" href="datamodel.html#customizing-module-attribute-access" title="Link to this heading">¶</a></h4>
<p id="index-83">특수한 이름 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 과 <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> 는 모듈 어트리뷰트에 대한 접근을 사용자 정의하는 데 사용될 수도 있습니다. 모듈 수준의 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 함수는 하나의 인자로 어트리뷰트의 이름을 받아서 계산된 값을 돌려주거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 발생시켜야 합니다. 일반적인 조회(즉 <a class="reference internal" href="datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__getattribute__()</span></code></a>)를 통해 어트리뷰트가 모듈 객체에서 발견되지 않으면, <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 일으키기 전에 모듈 <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 을 검색합니다. 발견되면, 어트리뷰트 이름으로 그 함수를 호출하고 결과를 돌려줍니다.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> function should accept no arguments, and return an iterable of
strings that represents the names accessible on module. If present, this
function overrides the standard <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> search on a module.</p>
<p>모듈 동작(어트리뷰트 설정, 프로퍼티 등)을 보다 세밀하게 사용자 정의하려면, 모듈 객체의 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 어트리뷰트를 <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> 의 서브 클래스로 설정할 수 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">ModuleType</span>

<span class="k">class</span> <span class="nc">VerboseModule</span><span class="p">(</span><span class="n">ModuleType</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Verbose </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Setting </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s1">...&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">VerboseModule</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>모듈 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 정의와 모듈 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 설정은 어트리뷰트 액세스 구문을 사용하는 조회에만 영향을 미칩니다 – 모듈 전역에 대한 직접적인 액세스(모듈 내의 코드에 의한 액세스이거나 모듈의 전역 딕셔너리에 대한 참조를 거치거나)는 영향받지 않습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이제 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 모듈 어트리뷰트가 쓰기 가능합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7: </span><code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 과 <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> 모듈 어트리뷰트.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-121"></span><a class="pep reference external" href="https://peps.python.org/pep-0562/"><strong>PEP 562</strong></a> - 모듈 __getattr__ 과 __dir__</dt><dd><p>모듈에 대한 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 과 <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> 함수를 설명합니다.</p>
</dd>
</dl>
</div>
</section>
<section id="implementing-descriptors">
<span id="descriptors"></span><h4><span class="section-number">3.3.2.2. </span>디스크립터 구현하기<a class="headerlink" href="datamodel.html#implementing-descriptors" title="Link to this heading">¶</a></h4>
<p>다음에 오는 메서드들은 메서드를 가진 클래스(소위 <em>디스크립터(descriptor)</em> 클래스)의 인스턴스가 <em>소유자(owner)</em> 클래스에 등장할 때만 적용됩니다(디스크립터는 소유자 클래스의 딕셔너리나 그 부모 클래스 중 하나의 딕셔너리에 있어야 합니다). 아래의 예에서, “어트리뷰트” 는 이름이 소유자 클래스의 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 의 키로 사용되고 있는 어트리뷰트를 가리킵니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__get__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__get__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">owner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__get__" title="Link to this definition">¶</a></dt>
<dd><p>소유자 클래스(클래스 어트리뷰트 액세스) 나 그 클래스의 인스턴스(인스턴스 어트리뷰트 액세스)의 어트리뷰트를 취하려고 할 때 호출됩니다. 선택적 <em>owner</em> 인자는 소유자 클래스입니다. 반면에 <em>instance</em> 는 어트리뷰트 참조가 일어나고 있는 인스턴스이거나, 어트리뷰트가 <em>owner</em> 를 통해 액세스 되는 경우 <cite>None</cite> 입니다.</p>
<p>이 메서드는 계산된 어트리뷰트 값을 돌려주거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 예외를 일으켜야 합니다.</p>
<p><span class="target" id="index-122"></span><a class="pep reference external" href="https://peps.python.org/pep-0252/"><strong>PEP 252</strong></a>는 <a class="reference internal" href="datamodel.html#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>이 하나나 두 개의 인자를 갖는 콜러블이라고 지정합니다. 파이썬 자신의 내장 디스크립터는 이 명세를 지원합니다; 그러나, 일부 제삼자 도구에는 두 인수를 모두 요구하는 디스크립터가 있을 수 있습니다. 파이썬 자신의 <a class="reference internal" href="datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 구현은 필요한지와 관계없이 항상 두 인자를 모두 전달합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__set__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__set__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__set__" title="Link to this definition">¶</a></dt>
<dd><p>소유자 클래스의 인스턴스 <em>instance</em> 의 어트리뷰트를 새 값 <em>value</em> 로 설정할 때 호출됩니다.</p>
<p><a class="reference internal" href="datamodel.html#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a>이나 <a class="reference internal" href="datamodel.html#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>를 추가하면 디스크립터 유형이 “데이터 디스크립터(data descriptor)”로 변경됨에 유의하십시오. 자세한 내용은 <a class="reference internal" href="datamodel.html#descriptor-invocation"><span class="std std-ref">디스크립터 호출하기</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__delete__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__delete__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__delete__" title="Link to this definition">¶</a></dt>
<dd><p>소유자 클래스의 인스턴스 <em>instance</em> 의 어트리뷰트를 삭제할 때 호출됩니다.</p>
</dd></dl>

<p>Instances of descriptors may also have the <code class="xref py py-attr docutils literal notranslate"><span class="pre">__objclass__</span></code> attribute
present:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="object.__objclass__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__objclass__</span></span><a class="headerlink" href="datamodel.html#object.__objclass__" title="Link to this definition">¶</a></dt>
<dd><p>The attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">__objclass__</span></code> is interpreted by the <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> module
as specifying the class where this object was defined (setting this
appropriately can assist in runtime introspection of dynamic class attributes).
For callables, it may indicate that an instance of the given type (or a
subclass) is expected or required as the first positional argument (for example,
CPython sets this attribute for unbound methods that are implemented in C).</p>
</dd></dl>

</section>
<section id="invoking-descriptors">
<span id="descriptor-invocation"></span><h4><span class="section-number">3.3.2.3. </span>디스크립터 호출하기<a class="headerlink" href="datamodel.html#invoking-descriptors" title="Link to this heading">¶</a></h4>
<p>In general, a descriptor is an object attribute with “binding behavior”, one
whose attribute access has been overridden by methods in the descriptor
protocol:  <a class="reference internal" href="datamodel.html#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="datamodel.html#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a>, and
<a class="reference internal" href="datamodel.html#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>. If any of
those methods are defined for an object, it is said to be a descriptor.</p>
<p>어트리뷰트 액세스의 기본 동작은 객체의 딕셔너리에서 어트리뷰트를 읽고, 쓰고, 삭제하는 것입니다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">a.x</span></code> 는 <code class="docutils literal notranslate"><span class="pre">a.__dict__['x']</span></code> 에서 시작해서 <code class="docutils literal notranslate"><span class="pre">type(a).__dict__['x']</span></code> 를 거쳐 <code class="docutils literal notranslate"><span class="pre">type(a)</span></code> 의 메타 클래스를 제외한 베이스 클래스들을 거쳐 가는 일련의 조회로 구성됩니다.</p>
<p>그러나, 만약 조회한 값이 디스크립터 메서드를 구현한 객체면, 파이썬은 기본 동작 대신에 디스크립터 메서드를 호출할 수 있습니다. 우선순위 목록의 어느 위치에서 이런 일이 일어나는지는 어떤 디스크립터 메서드가 정의되어 있고 어떤 식으로 호출되는지에 따라 다릅니다.</p>
<p>디스크립터 호출의 시작점은 결합(binding)입니다, <code class="docutils literal notranslate"><span class="pre">a.x</span></code>. 어떻게 인자들이 조합되는지는 <code class="docutils literal notranslate"><span class="pre">a</span></code> 에 따라 다릅니다:</p>
<dl class="simple">
<dt>직접 호출</dt><dd><p>가장 간단하면서도 가장 덜 사용되는 호출은 사용자의 코드가 디스크립터 메서드를 직접 호출할 때입니다: <code class="docutils literal notranslate"><span class="pre">x.__get__(a)</span></code></p>
</dd>
<dt>인스턴스 결합</dt><dd><p>객체 인스턴스에 결합하면, <code class="docutils literal notranslate"><span class="pre">a.x</span></code> 는 이런 호출로 변환됩니다: <code class="docutils literal notranslate"><span class="pre">type(a).__dict__['x'].__get__(a,</span> <span class="pre">type(a))</span></code>.</p>
</dd>
<dt>클래스 결합</dt><dd><p>클래스에 결합하면, <code class="docutils literal notranslate"><span class="pre">A.x</span></code> 는 이런 호출로 변환됩니다: <code class="docutils literal notranslate"><span class="pre">A.__dict__['x'].__get__(None,</span> <span class="pre">A)</span></code>.</p>
</dd>
<dt>Super 결합</dt><dd><p>A dotted lookup such as <code class="docutils literal notranslate"><span class="pre">super(A,</span> <span class="pre">a).x</span></code> searches
<code class="docutils literal notranslate"><span class="pre">a.__class__.__mro__</span></code> for a base class <code class="docutils literal notranslate"><span class="pre">B</span></code> following <code class="docutils literal notranslate"><span class="pre">A</span></code> and then
returns <code class="docutils literal notranslate"><span class="pre">B.__dict__['x'].__get__(a,</span> <span class="pre">A)</span></code>.  If not a descriptor, <code class="docutils literal notranslate"><span class="pre">x</span></code> is
returned unchanged.</p>
</dd>
</dl>
<p>For instance bindings, the precedence of descriptor invocation depends on
which descriptor methods are defined.  A descriptor can define any combination
of <a class="reference internal" href="datamodel.html#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="datamodel.html#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> and
<a class="reference internal" href="datamodel.html#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>.  If it does not
define <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code>, then accessing the attribute will return the descriptor
object itself unless there is a value in the object’s instance dictionary.  If
the descriptor defines <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code> and/or <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code>, it is a data
descriptor; if it defines neither, it is a non-data descriptor.  Normally, data
descriptors define both <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code>, while non-data
descriptors have just the <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> method.  Data descriptors with
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code> (and/or <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code>) defined
always override a redefinition in an
instance dictionary.  In contrast, non-data descriptors can be overridden by
instances.</p>
<p>Python methods (including those decorated with
<a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code></a> and <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;classmethod</span></code></a>) are
implemented as non-data descriptors.  Accordingly, instances can redefine and
override methods.  This allows individual instances to acquire behaviors that
differ from other instances of the same class.</p>
<p><a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> 함수는 데이터 디스크립터로 구현됩니다. 이 때문에, 인스턴스는 프로퍼티(property)의 동작을 변경할 수 없습니다.</p>
</section>
<section id="slots">
<span id="id11"></span><h4><span class="section-number">3.3.2.4. </span>__slots__<a class="headerlink" href="datamodel.html#slots" title="Link to this heading">¶</a></h4>
<p><em>__slots__</em> allow us to explicitly declare data members (like
properties) and deny the creation of <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> and <em>__weakref__</em>
(unless explicitly declared in <em>__slots__</em> or available in a parent.)</p>
<p>The space saved over using <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> can be significant.
Attribute lookup speed can be significantly improved as well.</p>
<dl class="py data">
<dt class="sig sig-object py" id="object.__slots__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__slots__</span></span><a class="headerlink" href="datamodel.html#object.__slots__" title="Link to this definition">¶</a></dt>
<dd><p>This class variable can be assigned a string, iterable, or sequence of
strings with variable names used by instances.  <em>__slots__</em> reserves space
for the declared variables and prevents the automatic creation of
<a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>
and <em>__weakref__</em> for each instance.</p>
</dd></dl>

<p id="datamodel-note-slots">Notes on using <em>__slots__</em>:</p>
<ul class="simple">
<li><p>When inheriting from a class without <em>__slots__</em>, the
<a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> and
<em>__weakref__</em> attribute of the instances will always be accessible.</p></li>
<li><p>Without a <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> variable, instances cannot be assigned new
variables not
listed in the <em>__slots__</em> definition.  Attempts to assign to an unlisted
variable name raises <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. If dynamic assignment of new
variables is desired, then add <code class="docutils literal notranslate"><span class="pre">'__dict__'</span></code> to the sequence of strings in
the <em>__slots__</em> declaration.</p></li>
<li><p>Without a <em>__weakref__</em> variable for each instance, classes defining
<em>__slots__</em> do not support <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weak</span> <span class="pre">references</span></code></a> to its instances.
If weak reference
support is needed, then add <code class="docutils literal notranslate"><span class="pre">'__weakref__'</span></code> to the sequence of strings in the
<em>__slots__</em> declaration.</p></li>
<li><p><em>__slots__</em> are implemented at the class level by creating <a class="reference internal" href="datamodel.html#descriptors"><span class="std std-ref">descriptors</span></a>
for each variable name.  As a result, class attributes
cannot be used to set default values for instance variables defined by
<em>__slots__</em>; otherwise, the class attribute would overwrite the descriptor
assignment.</p></li>
<li><p>The action of a <em>__slots__</em> declaration is not limited to the class
where it is defined.  <em>__slots__</em> declared in parents are available in
child classes. However, child subclasses will get a <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> and
<em>__weakref__</em> unless they also define <em>__slots__</em> (which should only
contain names of any <em>additional</em> slots).</p></li>
<li><p>클래스가 베이스 클래스의 <em>__slots__</em> 에 정의된 이름과 같은 이름의 변수를 <em>__slots__</em> 에 선언한다면, 베이스 클래스가 정의한 변수는 액세스할 수 없는 상태가 됩니다(베이스 클래스로부터 디스크립터를 직접 조회하는 경우는 예외다). 이것은 프로그램을 정의되지 않은 상태로 보내게 됩니다. 미래에는, 이를 방지하기 위한 검사가 추가될 것입니다.</p></li>
<li><p><a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> will be raised if nonempty <em>__slots__</em> are defined for a
class derived from a
<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">&quot;variable-length&quot;</span> <span class="pre">built-in</span> <span class="pre">type</span></code></a> such as
<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, and <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>.</p></li>
<li><p>Any non-string <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> may be assigned to <em>__slots__</em>.</p></li>
<li><p>If a <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a> is used to assign <em>__slots__</em>, the dictionary
keys will be used as the slot names. The values of the dictionary can be used
to provide per-attribute docstrings that will be recognised by
<a class="reference internal" href="../library/inspect.html#inspect.getdoc" title="inspect.getdoc"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getdoc()</span></code></a> and displayed in the output of <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="../library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> assignment works only if both classes have the
same <em>__slots__</em>.</p></li>
<li><p><a class="reference internal" href="../tutorial/classes.html#tut-multiple"><span class="std std-ref">Multiple inheritance</span></a> with multiple slotted parent
classes can be used,
but only one parent is allowed to have attributes created by slots
(the other bases must have empty slot layouts) - violations raise
<a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p></li>
<li><p>If an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> is used for <em>__slots__</em> then a <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a> is
created for each
of the iterator’s values. However, the <em>__slots__</em> attribute will be an empty
iterator.</p></li>
</ul>
</section>
</section>
<section id="customizing-class-creation">
<span id="class-customization"></span><h3><span class="section-number">3.3.3. </span>클래스 생성 커스터마이제이션<a class="headerlink" href="datamodel.html#customizing-class-creation" title="Link to this heading">¶</a></h3>
<p>Whenever a class inherits from another class, <a class="reference internal" href="datamodel.html#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> is
called on the parent class. This way, it is possible to write classes which
change the behavior of subclasses. This is closely related to class
decorators, but where class decorators only affect the specific class they’re
applied to, <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> solely applies to future subclasses of the
class defining the method.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__init_subclass__">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__init_subclass__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__init_subclass__" title="Link to this definition">¶</a></dt>
<dd><p>이 메서드는 포함하는 클래스의 서브 클래스가 만들어질 때마다 호출됩니다. <em>cls</em> 는 새 서브 클래스입니다. 만약 일반적인 인스턴스 메서드로 정의되면, 이 메서드는 묵시적으로 클래스 메서드로 변경됩니다.</p>
<p>Keyword arguments which are given to a new class are passed to
the parent class’s <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>. For compatibility with
other classes using <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>, one should take out the
needed keyword arguments and pass the others over to the base
class, as in:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Philosopher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">default_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">default_name</span> <span class="o">=</span> <span class="n">default_name</span>

<span class="k">class</span> <span class="nc">AustralianPhilosopher</span><span class="p">(</span><span class="n">Philosopher</span><span class="p">,</span> <span class="n">default_name</span><span class="o">=</span><span class="s2">&quot;Bruce&quot;</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>기본 구현 <code class="docutils literal notranslate"><span class="pre">object.__init_subclass__</span></code> 는 아무 일도 하지 않지만, 인자가 포함되어 호출되면 예외를 발생시킵니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>메타 클래스 힌트 <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> 는 나머지 형 절차에 의해 소비되고, <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> 로 전달되지 않습니다. 실제 메타 클래스 (명시적인 힌트 대신에) 는 <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code> 로 액세스할 수 있습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<p>When a class is created, <code class="xref py py-meth docutils literal notranslate"><span class="pre">type.__new__()</span></code> scans the class variables
and makes callbacks to those with a <a class="reference internal" href="datamodel.html#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> hook.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__set_name__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__set_name__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">owner</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__set_name__" title="Link to this definition">¶</a></dt>
<dd><p>Automatically called at the time the owning class <em>owner</em> is
created. The object has been assigned to <em>name</em> in that class:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>  <span class="c1"># Automatically calls: x.__set_name__(A, &#39;x&#39;)</span>
</pre></div>
</div>
<p>If the class variable is assigned after the class is created,
<a class="reference internal" href="datamodel.html#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> will not be called automatically.
If needed, <a class="reference internal" href="datamodel.html#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> can be called directly:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
   <span class="k">pass</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">A</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">c</span>                  <span class="c1"># The hook is not called</span>
<span class="n">c</span><span class="o">.</span><span class="n">__set_name__</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>   <span class="c1"># Manually invoke the hook</span>
</pre></div>
</div>
<p>더 자세한 내용은 <a class="reference internal" href="datamodel.html#class-object-creation"><span class="std std-ref">클래스 객체 만들기</span></a> 을 참고하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<section id="metaclasses">
<span id="id12"></span><h4><span class="section-number">3.3.3.1. </span>메타 클래스<a class="headerlink" href="datamodel.html#metaclasses" title="Link to this heading">¶</a></h4>
<p id="index-86">기본적으로, 클래스는 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 을 사용해서 만들어집니다. 클래스의 바디는 새 이름 공간에서 실행되고, 클래스 이름은 <code class="docutils literal notranslate"><span class="pre">type(name,</span> <span class="pre">bases,</span> <span class="pre">namespace)</span></code> 의 결과에 지역적으로 연결됩니다.</p>
<p>클래스를 만드는 과정은 클래스 정의 줄에 <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> 키워드 인자를 전달하거나, 그런 인자를 포함한 이미 존재하는 클래스를 계승함으로써 커스터마이즈될 수 있습니다. 다음 예에서, <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> 와 <code class="docutils literal notranslate"><span class="pre">MySubclass</span></code> 는 모두 <code class="docutils literal notranslate"><span class="pre">Meta</span></code> 의 인스턴스입니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MySubclass</span><span class="p">(</span><span class="n">MyClass</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>클래스 정의에서 지정된 다른 키워드 인자들은 아래에서 설명되는 모든 메타 클래스 연산들로 전달됩니다.</p>
<p>클래스 정의가 실행될 때, 다음과 같은 단계가 수행됩니다.:</p>
<ul class="simple">
<li><p>MRO 항목이 결정됩니다;</p></li>
<li><p>적절한 메타 클래스가 결정됩니다;</p></li>
<li><p>클래스 이름 공간이 준비됩니다;</p></li>
<li><p>클래스 바디가 실행됩니다;</p></li>
<li><p>클래스 객체가 만들어집니다.</p></li>
</ul>
</section>
<section id="resolving-mro-entries">
<h4><span class="section-number">3.3.3.2. </span>MRO 항목 결정하기<a class="headerlink" href="datamodel.html#resolving-mro-entries" title="Link to this heading">¶</a></h4>
<dl class="py method">
<dt class="sig sig-object py" id="object.__mro_entries__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__mro_entries__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__mro_entries__" title="Link to this definition">¶</a></dt>
<dd><p>If a base that appears in a class definition is not an instance of
<a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>, then an <code class="xref py py-meth docutils literal notranslate"><span class="pre">__mro_entries__()</span></code> method is searched on the base.
If an <code class="xref py py-meth docutils literal notranslate"><span class="pre">__mro_entries__()</span></code> method is found, the base is substituted with the
result of a call to <code class="xref py py-meth docutils literal notranslate"><span class="pre">__mro_entries__()</span></code> when creating the class.
The method is called with the original bases tuple
passed to the <em>bases</em> parameter, and must return a tuple
of classes that will be used instead of the base. The returned tuple may be
empty: in these cases, the original base is ignored.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><a class="reference internal" href="../library/types.html#types.resolve_bases" title="types.resolve_bases"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.resolve_bases()</span></code></a></dt><dd><p>Dynamically resolve bases that are not instances of <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
</dd>
<dt><a class="reference internal" href="../library/types.html#types.get_original_bases" title="types.get_original_bases"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.get_original_bases()</span></code></a></dt><dd><p>Retrieve a class’s “original bases” prior to modifications by
<a class="reference internal" href="datamodel.html#object.__mro_entries__" title="object.__mro_entries__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mro_entries__()</span></code></a>.</p>
</dd>
<dt><span class="target" id="index-87"></span><a class="pep reference external" href="https://peps.python.org/pep-0560/"><strong>PEP 560</strong></a></dt><dd><p>Core support for typing module and generic types.</p>
</dd>
</dl>
</div>
</section>
<section id="determining-the-appropriate-metaclass">
<h4><span class="section-number">3.3.3.3. </span>적절한 메타 클래스 선택하기<a class="headerlink" href="datamodel.html#determining-the-appropriate-metaclass" title="Link to this heading">¶</a></h4>
<p id="index-88">클래스 정의의 적절한 메타 클래스는 다음과 같이 결정됩니다:</p>
<ul class="simple">
<li><p>베이스와 명시적인 메타 클래스를 주지 않는 경우 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 이 사용됩니다;</p></li>
<li><p>명시적인 메타 클래스가 지정되고, 그것이 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 의 인스턴스가 <em>아니면</em>, 그것을 메타 클래스로 사용합니다;</p></li>
<li><p><a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 의 인스턴스가 명시적인 메타 클래스로 주어지거나, 베이스가 정의되었으면, 가장 많이 파생된 메타 클래스가 사용됩니다.</p></li>
</ul>
<p>가장 많이 파생된 메타 클래스는 명시적으로 지정된 메타 클래스(있다면)와 지정된 모든 베이스 클래스들의 메타 클래스들(즉, <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code>) 중에서 선택됩니다. 가장 많이 파생된 메타 클래스는 이들 <em>모두</em> 의 서브 타입(subtype)입니다. 만약 어느 것도 이 조건을 만족하지 못한다면, 클래스 정의는 <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> 를 발생시키며 실패합니다.</p>
</section>
<section id="preparing-the-class-namespace">
<span id="prepare"></span><h4><span class="section-number">3.3.3.4. </span>클래스 이름 공간 준비하기<a class="headerlink" href="datamodel.html#preparing-the-class-namespace" title="Link to this heading">¶</a></h4>
<p id="index-89">Once the appropriate metaclass has been identified, then the class namespace
is prepared. If the metaclass has a <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> attribute, it is called
as <code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">=</span> <span class="pre">metaclass.__prepare__(name,</span> <span class="pre">bases,</span> <span class="pre">**kwds)</span></code> (where the
additional keyword arguments, if any, come from the class definition). The
<code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> method should be implemented as a
<a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod</span></code></a>. The
namespace returned by <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> is passed in to <code class="docutils literal notranslate"><span class="pre">__new__</span></code>, but when
the final class object is created the namespace is copied into a new <code class="docutils literal notranslate"><span class="pre">dict</span></code>.</p>
<p>만약 메타 클래스에 <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> 어트리뷰트가 없다면, 클래스 이름 공간은 빈 순서 있는 매핑으로 초기화됩니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-123"></span><a class="pep reference external" href="https://peps.python.org/pep-3115/"><strong>PEP 3115</strong></a> - 파이썬 3000 에서의 메타 클래스</dt><dd><p><code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> 이름 공간 훅을 도입했습니다</p>
</dd>
</dl>
</div>
</section>
<section id="executing-the-class-body">
<h4><span class="section-number">3.3.3.5. </span>클래스 바디 실행하기<a class="headerlink" href="datamodel.html#executing-the-class-body" title="Link to this heading">¶</a></h4>
<p id="index-91">클래스 바디는 (대략) <code class="docutils literal notranslate"><span class="pre">exec(body,</span> <span class="pre">globals(),</span> <span class="pre">namespace)</span></code> 과같이 실행됩니다. 일반적인 <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 호출과 주된 차이점은 클래스 정의가 함수 내부에서 이루어질 때 어휘 스코핑(lexical scoping) 이 클래스 바디(모든 메서드들을 포함해서)로 하여금 현재와 외부 스코프에 있는 이름들을 참조하도록 허락한다는 것입니다.</p>
<p>하지만, 클래스 정의가 함수 내부에서 이루어질 때조차도, 클래스 내부에서 정의된 메서드들은 클래스 스코프에서 정의된 이름들을 볼 수 없습니다. 클래스 변수는 인스턴스나 클래스 메서드의 첫 번째 매개변수를 통해 액세스하거나 다음 섹션에서 설명하는 묵시적으로 어휘 스코핑된 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 참조를 통해야 합니다.</p>
</section>
<section id="creating-the-class-object">
<span id="class-object-creation"></span><h4><span class="section-number">3.3.3.6. </span>클래스 객체 만들기<a class="headerlink" href="datamodel.html#creating-the-class-object" title="Link to this heading">¶</a></h4>
<p id="index-92">일단 클래스 이름 공간이 클래스 바디를 실행함으로써 채워지면, 클래스 객체가 <code class="docutils literal notranslate"><span class="pre">metaclass(name,</span> <span class="pre">bases,</span> <span class="pre">namespace,</span> <span class="pre">**kwds)</span></code> 을 통해 만들어집니다(여기에서 전달되는 추가적인 키워드 인자들은 <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> 에 전달된 것들과 같습니다).</p>
<p>이 클래스 객체는 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 에 인자를 주지 않는 경우 참조되는 것입니다. <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 는 클래스 바디의 메서드들 중 어느 하나라도 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 나 <code class="docutils literal notranslate"><span class="pre">super</span></code> 를 참조할 경우 컴파일러에 의해 만들어지는 묵시적인 클로저(closure) 참조입니다. 이것은 인자 없는 형태의 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 가 어휘 스코핑 기반으로 현재 정의되고 있는 클래스를 올바르게 찾을 수 있도록 합니다. 반면에 현재의 호출에 사용된 클래스나 인스턴스는 메서드로 전달된 첫 번째 인자에 기초해서 식별됩니다.</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> CPython 3.6 이상에서, <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 셀(cell)은 클래스 이름 공간의 <code class="docutils literal notranslate"><span class="pre">__classcell__</span></code> 엔트리로 메타 클래스에 전달됩니다. 만약 존재한다면, 이것은 클래스가 올바르게 초기화되기 위해 <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> 호출까지 거슬러서 전파되어야 합니다. 이렇게 하지 못하면 파이썬 3.8 에서는 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>로 이어질 것입니다.</p>
</div>
<p>When using the default metaclass <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>, or any metaclass that ultimately
calls <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code>, the following additional customization steps are
invoked after creating the class object:</p>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> method collects all of the attributes in the class
namespace that define a <a class="reference internal" href="datamodel.html#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> method;</p></li>
<li><p>Those <code class="docutils literal notranslate"><span class="pre">__set_name__</span></code> methods are called with the class
being defined and the assigned name of that particular attribute;</p></li>
<li><p>The <a class="reference internal" href="datamodel.html#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> hook is called on the
immediate parent of the new class in its method resolution order.</p></li>
</ol>
<p>클래스 객체가 만들어진 후에, 클래스 정의에 포함된 클래스 데코레이터들에게 (있다면) 클래스를 전달하고, 그 결과를 클래스가 정의되는 지역 이름 공간에 연결합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> 로 새 클래스가 만들어질 때, 이름 공간 매개변수로 제공되는 객체는 새로 만든 순서 있는 매핑으로 복사되고, 원래의 객체는 버립니다. 새 사본은 읽기 전용 프락시(read-only proxy)로 둘러싸이는데, 이것이 클래스 객체의 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 어트리뷰트가 됩니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-124"></span><a class="pep reference external" href="https://peps.python.org/pep-3135/"><strong>PEP 3135</strong></a> - 새 super</dt><dd><p>묵시적인 __class__ 클로저 참조를 설명합니다</p>
</dd>
</dl>
</div>
</section>
<section id="uses-for-metaclasses">
<h4><span class="section-number">3.3.3.7. </span>메타 클래스의 용도<a class="headerlink" href="datamodel.html#uses-for-metaclasses" title="Link to this heading">¶</a></h4>
<p>메타 클래스의 잠재적인 용도에는 한계가 없습니다. 탐색 된 몇 가지 아이디어들에는 enum, 로깅, 인터페이스 검사, 자동화된 위임(automatic delegation), 자동화된 프로퍼티(properety) 생성, 프락시(proxy), 프레임웍(framework), 자동화된 자원 로킹/동기화(automatic resource locking/synchronization) 등이 있습니다.</p>
</section>
</section>
<section id="customizing-instance-and-subclass-checks">
<h3><span class="section-number">3.3.4. </span>인스턴스 및 서브 클래스 검사 커스터마이제이션<a class="headerlink" href="datamodel.html#customizing-instance-and-subclass-checks" title="Link to this heading">¶</a></h3>
<p>다음 메서드들은 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 와 <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 내장 함수들의 기본 동작을 재정의하는 데 사용됩니다.</p>
<p>특히, 메타 클래스 <a class="reference internal" href="../library/abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABCMeta</span></code></a> 는 추상 베이스 클래스(Abstract Base Class, ABC)를 다른 ABC를 포함한 임의의 클래스나 형(내장형을 포함합니다)에 “가상 베이스 클래스(virtual base class)”로 추가할 수 있게 하려고 이 메서드들을 구현합니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="class.__instancecheck__">
<span class="sig-prename descclassname"><span class="pre">class.</span></span><span class="sig-name descname"><span class="pre">__instancecheck__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#class.__instancecheck__" title="Link to this definition">¶</a></dt>
<dd><p><em>instance</em> 가 (직접적이거나 간접적으로) <em>class</em> 의 인스턴스로 취급될 수 있으면 참을 돌려줍니다. 만약 정의되면, <code class="docutils literal notranslate"><span class="pre">isinstance(instance,</span> <span class="pre">class)</span></code> 를 구현하기 위해 호출됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="class.__subclasscheck__">
<span class="sig-prename descclassname"><span class="pre">class.</span></span><span class="sig-name descname"><span class="pre">__subclasscheck__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subclass</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#class.__subclasscheck__" title="Link to this definition">¶</a></dt>
<dd><p><em>subclass</em> 가 (직접적이거나 간접적으로) <em>class</em> 의 서브 클래스로 취급될 수 있으면 참을 돌려줍니다. 만약 정의되면, <code class="docutils literal notranslate"><span class="pre">issubclass(subclass,</span> <span class="pre">class)</span></code> 를 구현하기 위해 호출됩니다.</p>
</dd></dl>

<p>이 메서드들은 클래스의 형(메타 클래스)에서 조회된다는 것에 주의해야 합니다. 실제 클래스에서 클래스 메서드로 정의될 수 없습니다. 이것은 인스턴스에 대해 호출되는 특수 메서드들의 조회와 일관성 있습니다. 이 경우 인스턴스는 클래스 자체다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-125"></span><a class="pep reference external" href="https://peps.python.org/pep-3119/"><strong>PEP 3119</strong></a> - 추상 베이스 클래스의 도입</dt><dd><p><a class="reference internal" href="datamodel.html#class.__instancecheck__" title="class.__instancecheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__instancecheck__()</span></code></a> 와 <a class="reference internal" href="datamodel.html#class.__subclasscheck__" title="class.__subclasscheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__subclasscheck__()</span></code></a> 를 통해 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 와 <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 의 동작을 커스터마이징하는 데 필요한 규약을 포함하는데, 이 기능의 동기는 언어에 추상 베이스 클래스 (<a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> 모듈을 보십시오)를 추가하고자 하는 데 있습니다.</p>
</dd>
</dl>
</div>
</section>
<section id="emulating-generic-types">
<h3><span class="section-number">3.3.5. </span>제네릭 형 흉내 내기<a class="headerlink" href="datamodel.html#emulating-generic-types" title="Link to this heading">¶</a></h3>
<p>When using <a class="reference internal" href="../glossary.html#term-annotation"><span class="xref std std-term">type annotations</span></a>, it is often useful to
<em>parameterize</em> a <a class="reference internal" href="../glossary.html#term-generic-type"><span class="xref std std-term">generic type</span></a> using Python’s square-brackets notation.
For example, the annotation <code class="docutils literal notranslate"><span class="pre">list[int]</span></code> might be used to signify a
<a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> in which all the elements are of type <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-95"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> - Type Hints</dt><dd><p>Introducing Python’s framework for type annotations</p>
</dd>
<dt><a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Types</span></a></dt><dd><p>Documentation for objects representing parameterized generic classes</p>
</dd>
<dt><a class="reference internal" href="../library/typing.html#generics"><span class="std std-ref">제네릭</span></a>, <a class="reference internal" href="../library/typing.html#user-defined-generics"><span class="std std-ref">user-defined generics</span></a> and <a class="reference internal" href="../library/typing.html#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a></dt><dd><p>Documentation on how to implement generic classes that can be
parameterized at runtime and understood by static type-checkers.</p>
</dd>
</dl>
</div>
<p>A class can <em>generally</em> only be parameterized if it defines the special
class method <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__class_getitem__">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__class_getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__class_getitem__" title="Link to this definition">¶</a></dt>
<dd><p><em>key</em> 에 있는 형 인자에 의한 제네릭 클래스의 특수화를 나타내는 객체를 돌려줍니다.</p>
<p>When defined on a class, <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> is automatically a class
method. As such, there is no need for it to be decorated with
<a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;classmethod</span></code></a> when it is defined.</p>
</dd></dl>

<section id="the-purpose-of-class-getitem">
<h4><span class="section-number">3.3.5.1. </span>The purpose of <em>__class_getitem__</em><a class="headerlink" href="datamodel.html#the-purpose-of-class-getitem" title="Link to this heading">¶</a></h4>
<p>The purpose of <a class="reference internal" href="datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> is to allow runtime
parameterization of standard-library generic classes in order to more easily
apply <a class="reference internal" href="../glossary.html#term-type-hint"><span class="xref std std-term">type hints</span></a> to these classes.</p>
<p>To implement custom generic classes that can be parameterized at runtime and
understood by static type-checkers, users should either inherit from a standard
library class that already implements <a class="reference internal" href="datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>, or
inherit from <a class="reference internal" href="../library/typing.html#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a>, which has its own implementation of
<code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>.</p>
<p>Custom implementations of <a class="reference internal" href="datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> on classes defined
outside of the standard library may not be understood by third-party
type-checkers such as mypy. Using <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> on any class for
purposes other than type hinting is discouraged.</p>
</section>
<section id="class-getitem-versus-getitem">
<span id="classgetitem-versus-getitem"></span><h4><span class="section-number">3.3.5.2. </span><em>__class_getitem__</em> versus <em>__getitem__</em><a class="headerlink" href="datamodel.html#class-getitem-versus-getitem" title="Link to this heading">¶</a></h4>
<p>Usually, the <a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscription</span></a> of an object using square
brackets will call the <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> instance method defined on
the object’s class. However, if the object being subscribed is itself a class,
the class method <a class="reference internal" href="datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> may be called instead.
<code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> should return a <a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias</span></a>
object if it is properly defined.</p>
<p>Presented with the <a class="reference internal" href="../glossary.html#term-expression"><span class="xref std std-term">expression</span></a> <code class="docutils literal notranslate"><span class="pre">obj[x]</span></code>, the Python interpreter
follows something like the following process to decide whether
<a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> or <a class="reference internal" href="datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> should be
called:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">isclass</span>

<span class="k">def</span> <span class="nf">subscribe</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the result of the expression &#39;obj[x]&#39;&quot;&quot;&quot;</span>

    <span class="n">class_of_obj</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="c1"># If the class of obj defines __getitem__,</span>
    <span class="c1"># call class_of_obj.__getitem__(obj, x)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">class_of_obj</span><span class="p">,</span> <span class="s1">&#39;__getitem__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">class_of_obj</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Else, if obj is a class and defines __class_getitem__,</span>
    <span class="c1"># call obj.__class_getitem__(x)</span>
    <span class="k">elif</span> <span class="n">isclass</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__class_getitem__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">__class_getitem__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Else, raise an exception</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">class_of_obj</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; object is not subscriptable&quot;</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>In Python, all classes are themselves instances of other classes. The class of
a class is known as that class’s <a class="reference internal" href="../glossary.html#term-metaclass"><span class="xref std std-term">metaclass</span></a>, and most classes have the
<a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> class as their metaclass. <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> does not define
<a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, meaning that expressions such as <code class="docutils literal notranslate"><span class="pre">list[int]</span></code>,
<code class="docutils literal notranslate"><span class="pre">dict[str,</span> <span class="pre">float]</span></code> and <code class="docutils literal notranslate"><span class="pre">tuple[str,</span> <span class="pre">bytes]</span></code> all result in
<a class="reference internal" href="datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> being called:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># list has class &quot;type&quot; as its metaclass, like most classes:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="go">&lt;class &#39;type&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">tuple</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># &quot;list[int]&quot; calls &quot;list.__class_getitem__(int)&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="go">list[int]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># list.__class_getitem__ returns a GenericAlias object:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span>
<span class="go">&lt;class &#39;types.GenericAlias&#39;&gt;</span>
</pre></div>
</div>
<p>However, if a class has a custom metaclass that defines
<a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, subscribing the class may result in different
behaviour. An example of this can be found in the <a class="reference internal" href="../library/enum.html#module-enum" title="enum: Implementation of an enumeration class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">enum</span></code></a> module:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Menu</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="gp">... </span><span class="w">    </span><span class="sd">&quot;&quot;&quot;A breakfast menu&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="n">SPAM</span> <span class="o">=</span> <span class="s1">&#39;spam&#39;</span>
<span class="gp">... </span>    <span class="n">BACON</span> <span class="o">=</span> <span class="s1">&#39;bacon&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Enum classes have a custom metaclass:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Menu</span><span class="p">)</span>
<span class="go">&lt;class &#39;enum.EnumMeta&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># EnumMeta defines __getitem__,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># so __class_getitem__ is not called,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># and the result is not a GenericAlias object:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Menu</span><span class="p">[</span><span class="s1">&#39;SPAM&#39;</span><span class="p">]</span>
<span class="go">&lt;Menu.SPAM: &#39;spam&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Menu</span><span class="p">[</span><span class="s1">&#39;SPAM&#39;</span><span class="p">])</span>
<span class="go">&lt;enum &#39;Menu&#39;&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-96"></span><a class="pep reference external" href="https://peps.python.org/pep-0560/"><strong>PEP 560</strong></a> - Core Support for typing module and generic types</dt><dd><p>Introducing <a class="reference internal" href="datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>, and outlining when a
<a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscription</span></a> results in <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>
being called instead of <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a></p>
</dd>
</dl>
</div>
</section>
</section>
<section id="emulating-callable-objects">
<span id="id13"></span><h3><span class="section-number">3.3.6. </span>콜러블 객체 흉내 내기<a class="headerlink" href="datamodel.html#emulating-callable-objects" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="object.__call__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">args...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__call__" title="Link to this definition">¶</a></dt>
<dd><p id="index-97">인스턴스가 함수처럼 “호출될” 때 호출됩니다; 이 메서드가 정의되면, <code class="docutils literal notranslate"><span class="pre">x(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> 는 대략 <code class="docutils literal notranslate"><span class="pre">type(x).__call__(x,</span> <span class="pre">arg1,</span> <span class="pre">...)</span></code>로 번역됩니다.</p>
</dd></dl>

</section>
<section id="emulating-container-types">
<span id="sequence-types"></span><h3><span class="section-number">3.3.7. </span>컨테이너형 흉내 내기<a class="headerlink" href="datamodel.html#emulating-container-types" title="Link to this heading">¶</a></h3>
<p>The following methods can be defined to implement container objects.  Containers
usually are <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequences</span></a> (such as <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">lists</span></code></a> or
<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuples</span></code></a>) or <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mappings</span></a> (like
<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionaries</span></code></a>),
but can represent other containers as well.  The first set of methods is used
either to emulate a sequence or to emulate a mapping; the difference is that for
a sequence, the allowable keys should be the integers <em>k</em> for which <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span>
<span class="pre">N</span></code> where <em>N</em> is the length of the sequence, or <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> objects, which define a
range of items.  It is also recommended that mappings provide the methods
<code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">setdefault()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code>, and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> behaving similar to those for Python’s standard <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a>
objects.  The <a class="reference internal" href="../library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> module provides a
<a class="reference internal" href="../library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></a>
<a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a> to help create those methods from a base set of
<a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>,
<a class="reference internal" href="datamodel.html#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a>, and <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>.
Mutable sequences should provide methods <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">extend()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code>, like Python standard <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>
objects. Finally,
sequence types should implement addition (meaning concatenation) and
multiplication (meaning repetition) by defining the methods
<a class="reference internal" href="datamodel.html#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>, <a class="reference internal" href="datamodel.html#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__radd__()</span></code></a>, <a class="reference internal" href="datamodel.html#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a>,
<a class="reference internal" href="datamodel.html#object.__mul__" title="object.__mul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mul__()</span></code></a>, <a class="reference internal" href="datamodel.html#object.__rmul__" title="object.__rmul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rmul__()</span></code></a> and <a class="reference internal" href="datamodel.html#object.__imul__" title="object.__imul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__imul__()</span></code></a>
described below; they should not define other numerical
operators.  It is recommended that both mappings and sequences implement the
<a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> method to allow efficient use of the <code class="docutils literal notranslate"><span class="pre">in</span></code>
operator; for
mappings, <code class="docutils literal notranslate"><span class="pre">in</span></code> should search the mapping’s keys; for sequences, it should
search through the values.  It is further recommended that both mappings and
sequences implement the <a class="reference internal" href="datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method to allow efficient iteration
through the container; for mappings, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> should iterate
through the object’s keys; for sequences, it should iterate through the values.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__len__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__len__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__len__" title="Link to this definition">¶</a></dt>
<dd><p id="index-98">Called to implement the built-in function <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>.  Should return the length
of the object, an integer <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0.  Also, an object that doesn’t define a
<a class="reference internal" href="datamodel.html#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> method and whose <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code> method returns zero is
considered to be false in a Boolean context.</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> In CPython, the length is required to be at most <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a>.
If the length is larger than <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxsize</span></code> some features (such as
<a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>) may raise <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>.  To prevent raising
<code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code> by truth value testing, an object must define a
<a class="reference internal" href="datamodel.html#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> method.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__length_hint__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__length_hint__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__length_hint__" title="Link to this definition">¶</a></dt>
<dd><p>Called to implement <a class="reference internal" href="../library/operator.html#operator.length_hint" title="operator.length_hint"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.length_hint()</span></code></a>. Should return an estimated
length for the object (which may be greater or less than the actual length).
The length must be an integer <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0. The return value may also be
<a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>, which is treated the same as if the
<code class="docutils literal notranslate"><span class="pre">__length_hint__</span></code> method didn’t exist at all. This method is purely an
optimization and is never required for correctness.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<div class="admonition note" id="index-99">
<p class="admonition-title">참고</p>
<p>슬라이싱은 전적으로 다음에 나오는 세 메서드들에의해 수행됩니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p>과 같은 호출은</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p>로 번역되고, 다른 형태도 마찬가지입니다. 빠진 슬라이스 항목은 항상 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 채워집니다.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="object.__getitem__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__getitem__" title="Link to this definition">¶</a></dt>
<dd><p>Called to implement evaluation of <code class="docutils literal notranslate"><span class="pre">self[key]</span></code>. For <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequence</span></a> types,
the accepted keys should be integers. Optionally, they may support
<a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> objects as well.  Negative index support is also optional.
If <em>key</em> is
of an inappropriate type, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> may be raised; if <em>key</em> is a value
outside the set of indexes for the sequence (after any special
interpretation of negative values), <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> should be raised. For
<a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a> types, if <em>key</em> is missing (not in the container),
<a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> should be raised.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 루프는 시퀀스의 끝을 올바로 감지하기 위해, 잘못된 인덱스에 대해 <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 가 일어날 것으로 기대하고 있습니다.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>When <a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscripting</span></a> a <em>class</em>, the special
class method <a class="reference internal" href="datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> may be called instead of
<code class="docutils literal notranslate"><span class="pre">__getitem__()</span></code>. See <a class="reference internal" href="datamodel.html#classgetitem-versus-getitem"><span class="std std-ref">__class_getitem__ versus __getitem__</span></a> for more
details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__setitem__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__setitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__setitem__" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self[key]</span></code> 로의 대입을 구현하기 위해 호출됩니다. <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 과 같은 주의가 필요합니다. 매핑의 경우에는, 객체가 키에 대해 값의 변경이나 새 키의 추가를 허락할 경우, 시퀀스의 경우는 항목이 교체될 수 있을 때만 구현되어야 합니다. 잘못된 <em>key</em> 값의 경우는 <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 에서와 같은 예외를 일으켜야 합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__delitem__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__delitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__delitem__" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self[key]</span></code> 의 삭제를 구현하기 위해 호출됩니다. <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 과 같은 주의가 필요합니다. 매핑의 경우에는, 객체가 키의 삭제를 허락할 경우, 시퀀스의 경우는 항목이 시퀀스로부터 제거될 수 있을 때만 구현되어야 합니다. 잘못된 <em>key</em> 값의 경우는 <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 에서와 같은 예외를 일으켜야 합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__missing__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__missing__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__missing__" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.<a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 이 dict 서브 클래스에서 키가 딕셔너리에 없으면 <code class="docutils literal notranslate"><span class="pre">self[key]</span></code> 를 구현하기 위해 호출합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__iter__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__iter__" title="Link to this definition">¶</a></dt>
<dd><p>This method is called when an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> is required for a container.
This method should return a new iterator object that can iterate over all the
objects in the container.  For mappings, it should iterate over the keys of
the container.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__reversed__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__reversed__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__reversed__" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 내장 함수가 역 이터레이션(reverse iteration)을 구현하기 위해 (있다면) 호출합니다. 컨테이너에 있는 객체들을 역 순으로 탐색하는 새 이터레이터 객체를 돌려줘야 합니다.</p>
<p><a class="reference internal" href="datamodel.html#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> 메서드가 제공되지 않으면, <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 내장함수는 시퀀스 프로토콜(<a class="reference internal" href="datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 과 <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>)을 대안으로 사용합니다. 시퀀스 프로토콜을 지원하는 객체들은 <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 가 제공하는 것보다 더 효율적인 구현을 제공할 수 있을 때만 <a class="reference internal" href="datamodel.html#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> 를 제공해야 합니다.</p>
</dd></dl>

<p>멤버십 검사 연산자들(<a class="reference internal" href="expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 과 <a class="reference internal" href="expressions.html#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>) 은 보통 컨테이너에 대한 이터레이션으로 구현됩니다. 하지만, 컨테이너 객체는 더 효율적인 구현을 다음과 같은 특수 메서드를 통해 제공할 수 있습니다. 이 경우 객체는 이터러블일 필요도 없습니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__contains__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__contains__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__contains__" title="Link to this definition">¶</a></dt>
<dd><p>멤버십 검사 연산자를 구현하기 위해 호출됩니다. <em>item</em> 이 <em>self</em> 에 있으면 참을, 그렇지 않으면 거짓을 돌려줘야 합니다. 매핑 객체의 경우, 키-값 쌍이 아니라 매핑의 키가 고려되어야 합니다.</p>
<p><a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> 를 정의하지 않는 객체의 경우, 멤버십 검사는 먼저 <a class="reference internal" href="datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 를 통한 이터레이션을 시도한 후, <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 을 통한 낡은 시퀀스 이터레이션 프로토콜을 시도합니다. <a class="reference internal" href="expressions.html#membership-test-details"><span class="std std-ref">언어 레퍼런스의 이 절</span></a>을 참고하십시오.</p>
</dd></dl>

</section>
<section id="emulating-numeric-types">
<span id="numeric-types"></span><h3><span class="section-number">3.3.8. </span>숫자 형 흉내 내기<a class="headerlink" href="datamodel.html#emulating-numeric-types" title="Link to this heading">¶</a></h3>
<p>숫자 형을 흉내 내기 위해 다음과 같은 메서드들을 정의할 수 있습니다. 구현되는 특별한 종류의 숫자에 의해 지원되지 않는 연산들(예를 들어, 정수가 아닌 숫자들에 대한 비트 연산들)에 대응하는 메서드들을 정의되지 않은 채로 남겨두어야 합니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__add__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__add__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__sub__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__sub__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__mul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__mul__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__matmul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__matmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__matmul__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__truediv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__truediv__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__floordiv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__floordiv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__floordiv__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__mod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__mod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__mod__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__divmod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__divmod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__divmod__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__pow__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__pow__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__pow__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__lshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__lshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__lshift__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__rshift__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__and__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__and__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__xor__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__xor__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__xor__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__or__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__or__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__or__" title="Link to this definition">¶</a></dt>
<dd><p id="index-100">These methods are called to implement the binary arithmetic operations
(<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>,
<a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>).  For instance, to
evaluate the expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>, where <em>x</em> is an instance of a class that
has an <a class="reference internal" href="datamodel.html#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> method, <code class="docutils literal notranslate"><span class="pre">type(x).__add__(x,</span> <span class="pre">y)</span></code> is called.  The
<a class="reference internal" href="datamodel.html#object.__divmod__" title="object.__divmod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__divmod__()</span></code></a> method should be the equivalent to using
<a class="reference internal" href="datamodel.html#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code></a> and <a class="reference internal" href="datamodel.html#object.__mod__" title="object.__mod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mod__()</span></code></a>; it should not be related to
<a class="reference internal" href="datamodel.html#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a>.  Note that <a class="reference internal" href="datamodel.html#object.__pow__" title="object.__pow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pow__()</span></code></a> should be defined to accept
an optional third argument if the ternary version of the built-in <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>
function is to be supported.</p>
<p>If one of those methods does not support the operation with the supplied
arguments, it should return <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__radd__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__radd__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rsub__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__rsub__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rmul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__rmul__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rmatmul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rmatmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__rmatmul__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rtruediv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rtruediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__rtruediv__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rfloordiv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rfloordiv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__rfloordiv__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rmod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rmod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__rmod__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rdivmod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rdivmod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__rdivmod__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rpow__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rpow__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__rpow__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rlshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rlshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__rlshift__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rrshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rrshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__rrshift__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rand__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__rand__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rxor__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rxor__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__rxor__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ror__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ror__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__ror__" title="Link to this definition">¶</a></dt>
<dd><p id="index-101">These methods are called to implement the binary arithmetic operations
(<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>,
<a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>) with reflected
(swapped) operands.  These functions are only called if the left operand does
not support the corresponding operation <a class="footnote-reference brackets" href="datamodel.html#id19" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> and the operands are of different
types. <a class="footnote-reference brackets" href="datamodel.html#id20" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> For instance, to evaluate the expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code>, where <em>y</em> is
an instance of a class that has an <a class="reference internal" href="datamodel.html#object.__rsub__" title="object.__rsub__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rsub__()</span></code></a> method,
<code class="docutils literal notranslate"><span class="pre">type(y).__rsub__(y,</span> <span class="pre">x)</span></code> is called if <code class="docutils literal notranslate"><span class="pre">type(x).__sub__(x,</span> <span class="pre">y)</span></code> returns
<a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>.</p>
<p id="index-102">삼 항 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> 는 <a class="reference internal" href="datamodel.html#object.__rpow__" title="object.__rpow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rpow__()</span></code></a> 를 호출하려고 시도하지 않음에 주의해야 합니다 (그렇게 하려면 코어션 규칙이 너무 복잡해집니다).</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>만약 오른쪽 피연산자의 형이 왼쪽 피연산자의 형의 서브 클래스이고, 그 서브 클래스가 연산의 뒤집힌 메서드의 다른 구현을 제공하면, 이 메서드가 왼쪽 연산자의 뒤집히지 않은 메서드보다 먼저 호출됩니다. 이 동작은 서브 클래스가 조상들의 연산을 재정의할 수 있도록 합니다.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__iadd__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__iadd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__iadd__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__isub__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__isub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__isub__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__imul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__imul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__imul__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__imatmul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__imatmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__imatmul__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__itruediv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__itruediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__itruediv__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ifloordiv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ifloordiv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__ifloordiv__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__imod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__imod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__imod__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ipow__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ipow__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__ipow__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ilshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ilshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__ilshift__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__irshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__irshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__irshift__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__iand__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__iand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__iand__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ixor__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ixor__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__ixor__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ior__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ior__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__ior__" title="Link to this definition">¶</a></dt>
<dd><p>These methods are called to implement the augmented arithmetic assignments
(<code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;=</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">//=</span></code>, <code class="docutils literal notranslate"><span class="pre">%=</span></code>, <code class="docutils literal notranslate"><span class="pre">**=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>,
<code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>, <code class="docutils literal notranslate"><span class="pre">^=</span></code>, <code class="docutils literal notranslate"><span class="pre">|=</span></code>).  These methods should attempt to do the
operation in-place (modifying <em>self</em>) and return the result (which could be,
but does not have to be, <em>self</em>).  If a specific method is not defined, or if
that method returns <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>, the
augmented assignment falls back to the normal methods.  For instance, if <em>x</em>
is an instance of a class with an <a class="reference internal" href="datamodel.html#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a> method, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">y</span></code> is
equivalent to <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x.__iadd__(y)</span></code> . If <a class="reference internal" href="datamodel.html#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a> does not exist, or if <code class="docutils literal notranslate"><span class="pre">x.__iadd__(y)</span></code>
returns <code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code>, <code class="docutils literal notranslate"><span class="pre">x.__add__(y)</span></code> and
<code class="docutils literal notranslate"><span class="pre">y.__radd__(x)</span></code> are considered, as with the evaluation of <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>. In
certain situations, augmented assignment can result in unexpected errors (see
<a class="reference internal" href="../faq/programming.html#faq-augmented-assignment-tuple-error"><span class="std std-ref">덧셈은 작동하는데, 왜 a_tuple[i] += [‘item’]이 예외를 일으킵니까?</span></a>), but this behavior is in fact
part of the data model.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__neg__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__neg__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__pos__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__pos__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__abs__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__abs__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__abs__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__invert__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__invert__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__invert__" title="Link to this definition">¶</a></dt>
<dd><p id="index-103">일 항 산술 연산(<code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">~</span></code>)을 구현하기 위해 호출됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__complex__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__complex__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__complex__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__int__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__int__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__int__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__float__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__float__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__float__" title="Link to this definition">¶</a></dt>
<dd><p id="index-104">내장 함수 <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a>를 구현하기 위해 호출됩니다. 적절한 형의 값을 돌려줘야 합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__index__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__index__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__index__" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../library/operator.html#operator.index" title="operator.index"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.index()</span></code></a> 를 구현하기 위해 호출되고, 파이썬이 숫자 객체를 정수 객체로 손실 없이 변환해야 할 때(슬라이싱이나 내장 <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a>, <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a>, <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a> 함수들에서와같이)마다 호출됩니다. 이 메서드의 존재는 숫자 객체가 정수 형임을 가리킵니다. 반드시 정수를 돌려줘야 합니다.</p>
<p><a class="reference internal" href="datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a>, <a class="reference internal" href="datamodel.html#object.__float__" title="object.__float__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code></a> 및 <a class="reference internal" href="datamodel.html#object.__complex__" title="object.__complex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__complex__()</span></code></a>가 정의되어 있지 않으면, 해당 내장 함수 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> 및 <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a>는 <a class="reference internal" href="datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>를 사용합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__round__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__round__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">ndigits</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__round__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__trunc__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__trunc__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__trunc__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__floor__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__floor__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__floor__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ceil__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ceil__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__ceil__" title="Link to this definition">¶</a></dt>
<dd><p id="index-105">내장 함수 <a class="reference internal" href="../library/functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a>와 <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 함수 <a class="reference internal" href="../library/math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal notranslate"><span class="pre">trunc()</span></code></a>, <a class="reference internal" href="../library/math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a>, <a class="reference internal" href="../library/math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">ceil()</span></code></a> 을 구현하기 위해 호출됩니다. <em>ndigits</em> 가 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__round__()</span></code> 로 전달되지 않는 한, 이 메서드들은 모두 <a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a> (보통 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) 로 잘린 객체의 값을 돌려줘야 합니다.</p>
<p>The built-in function <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> falls back to <a class="reference internal" href="datamodel.html#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code></a> if neither
<a class="reference internal" href="datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a> nor <a class="reference internal" href="datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> is defined.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>The delegation of <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> to <a class="reference internal" href="datamodel.html#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code></a> is deprecated.</p>
</div>
</dd></dl>

</section>
<section id="with-statement-context-managers">
<span id="context-managers"></span><h3><span class="section-number">3.3.9. </span>with 문 컨텍스트 관리자<a class="headerlink" href="datamodel.html#with-statement-context-managers" title="Link to this heading">¶</a></h3>
<p><em class="dfn">컨텍스트 관리자 (context manager)</em> 는 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문을 실행할 때 자리 잡는 실행 컨텍스트(context)를 정의하는 객체입니다. 코드 블록의 실행을 위해, 컨텍스트 관리자는 원하는 실행시간 컨텍스트로의 진입과 탈출을 처리합니다. 컨텍스트 관리자는 보통 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> 문(<a class="reference internal" href="compound_stmts.html#with"><span class="std std-ref">with 문</span></a> 섹션에서 설명합니다)으로 시작되지만, 그들의 메서드를 호출해서 직접 사용할 수도 있습니다.</p>
<p id="index-106">컨텍스트 관리자의 전형적인 용도에는 다양한 종류의 전역 상태(global state)를 보관하고 복구하는 것, 자원을 로킹(locking)하고 언로킹(unlocking)하는 것, 열린 파일을 닫는 것 등이 있습니다.</p>
<p>컨텍스트 관리자에 대한 더 자세한 정보는 <a class="reference internal" href="../library/stdtypes.html#typecontextmanager"><span class="std std-ref">컨텍스트 관리자 형</span></a> 에 나옵니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__enter__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__enter__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__enter__" title="Link to this definition">¶</a></dt>
<dd><p>이 객체와 연관된 실행시간 컨텍스트에 진입합니다. <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문은 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> 절로 지정된 대상이 있다면, 이 메서드의 반환 값을 연결합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__exit__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__exit__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__exit__" title="Link to this definition">¶</a></dt>
<dd><p>이 객체와 연관된 실행시간 컨텍스트를 종료합니다. 매개변수들은 컨텍스트에서 벗어나게 만든 예외를 기술합니다. 만약 컨텍스트가 예외 없이 종료한다면, 세 인자 모두 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 이 됩니다.</p>
<p>만약 예외가 제공되고, 메서드가 예외를 중지시키고 싶으면 (즉 확산하는 것을 막으려면) 참(true)을 돌려줘야 합니다. 그렇지 않으면 예외는 이 메서드가 종료한 후에 계속 진행됩니다.</p>
<p>Note that <a class="reference internal" href="datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> methods should not reraise the passed-in exception;
this is the caller’s responsibility.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-126"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a> - “with” 문</dt><dd><p>파이썬 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문에 대한 규격, 배경, 예.</p>
</dd>
</dl>
</div>
</section>
<section id="customizing-positional-arguments-in-class-pattern-matching">
<span id="class-pattern-matching"></span><h3><span class="section-number">3.3.10. </span>Customizing positional arguments in class pattern matching<a class="headerlink" href="datamodel.html#customizing-positional-arguments-in-class-pattern-matching" title="Link to this heading">¶</a></h3>
<p>When using a class name in a pattern, positional arguments in the pattern are not
allowed by default, i.e. <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">MyClass(x,</span> <span class="pre">y)</span></code> is typically invalid without special
support in <code class="docutils literal notranslate"><span class="pre">MyClass</span></code>. To be able to use that kind of pattern, the class needs to
define a <em>__match_args__</em> attribute.</p>
<dl class="py data">
<dt class="sig sig-object py" id="object.__match_args__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__match_args__</span></span><a class="headerlink" href="datamodel.html#object.__match_args__" title="Link to this definition">¶</a></dt>
<dd><p>This class variable can be assigned a tuple of strings. When this class is
used in a class pattern with positional arguments, each positional argument will
be converted into a keyword argument, using the corresponding value in
<em>__match_args__</em> as the keyword. The absence of this attribute is equivalent to
setting it to <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p>
</dd></dl>

<p>For example, if <code class="docutils literal notranslate"><span class="pre">MyClass.__match_args__</span></code> is <code class="docutils literal notranslate"><span class="pre">(&quot;left&quot;,</span> <span class="pre">&quot;center&quot;,</span> <span class="pre">&quot;right&quot;)</span></code> that means
that <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">MyClass(x,</span> <span class="pre">y)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">MyClass(left=x,</span> <span class="pre">center=y)</span></code>. Note
that the number of arguments in the pattern must be smaller than or equal to the number
of elements in <em>__match_args__</em>; if it is larger, the pattern match attempt will raise
a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-108"></span><a class="pep reference external" href="https://peps.python.org/pep-0634/"><strong>PEP 634</strong></a> - Structural Pattern Matching</dt><dd><p>The specification for the Python <code class="docutils literal notranslate"><span class="pre">match</span></code> statement.</p>
</dd>
</dl>
</div>
</section>
<section id="emulating-buffer-types">
<span id="python-buffer-protocol"></span><h3><span class="section-number">3.3.11. </span>Emulating buffer types<a class="headerlink" href="datamodel.html#emulating-buffer-types" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">buffer protocol</span></a> provides a way for Python
objects to expose efficient access to a low-level memory array. This protocol
is implemented by builtin types such as <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> and <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>,
and third-party libraries may define additional buffer types.</p>
<p>While buffer types are usually implemented in C, it is also possible to
implement the protocol in Python.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__buffer__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__buffer__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__buffer__" title="Link to this definition">¶</a></dt>
<dd><p>Called when a buffer is requested from <em>self</em> (for example, by the
<a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> constructor). The <em>flags</em> argument is an integer
representing the kind of buffer requested, affecting for example whether
the returned buffer is read-only or writable. <a class="reference internal" href="../library/inspect.html#inspect.BufferFlags" title="inspect.BufferFlags"><code class="xref py py-class docutils literal notranslate"><span class="pre">inspect.BufferFlags</span></code></a>
provides a convenient way to interpret the flags. The method must return
a <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__release_buffer__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__release_buffer__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__release_buffer__" title="Link to this definition">¶</a></dt>
<dd><p>Called when a buffer is no longer needed. The <em>buffer</em> argument is a
<a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> object that was previously returned by
<a class="reference internal" href="datamodel.html#object.__buffer__" title="object.__buffer__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__buffer__()</span></code></a>. The method must release any resources associated
with the buffer. This method should return <code class="docutils literal notranslate"><span class="pre">None</span></code>.
Buffer objects that do not need to perform any cleanup are not required
to implement this method.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-109"></span><a class="pep reference external" href="https://peps.python.org/pep-0688/"><strong>PEP 688</strong></a> - Making the buffer protocol accessible in Python</dt><dd><p>Introduces the Python <code class="docutils literal notranslate"><span class="pre">__buffer__</span></code> and <code class="docutils literal notranslate"><span class="pre">__release_buffer__</span></code> methods.</p>
</dd>
<dt><a class="reference internal" href="../library/collections.abc.html#collections.abc.Buffer" title="collections.abc.Buffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Buffer</span></code></a></dt><dd><p>ABC for buffer types.</p>
</dd>
</dl>
</div>
</section>
<section id="special-method-lookup">
<span id="special-lookup"></span><h3><span class="section-number">3.3.12. </span>특수 메서드 조회<a class="headerlink" href="datamodel.html#special-method-lookup" title="Link to this heading">¶</a></h3>
<p>사용자 정의 클래스의 경우, 묵시적인 특수 메서드의 호출은 객체의 인스턴스 딕셔너리가 아닌 객체의 형에 정의되어 있을 때만 올바르게 동작함이 보장됩니다. 이런 동작은 다음과 같은 코드가 예외를 일으키는 원인입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">object of type &#39;C&#39; has no len()</span>
</pre></div>
</div>
<p>The rationale behind this behaviour lies with a number of special methods such
as <a class="reference internal" href="datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> and <a class="reference internal" href="datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> that are implemented
by all objects,
including type objects. If the implicit lookup of these methods used the
conventional lookup process, they would fail when invoked on the type object
itself:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">descriptor &#39;__hash__&#39; of &#39;int&#39; object needs an argument</span>
</pre></div>
</div>
<p>클래스의 연결되지 않은 메서드를 호출하려는 이런 식의 잘못된 시도는 종종 ‘메타 클래스 혼란(metaclass confusion)’ 이라고 불리고, 특수 메서드를 조회할 때 인스턴스를 우회하는 방법으로 피할 수 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In addition to bypassing any instance attributes in the interest of
correctness, implicit special method lookup generally also bypasses the
<a class="reference internal" href="datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> method even of the object’s metaclass:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Metaclass getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Class getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>                 <span class="c1"># Explicit lookup via instance</span>
<span class="go">Class getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>          <span class="c1"># Explicit lookup via type</span>
<span class="go">Metaclass getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>                      <span class="c1"># Implicit lookup</span>
<span class="go">10</span>
</pre></div>
</div>
<p>Bypassing the <a class="reference internal" href="datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> machinery in this fashion
provides significant scope for speed optimisations within the
interpreter, at the cost of some flexibility in the handling of
special methods (the special method <em>must</em> be set on the class
object itself in order to be consistently invoked by the interpreter).</p>
</section>
</section>
<section id="coroutines">
<span id="index-110"></span><h2><span class="section-number">3.4. </span>코루틴(Coroutines)<a class="headerlink" href="datamodel.html#coroutines" title="Link to this heading">¶</a></h2>
<section id="awaitable-objects">
<h3><span class="section-number">3.4.1. </span>어웨이터블 객체(Awaitable Objects)<a class="headerlink" href="datamodel.html#awaitable-objects" title="Link to this heading">¶</a></h3>
<p>An <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> object generally implements an <a class="reference internal" href="datamodel.html#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> method.
<a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Coroutine objects</span></a> returned from <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> functions
are awaitable.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>The <a class="reference internal" href="../glossary.html#term-generator-iterator"><span class="xref std std-term">generator iterator</span></a> objects returned from generators
decorated with <a class="reference internal" href="../library/types.html#types.coroutine" title="types.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.coroutine()</span></code></a>
are also awaitable, but they do not implement <a class="reference internal" href="datamodel.html#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="object.__await__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__await__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__await__" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">이터레이터</span></a> 를 돌려줘야 합니다. <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a> 객체를 구현하기 위해 사용되어야 합니다. 예를 들어, <a class="reference internal" href="../library/asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 는 <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식과 호환되기 위해 이 메서드를 구현합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>The language doesn’t place any restriction on the type or value of the
objects yielded by the iterator returned by <code class="docutils literal notranslate"><span class="pre">__await__</span></code>, as this is
specific to the implementation of the asynchronous execution framework
(e.g. <a class="reference internal" href="../library/asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a>) that will be managing the <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> object.</p>
</div>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><span class="target" id="index-127"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> 가 어웨이터블 객체에 대한 더 자세한 정보를 포함하고 있습니다.</p>
</div>
</section>
<section id="coroutine-objects">
<span id="id16"></span><h3><span class="section-number">3.4.2. </span>코루틴 객체(Coroutine Objects)<a class="headerlink" href="datamodel.html#coroutine-objects" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Coroutine objects</span></a> are <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> objects.
A coroutine’s execution can be controlled by calling <a class="reference internal" href="datamodel.html#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> and
iterating over the result.  When the coroutine has finished executing and
returns, the iterator raises <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, and the exception’s
<a class="reference internal" href="../library/exceptions.html#StopIteration.value" title="StopIteration.value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> attribute holds the return value.  If the
coroutine raises an exception, it is propagated by the iterator.  Coroutines
should not directly raise unhandled <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exceptions.</p>
<p>코루틴은 다음에 나열하는 메서드들 또한 갖고 있는데, 제너레이터(<a class="reference internal" href="expressions.html#generator-methods"><span class="std std-ref">제너레이터-이터레이터 메서드</span></a> 를 보십시오)의 것들과 닮았습니다. 하지만, 제너레이터와는 달리, 코루틴은 이터레이션을 직접 지원하지는 않습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5.2에서 변경: </span>코루틴을 두 번 await 하면 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 를 일으킵니다.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="coroutine.send">
<span class="sig-prename descclassname"><span class="pre">coroutine.</span></span><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#coroutine.send" title="Link to this definition">¶</a></dt>
<dd><p>Starts or resumes execution of the coroutine.  If <em>value</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>,
this is equivalent to advancing the iterator returned by
<a class="reference internal" href="datamodel.html#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>.  If <em>value</em> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, this method delegates
to the <a class="reference internal" href="expressions.html#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> method of the iterator that caused
the coroutine to suspend.  The result (return value,
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, or other exception) is the same as when
iterating over the <code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code> return value, described above.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coroutine.throw">
<span class="sig-prename descclassname"><span class="pre">coroutine.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#coroutine.throw" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">coroutine.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Raises the specified exception in the coroutine.  This method delegates
to the <a class="reference internal" href="expressions.html#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> method of the iterator that caused
the coroutine to suspend, if it has such a method.  Otherwise,
the exception is raised at the suspension point.  The result
(return value, <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, or other exception) is the same as
when iterating over the <a class="reference internal" href="datamodel.html#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> return value, described
above.  If the exception is not caught in the coroutine, it propagates
back to the caller.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span>The second signature (type[, value[, traceback]]) is deprecated and
may be removed in a future version of Python.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coroutine.close">
<span class="sig-prename descclassname"><span class="pre">coroutine.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#coroutine.close" title="Link to this definition">¶</a></dt>
<dd><p>코루틴이 자신을 정리하고 종료하도록 만듭니다. 만약 코루틴이 일시 중지 중이면, 이 메서드는 먼저 코루틴이 일시 중지되도록 한 이터레이터의 <a class="reference internal" href="expressions.html#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 메서드로 위임합니다(그런 메서드를 가지는 경우). 그런 다음 일시 중지지점에서 <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> 를 발생시키는데, 코루틴이 즉시 자신을 정리하도록 만듭니다. 마지막으로 코루틴에 실행을 종료했다고 표시하는데, 아직 시작하지조차 않았을 때도 그렇다.</p>
<p>코루틴 객체가 파괴될 때는 위의 프로세스에 따라 자동으로 닫힙니다(closed).</p>
</dd></dl>

</section>
<section id="asynchronous-iterators">
<span id="async-iterators"></span><h3><span class="section-number">3.4.3. </span>비동기 이터레이터(Asynchronous Iterators)<a class="headerlink" href="datamodel.html#asynchronous-iterators" title="Link to this heading">¶</a></h3>
<p><em>비동기 이터레이터</em> 는 자신의 <code class="docutils literal notranslate"><span class="pre">__anext__</span></code> 메서드에서 비동기 코드를 호출할 수 있습니다.</p>
<p>비동기 이터레이터는 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 문에서 사용될 수 있습니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__aiter__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__aiter__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__aiter__" title="Link to this definition">¶</a></dt>
<dd><p><em>비동기 이터레이터</em> 객체를 돌려줘야 합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__anext__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__anext__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__anext__" title="Link to this definition">¶</a></dt>
<dd><p>이터레이터의 다음 값을 주는 <em>어웨이터블</em> 을 돌려줘야 합니다. 이터레이션이 끝나면 <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 에러를 일으켜야 합니다.</p>
</dd></dl>

<p>비동기 이터러블 객체의 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Reader</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__anext__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopAsyncIteration</span>
        <span class="k">return</span> <span class="n">val</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>Prior to Python 3.7, <a class="reference internal" href="datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> could return an <em>awaitable</em>
that would resolve to an
<a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a>.</p>
<p>Starting with Python 3.7, <a class="reference internal" href="datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> must return an
asynchronous iterator object.  Returning anything else
will result in a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> error.</p>
</div>
</section>
<section id="asynchronous-context-managers">
<span id="async-context-managers"></span><h3><span class="section-number">3.4.4. </span>비동기 컨텍스트 관리자<a class="headerlink" href="datamodel.html#asynchronous-context-managers" title="Link to this heading">¶</a></h3>
<p><em>비동기 컨텍스트 관리자(asynchronous context manager)</em> 는 <code class="docutils literal notranslate"><span class="pre">__aenter__</span></code> 와 <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> 메서드에서 실행을 일시 중지할 수 있는 <em>컨텍스트 관리자</em> 입니다.</p>
<p>비동기 컨텍스트 관리자는 <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 문에서 사용될 수 있습니다.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__aenter__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__aenter__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__aenter__" title="Link to this definition">¶</a></dt>
<dd><p>Semantically similar to <a class="reference internal" href="datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a>, the only
difference being that it must return an <em>awaitable</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__aexit__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__aexit__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="datamodel.html#object.__aexit__" title="Link to this definition">¶</a></dt>
<dd><p>Semantically similar to <a class="reference internal" href="datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a>, the only
difference being that it must return an <em>awaitable</em>.</p>
</dd></dl>

<p>비동기 컨텍스트 관리자 클래스의 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;entering context&#39;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;exiting context&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<p class="rubric">각주</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id17" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="datamodel.html#id1">1</a><span class="fn-bracket">]</span></span>
<p>어떤 제한된 조건으로, 어떤 경우에 객체의 형을 변경하는 것이 <em>가능합니다</em>. 하지만 잘못 다뤄지면 아주 괴상한 결과로 이어질 수 있으므로 일반적으로 좋은 생각이 아닙니다.</p>
</aside>
<aside class="footnote brackets" id="id18" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="datamodel.html#id10">2</a><span class="fn-bracket">]</span></span>
<p>The <a class="reference internal" href="datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, <a class="reference internal" href="datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>,
<a class="reference internal" href="datamodel.html#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a>, and <a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> methods have
special handling for this; others
will still raise a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, but may do so by relying on
the behavior that <code class="docutils literal notranslate"><span class="pre">None</span></code> is not callable.</p>
</aside>
<aside class="footnote brackets" id="id19" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="datamodel.html#id14">3</a><span class="fn-bracket">]</span></span>
<p>“Does not support” here means that the class has no such method, or
the method returns <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>.  Do not set the method to
<code class="docutils literal notranslate"><span class="pre">None</span></code> if you want to force fallback to the right operand’s reflected
method—that will instead have the opposite effect of explicitly
<em>blocking</em> such fallback.</p>
</aside>
<aside class="footnote brackets" id="id20" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="datamodel.html#id15">4</a><span class="fn-bracket">]</span></span>
<p>For operands of the same type, it is assumed that if the non-reflected
method – such as <a class="reference internal" href="datamodel.html#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> – fails then the overall
operation is not
supported, which is why the reflected method is not called.</p>
</aside>
</aside>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="datamodel.html#">3. 데이터 모델</a><ul>
<li><a class="reference internal" href="datamodel.html#objects-values-and-types">3.1. 객체, 값, 형</a></li>
<li><a class="reference internal" href="datamodel.html#the-standard-type-hierarchy">3.2. 표준형 계층</a><ul>
<li><a class="reference internal" href="datamodel.html#none">3.2.1. None</a></li>
<li><a class="reference internal" href="datamodel.html#notimplemented">3.2.2. NotImplemented</a></li>
<li><a class="reference internal" href="datamodel.html#ellipsis">3.2.3. Ellipsis</a></li>
<li><a class="reference internal" href="datamodel.html#numbers-number">3.2.4. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a><ul>
<li><a class="reference internal" href="datamodel.html#numbers-integral">3.2.4.1. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a></li>
<li><a class="reference internal" href="datamodel.html#numbers-real-float">3.2.4.2. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>)</a></li>
<li><a class="reference internal" href="datamodel.html#numbers-complex-complex">3.2.4.3. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code> (<code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#sequences">3.2.5. 시퀀스들</a><ul>
<li><a class="reference internal" href="datamodel.html#immutable-sequences">3.2.5.1. 불변 시퀀스</a></li>
<li><a class="reference internal" href="datamodel.html#mutable-sequences">3.2.5.2. 가변 시퀀스</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#set-types">3.2.6. 집합 형들(Set types)</a></li>
<li><a class="reference internal" href="datamodel.html#mappings">3.2.7. 매핑(Mappings)</a><ul>
<li><a class="reference internal" href="datamodel.html#dictionaries">3.2.7.1. 딕셔너리(Dictionaries)</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#callable-types">3.2.8. 콜러블(Callable types)</a><ul>
<li><a class="reference internal" href="datamodel.html#user-defined-functions">3.2.8.1. 사용자 정의 함수</a><ul>
<li><a class="reference internal" href="datamodel.html#special-read-only-attributes">3.2.8.1.1. Special read-only attributes</a></li>
<li><a class="reference internal" href="datamodel.html#special-writable-attributes">3.2.8.1.2. Special writable attributes</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#instance-methods">3.2.8.2. 인스턴스 메서드(Instance methods)</a></li>
<li><a class="reference internal" href="datamodel.html#generator-functions">3.2.8.3. 제너레이터 함수(Generator functions)</a></li>
<li><a class="reference internal" href="datamodel.html#coroutine-functions">3.2.8.4. 코루틴 함수(Coroutine functions)</a></li>
<li><a class="reference internal" href="datamodel.html#asynchronous-generator-functions">3.2.8.5. 비동기 제너레이터 함수(Asynchronous generator functions)</a></li>
<li><a class="reference internal" href="datamodel.html#built-in-functions">3.2.8.6. 내장 함수(Built-in functions)</a></li>
<li><a class="reference internal" href="datamodel.html#built-in-methods">3.2.8.7. 내장 메서드(Built-in methods)</a></li>
<li><a class="reference internal" href="datamodel.html#classes">3.2.8.8. 클래스(Classes)</a></li>
<li><a class="reference internal" href="datamodel.html#class-instances">3.2.8.9. 클래스 인스턴스(Class Instances)</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#modules">3.2.9. 모듈(Modules)</a></li>
<li><a class="reference internal" href="datamodel.html#custom-classes">3.2.10. 사용자 정의 클래스(Custom classes)</a></li>
<li><a class="reference internal" href="datamodel.html#id3">3.2.11. 클래스 인스턴스(Class instances)</a></li>
<li><a class="reference internal" href="datamodel.html#i-o-objects-also-known-as-file-objects">3.2.12. I/O 객체 (파일 객체라고도 알려져 있습니다)</a></li>
<li><a class="reference internal" href="datamodel.html#internal-types">3.2.13. 내부 형(Internal types)</a><ul>
<li><a class="reference internal" href="datamodel.html#code-objects">3.2.13.1. 코드 객체(Code objects)</a><ul>
<li><a class="reference internal" href="datamodel.html#index-58">3.2.13.1.1. Special read-only attributes</a></li>
<li><a class="reference internal" href="datamodel.html#methods-on-code-objects">3.2.13.1.2. Methods on code objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#frame-objects">3.2.13.2. 프레임 객체(Frame objects)</a><ul>
<li><a class="reference internal" href="datamodel.html#index-64">3.2.13.2.1. Special read-only attributes</a></li>
<li><a class="reference internal" href="datamodel.html#index-65">3.2.13.2.2. Special writable attributes</a></li>
<li><a class="reference internal" href="datamodel.html#frame-object-methods">3.2.13.2.3. Frame object methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#traceback-objects">3.2.13.3. 트레이스백 객체(Traceback objects)</a></li>
<li><a class="reference internal" href="datamodel.html#slice-objects">3.2.13.4. 슬라이스 객체(Slice objects)</a></li>
<li><a class="reference internal" href="datamodel.html#static-method-objects">3.2.13.5. 스태틱 메서드 객체(Static method objects)</a></li>
<li><a class="reference internal" href="datamodel.html#class-method-objects">3.2.13.6. 클래스 메서드 객체(Class method objects)</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#special-method-names">3.3. 특수 메서드 이름들</a><ul>
<li><a class="reference internal" href="datamodel.html#basic-customization">3.3.1. 기본적인 커스터마이제이션</a></li>
<li><a class="reference internal" href="datamodel.html#customizing-attribute-access">3.3.2. 어트리뷰트 액세스 커스터마이제이션</a><ul>
<li><a class="reference internal" href="datamodel.html#customizing-module-attribute-access">3.3.2.1. 모듈 어트리뷰트 액세스 커스터마이제이션</a></li>
<li><a class="reference internal" href="datamodel.html#implementing-descriptors">3.3.2.2. 디스크립터 구현하기</a></li>
<li><a class="reference internal" href="datamodel.html#invoking-descriptors">3.3.2.3. 디스크립터 호출하기</a></li>
<li><a class="reference internal" href="datamodel.html#slots">3.3.2.4. __slots__</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#customizing-class-creation">3.3.3. 클래스 생성 커스터마이제이션</a><ul>
<li><a class="reference internal" href="datamodel.html#metaclasses">3.3.3.1. 메타 클래스</a></li>
<li><a class="reference internal" href="datamodel.html#resolving-mro-entries">3.3.3.2. MRO 항목 결정하기</a></li>
<li><a class="reference internal" href="datamodel.html#determining-the-appropriate-metaclass">3.3.3.3. 적절한 메타 클래스 선택하기</a></li>
<li><a class="reference internal" href="datamodel.html#preparing-the-class-namespace">3.3.3.4. 클래스 이름 공간 준비하기</a></li>
<li><a class="reference internal" href="datamodel.html#executing-the-class-body">3.3.3.5. 클래스 바디 실행하기</a></li>
<li><a class="reference internal" href="datamodel.html#creating-the-class-object">3.3.3.6. 클래스 객체 만들기</a></li>
<li><a class="reference internal" href="datamodel.html#uses-for-metaclasses">3.3.3.7. 메타 클래스의 용도</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#customizing-instance-and-subclass-checks">3.3.4. 인스턴스 및 서브 클래스 검사 커스터마이제이션</a></li>
<li><a class="reference internal" href="datamodel.html#emulating-generic-types">3.3.5. 제네릭 형 흉내 내기</a><ul>
<li><a class="reference internal" href="datamodel.html#the-purpose-of-class-getitem">3.3.5.1. The purpose of <em>__class_getitem__</em></a></li>
<li><a class="reference internal" href="datamodel.html#class-getitem-versus-getitem">3.3.5.2. <em>__class_getitem__</em> versus <em>__getitem__</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#emulating-callable-objects">3.3.6. 콜러블 객체 흉내 내기</a></li>
<li><a class="reference internal" href="datamodel.html#emulating-container-types">3.3.7. 컨테이너형 흉내 내기</a></li>
<li><a class="reference internal" href="datamodel.html#emulating-numeric-types">3.3.8. 숫자 형 흉내 내기</a></li>
<li><a class="reference internal" href="datamodel.html#with-statement-context-managers">3.3.9. with 문 컨텍스트 관리자</a></li>
<li><a class="reference internal" href="datamodel.html#customizing-positional-arguments-in-class-pattern-matching">3.3.10. Customizing positional arguments in class pattern matching</a></li>
<li><a class="reference internal" href="datamodel.html#emulating-buffer-types">3.3.11. Emulating buffer types</a></li>
<li><a class="reference internal" href="datamodel.html#special-method-lookup">3.3.12. 특수 메서드 조회</a></li>
</ul>
</li>
<li><a class="reference internal" href="datamodel.html#coroutines">3.4. 코루틴(Coroutines)</a><ul>
<li><a class="reference internal" href="datamodel.html#awaitable-objects">3.4.1. 어웨이터블 객체(Awaitable Objects)</a></li>
<li><a class="reference internal" href="datamodel.html#coroutine-objects">3.4.2. 코루틴 객체(Coroutine Objects)</a></li>
<li><a class="reference internal" href="datamodel.html#asynchronous-iterators">3.4.3. 비동기 이터레이터(Asynchronous Iterators)</a></li>
<li><a class="reference internal" href="datamodel.html#asynchronous-context-managers">3.4.4. 비동기 컨텍스트 관리자</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="lexical_analysis.html"
                          title="이전 장"><span class="section-number">2. </span>어휘 분석</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="executionmodel.html"
                          title="다음 장"><span class="section-number">4. </span>실행 모델</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/datamodel.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="사이드바 닫기">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 실행 모델"
             >다음</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. 어휘 분석"
             >이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 언어 레퍼런스</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="datamodel.html"><span class="section-number">3. </span>데이터 모델</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    저작권
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="../../../license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      최종 업데이트: Jun 09, 2024 (17:23 UTC)
    
      <a href="../../../bugs.html">Found a bug</a>?
    
    <br />

    <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7 버전으로 생성되었습니다.
    </div>

    <script type="text/javascript" src="../_static/switchers.js"></script>
  </body>
</html>