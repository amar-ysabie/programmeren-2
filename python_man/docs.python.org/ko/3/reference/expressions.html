<!DOCTYPE html>

<html lang="ko" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="6. 표현식" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/reference/expressions.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="이 장은 파이썬에서 사용되는 표현식 요소들의 의미를 설명합니다. 문법 유의 사항: 여기와 이어지는 장에서는, 어휘 분석이 아니라 문법을 설명하기 위해 확장 BNF 표기법을 사용합니다. 문법 규칙이 다음과 같은 형태를 가지고, 뜻(semantics)을 주지 않으면, 이 형태의 name 의 뜻은 othername 과 같습니다. 산술 변환: 다음에 나오는 ..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="이 장은 파이썬에서 사용되는 표현식 요소들의 의미를 설명합니다. 문법 유의 사항: 여기와 이어지는 장에서는, 어휘 분석이 아니라 문법을 설명하기 위해 확장 BNF 표기법을 사용합니다. 문법 규칙이 다음과 같은 형태를 가지고, 뜻(semantics)을 주지 않으면, 이 형태의 name 의 뜻은 othername 과 같습니다. 산술 변환: 다음에 나오는 ..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>6. 표현식 &#8212; Python 3.12.4 문서</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css%3Fv=80d5e7a1.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css%3Fv=bb723527.css" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css%3Fv=b20cc3f5.css" />
    
    <script src="../_static/documentation_options.js%3Fv=3050f571"></script>
    <script src="../_static/doctools.js%3Fv=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js%3Fv=dc90522c"></script>
    <script src="../_static/translations.js%3Fv=b5f768d8"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.12.4 문서에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="7. 단순문(Simple statements)" href="simple_stmts.html" />
    <link rel="prev" title="5. 임포트 시스템" href="import.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="../../../3/reference/expressions.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" />
                <input type="submit" value="이동"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="expressions.html#">6. 표현식</a><ul>
<li><a class="reference internal" href="expressions.html#arithmetic-conversions">6.1. 산술 변환</a></li>
<li><a class="reference internal" href="expressions.html#atoms">6.2. 아톰 (Atoms)</a><ul>
<li><a class="reference internal" href="expressions.html#atom-identifiers">6.2.1. 식별자 (이름)</a></li>
<li><a class="reference internal" href="expressions.html#literals">6.2.2. 리터럴 (Literals)</a></li>
<li><a class="reference internal" href="expressions.html#parenthesized-forms">6.2.3. 괄호 안에 넣은 형</a></li>
<li><a class="reference internal" href="expressions.html#displays-for-lists-sets-and-dictionaries">6.2.4. 리스트, 집합, 딕셔너리의 디스플레이(display)</a></li>
<li><a class="reference internal" href="expressions.html#list-displays">6.2.5. 리스트 디스플레이</a></li>
<li><a class="reference internal" href="expressions.html#set-displays">6.2.6. 집합 디스플레이</a></li>
<li><a class="reference internal" href="expressions.html#dictionary-displays">6.2.7. 딕셔너리 디스플레이</a></li>
<li><a class="reference internal" href="expressions.html#generator-expressions">6.2.8. 제너레이터 표현식 (Generator expressions)</a></li>
<li><a class="reference internal" href="expressions.html#yield-expressions">6.2.9. 일드 표현식(Yield expressions)</a><ul>
<li><a class="reference internal" href="expressions.html#generator-iterator-methods">6.2.9.1. 제너레이터-이터레이터 메서드</a></li>
<li><a class="reference internal" href="expressions.html#examples">6.2.9.2. 사용 예</a></li>
<li><a class="reference internal" href="expressions.html#asynchronous-generator-functions">6.2.9.3. 비동기 제너레이터 함수</a></li>
<li><a class="reference internal" href="expressions.html#asynchronous-generator-iterator-methods">6.2.9.4. 비동기 제너레이터-이터레이터 메서드</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="expressions.html#primaries">6.3. 프라이머리</a><ul>
<li><a class="reference internal" href="expressions.html#attribute-references">6.3.1. 어트리뷰트 참조</a></li>
<li><a class="reference internal" href="expressions.html#subscriptions">6.3.2. 서브스크립션(Subscriptions)</a></li>
<li><a class="reference internal" href="expressions.html#slicings">6.3.3. 슬라이싱(Slicings)</a></li>
<li><a class="reference internal" href="expressions.html#calls">6.3.4. 호출</a></li>
</ul>
</li>
<li><a class="reference internal" href="expressions.html#await-expression">6.4. 어웨이트 표현식</a></li>
<li><a class="reference internal" href="expressions.html#the-power-operator">6.5. 거듭제곱 연산자</a></li>
<li><a class="reference internal" href="expressions.html#unary-arithmetic-and-bitwise-operations">6.6. 일 항 산술과 비트 연산</a></li>
<li><a class="reference internal" href="expressions.html#binary-arithmetic-operations">6.7. 이항 산술 연산</a></li>
<li><a class="reference internal" href="expressions.html#shifting-operations">6.8. 시프트 연산</a></li>
<li><a class="reference internal" href="expressions.html#binary-bitwise-operations">6.9. 이항 비트 연산</a></li>
<li><a class="reference internal" href="expressions.html#comparisons">6.10. 비교</a><ul>
<li><a class="reference internal" href="expressions.html#value-comparisons">6.10.1. 값 비교</a></li>
<li><a class="reference internal" href="expressions.html#membership-test-operations">6.10.2. 멤버십 검사 연산</a></li>
<li><a class="reference internal" href="expressions.html#is-not">6.10.3. 아이덴티티 비교</a></li>
</ul>
</li>
<li><a class="reference internal" href="expressions.html#boolean-operations">6.11. 논리 연산(Boolean operations)</a></li>
<li><a class="reference internal" href="expressions.html#assignment-expressions">6.12. 대입 표현식</a></li>
<li><a class="reference internal" href="expressions.html#conditional-expressions">6.13. 조건 표현식(Conditional expressions)</a></li>
<li><a class="reference internal" href="expressions.html#lambda">6.14. 람다(Lambdas)</a></li>
<li><a class="reference internal" href="expressions.html#expression-lists">6.15. 표현식 목록(Expression lists)</a></li>
<li><a class="reference internal" href="expressions.html#evaluation-order">6.16. 값을 구하는 순서</a></li>
<li><a class="reference internal" href="expressions.html#operator-precedence">6.17. 연산자 우선순위</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="import.html"
                          title="이전 장"><span class="section-number">5. </span>임포트 시스템</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="simple_stmts.html"
                          title="다음 장"><span class="section-number">7. </span>단순문(Simple statements)</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/expressions.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. 단순문(Simple statements)"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. 임포트 시스템"
             accesskey="P">이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 언어 레퍼런스</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="expressions.html"><span class="section-number">6. </span>표현식</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="expressions">
<span id="id1"></span><h1><span class="section-number">6. </span>표현식<a class="headerlink" href="expressions.html#expressions" title="Link to this heading">¶</a></h1>
<p id="index-0">이 장은 파이썬에서 사용되는 표현식 요소들의 의미를 설명합니다.</p>
<p><strong>문법 유의 사항:</strong> 여기와 이어지는 장에서는, 어휘 분석이 아니라 문법을 설명하기 위해 확장 BNF 표기법을 사용합니다. 문법 규칙이 다음과 같은 형태를 가지고,</p>
<pre>
<strong id="grammar-token-python-grammar-name">name</strong> ::=  othername
</pre>
<p>뜻(semantics)을 주지 않으면, 이 형태의 <code class="docutils literal notranslate"><span class="pre">name</span></code> 의 뜻은 <code class="docutils literal notranslate"><span class="pre">othername</span></code> 과 같습니다.</p>
<section id="arithmetic-conversions">
<span id="conversions"></span><h2><span class="section-number">6.1. </span>산술 변환<a class="headerlink" href="expressions.html#arithmetic-conversions" title="Link to this heading">¶</a></h2>
<p id="index-1">다음에 나오는 산술 연산자의 설명이 “숫자 인자들은 공통 형으로 변환된다”라는 구절을 사용할 때, 내장형의 연산자 구현이 다음과 같이 동작한다는 뜻입니다:</p>
<ul class="simple">
<li><p>어느 한 인자가 복소수면 다른 하나는 복소수로 변환됩니다;</p></li>
<li><p>그렇지 않고, 어느 한 인자가 실수면, 다른 하나는 실수로 변환됩니다;</p></li>
<li><p>그렇지 않으면, 두 인자는 모두 정수여야 하고, 변환은 필요 없습니다.</p></li>
</ul>
<p>어떤 연산자들(예를 들어, ‘%’ 연산자의 왼쪽 인자로 주어지는 문자열)에 대해서는 몇 가지 추가의 규칙이 적용됩니다. 확장(extension)은 그들 자신의 변환 규칙을 정의해야 합니다.</p>
</section>
<section id="atoms">
<span id="id2"></span><h2><span class="section-number">6.2. </span>아톰 (Atoms)<a class="headerlink" href="expressions.html#atoms" title="Link to this heading">¶</a></h2>
<p id="index-2">아톰은 표현식의 가장 기본적인 요소입니다. 가장 간단한 아톰은 식별자와 리터럴입니다. 괄호, 대괄호, 중괄호로 둘러싸인 형태도 문법적으로 아톰으로 분류됩니다. 아톰의 문법은 이렇습니다:</p>
<pre>
<strong id="grammar-token-python-grammar-atom">atom     </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-literal"><code class="xref docutils literal notranslate"><span class="pre">literal</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-enclosure"><code class="xref docutils literal notranslate"><span class="pre">enclosure</span></code></a>
<strong id="grammar-token-python-grammar-enclosure">enclosure</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-parenth_form"><code class="xref docutils literal notranslate"><span class="pre">parenth_form</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-list_display"><code class="xref docutils literal notranslate"><span class="pre">list_display</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-dict_display"><code class="xref docutils literal notranslate"><span class="pre">dict_display</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-set_display"><code class="xref docutils literal notranslate"><span class="pre">set_display</span></code></a>
               | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-generator_expression"><code class="xref docutils literal notranslate"><span class="pre">generator_expression</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-yield_atom"><code class="xref docutils literal notranslate"><span class="pre">yield_atom</span></code></a>
</pre>
<section id="atom-identifiers">
<span id="identifiers-names"></span><h3><span class="section-number">6.2.1. </span>식별자 (이름)<a class="headerlink" href="expressions.html#atom-identifiers" title="Link to this heading">¶</a></h3>
<p id="index-3">아톰으로 등장하는 식별자는 이름입니다. 어휘 정의에 대해서는 <a class="reference internal" href="lexical_analysis.html#identifiers"><span class="std std-ref">식별자와 키워드</span></a> 섹션을, 이름과 연결에 대한 문서는 <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">이름과 연결(binding)</span></a> 섹션을 보세요.</p>
<p id="index-4">이름이 객체에 연결될 때, 아톰의 값을 구하면 객체가 나옵니다. 이름이 연결되지 않았을 때, 값을 구하려고 하면 <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 예외가 일어납니다.</p>
<p id="index-5"><span id="private-name-mangling"></span><strong>비공개 이름 뒤섞기(private name mangling):</strong> 클래스 정의에 등장하는 식별자가 두 개나 그 이상의 밑줄로 시작하고, 두 개나 그 이상의 밑줄로 끝나지 않으면, 그 클래스의 <em class="dfn">비공개 이름(private name)</em> 으로 간주합니다. 비공개 이름은 그 들을 위한 코드가 만들어지기 전에 더 긴 형태로 변환됩니다. 이 변환은 그 이름의 앞에 클래스 이름을 삽입하는데, 클래스 이름의 처음에 오는 모든 밑줄을 제거한 후, 하나의 밑줄을 추가합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">Ham</span></code> 이라는 이름의 클래스에 식별자 <code class="docutils literal notranslate"><span class="pre">__spam</span></code> 이 등장하면, <code class="docutils literal notranslate"><span class="pre">_Ham__spam</span></code> 으로 변환됩니다. 이 변환은 식별자가 사용되는 문법적인 문맥에 무관합니다. 변환된 이름이 극단적으로 길면(255자보다 길면), 구현이 정의한 잘라내기가 발생할 수 있습니다. 클래스 이름이 밑줄로만 구성되어 있으면, 변환은 일어나지 않습니다.</p>
</section>
<section id="literals">
<span id="atom-literals"></span><h3><span class="section-number">6.2.2. </span>리터럴 (Literals)<a class="headerlink" href="expressions.html#literals" title="Link to this heading">¶</a></h3>
<p id="index-6">파이썬은 문자열과 바이트열 리터럴과 여러 가지 숫자 리터럴들을 지원합니다:</p>
<pre>
<strong id="grammar-token-python-grammar-literal">literal</strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-stringliteral"><code class="xref docutils literal notranslate"><span class="pre">stringliteral</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-bytesliteral"><code class="xref docutils literal notranslate"><span class="pre">bytesliteral</span></code></a>
             | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-integer"><code class="xref docutils literal notranslate"><span class="pre">integer</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-floatnumber"><code class="xref docutils literal notranslate"><span class="pre">floatnumber</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-imagnumber"><code class="xref docutils literal notranslate"><span class="pre">imagnumber</span></code></a>
</pre>
<p>리터럴의 값을 구하면 주어진 형(문자열, 바이트열, 정수, 실수, 복소수)과 주어진 값을 갖는 객체가 나옵니다. 실수와 복소수의 경우는 근삿값일 수 있습니다. 자세한 내용은 <a class="reference internal" href="lexical_analysis.html#literals"><span class="std std-ref">리터럴</span></a> 섹션을 보세요.</p>
<p id="index-7">모든 리터럴은 불변 데이터형에 대응하기 때문에, 객체의 아이덴티티는 값 보다 덜 중요합니다. 같은 값의 리터럴에 대해 반복적으로 값을 구하면 (프로그램 텍스트의 같은 장소에 있거나 다른 장소에 있을 때) 같은 객체를 얻을 수도 있고, 같은 값의 다른 객체를 얻을 수도 있습니다.</p>
</section>
<section id="parenthesized-forms">
<span id="parenthesized"></span><h3><span class="section-number">6.2.3. </span>괄호 안에 넣은 형<a class="headerlink" href="expressions.html#parenthesized-forms" title="Link to this heading">¶</a></h3>
<p id="index-8">괄호 안에 넣은 형은, 괄호로 둘러싸인 생략 가능한 표현식 목록입니다:</p>
<pre>
<strong id="grammar-token-python-grammar-parenth_form">parenth_form</strong> ::=  &quot;(&quot; [<a class="reference internal" href="expressions.html#grammar-token-python-grammar-starred_expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a>] &quot;)&quot;
</pre>
<p>괄호 안에 넣은 표현식 목록은, 무엇이건 그 표현식 목록이 산출하는 것이 됩니다: 목록이 적어도 하나의 쉼표를 포함하면, 튜플이 됩니다; 그렇지 않으면 표현식 목록을 구성한 단일 표현식이 됩니다.</p>
<p id="index-9">빈 괄호 쌍은 빈 튜플 객체를 만듭니다. 튜플은 불변이기 때문에 리터럴에서와 같은 규칙이 적용됩니다 (즉, 두 개의 빈 튜플은 같은 객체일 수도 있고 그렇지 않을 수도 있습니다).</p>
<p id="index-10">Note that tuples are not formed by the parentheses, but rather by use of the
comma.  The exception is the empty tuple, for which parentheses <em>are</em>
required — allowing unparenthesized “nothing” in expressions would cause
ambiguities and allow common typos to pass uncaught.</p>
</section>
<section id="displays-for-lists-sets-and-dictionaries">
<span id="comprehensions"></span><h3><span class="section-number">6.2.4. </span>리스트, 집합, 딕셔너리의 디스플레이(display)<a class="headerlink" href="expressions.html#displays-for-lists-sets-and-dictionaries" title="Link to this heading">¶</a></h3>
<p id="index-11">리스트, 집합, 딕셔너리를 구성하기 위해, 파이썬은 “디스플레이(displays)”라고 부르는 특별한 문법을 각기 두 가지 스타일로 제공합니다:</p>
<ul class="simple">
<li><p>컨테이너의 내용을 명시적으로 나열하거나,</p></li>
<li><p>일련의 루프와 필터링 지시들을 통해 계산되는데, <em class="dfn">컴프리헨션 (comprehension)</em> 이라고 불립니다.</p></li>
</ul>
<p id="index-12">컴프리헨션의 공통 문법 요소들은 이렇습니다:</p>
<pre>
<strong id="grammar-token-python-grammar-comprehension">comprehension</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-assignment_expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> <a class="reference internal" href="expressions.html#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a>
<strong id="grammar-token-python-grammar-comp_for">comp_for     </strong> ::=  [&quot;async&quot;] &quot;for&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-python-grammar-target_list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a> &quot;in&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [<a class="reference internal" href="expressions.html#grammar-token-python-grammar-comp_iter"><code class="xref docutils literal notranslate"><span class="pre">comp_iter</span></code></a>]
<strong id="grammar-token-python-grammar-comp_iter">comp_iter    </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-comp_if"><code class="xref docutils literal notranslate"><span class="pre">comp_if</span></code></a>
<strong id="grammar-token-python-grammar-comp_if">comp_if      </strong> ::=  &quot;if&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [<a class="reference internal" href="expressions.html#grammar-token-python-grammar-comp_iter"><code class="xref docutils literal notranslate"><span class="pre">comp_iter</span></code></a>]
</pre>
<p>컴프리헨션은 하나의 표현식과 그 뒤를 따르는 최소한 하나의 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 절과 없거나 여러 개의 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 또는 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> 절로 구성됩니다. 이 경우, 새 컨테이너의 요소들은 각 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 또는 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> 절이 왼쪽에서 오른쪽으로 중첩된 블록을 이루고, 가장 안쪽에 있는 블록에서 표현식의 값을 구해서 만들어낸 것들입니다.</p>
<p>하지만, 가장 왼쪽의 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 절에 있는 이터러블 표현식을 제외하고는, 컴프리헨션은 묵시적으로 중첩된 스코프에서 실행됩니다. 이렇게 해서 <code class="docutils literal notranslate"><span class="pre">target_list</span></code> 에서 대입되는 이름이 둘러싸는 스코프로 “누수” 되지 않도록 합니다.</p>
<p>가장 왼쪽의 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 절의 이터러블 표현식은, 둘러싸는 스코프에서 직접 평가된 다음, 묵시적으로 중첩된 스코프로 인자로 전달됩니다. 뒤따르는 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 절과 가장 왼쪽 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 절의 모든 필터 조건은, 가장 왼쪽 이터러블에서 얻은 값에 따라 달라질 수 있으므로 둘러싸는 스코프에서 평가할 수 없습니다. 예를 들면, <code class="docutils literal notranslate"><span class="pre">[x*y</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">range(x,</span> <span class="pre">x+10)]</span></code>.</p>
<p>컴프리헨션이 항상 적절한 형의 컨테이너가 되게 하려고, 묵시적으로 중첩된 스코프에서 <code class="docutils literal notranslate"><span class="pre">yield</span></code> 와 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 표현식은 금지됩니다.</p>
<p id="index-13">Since Python 3.6, in an <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> function, an <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code>
clause may be used to iterate over a <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a>.
A comprehension in an <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> function may consist of either a
<code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> or <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> clause following the leading
expression, may contain additional <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> or <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code>
clauses, and may also use <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> expressions.
If a comprehension contains either <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> clauses or
<code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code> expressions or other asynchronous comprehensions it is called
an <em class="dfn">asynchronous comprehension</em>.  An asynchronous comprehension may
suspend the execution of the coroutine function in which it appears.
See also <span class="target" id="index-14"></span><a class="pep reference external" href="https://peps.python.org/pep-0530/"><strong>PEP 530</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6: </span>비동기 컴프리헨션이 도입되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><code class="docutils literal notranslate"><span class="pre">yield</span></code> 와 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 은 묵시적으로 중첩된 스코프에서 금지됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.11에서 변경: </span>Asynchronous comprehensions are now allowed inside comprehensions in
asynchronous functions. Outer comprehensions implicitly become
asynchronous.</p>
</div>
</section>
<section id="list-displays">
<span id="lists"></span><h3><span class="section-number">6.2.5. </span>리스트 디스플레이<a class="headerlink" href="expressions.html#list-displays" title="Link to this heading">¶</a></h3>
<p id="index-15">리스트 디스플레이는 대괄호(square brackets)로 둘러싸인 표현식의 나열인데 비어있을 수 있습니다:</p>
<pre>
<strong id="grammar-token-python-grammar-list_display">list_display</strong> ::=  &quot;[&quot; [<a class="reference internal" href="expressions.html#grammar-token-python-grammar-starred_list"><code class="xref docutils literal notranslate"><span class="pre">starred_list</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>] &quot;]&quot;
</pre>
<p>리스트 디스플레이는 리스트 객체를 만드는데, 그 내용은 표현식의 목록이나 컴프리헨션으로 지정할 수 있습니다. 쉼표로 분리된 표현식의 목록이 제공될 때, 그 요소들은 왼쪽에서 오른쪽으로 값이 구해지고, 그 순서대로 리스트 객체에 삽입됩니다. 컴프리헨션이 제공될 때, 리스트는 컴프리헨션으로 만들어지는 요소들로 구성됩니다.</p>
</section>
<section id="set-displays">
<span id="set"></span><h3><span class="section-number">6.2.6. </span>집합 디스플레이<a class="headerlink" href="expressions.html#set-displays" title="Link to this heading">¶</a></h3>
<p id="index-16">집합 디스플레이는 중괄호(curly braces)로 표시되고, 키와 값을 분리하는 콜론(colon)이 없는 것으로 딕셔너리 디스플레이와 구분될 수 있습니다.</p>
<pre>
<strong id="grammar-token-python-grammar-set_display">set_display</strong> ::=  &quot;{&quot; (<a class="reference internal" href="expressions.html#grammar-token-python-grammar-starred_list"><code class="xref docutils literal notranslate"><span class="pre">starred_list</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>) &quot;}&quot;
</pre>
<p>집합 디스플레이는 새 가변 집합 객체를 만드는데, 그 내용은 표현식의 시퀀스나 컴프리헨션으로 지정됩니다. 쉼표로 분리된 표현식의 목록이 제공될 때, 그 요소들은 왼쪽에서 오른쪽으로 값이 구해지고, 집합 객체에 더해집니다. 컴프리헨션이 제공될 때, 집합은 컴프리헨션으로 만들어지는 요소들로 구성됩니다.</p>
<p>빈 집합은 <code class="docutils literal notranslate"><span class="pre">{}</span></code> 으로 만들어질 수 없습니다; 이 리터럴은 빈 딕셔너리를 만듭니다.</p>
</section>
<section id="dictionary-displays">
<span id="dict"></span><h3><span class="section-number">6.2.7. </span>딕셔너리 디스플레이<a class="headerlink" href="expressions.html#dictionary-displays" title="Link to this heading">¶</a></h3>
<p id="index-17">A dictionary display is a possibly empty series of dict items (key/value pairs)
enclosed in curly braces:</p>
<pre>
<strong id="grammar-token-python-grammar-dict_display">dict_display      </strong> ::=  &quot;{&quot; [<a class="reference internal" href="expressions.html#grammar-token-python-grammar-dict_item_list"><code class="xref docutils literal notranslate"><span class="pre">dict_item_list</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-dict_comprehension"><code class="xref docutils literal notranslate"><span class="pre">dict_comprehension</span></code></a>] &quot;}&quot;
<strong id="grammar-token-python-grammar-dict_item_list">dict_item_list    </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-dict_item"><code class="xref docutils literal notranslate"><span class="pre">dict_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-dict_item"><code class="xref docutils literal notranslate"><span class="pre">dict_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-dict_item">dict_item         </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | &quot;**&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>
<strong id="grammar-token-python-grammar-dict_comprehension">dict_comprehension</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> <a class="reference internal" href="expressions.html#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a>
</pre>
<p>딕셔너리 디스플레이는 새 딕셔너리 객체를 만듭니다.</p>
<p>If a comma-separated sequence of dict items is given, they are evaluated
from left to right to define the entries of the dictionary: each key object is
used as a key into the dictionary to store the corresponding value.  This means
that you can specify the same key multiple times in the dict item list, and the
final dictionary’s value for that key will be the last one given.</p>
<p id="index-18">A double asterisk <code class="docutils literal notranslate"><span class="pre">**</span></code> denotes <em class="dfn">dictionary unpacking</em>.
Its operand must be a <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>.  Each mapping item is added
to the new dictionary.  Later values replace values already set by
earlier dict items and earlier dictionary unpackings.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5: </span><span class="target" id="index-109"></span><a class="pep reference external" href="https://peps.python.org/pep-0448/"><strong>PEP 448</strong></a> 에서 처음 제안된 딕셔너리 디스플레이로의 언 패킹.</p>
</div>
<p>딕셔너리 컴프리헨션은, 리스트와 집합 컴프리헨션에 대비해서, 일반적인 “for” 와 “if” 절 앞에 콜론으로 분리된 두 개의 표현식을 필요로 합니다. 컴프리헨션이 실행될 때, 만들어지는 키와 값 요소들이 만들어지는 순서대로 딕셔너리에 삽입됩니다.</p>
<p id="index-20">Restrictions on the types of the key values are listed earlier in section
<a class="reference internal" href="datamodel.html#types"><span class="std std-ref">표준형 계층</span></a>.  (To summarize, the key type should be <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>, which excludes
all mutable objects.)  Clashes between duplicate keys are not detected; the last
value (textually rightmost in the display) stored for a given key value
prevails.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>파이썬 3.8 이전에는, 딕셔너리 컴프리헨션에서, 키와 값의 평가 순서가 잘 정의되어 있지 않았습니다. CPython에서, 값이 키보다 먼저 평가되었습니다. 3.8부터는, <span class="target" id="index-110"></span><a class="pep reference external" href="https://peps.python.org/pep-0572/"><strong>PEP 572</strong></a>의 제안에 따라 키가 값보다 먼저 평가됩니다.</p>
</div>
</section>
<section id="generator-expressions">
<span id="genexpr"></span><h3><span class="section-number">6.2.8. </span>제너레이터 표현식 (Generator expressions)<a class="headerlink" href="expressions.html#generator-expressions" title="Link to this heading">¶</a></h3>
<p id="index-22">제너레이터 표현식은 괄호로 둘러싸인 간결한 제너레이터 표기법입니다.</p>
<pre>
<strong id="grammar-token-python-grammar-generator_expression">generator_expression</strong> ::=  &quot;(&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> <a class="reference internal" href="expressions.html#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a> &quot;)&quot;
</pre>
<p>제너레이터 표현식은 새 제너레이터 객체를 만듭니다. 문법은 대괄호나 중괄호 대신 괄호로 둘러싸인다는 점만 제외하면 컴프리헨션과 같습니다.</p>
<p>제너레이터 표현식에 사용되는 변수들은 제너레이터 객체의 <a class="reference internal" href="expressions.html#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 메서드가 호출될 때 느긋하게(lazily) 값이 구해집니다 (일반 제너레이터와 마찬가지입니다). 그러나 가장 왼쪽의 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 절에 있는 이터러블 표현식은 즉시 값이 구해져서, 그것으로 인해 발생하는 에러는 첫 번째 값이 검색되는 지점이 아니라 제너레이터 표현식이 정의된 지점에서 발생합니다. 후속 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 절과 가장 왼쪽 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 절의 모든 필터 조건은, 가장 왼쪽 이터러블에서 가져온 값에 따라 달라질 수 있으므로 둘러싸는 스코프에서 평가할 수 없습니다. 예를 들어: <code class="docutils literal notranslate"><span class="pre">(x*y</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">range(x,</span> <span class="pre">x+10))</span></code>.</p>
<p>단지 하나의 인자만 갖는 호출에서는 괄호를 생략할 수 있습니다. 자세한 내용은 <a class="reference internal" href="expressions.html#calls"><span class="std std-ref">호출</span></a> 섹션을 보세요.</p>
<p>제너레이터 표현식 자체의 기대되는 연산을 방해하지 않기 위해, 묵시적으로 정의된 제너레이터에서 <code class="docutils literal notranslate"><span class="pre">yield</span></code> 와 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 표현식은 금지됩니다.</p>
<p>제너레이터 표현식이 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 절이나 <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식을 포함하면 <em class="dfn">비동기 제너레이터 표현식 (asynchronous generator expression)</em> 이라고 불립니다. 비동기 제너레이터 표현식은 새 비동기 제너레이터 객체를 돌려주는데 이것은 비동기 이터레이터입니다 (<a class="reference internal" href="datamodel.html#async-iterators"><span class="std std-ref">비동기 이터레이터(Asynchronous Iterators)</span></a> 를 참조하세요).</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6: </span>비동기식 제너레이터 표현식이 도입되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>파이썬 3.7 이전에는, 비동기 제너레이터 표현식이 <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 코루틴에만 나타날 수 있었습니다. 3.7부터는, 모든 함수가 비동기식 제너레이터 표현식을 사용할 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><code class="docutils literal notranslate"><span class="pre">yield</span></code> 와 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 은 묵시적으로 중첩된 스코프에서 금지됩니다.</p>
</div>
</section>
<section id="yield-expressions">
<span id="yieldexpr"></span><h3><span class="section-number">6.2.9. </span>일드 표현식(Yield expressions)<a class="headerlink" href="expressions.html#yield-expressions" title="Link to this heading">¶</a></h3>
<pre id="index-23">
<strong id="grammar-token-python-grammar-yield_atom">yield_atom      </strong> ::=  &quot;(&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-yield_expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a> &quot;)&quot;
<strong id="grammar-token-python-grammar-yield_from">yield_from      </strong> ::=  &quot;yield&quot; &quot;from&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-yield_expression">yield_expression</strong> ::=  &quot;yield&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression_list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-yield_from"><code class="xref docutils literal notranslate"><span class="pre">yield_from</span></code></a>
</pre>
<p>The yield expression is used when defining a <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a> function
or an <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a> function and
thus can only be used in the body of a function definition.  Using a yield
expression in a function’s body causes that function to be a generator function,
and using it in an <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> function’s body causes that
coroutine function to be an asynchronous generator function. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>  <span class="c1"># defines a generator function</span>
    <span class="k">yield</span> <span class="mi">123</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">agen</span><span class="p">():</span> <span class="c1"># defines an asynchronous generator function</span>
    <span class="k">yield</span> <span class="mi">123</span>
</pre></div>
</div>
<p>둘러싸는 스코프에 대한 부작용으로 인해, <code class="docutils literal notranslate"><span class="pre">yield</span></code> 표현식은 컴프리헨션과 제너레이터 표현식을 구현하는 데 사용되는 묵시적으로 정의된 스코프에 사용될 수 없습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>일드 표현식은 컴프리헨션과 제너레이터 표현식을 구현하는 데 사용되는 묵시적으로 정의된 스코프에서 금지됩니다.</p>
</div>
<p>제너레이터 함수는 다음에서 설명합니다. 반면에 비동기 제너레이터 함수는 <a class="reference internal" href="expressions.html#asynchronous-generator-functions"><span class="std std-ref">비동기 제너레이터 함수</span></a> 섹션에서 별도로 설명합니다.</p>
<p>When a generator function is called, it returns an iterator known as a
generator.  That generator then controls the execution of the generator
function.  The execution starts when one of the generator’s methods is called.
At that time, the execution proceeds to the first yield expression, where it is
suspended again, returning the value of <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a>
to the generator’s caller,
or <code class="docutils literal notranslate"><span class="pre">None</span></code> if <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> is omitted.
By suspended, we mean that all local state is
retained, including the current bindings of local variables, the instruction
pointer, the internal evaluation stack, and the state of any exception handling.
When the execution is resumed by calling one of the generator’s methods, the
function can proceed exactly as if the yield expression were just another
external call.  The value of the yield expression after resuming depends on the
method which resumed the execution.  If <a class="reference internal" href="expressions.html#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> is used
(typically via either a <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> or the <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> builtin) then the
result is <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.  Otherwise, if <a class="reference internal" href="expressions.html#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> is used, then
the result will be the value passed in to that method.</p>
<p id="index-24">이 모든 것들은 제너레이터 함수를 코루틴과 아주 비슷하게 만듭니다; 여러 번 결과를 만들고, 하나 이상의 진입 지점을 갖고 있으며, 실행이 일시 중지될 수 있습니다. 유일한 차이점은 제너레이터 함수는 yield 한 후에 실행이 어디에서 계속되어야 하는지를 제어할 수 없다는 점입니다; 제어는 항상 제너레이터의 호출자로 전달됩니다.</p>
<p>일드 표현식은 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 구조물의 어디에서건 허락됩니다. 제너레이터가 (참조 횟수가 0이 되거나 가비지 수거됨으로써) 파이널라이즈(finalize)되기 전에 재개되지 않으면, 제너레이터-이터레이터의 <a class="reference internal" href="expressions.html#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 메서드가 호출되어, 대기 중인 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절이 실행되도록 허락합니다.</p>
<p id="index-25"><code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> 이 사용될 때, 제공된 표현식은 어터러블이어야 합니다. 그 이터러블을 이터레이트 해서 생성되는 값들은 현재 제너레이터 메서드의 호출자에게 바로 전달됩니다. <a class="reference internal" href="expressions.html#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 로 전달된 모든 값과 <a class="reference internal" href="expressions.html#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> 로 전달된 모든 예외는 밑에 있는(underlying) 이터레이터가 해당 메서드를 갖고 있다면 그곳으로 전달됩니다. 그렇지 않다면, <a class="reference internal" href="expressions.html#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 는 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 나 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으키지만, <a class="reference internal" href="expressions.html#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> 는 전달된 예외를 즉시 일으킨다.</p>
<p>밑에 있는 이러레이터가 완료될 때, 발생하는 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 인스턴스의 <a class="reference internal" href="../library/exceptions.html#StopIteration.value" title="StopIteration.value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> 어트리뷰트는 일드 표현식의 값이 됩니다. <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 를 일으킬 때 명시적으로 설정되거나, 서브 이터레이터가 제너레이터일 경우는 자동으로 이루어집니다 (서브 제너레이터가 값을 돌려(return)줌으로써).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>서브 이터레이터로 제어 흐름을 위임하는 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> 를 추가했습니다.</p>
</div>
<p>일드 표현식이 대입문의 우변에 홀로 나온다면 괄호를 생략할 수 있습니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-111"></span><a class="pep reference external" href="https://peps.python.org/pep-0255/"><strong>PEP 255</strong></a> - 간단한 제너레이터</dt><dd><p>파이썬에 제너레이터와 <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 문을 추가하는 제안.</p>
</dd>
<dt><span class="target" id="index-112"></span><a class="pep reference external" href="https://peps.python.org/pep-0342/"><strong>PEP 342</strong></a> - 개선된 제너레이터를 통한 코루틴</dt><dd><p>제너레이터의 API와 문법을 개선해서, 간단한 코루틴으로 사용할 수 있도록 만드는 제안.</p>
</dd>
<dt><span class="target" id="index-113"></span><a class="pep reference external" href="https://peps.python.org/pep-0380/"><strong>PEP 380</strong></a> - 서브 제너레이터로 위임하는 문법</dt><dd><p>The proposal to introduce the <a class="reference internal" href="expressions.html#grammar-token-python-grammar-yield_from"><code class="xref std std-token docutils literal notranslate"><span class="pre">yield_from</span></code></a> syntax,
making delegation to subgenerators easy.</p>
</dd>
<dt><span class="target" id="index-114"></span><a class="pep reference external" href="https://peps.python.org/pep-0525/"><strong>PEP 525</strong></a> - 비동기 제너레이터</dt><dd><p>코루틴 함수에 제너레이터 기능을 추가하여 <span class="target" id="index-115"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>을 확장한 제안.</p>
</dd>
</dl>
</div>
<section id="generator-iterator-methods">
<span id="generator-methods"></span><span id="index-31"></span><h4><span class="section-number">6.2.9.1. </span>제너레이터-이터레이터 메서드<a class="headerlink" href="expressions.html#generator-iterator-methods" title="Link to this heading">¶</a></h4>
<p>이 서브섹션은 제너레이터 이터레이터의 메서드들을 설명합니다. 제너레이터 함수의 실행을 제어하는데 사용될 수 있습니다.</p>
<p>제너레이터가 이미 실행 중일 때 아래에 나오는 메서드들을 호출하면 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 예외를 일으키는 것에 주의해야 합니다.</p>
<dl class="py method" id="index-32">
<dt class="sig sig-object py" id="generator.__next__">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">__next__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="expressions.html#generator.__next__" title="Link to this definition">¶</a></dt>
<dd><p>Starts the execution of a generator function or resumes it at the last
executed yield expression.  When a generator function is resumed with a
<a class="reference internal" href="expressions.html#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> method, the current yield expression always
evaluates to <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.  The execution then continues to the next yield
expression, where the generator is suspended again, and the value of the
<a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> is returned to <a class="reference internal" href="expressions.html#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a>’s
caller.  If the generator exits without yielding another value, a
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception is raised.</p>
<p>이 메서드는 보통 묵시적으로 호출됩니다, 예를 들어, <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 루프나 내장 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 함수에 의해.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="generator.send">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="expressions.html#generator.send" title="Link to this definition">¶</a></dt>
<dd><p>실행을 재개하고 제너레이터 함수로 값을 “보냅니다(send)”. <em>value</em> 인자는 현재 일드 표현식의 값이 됩니다. <a class="reference internal" href="expressions.html#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 메서드는 제너레이터가 yield 하는 다음 값을 돌려주거나, 제너레이터가 다른 값을 yield 하지 않고 종료하면 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 을 일으킵니다. <a class="reference internal" href="expressions.html#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 가 제너레이터를 시작시키도록 호출될 때, 값을 받을 일드 표현식이 없으므로, 인자로는 반드시 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 을 전달해야 합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="generator.throw">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="expressions.html#generator.throw" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Raises an exception at the point where the generator was paused,
and returns the next value yielded by the generator function.  If the generator
exits without yielding another value, a <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception is
raised.  If the generator function does not catch the passed-in exception, or
raises a different exception, then that exception propagates to the caller.</p>
<p>In typical use, this is called with a single exception instance similar to the
way the <a class="reference internal" href="simple_stmts.html#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> keyword is used.</p>
<p>For backwards compatibility, however, the second signature is
supported, following a convention from older versions of Python.
The <em>type</em> argument should be an exception class, and <em>value</em>
should be an exception instance. If the <em>value</em> is not provided, the
<em>type</em> constructor is called to get an instance. If <em>traceback</em>
is provided, it is set on the exception, otherwise any existing
<a class="reference internal" href="../library/exceptions.html#BaseException.__traceback__" title="BaseException.__traceback__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__traceback__</span></code></a> attribute stored in <em>value</em> may
be cleared.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span>The second signature (type[, value[, traceback]]) is deprecated and
may be removed in a future version of Python.</p>
</div>
</dd></dl>

<dl class="py method" id="index-33">
<dt class="sig sig-object py" id="generator.close">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="expressions.html#generator.close" title="Link to this definition">¶</a></dt>
<dd><p>제너레이터가 일시 정지한 지점에서 <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> 를 일으킵니다. 그런 다음 제너레이터 함수가 우아하게(gracefully) 종료하거나, 이미 닫혔거나, (그 예외를 잡지 않음으로써) <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> 를 일으키면 close는 호출자로 돌아갑니다. 제너레이터가 값을 yield 하면 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 가 발생합니다. 제너레이터가 다른 예외를 일으키면, 호출자로 퍼집니다. 제너레이터가 예외나 정상 종료로 인해 이미 종료되었다면, <a class="reference internal" href="expressions.html#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 는 아무런 일도 하지 않습니다.</p>
</dd></dl>

</section>
<section id="examples">
<span id="index-34"></span><h4><span class="section-number">6.2.9.2. </span>사용 예<a class="headerlink" href="expressions.html#examples" title="Link to this heading">¶</a></h4>
<p>여기에 제너레이터와 제너레이터 함수의 동작을 시연하는 간단한 예가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Execution starts when &#39;next()&#39; is called for the first time.&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="n">e</span>
<span class="gp">... </span>    <span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Don&#39;t forget to clean up when &#39;close()&#39; is called.&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span> <span class="o">=</span> <span class="n">echo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">Execution starts when &#39;next()&#39; is called for the first time.</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">generator</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="s2">&quot;spam&quot;</span><span class="p">)</span>
<span class="go">TypeError(&#39;spam&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">Don&#39;t forget to clean up when &#39;close()&#39; is called.</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 을 사용하는 예는, “What’s New in Python.” 에 있는 <a class="reference internal" href="../whatsnew/3.3.html#pep-380"><span class="std std-ref">PEP 380: Syntax for Delegating to a Subgenerator</span></a> 을 보세요.</p>
</section>
<section id="asynchronous-generator-functions">
<span id="id3"></span><h4><span class="section-number">6.2.9.3. </span>비동기 제너레이터 함수<a class="headerlink" href="expressions.html#asynchronous-generator-functions" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 를 사용한 함수나 메서드에서 일드 표현식의 존재는 그 함수를 <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">비동기 제너레이터</span></a> 함수로 정의합니다.</p>
<p>비동기 제너레이터 함수가 호출되면, 비동기 제너레이터 객체로 알려진 비동기 이터레이터를 돌려줍니다. 그런 다음 그 객체는 제너레이터 함수의 실행을 제어합니다. 비동기 제너레이터 객체는 보통 코루틴 함수의 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 문에서 사용되는데, 제너레이터 객체가 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 문에서 사용되는 방식과 유사합니다.</p>
<p>Calling one of the asynchronous generator’s methods returns an <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a>
object, and the execution starts when this object is awaited on. At that time,
the execution proceeds to the first yield expression, where it is suspended
again, returning the value of <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> to the
awaiting coroutine. As with a generator, suspension means that all local state
is retained, including the current bindings of local variables, the instruction
pointer, the internal evaluation stack, and the state of any exception handling.
When the execution is resumed by awaiting on the next object returned by the
asynchronous generator’s methods, the function can proceed exactly as if the
yield expression were just another external call. The value of the yield
expression after resuming depends on the method which resumed the execution.  If
<a class="reference internal" href="expressions.html#agen.__anext__" title="agen.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> is used then the result is <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>. Otherwise, if
<a class="reference internal" href="expressions.html#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> is used, then the result will be the value passed in to that
method.</p>
<p>If an asynchronous generator happens to exit early by <a class="reference internal" href="simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a>, the caller
task being cancelled, or other exceptions, the generator’s async cleanup code
will run and possibly raise exceptions or access context variables in an
unexpected context–perhaps after the lifetime of tasks it depends, or
during the event loop shutdown when the async-generator garbage collection hook
is called.
To prevent this, the caller must explicitly close the async generator by calling
<a class="reference internal" href="expressions.html#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> method to finalize the generator and ultimately detach it
from the event loop.</p>
<p>비동기 제너레이터 함수에서, 일드 표현식은 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 구조물의 어디에서건 허락됩니다. 하지만, 비동기 제너레이터가 (참조 횟수가 0이 되거나 가비지 수거됨으로써) 파이널라이즈(finalize)되기 전에 재개되지 않으면, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code> 구조물 내의 일드 표현식은 대기 중인 <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절을 실행하는 데 실패할 수 있습니다. 이 경우에, 비동기 제너레이터-이터레이터의 <a class="reference internal" href="expressions.html#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> 를 호출하고, 그 결과로 오는 코루틴 객체를 실행해서, 대기 중인 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 절이 실행되도록 하는 책임은, 비동기 제너레이터를 실행하는 이벤트 루프(event loop)나 스케줄러(scheduler)에게 있습니다.</p>
<p>To take care of finalization upon event loop termination, an event loop should
define a <em>finalizer</em> function which takes an asynchronous generator-iterator and
presumably calls <a class="reference internal" href="expressions.html#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> and executes the coroutine.
This  <em>finalizer</em> may be registered by calling <a class="reference internal" href="../library/sys.html#sys.set_asyncgen_hooks" title="sys.set_asyncgen_hooks"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.set_asyncgen_hooks()</span></code></a>.
When first iterated over, an asynchronous generator-iterator will store the
registered <em>finalizer</em> to be called upon finalization. For a reference example
of a <em>finalizer</em> method see the implementation of
<code class="docutils literal notranslate"><span class="pre">asyncio.Loop.shutdown_asyncgens</span></code> in <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/asyncio/base_events.py">Lib/asyncio/base_events.py</a>.</p>
<p>표현식 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> 를 비동기 제너레이터 함수에서 사용하는 것은 문법 에러다.</p>
</section>
<section id="asynchronous-generator-iterator-methods">
<span id="asynchronous-generator-methods"></span><span id="index-35"></span><h4><span class="section-number">6.2.9.4. </span>비동기 제너레이터-이터레이터 메서드<a class="headerlink" href="expressions.html#asynchronous-generator-iterator-methods" title="Link to this heading">¶</a></h4>
<p>이 서브섹션은 비동기 제너레이터 이터레이터의 메서드를 설명하는데, 제너레이터 함수의 실행을 제어하는 데 사용됩니다.</p>
<dl class="py method" id="index-36">
<dt class="sig sig-object py" id="agen.__anext__">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">__anext__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="expressions.html#agen.__anext__" title="Link to this definition">¶</a></dt>
<dd><p>Returns an awaitable which when run starts to execute the asynchronous
generator or resumes it at the last executed yield expression.  When an
asynchronous generator function is resumed with an <a class="reference internal" href="expressions.html#agen.__anext__" title="agen.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a>
method, the current yield expression always evaluates to <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> in the
returned awaitable, which when run will continue to the next yield
expression. The value of the <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> of the
yield expression is the value of the <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception raised by
the completing coroutine.  If the asynchronous generator exits without
yielding another value, the awaitable instead raises a
<a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> exception, signalling that the asynchronous
iteration has completed.</p>
<p>이 메서드는 보통 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 루프에 의해 묵시적으로 호출됩니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="agen.asend">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">asend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="expressions.html#agen.asend" title="Link to this definition">¶</a></dt>
<dd><p>어웨이터블을 돌려주는데, 실행하면 비동기 제너레이터의 실행을 재개합니다. 제너레이터의 <a class="reference internal" href="expressions.html#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 메서드 처럼, 이것은 값을 비동기 제너레이터 함수로 “보내(send)”고, <em>value</em> 인자는 현재 일드 표현식의 결과가 됩니다. <a class="reference internal" href="expressions.html#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> 메서드가 돌려주는 어웨이터블은 제너레이터가 yield 하는 다음 값을 발생시킨 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 의 값으로 돌려주거나, 비동기 제너레이터가 다른 값을 yield 하지 않고 종료하면 <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 를 일으킵니다. 비동기 제너레이터를 시작시키도록 <a class="reference internal" href="expressions.html#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> 가 호출될 때, 값을 받을 일드 표현식이 없으므로 인자를 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 으로 호출해야 합니다.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="agen.athrow">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">athrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="expressions.html#agen.athrow" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">athrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>어웨이터블을 돌려주는데, 비동기 제너레이터가 일시 중지한 지점에 <code class="docutils literal notranslate"><span class="pre">type</span></code> 형의 예외를 일으키고, 제너레이터 함수가 yield 한 다음 값을 발생하는 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 예외의 값으로 돌려줍니다. 비동기 제너레이터가 다른 값을 yield 하지 않고 종료하면, 어웨이터블에 의해 <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 예외가 일어납니다. 제너레이터 함수가 전달된 예외를 잡지 않거나, 다른 예외를 일으키면, 어웨이터블을 실행할 때 그 예외가 어웨이터블의 호출자에게 퍼집니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.12에서 변경: </span>The second signature (type[, value[, traceback]]) is deprecated and
may be removed in a future version of Python.</p>
</div>
</dd></dl>

<dl class="py method" id="index-37">
<dt class="sig sig-object py" id="agen.aclose">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="expressions.html#agen.aclose" title="Link to this definition">¶</a></dt>
<dd><p>어웨이터블을 돌려주는데, 실행하면, 비동기 제너레이터 함수가 일시 정지한 지점으로 <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> 를 던집니다. 만약 그 이후에 비동기 제너레이터 함수가 우아하게 (gracefully) 종료하거나, 이미 닫혔거나, (그 예외를 잡지 않음으로써) <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> 를 일으키면, 돌려준 어웨이터블은 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 예외를 일으킵니다. 이어지는 비동기 제너레이터 호출이 돌려주는 추가의 어웨이터블들은 <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 예외를 일으킵니다. 만약 비동기 제너레이터가 값을 yield 하면 어웨이터블에 의해 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 가 발생합니다. 만약 비동기 제너레이터가 그 밖의 다른 예외를 일으키면, 어웨이터블의 호출자로 퍼집니다. 만약 비동기 제너레이터가 예외나 정상 종료로 이미 종료했으면, 더 이어지는 <a class="reference internal" href="expressions.html#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> 호출은 아무것도 하지 않는 어웨이터블을 돌려줍니다.</p>
</dd></dl>

</section>
</section>
</section>
<section id="primaries">
<span id="id4"></span><h2><span class="section-number">6.3. </span>프라이머리<a class="headerlink" href="expressions.html#primaries" title="Link to this heading">¶</a></h2>
<p id="index-38">프라이머리는 언어에서 가장 강하게 결합하는 연산들을 나타냅니다. 문법은 이렇습니다:</p>
<pre>
<strong id="grammar-token-python-grammar-primary">primary</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-atom"><code class="xref docutils literal notranslate"><span class="pre">atom</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-attributeref"><code class="xref docutils literal notranslate"><span class="pre">attributeref</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-subscription"><code class="xref docutils literal notranslate"><span class="pre">subscription</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-slicing"><code class="xref docutils literal notranslate"><span class="pre">slicing</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-call"><code class="xref docutils literal notranslate"><span class="pre">call</span></code></a>
</pre>
<section id="attribute-references">
<span id="id5"></span><h3><span class="section-number">6.3.1. </span>어트리뷰트 참조<a class="headerlink" href="expressions.html#attribute-references" title="Link to this heading">¶</a></h3>
<p id="index-39">어트리뷰트 참조는 마침표(period)와 이름이 뒤에 붙은 프라이머리다:</p>
<pre>
<strong id="grammar-token-python-grammar-attributeref">attributeref</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;.&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
</pre>
<p id="index-40">The primary must evaluate to an object of a type that supports attribute
references, which most objects do.  This object is then asked to produce the
attribute whose name is the identifier. The type and value produced is
determined by the object.  Multiple evaluations of the same attribute
reference may yield different objects.</p>
<p>This production can be customized by overriding the
<a class="reference internal" href="datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> method or the <a class="reference internal" href="datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>
method.  The <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code> method is called first and either
returns a value or raises <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> if the attribute is not
available.</p>
<p>If an <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> is raised and the object has a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code>
method, that method is called as a fallback.</p>
</section>
<section id="subscriptions">
<span id="id6"></span><h3><span class="section-number">6.3.2. </span>서브스크립션(Subscriptions)<a class="headerlink" href="expressions.html#subscriptions" title="Link to this heading">¶</a></h3>
<p id="index-42"><span id="index-41"></span>The subscription of an instance of a <a class="reference internal" href="datamodel.html#sequence-types"><span class="std std-ref">container class</span></a>
will generally select an element from the container. The subscription of a
<a class="reference internal" href="../glossary.html#term-generic-type"><span class="xref std std-term">generic class</span></a> will generally return a
<a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias</span></a> object.</p>
<pre>
<strong id="grammar-token-python-grammar-subscription">subscription</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression_list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> &quot;]&quot;
</pre>
<p>When an object is subscripted, the interpreter will evaluate the primary and
the expression list.</p>
<p>The primary must evaluate to an object that supports subscription. An object
may support subscription through defining one or both of
<a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> and <a class="reference internal" href="datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>. When the
primary is subscripted, the evaluated result of the expression list will be
passed to one of these methods. For more details on when <code class="docutils literal notranslate"><span class="pre">__class_getitem__</span></code>
is called instead of <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>, see <a class="reference internal" href="datamodel.html#classgetitem-versus-getitem"><span class="std std-ref">__class_getitem__ versus __getitem__</span></a>.</p>
<p>If the expression list contains at least one comma, it will evaluate to a
<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the items of the expression list. Otherwise, the
expression list will evaluate to the value of the list’s sole member.</p>
<p>For built-in objects, there are two types of objects that support subscription
via <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>:</p>
<ol class="arabic simple">
<li><p>Mappings. If the primary is a <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>, the expression list must
evaluate to an object whose value is one of the keys of the mapping, and the
subscription selects the value in the mapping that corresponds to that key.
An example of a builtin mapping class is the <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> class.</p></li>
<li><p>Sequences. If the primary is a <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequence</span></a>, the expression list must
evaluate to an <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> or a <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> (as discussed in the
following section). Examples of builtin sequence classes include the
<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> and <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> classes.</p></li>
</ol>
<p>The formal syntax makes no special provision for negative indices in
<a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequences</span></a>. However, built-in sequences all provide a <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>
method that interprets negative indices by adding the length of the sequence
to the index so that, for example, <code class="docutils literal notranslate"><span class="pre">x[-1]</span></code> selects the last item of <code class="docutils literal notranslate"><span class="pre">x</span></code>. The
resulting value must be a nonnegative integer less than the number of items in
the sequence, and the subscription selects the item whose index is that value
(counting from zero). Since the support for negative indices and slicing
occurs in the object’s <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method, subclasses overriding
this method will need to explicitly add that support.</p>
<p id="index-43">A <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">string</span></code></a> is a special kind of sequence whose items are
<em>characters</em>. A character is not a separate data type but a
string of exactly one character.</p>
</section>
<section id="slicings">
<span id="id7"></span><h3><span class="section-number">6.3.3. </span>슬라이싱(Slicings)<a class="headerlink" href="expressions.html#slicings" title="Link to this heading">¶</a></h3>
<p id="index-45"><span id="index-44"></span>슬라이싱은 시퀀스 객체 (예를 들어, 문자열 튜플 리스트)에서 어떤 범위의 항목들을 선택합니다. 슬라이싱은 표현식이나 대입의 타깃이나 <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> 문에 사용될 수 있습니다. 슬라이싱의 문법은 이렇습니다:</p>
<pre>
<strong id="grammar-token-python-grammar-slicing">slicing     </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-slice_list"><code class="xref docutils literal notranslate"><span class="pre">slice_list</span></code></a> &quot;]&quot;
<strong id="grammar-token-python-grammar-slice_list">slice_list  </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-slice_item"><code class="xref docutils literal notranslate"><span class="pre">slice_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-slice_item"><code class="xref docutils literal notranslate"><span class="pre">slice_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-slice_item">slice_item  </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-proper_slice"><code class="xref docutils literal notranslate"><span class="pre">proper_slice</span></code></a>
<strong id="grammar-token-python-grammar-proper_slice">proper_slice</strong> ::=  [<a class="reference internal" href="expressions.html#grammar-token-python-grammar-lower_bound"><code class="xref docutils literal notranslate"><span class="pre">lower_bound</span></code></a>] &quot;:&quot; [<a class="reference internal" href="expressions.html#grammar-token-python-grammar-upper_bound"><code class="xref docutils literal notranslate"><span class="pre">upper_bound</span></code></a>] [ &quot;:&quot; [<a class="reference internal" href="expressions.html#grammar-token-python-grammar-stride"><code class="xref docutils literal notranslate"><span class="pre">stride</span></code></a>] ]
<strong id="grammar-token-python-grammar-lower_bound">lower_bound </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-upper_bound">upper_bound </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-stride">stride      </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>이 형식 문법에는 모호함이 있습니다: 표현식 목록처럼 보이는 것들은 모두 슬라이스 목록으로 보이기도 해서, 모든 서브스크립션이 슬라이싱으로 해석될 수도 있습니다. 문법을 더 복잡하게 만드는 대신, 이 경우에 서브스크립션으로 해석하는 것이 슬라이싱으로 해석하는 것에 우선한다고 정의하는 것으로 애매함을 제거합니다 (이 경우는 슬라이스 목록이 고유한 슬라이스(proper slice) 를 하나도 포함하지 않을 때입니다).</p>
<p id="index-46">The semantics for a slicing are as follows.  The primary is indexed (using the
same <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method as
normal subscription) with a key that is constructed from the slice list, as
follows.  If the slice list contains at least one comma, the key is a tuple
containing the conversion of the slice items; otherwise, the conversion of the
lone slice item is the key.  The conversion of a slice item that is an
expression is that expression.  The conversion of a proper slice is a slice
object (see section <a class="reference internal" href="datamodel.html#types"><span class="std std-ref">표준형 계층</span></a>) whose <a class="reference internal" href="../library/functions.html#slice.start" title="slice.start"><code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code></a>,
<a class="reference internal" href="../library/functions.html#slice.stop" title="slice.stop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code></a> and <a class="reference internal" href="../library/functions.html#slice.step" title="slice.step"><code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code></a> attributes are the values of the
expressions given as lower bound, upper bound and stride, respectively,
substituting <code class="docutils literal notranslate"><span class="pre">None</span></code> for missing expressions.</p>
</section>
<section id="calls">
<span id="index-47"></span><span id="id8"></span><h3><span class="section-number">6.3.4. </span>호출<a class="headerlink" href="expressions.html#calls" title="Link to this heading">¶</a></h3>
<p>호출은 콜러블 객체 (예를 들어, <a class="reference internal" href="../glossary.html#term-function"><span class="xref std std-term">함수</span></a>) 를 빌 수도 있는 <a class="reference internal" href="../glossary.html#term-argument"><span class="xref std std-term">인자</span></a> 들의 목록으로 호출합니다.</p>
<pre>
<strong id="grammar-token-python-grammar-call">call                </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;(&quot; [<a class="reference internal" href="expressions.html#grammar-token-python-grammar-argument_list"><code class="xref docutils literal notranslate"><span class="pre">argument_list</span></code></a> [&quot;,&quot;] | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>] &quot;)&quot;
<strong id="grammar-token-python-grammar-argument_list">argument_list       </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-positional_arguments"><code class="xref docutils literal notranslate"><span class="pre">positional_arguments</span></code></a> [&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-starred_and_keywords"><code class="xref docutils literal notranslate"><span class="pre">starred_and_keywords</span></code></a>]
                            [&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>]
                          | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-starred_and_keywords"><code class="xref docutils literal notranslate"><span class="pre">starred_and_keywords</span></code></a> [&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>]
                          | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>
<strong id="grammar-token-python-grammar-positional_arguments">positional_arguments</strong> ::=  positional_item (&quot;,&quot; positional_item)*
<strong id="grammar-token-python-grammar-positional_item">positional_item     </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-assignment_expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> | &quot;*&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-starred_and_keywords">starred_and_keywords</strong> ::=  (&quot;*&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a>)
                          (&quot;,&quot; &quot;*&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | &quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a>)*
<strong id="grammar-token-python-grammar-keywords_arguments">keywords_arguments  </strong> ::=  (<a class="reference internal" href="expressions.html#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a> | &quot;**&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)
                          (&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a> | &quot;,&quot; &quot;**&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)*
<strong id="grammar-token-python-grammar-keyword_item">keyword_item        </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> &quot;=&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>생략할 수 있는 마지막 쉼표가 위치나 키워드 인자 뒤에 나타날 수 있지만, 의미를 바꾸지 않습니다.</p>
<p id="index-48">The primary must evaluate to a callable object (user-defined functions, built-in
functions, methods of built-in objects, class objects, methods of class
instances, and all objects having a <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> method are callable).  All
argument expressions are evaluated before the call is attempted.  Please refer
to section <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a> for the syntax of formal <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameter</span></a> lists.</p>
<p>If keyword arguments are present, they are first converted to positional
arguments, as follows.  First, a list of unfilled slots is created for the
formal parameters.  If there are N positional arguments, they are placed in the
first N slots.  Next, for each keyword argument, the identifier is used to
determine the corresponding slot (if the identifier is the same as the first
formal parameter name, the first slot is used, and so on).  If the slot is
already filled, a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception is raised. Otherwise, the
argument is placed in the slot, filling it (even if the expression is
<code class="docutils literal notranslate"><span class="pre">None</span></code>, it fills the slot).  When all arguments have been processed, the slots
that are still unfilled are filled with the corresponding default value from the
function definition.  (Default values are calculated, once, when the function is
defined; thus, a mutable object such as a list or dictionary used as default
value will be shared by all calls that don’t specify an argument value for the
corresponding slot; this should usually be avoided.)  If there are any unfilled
slots for which no default value is specified, a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception is
raised.  Otherwise, the list of filled slots is used as the argument list for
the call.</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> 구현은 위치 매개변수가 이름을 갖지 않아서, 설사 문서화의 목적으로 이름이 붙여졌다 하더라도, 키워드로 공급될 수 없는 내장 함수들을 제공할 수 있습니다. CPython 에서, 인자들을 파싱하기 위해 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> 를 사용하는 C로 구현된 함수들이 이 경우입니다.</p>
</div>
<p>형식 매개변수 슬롯들보다 많은 위치 인자들이 있으면, <code class="docutils literal notranslate"><span class="pre">*identifier</span></code> 문법을 사용하는 형식 매개변수가 있지 않은 한, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 예외를 일으킵니다; 이 경우, 그 형식 매개변수는 남는 위치 인자들을 포함하는 튜플을 전달받습니다 (또는 남는 위치 인자들이 없으면 빈 튜플).</p>
<p>키워드 인자가 형식 매개변수 이름에 대응하지 않으면, <code class="docutils literal notranslate"><span class="pre">**identifier</span></code> 문법을 사용하는 형식 매개변수가 있지 않은 한, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 예외를 일으킵니다; 이 경우, 그 형식 매개변수는 남는 키워드 인자들을 포함하는 딕셔너리나, 남는 위치기반 인자들이 없으면 빈 (새) 딕셔너리를 전달받습니다.</p>
<p id="index-49">문법 <code class="docutils literal notranslate"><span class="pre">*expression</span></code> 이 함수 호출에 등장하면, <code class="docutils literal notranslate"><span class="pre">expression</span></code> 의 값은 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">이터러블</span></a> 이 되어야 합니다. 이 이터러블의 요소들은, 그것들이 추가의 위치 인자들인 것처럼 취급됩니다. 호출 <code class="docutils literal notranslate"><span class="pre">f(x1,</span> <span class="pre">x2,</span> <span class="pre">*y,</span> <span class="pre">x3,</span> <span class="pre">x4)</span></code> 의 경우, <em>y</em> 의 값을 구할 때 시퀀스 <em>y1</em>, …, <em>yM</em> 이 나온다면, 이것은 M+4개의 위치 인자들 <em>x1</em>, <em>x2</em>, <em>y1</em>, …, <em>yM</em>, <em>x3</em>, <em>x4</em> 로 호출하는 것과 동등합니다.</p>
<p>이로 인한 결과는 설사 <code class="docutils literal notranslate"><span class="pre">*expression</span></code> 문법이 명시적인 키워드 인자 <em>뒤에</em> 나올 수는 있어도, 키워드 인자 (그리고 모든 <code class="docutils literal notranslate"><span class="pre">**expression</span></code> 인자들 – 아래를 보라) <em>전에</em> 처리된다는 것입니다. 그래서:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">2 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">f() got multiple values for keyword argument &#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">1 2</span>
</pre></div>
</div>
<p>It is unusual for both keyword arguments and the <code class="docutils literal notranslate"><span class="pre">*expression</span></code> syntax to be
used in the same call, so in practice this confusion does not often arise.</p>
<p id="index-50">If the syntax <code class="docutils literal notranslate"><span class="pre">**expression</span></code> appears in the function call, <code class="docutils literal notranslate"><span class="pre">expression</span></code> must
evaluate to a <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>, the contents of which are treated as
additional keyword arguments. If a parameter matching a key has already been
given a value (by an explicit keyword argument, or from another unpacking),
a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception is raised.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">**expression</span></code> is used, each key in this mapping must be
a string.
Each value from the mapping is assigned to the first formal parameter
eligible for keyword assignment whose name is equal to the key.
A key need not be a Python identifier (e.g. <code class="docutils literal notranslate"><span class="pre">&quot;max-temp</span> <span class="pre">°F&quot;</span></code> is acceptable,
although it will not match any formal parameter that could be declared).
If there is no match to a formal parameter
the key-value pair is collected by the <code class="docutils literal notranslate"><span class="pre">**</span></code> parameter, if there is one,
or if there is not, a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception is raised.</p>
<p>문법 <code class="docutils literal notranslate"><span class="pre">*identifier</span></code> 이나 <code class="docutils literal notranslate"><span class="pre">**identifier</span></code> 를 사용하는 형식 매개변수들은 위치 인자 슬롯이나 키워드 인자 아름들로 사용될 수 없습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>함수 호출은 임의의 개수의 <code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">**</span></code> 언 패킹을 받아들이고, 위치 인자들이 이터러블 언 패킹 (<code class="docutils literal notranslate"><span class="pre">*</span></code>) 뒤에 올 수 있고, 키워드 인자가 딕셔너리 언 패킹 (<code class="docutils literal notranslate"><span class="pre">**</span></code>) 뒤에 올 수 있습니다. 최초로 <span class="target" id="index-116"></span><a class="pep reference external" href="https://peps.python.org/pep-0448/"><strong>PEP 448</strong></a> 에서 제안되었습니다.</p>
</div>
<p>호출은 예외를 일으키지 않는 한, 항상 어떤 값을 돌려줍니다, <code class="docutils literal notranslate"><span class="pre">None</span></code> 일 수 있습니다. 이 값이 어떻게 계산되는지는 콜러블 객체의 형에 달려있습니다.</p>
<p>만약 그것이—</p>
<dl>
<dt>사용자 정의 함수면:</dt><dd><p id="index-52">인자 목록을 전달해서 함수의 코드 블록이 실행됩니다. 코드 블록이 처음으로 하는 일은 형식 매개변수들을 인자에 결합하는 것입니다; 이것은 섹션 <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a> 에서 설명합니다. 코드 블록이 <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 문을 실행하면, 함수 호출의 반환 값을 지정하게 됩니다.</p>
</dd>
<dt>내장 함수나 메서드면:</dt><dd><p id="index-53">결과는 인터프리터에 달려있습니다; 내장 함수와 메서드들에 대한 설명은 <a class="reference internal" href="../library/functions.html#built-in-funcs"><span class="std std-ref">내장 함수</span></a> 를 보세요.</p>
</dd>
<dt>클래스 객체면:</dt><dd><p id="index-54">그 클래스의 새 인스턴스가 반환됩니다.</p>
</dd>
<dt>클래스 인스턴스 메서드면:</dt><dd><p id="index-55">대응하는 사용자 정의 함수가 호출되는데, 그 인스턴스가 첫 번째 인자가 되는 하나만큼 더 긴 인자 목록이 전달됩니다.</p>
</dd>
<dt>클래스 인스턴스면:</dt><dd><p id="index-56">The class must define a <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> method; the effect is then the same as
if that method was called.</p>
</dd>
</dl>
</section>
</section>
<section id="await-expression">
<span id="await"></span><span id="index-57"></span><h2><span class="section-number">6.4. </span>어웨이트 표현식<a class="headerlink" href="expressions.html#await-expression" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a> 에서 <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">코루틴</span></a> 의 실행을 일시 중지합니다. 오직 <a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">코루틴 함수</span></a> 에서만 사용할 수 있습니다.</p>
<pre>
<strong id="grammar-token-python-grammar-await_expr">await_expr</strong> ::=  &quot;await&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a>
</pre>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</section>
<section id="the-power-operator">
<span id="power"></span><h2><span class="section-number">6.5. </span>거듭제곱 연산자<a class="headerlink" href="expressions.html#the-power-operator" title="Link to this heading">¶</a></h2>
<p id="index-58">거듭제곱 연산자는 그것의 왼쪽에 붙는 일 항 연산자보다 더 강하게 결합합니다; 그것의 오른쪽에 붙는 일 항 연산자보다는 약하게 결합합니다. 문법은 이렇습니다:</p>
<pre>
<strong id="grammar-token-python-grammar-power">power</strong> ::=  (<a class="reference internal" href="expressions.html#grammar-token-python-grammar-await_expr"><code class="xref docutils literal notranslate"><span class="pre">await_expr</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a>) [&quot;**&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>]
</pre>
<p>그래서, 괄호가 없는 거듭제곱과 일 항 연산자의 시퀀스에서, 연산자는 오른쪽에서 왼쪽으로 값이 구해집니다 (이것이 피연산자의 값을 구하는 순서를 제약하는 것은 아닙니다): <code class="docutils literal notranslate"><span class="pre">-1**2</span></code> 은 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 이 됩니다.</p>
<p>거듭제곱 연산자는 내장 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> 함수가 두 개의 인자로 호출될 때와 같은 의미가 있습니다: 왼쪽 인자를 오른쪽 인자만큼 거듭제곱한 값을 줍니다. 숫자 인자는 먼저 공통 형으로 변환되고, 결과는 그 형입니다.</p>
<p>int 피연산자의 경우, 두 번째 인자가 음수가 아닌 이상 결과는 피연산자들과 같은 형을 갖습니다; 두 번째 인자가 음수면, 모든 인자는 float로 변환되고, float 결과가 전달됩니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">10**2</span></code> 는 <code class="docutils literal notranslate"><span class="pre">100</span></code> 를 돌려주지만, <code class="docutils literal notranslate"><span class="pre">10**-2</span></code> 는 <code class="docutils literal notranslate"><span class="pre">0.01</span></code> 를 돌려줍니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">0.0</span></code> 를 음수로 거듭제곱하면 <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a> 를 일으킵니다. 음수를 분수로 거듭제곱하면 복소수(<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>)가 나옵니다. (예전 버전에서는 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 를 일으켰습니다.)</p>
<p>This operation can be customized using the special <a class="reference internal" href="datamodel.html#object.__pow__" title="object.__pow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pow__()</span></code></a> method.</p>
</section>
<section id="unary-arithmetic-and-bitwise-operations">
<span id="unary"></span><h2><span class="section-number">6.6. </span>일 항 산술과 비트 연산<a class="headerlink" href="expressions.html#unary-arithmetic-and-bitwise-operations" title="Link to this heading">¶</a></h2>
<p id="index-59">모든 일 항 산술과 비트 연산자는 같은 우선순위를 갖습니다.</p>
<pre>
<strong id="grammar-token-python-grammar-u_expr">u_expr</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-power"><code class="xref docutils literal notranslate"><span class="pre">power</span></code></a> | &quot;-&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | &quot;+&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | &quot;~&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>
</pre>
<p id="index-60">The unary <code class="docutils literal notranslate"><span class="pre">-</span></code> (minus) operator yields the negation of its numeric argument; the
operation can be overridden with the <a class="reference internal" href="datamodel.html#object.__neg__" title="object.__neg__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__neg__()</span></code></a> special method.</p>
<p id="index-61">The unary <code class="docutils literal notranslate"><span class="pre">+</span></code> (plus) operator yields its numeric argument unchanged; the
operation can be overridden with the <a class="reference internal" href="datamodel.html#object.__pos__" title="object.__pos__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pos__()</span></code></a> special method.</p>
<p id="index-62">The unary <code class="docutils literal notranslate"><span class="pre">~</span></code> (invert) operator yields the bitwise inversion of its integer
argument.  The bitwise inversion of <code class="docutils literal notranslate"><span class="pre">x</span></code> is defined as <code class="docutils literal notranslate"><span class="pre">-(x+1)</span></code>.  It only
applies to integral numbers or to custom objects that override the
<a class="reference internal" href="datamodel.html#object.__invert__" title="object.__invert__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__invert__()</span></code></a> special method.</p>
<p id="index-63">세 가지 경우 모두, 인자가 올바른 형을 갖지 않는다면, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 예외가 발생합니다.</p>
</section>
<section id="binary-arithmetic-operations">
<span id="binary"></span><h2><span class="section-number">6.7. </span>이항 산술 연산<a class="headerlink" href="expressions.html#binary-arithmetic-operations" title="Link to this heading">¶</a></h2>
<p id="index-64">이항 산술 연산자는 관습적인 우선순위를 갖습니다. 이 연산자 중 일부는 일부 비 숫자 형에도 적용됨에 주의해야 합니다. 거듭제곱 연산자와는 별개로, 오직 두 가지 수준만 있는데, 하나는 곱셈형 연산자들이고, 하나는 덧셈형 연산자들입니다.</p>
<pre>
<strong id="grammar-token-python-grammar-m_expr">m_expr</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;*&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;&#64;&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> |
            <a class="reference internal" href="expressions.html#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;//&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;/&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> |
            <a class="reference internal" href="expressions.html#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;%&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>
<strong id="grammar-token-python-grammar-a_expr">a_expr</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> &quot;+&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> &quot;-&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a>
</pre>
<p id="index-65"><code class="docutils literal notranslate"><span class="pre">*</span></code> (곱셈) 연산자는 인자들의 곱을 줍니다. 인자들은 모두 숫자거나, 한 인자는 정수고 다른 인자는 시퀀스여야 합니다. 앞의 경우에, 숫자들은 공통 형으로 변환된 후 곱해집니다. 후자의 경우, 시퀀스의 반복이 수행됩니다; 음의 반복 값은 빈 시퀀스를 만듭니다.</p>
<p>This operation can be customized using the special <a class="reference internal" href="datamodel.html#object.__mul__" title="object.__mul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mul__()</span></code></a> and
<a class="reference internal" href="datamodel.html#object.__rmul__" title="object.__rmul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rmul__()</span></code></a> methods.</p>
<p id="index-66"><code class="docutils literal notranslate"><span class="pre">&#64;</span></code> (at) 연산자는 행렬 곱셈에 사용하려는 것입니다. 파이썬의 내장형들 어느 것도 이 연산자를 구현하지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<p id="index-67"><code class="docutils literal notranslate"><span class="pre">/</span></code> (나눗셈)과 <code class="docutils literal notranslate"><span class="pre">//</span></code> (정수 나눗셈, floor division) 연산자들은 그 인자들의 몫(quotient)을 줍니다. 숫자 인자들은 먼저 공통형으로 변환됩니다. 정수들의 나눗셈은 실수를 만드는 반면, 정수들의 정수 나눗셈은 정숫값을 줍니다; 그 결과는 수학적인 나눗셈의 결과에 ‘floor’ 함수를 적용한 것입니다. 0으로 나누는 것은 <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a> 예외를 일으킵니다.</p>
<p>This operation can be customized using the special <a class="reference internal" href="datamodel.html#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a> and
<a class="reference internal" href="datamodel.html#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code></a> methods.</p>
<p id="index-68"><code class="docutils literal notranslate"><span class="pre">%</span></code> (모듈로, modulo) 연산자는 첫 번째 인자를 두 번째 인자로 나눈 나머지를 줍니다. 숫자 인자들은 먼저 공통형으로 변환됩니다. 오른쪽 인자가 0이면 <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a> 예외를 일으킵니다. 인자들은 실수가 될 수 있습니다, 예를 들어, <code class="docutils literal notranslate"><span class="pre">3.14%0.7</span></code> 는 <code class="docutils literal notranslate"><span class="pre">0.34</span></code> 와 같습니다 (<code class="docutils literal notranslate"><span class="pre">3.14</span></code> 가 <code class="docutils literal notranslate"><span class="pre">4*0.7</span> <span class="pre">+</span> <span class="pre">0.34</span></code> 와 같으므로.) 모듈로 연산자는 항상 두 번째 피연산자와 같은 부호를 갖는 결과를 줍니다 (또는 0입니다); 결과의 절댓값은 두 번째 피연산자의 절댓값보다 작습니다 <a class="footnote-reference brackets" href="expressions.html#id17" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<p>정수 나눗셈과 모듈로 연산자는 다음과 같은 항등식으로 연결되어 있습니다: <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x//y)*y</span> <span class="pre">+</span> <span class="pre">(x%y)</span></code>. 정수 나눗셈과 모듈로는 내장 함수 <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> 와도 연결되어 있습니다: <code class="docutils literal notranslate"><span class="pre">divmod(x,</span> <span class="pre">y)</span> <span class="pre">==</span> <span class="pre">(x//y,</span> <span class="pre">x%y)</span></code>. <a class="footnote-reference brackets" href="expressions.html#id18" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p>
<p>숫자들에 대해 모듈로 연산을 수행하는 것에 더해, <code class="docutils literal notranslate"><span class="pre">%</span></code> 연산자는 예전 스타일의 문자열 포매팅 (인터폴레이션이라고도 알려져 있습니다)을 수행하기 위해 문자열 객체에 의해 다시 정의됩니다. 문자열 포매팅의 문법은 파이썬 라이브러리 레퍼런스의 섹션 <a class="reference internal" href="../library/stdtypes.html#old-string-formatting"><span class="std std-ref">printf 스타일 문자열 포매팅</span></a> 에서 설명합니다.</p>
<p>The <em>modulo</em> operation can be customized using the special <a class="reference internal" href="datamodel.html#object.__mod__" title="object.__mod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mod__()</span></code></a> method.</p>
<p>정수 나눗셈 연산자, 모듈로 연산자, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> 함수는 복소수에 대해서는 정의되어 있지 않습니다. 대신, 적절하다면, <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> 함수를 사용해서 실수로 변환하십시오.</p>
<p id="index-69"><code class="docutils literal notranslate"><span class="pre">+</span></code> (덧셈) 연산자는 그 인자들의 합을 줍니다. 인자들은 둘 다 숫자거나, 둘 다 같은 형의 시퀀스여야 합니다. 앞의 경우, 숫자들은 먼저 공통형으로 변환된 후, 함께 합쳐집니다. 후자의 경우 시퀀스는 이어붙이게 됩니다.</p>
<p>This operation can be customized using the special <a class="reference internal" href="datamodel.html#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> and
<a class="reference internal" href="datamodel.html#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__radd__()</span></code></a> methods.</p>
<p id="index-70"><code class="docutils literal notranslate"><span class="pre">-</span></code> (빼기) 연산자는 그 인자들의 차를 줍니다. 숫자 인자들은 먼저 공통형으로 변환됩니다.</p>
<p>This operation can be customized using the special <a class="reference internal" href="datamodel.html#object.__sub__" title="object.__sub__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__sub__()</span></code></a> method.</p>
</section>
<section id="shifting-operations">
<span id="shifting"></span><h2><span class="section-number">6.8. </span>시프트 연산<a class="headerlink" href="expressions.html#shifting-operations" title="Link to this heading">¶</a></h2>
<p id="index-71">시프트 연산은 산술 연산보다 낮은 우선순위를 갖습니다.</p>
<pre>
<strong id="grammar-token-python-grammar-shift_expr">shift_expr</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a> (&quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot;) <a class="reference internal" href="expressions.html#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a>
</pre>
<p>이 연산들은 정수들을 인자로 받아들입니다. 첫 번째 인자를 두 번째 인자로 주어진 비트 수만큼 왼쪽이나 오른쪽으로 밉니다(shift).</p>
<p>This operation can be customized using the special <a class="reference internal" href="datamodel.html#object.__lshift__" title="object.__lshift__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lshift__()</span></code></a> and
<a class="reference internal" href="datamodel.html#object.__rshift__" title="object.__rshift__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rshift__()</span></code></a> methods.</p>
<p id="index-72">오른쪽으로 <em>n</em> 비트 시프트 하는 것은 <code class="docutils literal notranslate"><span class="pre">pow(2,n)</span></code> 로 정수 나눗셈하는 것으로 정의됩니다. 왼쪽으로 <em>n</em> 비트 시프트 하는 것은 <code class="docutils literal notranslate"><span class="pre">pow(2,n)</span></code> 를 곱하는 것으로 정의됩니다.</p>
</section>
<section id="binary-bitwise-operations">
<span id="bitwise"></span><h2><span class="section-number">6.9. </span>이항 비트 연산<a class="headerlink" href="expressions.html#binary-bitwise-operations" title="Link to this heading">¶</a></h2>
<p id="index-73">세 개의 비트 연산은 각기 다른 우선순위를 갖습니다:</p>
<pre>
<strong id="grammar-token-python-grammar-and_expr">and_expr</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a> &quot;&amp;&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a>
<strong id="grammar-token-python-grammar-xor_expr">xor_expr</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a> &quot;^&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a>
<strong id="grammar-token-python-grammar-or_expr">or_expr </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a> &quot;|&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a>
</pre>
<p id="index-74">The <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> operator yields the bitwise AND of its arguments, which must be
integers or one of them must be a custom object overriding <a class="reference internal" href="datamodel.html#object.__and__" title="object.__and__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__and__()</span></code></a> or
<a class="reference internal" href="datamodel.html#object.__rand__" title="object.__rand__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rand__()</span></code></a> special methods.</p>
<p id="index-75">The <code class="docutils literal notranslate"><span class="pre">^</span></code> operator yields the bitwise XOR (exclusive OR) of its arguments, which
must be integers or one of them must be a custom object overriding <a class="reference internal" href="datamodel.html#object.__xor__" title="object.__xor__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__xor__()</span></code></a> or
<a class="reference internal" href="datamodel.html#object.__rxor__" title="object.__rxor__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rxor__()</span></code></a> special methods.</p>
<p id="index-76">The <code class="docutils literal notranslate"><span class="pre">|</span></code> operator yields the bitwise (inclusive) OR of its arguments, which
must be integers or one of them must be a custom object overriding <a class="reference internal" href="datamodel.html#object.__or__" title="object.__or__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__or__()</span></code></a> or
<a class="reference internal" href="datamodel.html#object.__ror__" title="object.__ror__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ror__()</span></code></a> special methods.</p>
</section>
<section id="comparisons">
<span id="id11"></span><h2><span class="section-number">6.10. </span>비교<a class="headerlink" href="expressions.html#comparisons" title="Link to this heading">¶</a></h2>
<p id="index-77">C와는 달리, 파이썬에서 모든 비교 연산은 같은 우선순위를 갖는데, 산술, 시프팅, 비트 연산들보다 낮습니다. 또한, C와는 달리, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">c</span></code> 와 같은 표현식이 수학에서와 같은 방식으로 해석됩니다.</p>
<pre>
<strong id="grammar-token-python-grammar-comparison">comparison   </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a> (<a class="reference internal" href="expressions.html#grammar-token-python-grammar-comp_operator"><code class="xref docutils literal notranslate"><span class="pre">comp_operator</span></code></a> <a class="reference internal" href="expressions.html#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>)*
<strong id="grammar-token-python-grammar-comp_operator">comp_operator</strong> ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;==&quot; | &quot;&gt;=&quot; | &quot;&lt;=&quot; | &quot;!=&quot;
                   | &quot;is&quot; [&quot;not&quot;] | [&quot;not&quot;] &quot;in&quot;
</pre>
<p>Comparisons yield boolean values: <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>. Custom
<em class="dfn">rich comparison methods</em> may return non-boolean values. In this case
Python will call <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a> on such value in boolean contexts.</p>
<p id="index-78">비교는 자유롭게 연결될 수 있습니다, 예를 들어, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> 와 동등한데, 차이점은 <code class="docutils literal notranslate"><span class="pre">y</span></code> 의 값을 오직 한 번만 구한다는 것입니다 (하지만 두 경우 모두 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> 가 거짓이면 <code class="docutils literal notranslate"><span class="pre">z</span></code> 의 값은 구하지 않습니다).</p>
<p>형식적으로, <em>a</em>, <em>b</em>, <em>c</em>, …, <em>y</em>, <em>z</em> 가 표현식이고, <em>op1</em>, <em>op2</em>, …, <em>opN</em> 가 비교 연산자면, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code> 는 각 표현식의 값을 최대 한 번만 구한다는 점을 제외하고는 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">and</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">and</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code> 와 동등합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span></code> 가 <em>a</em> 와 <em>c</em> 간의 어떤 종류의 비교도 암시하지 않기 때문에, 예를 들어, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> 이 완벽하게 (아마 이쁘지는 않더라도) 올바르다는 것에 주의해야 합니다.</p>
<section id="value-comparisons">
<span id="expressions-value-comparisons"></span><h3><span class="section-number">6.10.1. </span>값 비교<a class="headerlink" href="expressions.html#value-comparisons" title="Link to this heading">¶</a></h3>
<p>연산자 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code> 는 두 객체의 값을 비교합니다. 객체들이 같은 형일 필요는 없습니다.</p>
<p><a class="reference internal" href="datamodel.html#objects"><span class="std std-ref">객체, 값, 형</span></a> 장은 객체들이 (형과 아이덴티티에 더해) 값을 갖는다고 말하고 있습니다. 파이썬에서 객체의 값은 좀 추상적인 개념입니다: 예를 들어, 객체의 값에 대한 규범적인(canonical) 액세스 방법은 없습니다. 또한, 객체의 값이 특별한 방식(예를 들어, 모든 데이터 어트리뷰트로 구성되는 것)으로 구성되어야 한다는 요구 사항도 없습니다. 비교 연산자는 객체의 값이 무엇인지에 대한 특정한 종류의 개념을 구현합니다. 객체의 값을 비교를 통해 간접적으로 정의한다고 생각해도 좋습니다.</p>
<p>Because all types are (direct or indirect) subtypes of <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>, they
inherit the default comparison behavior from <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>.  Types can
customize their comparison behavior by implementing
<em class="dfn">rich comparison methods</em> like <a class="reference internal" href="datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a>, described in
<a class="reference internal" href="datamodel.html#customization"><span class="std std-ref">기본적인 커스터마이제이션</span></a>.</p>
<p>동등 비교 (<code class="docutils literal notranslate"><span class="pre">==</span></code> 와 <code class="docutils literal notranslate"><span class="pre">!=</span></code>) 의 기본 동작은 객체의 아이덴티티에 기반을 둡니다. 그래서, 같은 아이덴티티를 갖는 인스턴스 간의 동등 비교는 같음을 주고, 다른 아이덴티티를 갖는 인스턴스 간의 동등 비교는 다름을 줍니다. 이 기본 동작의 동기는 모든 객체가 반사적(reflexive) (즉, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> 를 암시합니다) 이도록 만들고자 하는 욕구입니다.</p>
<p>기본 대소 비교(order comparison) (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>) 는 제공되지 않습니다; 시도하면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으킵니다. 이 기본 동작의 동기는 동등함과 유사한 항등 관계가 없다는 것입니다.</p>
<p>다른 아이덴티티를 갖는 인스턴스들이 항상 서로 다르다는, 기본 동등 비교의 동작은, 객체의 값과 값 기반의 동등함에 대한 나름의 정의를 가진 형들이 필요로 하는 것과는 크게 다를 수 있습니다. 그런 형들은 자신의 비교 동작을 커스터마이즈 할 필요가 있고, 사실 많은 내장형이 그렇게 하고 있습니다.</p>
<p>다음 목록은 가장 중요한 내장형들의 비교 동작을 기술합니다.</p>
<ul>
<li><p>내장 숫자 형 ((<a class="reference internal" href="../library/stdtypes.html#typesnumeric"><span class="std std-ref">숫자 형 — int, float, complex</span></a>)) 과 표준 라이브러리 형 <a class="reference internal" href="../library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a> 과 <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a> 에 속하는 숫자들은, 복소수가 대소 비교를 지원하지 않는다는 제약 사항만 빼고는, 같거나 다른 형들 간의 비교가 가능합니다. 관련된 형들의 한계 안에서, 정밀도의 손실 없이 수학적으로 (알고리즘 적으로) 올바르게 비교합니다.</p>
<p>NaN(not-a-number) 값들 <code class="docutils literal notranslate"><span class="pre">float('NaN')</span></code> 과 <code class="docutils literal notranslate"><span class="pre">decimal.Decimal('NaN')</span></code>은 특별합니다. 모든 숫자와 NaN 간의 비교는 거짓입니다. 반 직관적으로 내포하고 있는 것은, NaN 이 자신과 같지 않다는 것입니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">float('NaN')</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">&lt;</span> <span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">3</span></code> 및 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">x</span></code>는 모두 거짓이지만, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">x</span></code>는 참입니다. 이 동작은 IEEE 754를 준수합니다.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> and <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> are singletons.  <span class="target" id="index-79"></span><a class="pep reference external" href="https://peps.python.org/pep-0008/"><strong>PEP 8</strong></a> advises that
comparisons for singletons should always be done with <code class="docutils literal notranslate"><span class="pre">is</span></code> or <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code>,
never the equality operators.</p></li>
<li><p>바이너리 시퀀스들 (<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 나 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 의 인스턴스들)은 형을 건너 상호 비교될 수 있습니다. 이것들은 요소들의 숫자 값을 사용해서 사전식으로(lexicographically) 비교합니다.</p></li>
<li><p>문자열들 (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 의 인스턴스들) 은 문자들의 유니코드 코드 포인트(Unicode code points) (내장 함수 <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a> 의 결과)를 사용해서 사전식으로 비교합니다. <a class="footnote-reference brackets" href="expressions.html#id19" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p>
<p>문자열과 바이너리 시퀀스는 직접 비교할 수 없습니다.</p>
</li>
<li><p>시퀀스들 (<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a> 의 인스턴스들)은 같은 형끼리 비교될 수 있는데, range는 대소 비교를 지원하지 않습니다. 서로 다른 형들 간의 동등 비교는 다름을 주고, 서로 다른 형들 간의 대소 비교는 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으킵니다.</p>
<p>시퀀스는 대응하는 요소 간의 비교를 사용해서 사전적으로 비교합니다. 내장 컨테이너는 일반적으로 동일한(identical) 객체가 자신과 같다고(equal) 가정합니다. 이를 통해 동일한 객체에 대한 동등성(equality) 검사를 우회하여 성능을 개선하고 내부 불변성을 유지합니다.</p>
<p>내장 컬렉션들의 사전적인 비교는 다음과 같이 이루어집니다:</p>
<ul class="simple">
<li><p>두 컬렉션이 같다고 비교되기 위해서는, 같은 형이고, 길이가 같고, 대응하는 요소들의 각 쌍이 같다고 비교되어야 합니다 (예를 들어, <code class="docutils literal notranslate"><span class="pre">[1,2]</span> <span class="pre">==</span> <span class="pre">(1,2)</span></code> 는 거짓인데, 형이 다르기 때문입니다).</p></li>
<li><p>대소 비교를 지원하는 컬렉션들은 첫 번째로 다른 요소들과 같은 순서를 줍니다 (예를 들어, <code class="docutils literal notranslate"><span class="pre">[1,2,x]</span> <span class="pre">&lt;=</span> <span class="pre">[1,2,y]</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> 와 같은 값입니다). 대응하는 요소가 없는 경우 더 짧은 컬렉션이 작다고 비교됩니다 (예를 들어, <code class="docutils literal notranslate"><span class="pre">[1,2]</span> <span class="pre">&lt;</span> <span class="pre">[1,2,3]</span></code> 은 참입니다).</p></li>
</ul>
</li>
<li><p>Mappings (instances of <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>) compare equal if and only if they have
equal <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code> pairs. Equality comparison of the keys and values
enforces reflexivity.</p>
<p>대소 비교 (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>) 는 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으킵니다.</p>
</li>
<li><p>집합들 (<a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 이나 <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 의 인스턴스들)은 같은 형들과 서로 다른 형들 간에 비교될 수 있습니다.</p>
<p>이것들은 부분집합(subset)과 상위집합(superset)을 뜻하는 대소비교 연산자들을 정의합니다. 이 관계는 전 순서(total ordering)를 정의하지 않습니다 (예를 들어, 두 집합 <code class="docutils literal notranslate"><span class="pre">{1,2}</span></code> 와 <code class="docutils literal notranslate"><span class="pre">{2,3}</span></code> 는 다르면서도, 하나가 다른 하나의 부분집합이지도, 하나가 다른 하나의 상위집합이지도 않습니다). 따라서, 전 순서에 의존하는 함수의 인자로는 적합하지 않습니다 (예를 들어, <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> 에 입력으로 집합의 리스트를 제공하면 정의되지 않은 결과를 줍니다).</p>
<p>집합의 비교는 그 요소들의 반사성을 강제합니다.</p>
</li>
<li><p>대부분의 다른 내장형들은 비교 메서드들을 구현하지 않기 때문에, 기본 비교 동작을 계승합니다.</p></li>
</ul>
<p>비교 동작을 커스터마이즈하는 사용자 정의 클래스들은 가능하다면 몇 가지 일관성 규칙을 준수해야 합니다:</p>
<ul>
<li><p>동등 비교는 반사적(reflexive)이어야 합니다. 다른 말로 표현하면, 아이덴티티가 같은 객체는 같다고 비교되어야 합니다:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> 면 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> 다.</p>
</div></blockquote>
</li>
<li><p>비교는 대칭적(symmetric)이어야 합니다. 다른 말로 표현하면, 다음과 같은 표현식은 같은 결과를 주어야 합니다:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">==</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">!=</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&gt;=</span> <span class="pre">x</span></code></p>
</div></blockquote>
</li>
<li><p>비교는 추이적(transitive)이어야 합니다. 다음 (철저하지 않은) 예들이 이것을 예증합니다:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> 면 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> 다</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> 면 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">z</span></code> 다</p>
</div></blockquote>
</li>
<li><p>역 비교는 논리적 부정이 되어야 합니다. 다른 말로 표현하면, 다음 표현식들이 같은 값을 주어야 합니다:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code> (전 순서의 경우)</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> (전 순서의 경우)</p>
</div></blockquote>
<p>마지막 두 표현식은 전 순서 컬렉션에 적용됩니다 (예를 들어, 시퀀스에는 적용되지만, 집합과 매핑은 그렇지 않습니다). <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">total_ordering()</span></code></a> 데코레이터도 보십시오.</p>
</li>
<li><p><a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 결과는 동등성과 일관성을 유지해야 합니다. 같은 객체들은 같은 해시값을 같거나 해시 불가능으로 지정되어야 합니다.</p></li>
</ul>
<p>파이썬은 이 일관성 규칙들을 강제하지 않습니다. 사실 NaN 값들은 이 규칙을 따르지 않는 예입니다.</p>
</section>
<section id="membership-test-operations">
<span id="membership-test-details"></span><span id="not-in"></span><span id="in"></span><h3><span class="section-number">6.10.2. </span>멤버십 검사 연산<a class="headerlink" href="expressions.html#membership-test-operations" title="Link to this heading">¶</a></h3>
<p>연산자 <a class="reference internal" href="expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 과 <a class="reference internal" href="expressions.html#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a> 은 멤버십을 검사합니다. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code> 는 <em>x</em> 가 <em>s</em> 의 멤버일 때 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를, 그렇지 않을 때 <code class="docutils literal notranslate"><span class="pre">False</span></code> 를 줍니다. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></code> 은 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code> 의 부정을 줍니다. 딕셔너리 뿐만 아니라 모든 내장 시퀀스들과 집합 형들이 이것을 지원하는데, 딕셔너리의 경우는 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code> 이 딕셔너리에 주어진 키가 있는지 검사합니다. list, tuple, set, frozenset, dict, collections.deque 와 같은 컨테이너형들의 경우, 표현식 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">any(x</span> <span class="pre">is</span> <span class="pre">e</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">e</span> <span class="pre">for</span> <span class="pre">e</span> <span class="pre">in</span> <span class="pre">y)</span></code> 와 동등합니다.</p>
<p>문자열과 바이트열 형의 경우, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> 는 <em>x</em> 가 <em>y</em> 의 부분 문자열(substring)인 경우, 그리고 오직 그 경우만 <code class="docutils literal notranslate"><span class="pre">True</span></code> 입니다. 동등한 검사는 <code class="docutils literal notranslate"><span class="pre">y.find(x)</span> <span class="pre">!=</span> <span class="pre">-1</span></code> 입니다. 빈 문자열은 항상 다른 문자열들의 부분 문자열로 취급되기 때문에, <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span> <span class="pre">in</span> <span class="pre">&quot;abc&quot;</span></code> 은 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 돌려줍니다.</p>
<p>For user-defined classes which define the <a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> method, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span>
<span class="pre">y</span></code> returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">y.__contains__(x)</span></code> returns a true value, and
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>For user-defined classes which do not define <a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> but do define
<a class="reference internal" href="datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> if some value <code class="docutils literal notranslate"><span class="pre">z</span></code>, for which the
expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">z</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">z</span></code> is true, is produced while iterating over <code class="docutils literal notranslate"><span class="pre">y</span></code>.
If an exception is raised during the iteration, it is as if <a class="reference internal" href="expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> raised
that exception.</p>
<p>Lastly, the old-style iteration protocol is tried: if a class defines
<a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> if and only if there is a non-negative
integer index <em>i</em> such that <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y[i]</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">y[i]</span></code>, and no lower integer index
raises the <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> exception.  (If any other exception is raised, it is as
if <a class="reference internal" href="expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> raised that exception).</p>
<p id="index-80">연산자 <a class="reference internal" href="expressions.html#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a> 은 <a class="reference internal" href="expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 의 논리적 부정으로 정의됩니다.</p>
</section>
<section id="is-not">
<span id="is"></span><span id="index-81"></span><span id="identity-comparisons"></span><h3><span class="section-number">6.10.3. </span>아이덴티티 비교<a class="headerlink" href="expressions.html#is-not" title="Link to this heading">¶</a></h3>
<p>연산자 <a class="reference internal" href="expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> 와 <a class="reference internal" href="expressions.html#is-not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></a> 은 객체의 아이덴티티를 검사합니다: <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> 는 <em>x</em> 와 <em>y</em> 가 아이덴티티가 같은 객체일 때, 그리고 오직 그 경우만 참입니다. 객체의 아이덴티티는 <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id()</span></code></a> 함수를 사용해서 결정됩니다. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">y</span></code> 은 논리적 부정 값을 줍니다. <a class="footnote-reference brackets" href="expressions.html#id20" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p>
</section>
</section>
<section id="boolean-operations">
<span id="not"></span><span id="or"></span><span id="and"></span><span id="booleans"></span><h2><span class="section-number">6.11. </span>논리 연산(Boolean operations)<a class="headerlink" href="expressions.html#boolean-operations" title="Link to this heading">¶</a></h2>
<pre id="index-82">
<strong id="grammar-token-python-grammar-or_test">or_test </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> &quot;or&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a>
<strong id="grammar-token-python-grammar-and_test">and_test</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a> &quot;and&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a>
<strong id="grammar-token-python-grammar-not_test">not_test</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-comparison"><code class="xref docutils literal notranslate"><span class="pre">comparison</span></code></a> | &quot;not&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a>
</pre>
<p>In the context of Boolean operations, and also when expressions are used by
control flow statements, the following values are interpreted as false:
<code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>, numeric zero of all types, and empty strings and containers
(including strings, tuples, lists, dictionaries, sets and frozensets).  All
other values are interpreted as true.  User-defined objects can customize their
truth value by providing a <a class="reference internal" href="datamodel.html#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> method.</p>
<p id="index-83">연산자 <a class="reference internal" href="expressions.html#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a> 은 그 인자가 거짓이면 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code> 를 줍니다.</p>
<p id="index-84">표현식 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></code> 는 먼저 <em>x</em> 의 값을 구합니다; <em>x</em> 가 거짓이면 그 값을 돌려줍니다; 그렇지 않으면 <em>y</em> 의 값을 구한 후에 그 결과를 돌려줍니다.</p>
<p id="index-85">표현식 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></code> 는 먼저 <em>x</em> 의 값을 구합니다; <em>x</em> 가 참이면 그 값을 돌려줍니다. 그렇지 않으면 <em>y</em> 의 값을 구한 후에 그 결과를 돌려줍니다.</p>
<p><a class="reference internal" href="expressions.html#and"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code></a> 와 <a class="reference internal" href="expressions.html#or"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code></a> 어느 것도 반환 값이나 그 형을 <code class="docutils literal notranslate"><span class="pre">False</span></code> 와 <code class="docutils literal notranslate"><span class="pre">True</span></code> 로 제한하지 않고, 대신 마지막에 값이 구해진 인자를 돌려줌에 주의해야 합니다. 이것은 때로 쓸모가 있습니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">s</span></code> 가 문자열이고 비어 있으면 기본값으로 대체되어야 한다면, 표현식 <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">or</span> <span class="pre">'foo'</span></code> 는 원하는 값을 제공합니다. <a class="reference internal" href="expressions.html#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a> 은 새 값을 만들어야 하므로, 그 인자의 형과 관계없이 논리값(boolean value)을 돌려줍니다 (예를 들어, <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">'foo'</span></code> 는 <code class="docutils literal notranslate"><span class="pre">''</span></code> 가 아니라 <code class="docutils literal notranslate"><span class="pre">False</span></code> 를 만듭니다.)</p>
</section>
<section id="assignment-expressions">
<span id="index-86"></span><h2><span class="section-number">6.12. </span>대입 표현식<a class="headerlink" href="expressions.html#assignment-expressions" title="Link to this heading">¶</a></h2>
<pre>
<strong id="grammar-token-python-grammar-assignment_expression">assignment_expression</strong> ::=  [<a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> &quot;:=&quot;] <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>An assignment expression (sometimes also called a “named expression” or
“walrus”) assigns an <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression</span></code></a> to an
<a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref std std-token docutils literal notranslate"><span class="pre">identifier</span></code></a>, while also returning the value of the
<a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression</span></code></a>.</p>
<p>일반적인 사용 사례 중 하나는 일치하는 정규식을 처리할 때입니다:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">matching</span> <span class="o">:=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">(</span><span class="n">matching</span><span class="p">)</span>
</pre></div>
</div>
<p>또는, 청크로 파일 스트림을 처리할 때:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">chunk</span> <span class="o">:=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">9000</span><span class="p">):</span>
    <span class="n">process</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
</pre></div>
</div>
<p>Assignment expressions must be surrounded by parentheses when
used as expression statements and when used as sub-expressions in
slicing, conditional, lambda,
keyword-argument, and comprehension-if expressions and
in <code class="docutils literal notranslate"><span class="pre">assert</span></code>, <code class="docutils literal notranslate"><span class="pre">with</span></code>, and <code class="docutils literal notranslate"><span class="pre">assignment</span></code> statements.
In all other places where they can be used, parentheses are not required,
including in <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">while</span></code> statements.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8: </span>대입 표현식에 대한 더 자세한 내용은 <span class="target" id="index-117"></span><a class="pep reference external" href="https://peps.python.org/pep-0572/"><strong>PEP 572</strong></a>를 참조하세요.</p>
</div>
</section>
<section id="conditional-expressions">
<span id="if-expr"></span><h2><span class="section-number">6.13. </span>조건 표현식(Conditional expressions)<a class="headerlink" href="expressions.html#conditional-expressions" title="Link to this heading">¶</a></h2>
<pre id="index-88">
<strong id="grammar-token-python-grammar-conditional_expression">conditional_expression</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [&quot;if&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> &quot;else&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
<strong id="grammar-token-python-grammar-expression">expression            </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-conditional_expression"><code class="xref docutils literal notranslate"><span class="pre">conditional_expression</span></code></a> | <a class="reference internal" href="expressions.html#grammar-token-python-grammar-lambda_expr"><code class="xref docutils literal notranslate"><span class="pre">lambda_expr</span></code></a>
</pre>
<p>조건 표현식은 (때로 “삼 항 연산자(ternary operator)”라고 불립니다) 모든 파이썬 연산에서 가장 낮은 우선순위를 갖습니다.</p>
<p>표현식 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">if</span> <span class="pre">C</span> <span class="pre">else</span> <span class="pre">y</span></code> 은 먼저 <em>x</em> 대신에 조건 <em>C</em> 의 값을 구합니다. <em>C</em> 가 참이면, <em>x</em> 의 값이 구해지고 그 값을 돌려줍니다; 그렇지 않으면, <em>y</em> 의 값을 구한 후에 그 결과를 돌려줍니다.</p>
<p>조건 표현식에 대한 더 자세한 내용은 <span class="target" id="index-118"></span><a class="pep reference external" href="https://peps.python.org/pep-0308/"><strong>PEP 308</strong></a> 를 참조하세요.</p>
</section>
<section id="lambda">
<span id="lambdas"></span><span id="id14"></span><h2><span class="section-number">6.14. </span>람다(Lambdas)<a class="headerlink" href="expressions.html#lambda" title="Link to this heading">¶</a></h2>
<pre id="index-90">
<strong id="grammar-token-python-grammar-lambda_expr">lambda_expr</strong> ::=  &quot;lambda&quot; [<a class="reference internal" href="compound_stmts.html#grammar-token-python-grammar-parameter_list"><code class="xref docutils literal notranslate"><span class="pre">parameter_list</span></code></a>] &quot;:&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>람다 표현식은 (때로 람다 형식(lambda forms)이라고 불립니다) 이름 없는 함수를 만드는 데 사용됩니다. 표현식 <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">parameters:</span> <span class="pre">expression</span></code> 는 함수 객체를 줍니다. 이 이름 없는 객체는 이렇게 정의된 함수 객체처럼 동작합니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def &lt;lambda&gt;(parameters):
    return expression
</pre></div>
</div>
<p>매개변수 목록의 문법은 <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a> 섹션을 보세요. 람다 표현식으로 만들어진 함수는 문장(statements)이나 어노테이션(annotations)을 포함할 수 없음에 주의해야 합니다.</p>
</section>
<section id="expression-lists">
<span id="exprlists"></span><h2><span class="section-number">6.15. </span>표현식 목록(Expression lists)<a class="headerlink" href="expressions.html#expression-lists" title="Link to this heading">¶</a></h2>
<pre id="index-91">
<strong id="grammar-token-python-grammar-expression_list">expression_list   </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> (&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-starred_list">starred_list      </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-starred_expression">starred_expression</strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | (<a class="reference internal" href="expressions.html#grammar-token-python-grammar-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a> &quot;,&quot;)* [<a class="reference internal" href="expressions.html#grammar-token-python-grammar-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a>]
<strong id="grammar-token-python-grammar-starred_item">starred_item      </strong> ::=  <a class="reference internal" href="expressions.html#grammar-token-python-grammar-assignment_expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> | &quot;*&quot; <a class="reference internal" href="expressions.html#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>
</pre>
<p id="index-92">리스트나 집합 디스플레이의 일부일 때를 제외하고, 최소한 하나의 쉼표를 포함하는 표현식 목록은 튜플을 줍니다. 튜플의 길이는 목록에 있는 표현식의 개수입니다. 표현식들은 왼쪽에서 오른쪽으로 값이 구해집니다.</p>
<p id="index-93">애스터리스크(asterisk) <code class="docutils literal notranslate"><span class="pre">*</span></code> 는 이터러블 언 패킹(<em class="dfn">iterable unpacking</em>)을 나타냅니다. 피연산자는 반드시 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">이터러블</span></a> 이어야 합니다. 그 이터러블이 항목들의 시퀀스로 확장되어서, 언 패킹 지점에서 새 튜플, 리스트, 집합에 포함됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5: </span>표현식 목록에서의 이터러블 언 패킹, <span class="target" id="index-119"></span><a class="pep reference external" href="https://peps.python.org/pep-0448/"><strong>PEP 448</strong></a> 에서 최초로 제안되었습니다.</p>
</div>
<p id="index-95">A trailing comma is required only to create a one-item tuple,
such as <code class="docutils literal notranslate"><span class="pre">1,</span></code>; it is optional in all other cases.
A single expression without a
trailing comma doesn’t create a tuple, but rather yields the value of that
expression. (To create an empty tuple, use an empty pair of parentheses:
<code class="docutils literal notranslate"><span class="pre">()</span></code>.)</p>
</section>
<section id="evaluation-order">
<span id="evalorder"></span><h2><span class="section-number">6.16. </span>값을 구하는 순서<a class="headerlink" href="expressions.html#evaluation-order" title="Link to this heading">¶</a></h2>
<p id="index-96">파이썬은 왼쪽에서 오른쪽으로 표현식의 값을 구합니다. 대입의 값을 구하는 동안, 우변의 값이 좌변보다 먼저 구해짐에 주목하십시오.</p>
<p>다음 줄들에서, 표현식은 그들의 끝에 붙은 숫자들의 순서대로 값이 구해집니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span>
<span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span><span class="p">)</span>
<span class="p">{</span><span class="n">expr1</span><span class="p">:</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">:</span> <span class="n">expr4</span><span class="p">}</span>
<span class="n">expr1</span> <span class="o">+</span> <span class="n">expr2</span> <span class="o">*</span> <span class="p">(</span><span class="n">expr3</span> <span class="o">-</span> <span class="n">expr4</span><span class="p">)</span>
<span class="n">expr1</span><span class="p">(</span><span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="o">*</span><span class="n">expr4</span><span class="p">,</span> <span class="o">**</span><span class="n">expr5</span><span class="p">)</span>
<span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span> <span class="o">=</span> <span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span>
</pre></div>
</div>
</section>
<section id="operator-precedence">
<span id="operator-summary"></span><h2><span class="section-number">6.17. </span>연산자 우선순위<a class="headerlink" href="expressions.html#operator-precedence" title="Link to this heading">¶</a></h2>
<p id="index-97">The following table summarizes the operator precedence in Python, from highest
precedence (most binding) to lowest precedence (least binding).  Operators in
the same box have the same precedence.  Unless the syntax is explicitly given,
operators are binary.  Operators in the same box group left to right (except for
exponentiation and conditional expressions, which group from right to left).</p>
<p>비교, 멤버십 검사, 아이덴티티 검사들은 모두 같은 우선순위를 갖고 <a class="reference internal" href="expressions.html#comparisons"><span class="std std-ref">비교</span></a> 섹션에서 설명한 것처럼 왼쪽에서 오른쪽으로 이어붙이기(chaining) 하는 기능을 갖습니다.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>연산자</p></th>
<th class="head"><p>설명</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">(expressions...)</span></code>,</p>
<p><code class="docutils literal notranslate"><span class="pre">[expressions...]</span></code>,
<code class="docutils literal notranslate"><span class="pre">{key:</span> <span class="pre">value...}</span></code>,
<code class="docutils literal notranslate"><span class="pre">{expressions...}</span></code></p>
</td>
<td><p>결합(binding) 또는 괄호 친 표현식, 리스트 디스플레이, 딕셔너리 디스플레이, 집합 디스플레이</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">x[index]</span></code>, <code class="docutils literal notranslate"><span class="pre">x[index:index]</span></code>,
<code class="docutils literal notranslate"><span class="pre">x(arguments...)</span></code>, <code class="docutils literal notranslate"><span class="pre">x.attribute</span></code></p></td>
<td><p>서브스크립션, 슬라이싱, 호출, 어트리뷰트 참조</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span> <span class="pre">x</span></code></a></p></td>
<td><p>어웨이트 표현식</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">**</span></code></p></td>
<td><p>거듭제곱 <a class="footnote-reference brackets" href="expressions.html#id21" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">+x</span></code>, <code class="docutils literal notranslate"><span class="pre">-x</span></code>, <code class="docutils literal notranslate"><span class="pre">~x</span></code></p></td>
<td><p>양, 음, 비트 NOT</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code></p></td>
<td><p>곱셈, 행렬 곱셈, 나눗셈, 정수 나눗셈, 나머지 <a class="footnote-reference brackets" href="expressions.html#id22" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td><p>덧셈과 뺄셈</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code></p></td>
<td><p>시프트</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&amp;</span></code></p></td>
<td><p>비트 AND</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">^</span></code></p></td>
<td><p>비트 XOR</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">|</span></code></p></td>
<td><p>비트 OR</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a>, <a class="reference internal" href="expressions.html#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>,
<a class="reference internal" href="expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a>, <a class="reference internal" href="expressions.html#is-not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></a>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
<td><p>비교, 멤버십 검사와 아이덴티티 검사를 포함합니다</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="expressions.html#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span></code></a></p></td>
<td><p>논리 NOT</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="expressions.html#and"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code></a></p></td>
<td><p>논리 AND</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="expressions.html#or"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code></a></p></td>
<td><p>논리 OR</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="expressions.html#if-expr"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> – <code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></p></td>
<td><p>조건 표현식</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a></p></td>
<td><p>람다 표현식</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">:=</span></code></p></td>
<td><p>대입 표현식</p></td>
</tr>
</tbody>
</table>
<p class="rubric">각주</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id17" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="expressions.html#id9">1</a><span class="fn-bracket">]</span></span>
<p><code class="docutils literal notranslate"><span class="pre">abs(x%y)</span> <span class="pre">&lt;</span> <span class="pre">abs(y)</span></code> 이 수학적으로는 참이지만, float의 경우에는 소수점 자름(roundoff) 때문에 수치적으로 참이 아닐 수 있습니다. 예를 들어, 파이썬 float가 IEEE 754 배정도 숫자인 플랫폼을 가정할 때, <code class="docutils literal notranslate"><span class="pre">-1e-100</span> <span class="pre">%</span> <span class="pre">1e100</span></code> 가 <code class="docutils literal notranslate"><span class="pre">1e100</span></code> 와 같은 부호를 가지기 위해, 계산된 결과는 <code class="docutils literal notranslate"><span class="pre">-1e-100</span> <span class="pre">+</span> <span class="pre">1e100</span></code> 인데, 수치적으로는 <code class="docutils literal notranslate"><span class="pre">1e100</span></code> 과 정확히 같은 값입니다. 함수 <a class="reference internal" href="../library/math.html#math.fmod" title="math.fmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.fmod()</span></code></a> 는 부호가 첫 번째 인자의 부호에 맞춰진 결과를 주기 때문에, 이 경우 <code class="docutils literal notranslate"><span class="pre">-1e-100</span></code> 을 돌려줍니다. 어떤 접근법이 더 적절한지는 응용 프로그램에 달려있습니다.</p>
</aside>
<aside class="footnote brackets" id="id18" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="expressions.html#id10">2</a><span class="fn-bracket">]</span></span>
<p>x가 y의 정확한 정수배와 아주 가까우면, 라운딩(rounding) 때문에 <code class="docutils literal notranslate"><span class="pre">x//y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">(x-x%y)//y</span></code> 보다 1 클 수 있습니다. 그런 경우, <code class="docutils literal notranslate"><span class="pre">divmod(x,y)[0]</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code> 가 <code class="docutils literal notranslate"><span class="pre">x</span></code> 와 아주 가깝도록 유지하기 위해, 파이썬은 뒤의 결과를 돌려줍니다.</p>
</aside>
<aside class="footnote brackets" id="id19" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="expressions.html#id12">3</a><span class="fn-bracket">]</span></span>
<p>유니코드 표준은 코드 포인트(<em class="dfn">code points</em>) (예를 들어, U+0041) 와 추상 문자(<em class="dfn">abstract characters</em>) (예를 들어, “LATIN CAPITAL LETTER A”) 를 구분합니다. 유니코드에 있는 대부분의 추상 문자들이 오직 하나의 코드 포인트만으로 표현되지만, 추가로 하나 이상의 코드 포인트의 시퀀스로 표현될 수 있는 추상 문자들이 많이 있습니다. 예를 들어, 추상 문자 “LATIN CAPITAL LETTER C WITH CEDILLA” 는 코드 위치 U+00C7 에 있는 한 개의 복합 문자(<em class="dfn">precomposed character</em>) 나 코드 위치 U+0043 (LATIN CAPITAL LETTER C) 에 있는 기본 문자(<em class="dfn">base character</em>) 와 뒤따르는 코드 위치 U+0327 (COMBINING CEDILLA) 에 있는 결합 문자(<em class="dfn">combining character</em>) 의 시퀀스로 표현될 수 있습니다.</p>
<p>문자열의 비교 연산자는 유니코드 코드 포인트 수준에서 비교합니다. 이것은 사람에게 반 직관적일 수 있습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">&quot;\u00C7&quot;</span> <span class="pre">==</span> <span class="pre">&quot;\u0043\u0327&quot;</span></code> 는 거짓입니다, 설사 두 문자열이 같은 추상 문자 “LATIN CAPITAL LETTER C WITH CEDILLA”를 표현할지라도 그렇습니다.</p>
<p>문자열을 추상 문자 수준에서 비교하려면 (즉, 사람에게 직관적인 방법으로), <a class="reference internal" href="../library/unicodedata.html#unicodedata.normalize" title="unicodedata.normalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">unicodedata.normalize()</span></code></a> 를 사용하십시오.</p>
</aside>
<aside class="footnote brackets" id="id20" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="expressions.html#id13">4</a><span class="fn-bracket">]</span></span>
<p>자동 가비지-수거(automatic garbage-collection)와 자유 목록(free lists)과 디스크립터(descriptor)의 동적인 성격 때문에, <a class="reference internal" href="expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> 연산자를 인스턴스 메서드들이나 상수들을 비교하는 것과 같은 특정한 방식으로 사용할 때, 겉으로 보기에 이상한 동작을 감지할 수 있습니다. 더 자세한 정보는 그들의 문서를 확인하십시오.</p>
</aside>
<aside class="footnote brackets" id="id21" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="expressions.html#id15">5</a><span class="fn-bracket">]</span></span>
<p>거듭제곱 연산자 <code class="docutils literal notranslate"><span class="pre">**</span></code> 는 오른쪽에 오는 산술이나 비트 일 항 연산자보다 약하게 결합합니다, 즉, <code class="docutils literal notranslate"><span class="pre">2**-1</span></code> 는 <code class="docutils literal notranslate"><span class="pre">0.5</span></code> 입니다.</p>
</aside>
<aside class="footnote brackets" id="id22" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="expressions.html#id16">6</a><span class="fn-bracket">]</span></span>
<p><code class="docutils literal notranslate"><span class="pre">%</span></code> 연산자는 문자열 포매팅에도 사용됩니다; 같은 우선순위가 적용됩니다.</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">목차</a></h3>
    <ul>
<li><a class="reference internal" href="expressions.html#">6. 표현식</a><ul>
<li><a class="reference internal" href="expressions.html#arithmetic-conversions">6.1. 산술 변환</a></li>
<li><a class="reference internal" href="expressions.html#atoms">6.2. 아톰 (Atoms)</a><ul>
<li><a class="reference internal" href="expressions.html#atom-identifiers">6.2.1. 식별자 (이름)</a></li>
<li><a class="reference internal" href="expressions.html#literals">6.2.2. 리터럴 (Literals)</a></li>
<li><a class="reference internal" href="expressions.html#parenthesized-forms">6.2.3. 괄호 안에 넣은 형</a></li>
<li><a class="reference internal" href="expressions.html#displays-for-lists-sets-and-dictionaries">6.2.4. 리스트, 집합, 딕셔너리의 디스플레이(display)</a></li>
<li><a class="reference internal" href="expressions.html#list-displays">6.2.5. 리스트 디스플레이</a></li>
<li><a class="reference internal" href="expressions.html#set-displays">6.2.6. 집합 디스플레이</a></li>
<li><a class="reference internal" href="expressions.html#dictionary-displays">6.2.7. 딕셔너리 디스플레이</a></li>
<li><a class="reference internal" href="expressions.html#generator-expressions">6.2.8. 제너레이터 표현식 (Generator expressions)</a></li>
<li><a class="reference internal" href="expressions.html#yield-expressions">6.2.9. 일드 표현식(Yield expressions)</a><ul>
<li><a class="reference internal" href="expressions.html#generator-iterator-methods">6.2.9.1. 제너레이터-이터레이터 메서드</a></li>
<li><a class="reference internal" href="expressions.html#examples">6.2.9.2. 사용 예</a></li>
<li><a class="reference internal" href="expressions.html#asynchronous-generator-functions">6.2.9.3. 비동기 제너레이터 함수</a></li>
<li><a class="reference internal" href="expressions.html#asynchronous-generator-iterator-methods">6.2.9.4. 비동기 제너레이터-이터레이터 메서드</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="expressions.html#primaries">6.3. 프라이머리</a><ul>
<li><a class="reference internal" href="expressions.html#attribute-references">6.3.1. 어트리뷰트 참조</a></li>
<li><a class="reference internal" href="expressions.html#subscriptions">6.3.2. 서브스크립션(Subscriptions)</a></li>
<li><a class="reference internal" href="expressions.html#slicings">6.3.3. 슬라이싱(Slicings)</a></li>
<li><a class="reference internal" href="expressions.html#calls">6.3.4. 호출</a></li>
</ul>
</li>
<li><a class="reference internal" href="expressions.html#await-expression">6.4. 어웨이트 표현식</a></li>
<li><a class="reference internal" href="expressions.html#the-power-operator">6.5. 거듭제곱 연산자</a></li>
<li><a class="reference internal" href="expressions.html#unary-arithmetic-and-bitwise-operations">6.6. 일 항 산술과 비트 연산</a></li>
<li><a class="reference internal" href="expressions.html#binary-arithmetic-operations">6.7. 이항 산술 연산</a></li>
<li><a class="reference internal" href="expressions.html#shifting-operations">6.8. 시프트 연산</a></li>
<li><a class="reference internal" href="expressions.html#binary-bitwise-operations">6.9. 이항 비트 연산</a></li>
<li><a class="reference internal" href="expressions.html#comparisons">6.10. 비교</a><ul>
<li><a class="reference internal" href="expressions.html#value-comparisons">6.10.1. 값 비교</a></li>
<li><a class="reference internal" href="expressions.html#membership-test-operations">6.10.2. 멤버십 검사 연산</a></li>
<li><a class="reference internal" href="expressions.html#is-not">6.10.3. 아이덴티티 비교</a></li>
</ul>
</li>
<li><a class="reference internal" href="expressions.html#boolean-operations">6.11. 논리 연산(Boolean operations)</a></li>
<li><a class="reference internal" href="expressions.html#assignment-expressions">6.12. 대입 표현식</a></li>
<li><a class="reference internal" href="expressions.html#conditional-expressions">6.13. 조건 표현식(Conditional expressions)</a></li>
<li><a class="reference internal" href="expressions.html#lambda">6.14. 람다(Lambdas)</a></li>
<li><a class="reference internal" href="expressions.html#expression-lists">6.15. 표현식 목록(Expression lists)</a></li>
<li><a class="reference internal" href="expressions.html#evaluation-order">6.16. 값을 구하는 순서</a></li>
<li><a class="reference internal" href="expressions.html#operator-precedence">6.17. 연산자 우선순위</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>이전 항목</h4>
    <p class="topless"><a href="import.html"
                          title="이전 장"><span class="section-number">5. </span>임포트 시스템</a></p>
  </div>
  <div>
    <h4>다음 항목</h4>
    <p class="topless"><a href="simple_stmts.html"
                          title="다음 장"><span class="section-number">7. </span>단순문(Simple statements)</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/expressions.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="사이드바 닫기">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. 단순문(Simple statements)"
             >다음</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. 임포트 시스템"
             >이전</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 언어 레퍼런스</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="expressions.html"><span class="section-number">6. </span>표현식</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="search" name="q" id="search-box" />
          <input type="submit" value="이동" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    저작권
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="../../../license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      최종 업데이트: Jun 09, 2024 (17:23 UTC)
    
      <a href="../../../bugs.html">Found a bug</a>?
    
    <br />

    <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7 버전으로 생성되었습니다.
    </div>

    <script type="text/javascript" src="../_static/switchers.js"></script>
  </body>
</html>