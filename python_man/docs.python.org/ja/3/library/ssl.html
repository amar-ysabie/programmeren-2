<!DOCTYPE html>

<html lang="ja" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="ssl --- ソケットオブジェクト用の TLS/SSL ラッパー" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/ssl.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Source code: Lib/ssl.py このモジュールは Transport Layer Security ( &quot;Secure Sockets Layer&quot; という名前でよく知られています) 暗号化と、クライアントサイド、サーバサイド両方のネットワークソケットのためのピア認証の仕組みを提供しています。このモジュールは OpenSSL ライブラリを利用しています。 OpenSSL は、..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Source code: Lib/ssl.py このモジュールは Transport Layer Security ( &quot;Secure Sockets Layer&quot; という名前でよく知られています) 暗号化と、クライアントサイド、サーバサイド両方のネットワークソケットのためのピア認証の仕組みを提供しています。このモジュールは OpenSSL ライブラリを利用しています。 OpenSSL は、..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>ssl --- ソケットオブジェクト用の TLS/SSL ラッパー &#8212; Python 3.12.4 ドキュメント</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css%3Fv=80d5e7a1.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css%3Fv=bb723527.css" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css%3Fv=b20cc3f5.css" />
    
    <script src="../_static/documentation_options.js%3Fv=7e11ab17"></script>
    <script src="../_static/doctools.js%3Fv=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js%3Fv=dc90522c"></script>
    <script src="../_static/translations.js%3Fv=4dbe4bdc"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.12.4 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="select --- I/O 完了の待機" href="select.html" />
    <link rel="prev" title="socket --- 低水準ネットワークインターフェース" href="socket.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="../../../3/library/ssl.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" />
                <input type="submit" value="検索"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="ssl.html#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code> --- ソケットオブジェクト用の TLS/SSL ラッパー</a><ul>
<li><a class="reference internal" href="ssl.html#functions-constants-and-exceptions">関数、定数、例外</a><ul>
<li><a class="reference internal" href="ssl.html#socket-creation">ソケットの作成</a></li>
<li><a class="reference internal" href="ssl.html#context-creation">コンテキストの作成</a></li>
<li><a class="reference internal" href="ssl.html#exceptions">例外</a></li>
<li><a class="reference internal" href="ssl.html#random-generation">乱数生成</a></li>
<li><a class="reference internal" href="ssl.html#certificate-handling">証明書の取り扱い</a></li>
<li><a class="reference internal" href="ssl.html#constants">定数</a></li>
</ul>
</li>
<li><a class="reference internal" href="ssl.html#ssl-sockets">SSL ソケット</a></li>
<li><a class="reference internal" href="ssl.html#ssl-contexts">SSL コンテキスト</a></li>
<li><a class="reference internal" href="ssl.html#certificates">証明書</a><ul>
<li><a class="reference internal" href="ssl.html#certificate-chains">証明書チェイン</a></li>
<li><a class="reference internal" href="ssl.html#ca-certificates">CA 証明書</a></li>
<li><a class="reference internal" href="ssl.html#combined-key-and-certificate">秘密鍵と証明書の組み合わせ</a></li>
<li><a class="reference internal" href="ssl.html#self-signed-certificates">自己署名証明書</a></li>
</ul>
</li>
<li><a class="reference internal" href="ssl.html#examples">使用例</a><ul>
<li><a class="reference internal" href="ssl.html#testing-for-ssl-support">SSLサポートをテストする</a></li>
<li><a class="reference internal" href="ssl.html#client-side-operation">クライアントサイドの処理</a></li>
<li><a class="reference internal" href="ssl.html#server-side-operation">サーバサイドの処理</a></li>
</ul>
</li>
<li><a class="reference internal" href="ssl.html#notes-on-non-blocking-sockets">ノンブロッキングソケットについての注意事項</a></li>
<li><a class="reference internal" href="ssl.html#memory-bio-support">メモリ BIO サポート</a></li>
<li><a class="reference internal" href="ssl.html#ssl-session">SSL セッション</a></li>
<li><a class="reference internal" href="ssl.html#security-considerations">セキュリティで考慮すべき点</a><ul>
<li><a class="reference internal" href="ssl.html#best-defaults">最善のデフォルト値</a></li>
<li><a class="reference internal" href="ssl.html#manual-settings">手動での設定</a><ul>
<li><a class="reference internal" href="ssl.html#verifying-certificates">証明書の検証</a></li>
<li><a class="reference internal" href="ssl.html#protocol-versions">プロトコルのバージョン</a></li>
<li><a class="reference internal" href="ssl.html#cipher-selection">暗号の選択</a></li>
</ul>
</li>
<li><a class="reference internal" href="ssl.html#multi-processing">マルチプロセス化</a></li>
</ul>
</li>
<li><a class="reference internal" href="ssl.html#tls-1-3">TLS 1.3</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="socket.html"
                          title="前の章へ"><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code> --- 低水準ネットワークインターフェース</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="select.html"
                          title="次の章へ"><code class="xref py py-mod docutils literal notranslate"><span class="pre">select</span></code> --- I/O 完了の待機</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/ssl.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="select.html" title="select --- I/O 完了の待機"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="socket.html" title="socket --- 低水準ネットワークインターフェース"
             accesskey="P">前へ</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" accesskey="U">ネットワーク通信とプロセス間通信</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="ssl.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code> --- ソケットオブジェクト用の TLS/SSL ラッパー</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" id="search-box" />
          <input type="submit" value="検索" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-ssl">
<span id="ssl-tls-ssl-wrapper-for-socket-objects"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code> --- ソケットオブジェクト用の TLS/SSL ラッパー<a class="headerlink" href="ssl.html#module-ssl" title="Link to this heading">¶</a></h1>
<p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/ssl.py">Lib/ssl.py</a></p>
<span id="index-0"></span><hr class="docutils" id="index-1" />
<p>このモジュールは Transport Layer Security ( &quot;Secure Sockets Layer&quot; という名前でよく知られています) 暗号化と、クライアントサイド、サーバサイド両方のネットワークソケットのためのピア認証の仕組みを提供しています。このモジュールは OpenSSL ライブラリを利用しています。 OpenSSL は、すべてのモダンな Unix システム、 Windows 、 macOS 、その他幾つかの OpenSSL がインストールされているプラットフォームで利用できます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>Some behavior may be platform dependent, since calls are made to the
operating system socket APIs.  The installed version of OpenSSL may also
cause variations in behavior. For example, TLSv1.3 comes with OpenSSL version
1.1.1.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p><a class="reference internal" href="ssl.html#ssl-security"><span class="std std-ref">セキュリティで考慮すべき点</span></a> を読まずにこのモジュールを使用しないでください。SSL のデフォルト設定はアプリケーションに十分ではないので、読まない場合はセキュリティに誤った意識を持ってしまうかもしれません。</p>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not Emscripten, not WASI.</p>
<p>This module does not work or is not available on WebAssembly platforms
<code class="docutils literal notranslate"><span class="pre">wasm32-emscripten</span></code> and <code class="docutils literal notranslate"><span class="pre">wasm32-wasi</span></code>. See
<a class="reference internal" href="intro.html#wasm-availability"><span class="std std-ref">WebAssembly プラットフォーム</span></a> for more information.</p>
</div>
<p>このセクションでは、 <code class="docutils literal notranslate"><span class="pre">ssl</span></code> モジュールのオブジェクトと関数を解説します。 TLS, SSL, 証明書に関するより一般的な情報は、末尾にある &quot;See Also&quot; のセクションを参照してください。</p>
<p>This module provides a class, <a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a>, which is derived from the
<a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> type, and provides a socket-like wrapper that also
encrypts and decrypts the data going over the socket with SSL.  It supports
additional methods such as <code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeercert()</span></code>, which retrieves the
certificate of the other side of the connection, and <code class="xref py py-meth docutils literal notranslate"><span class="pre">cipher()</span></code>, which
retrieves the cipher being used for the secure connection.</p>
<p>より洗練されたアプリケーションのために、 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> クラスが設定と証明書の管理の助けとなるでしょう。それは <a class="reference internal" href="ssl.html#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> メソッドを通して SSL ソケットを作成することで引き継がれます。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.5.3 で変更: </span>Updated to support linking with OpenSSL 1.1.0</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.6 で変更: </span>OpenSSL 0.9.8, 1.0.0, 1.0.1 は廃止されており、もはやサポートされていません。ssl モジュールは、将来的に OpenSSL 1.0.2 または 1.1.0 を必要とするようになります。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.10 で変更: </span><span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0644/"><strong>PEP 644</strong></a> has been implemented. The ssl module requires OpenSSL 1.1.1
or newer.</p>
<p>Use of deprecated constants and functions result in deprecation warnings.</p>
</div>
<section id="functions-constants-and-exceptions">
<h2>関数、定数、例外<a class="headerlink" href="ssl.html#functions-constants-and-exceptions" title="Link to this heading">¶</a></h2>
<section id="socket-creation">
<h3>ソケットの作成<a class="headerlink" href="ssl.html#socket-creation" title="Link to this heading">¶</a></h3>
<p>Instances of <a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> must be created using the
<a class="reference internal" href="ssl.html#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> method. The helper function
<a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> returns a new context with secure default
settings.</p>
<p>Client socket example with default context and IPv4/IPv6 dual stack:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">ssl</span>

<span class="n">hostname</span> <span class="o">=</span> <span class="s1">&#39;www.python.org&#39;</span>
<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span>

<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">create_connection</span><span class="p">((</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span> <span class="k">as</span> <span class="n">sock</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">server_hostname</span><span class="o">=</span><span class="n">hostname</span><span class="p">)</span> <span class="k">as</span> <span class="n">ssock</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ssock</span><span class="o">.</span><span class="n">version</span><span class="p">())</span>
</pre></div>
</div>
<p>Client socket example with custom context and IPv4:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">hostname</span> <span class="o">=</span> <span class="s1">&#39;www.python.org&#39;</span>
<span class="c1"># PROTOCOL_TLS_CLIENT requires valid cert chain and hostname</span>
<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLS_CLIENT</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_verify_locations</span><span class="p">(</span><span class="s1">&#39;path/to/cabundle.pem&#39;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">as</span> <span class="n">sock</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">server_hostname</span><span class="o">=</span><span class="n">hostname</span><span class="p">)</span> <span class="k">as</span> <span class="n">ssock</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ssock</span><span class="o">.</span><span class="n">version</span><span class="p">())</span>
</pre></div>
</div>
<p>Server socket example listening on localhost IPv4:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLS_SERVER</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_cert_chain</span><span class="p">(</span><span class="s1">&#39;/path/to/certchain.pem&#39;</span><span class="p">,</span> <span class="s1">&#39;/path/to/private.key&#39;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">as</span> <span class="n">sock</span><span class="p">:</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8443</span><span class="p">))</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">server_side</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">ssock</span><span class="p">:</span>
        <span class="n">conn</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">ssock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="o">...</span>
</pre></div>
</div>
</section>
<section id="context-creation">
<h3>コンテキストの作成<a class="headerlink" href="ssl.html#context-creation" title="Link to this heading">¶</a></h3>
<p>コンビニエンス関数が、共通の目的で使用される <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> オブジェクトを作成するのに役立ちます。</p>
<dl class="py function">
<dt class="sig sig-object py" id="ssl.create_default_context">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">create_default_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">purpose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Purpose.SERVER_AUTH</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cafile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">capath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cadata</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.create_default_context" title="Link to this definition">¶</a></dt>
<dd><p>新規の <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> オブジェクトを、与えられた <em>purpose</em> のデフォルト設定で返します。設定は <a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> モジュールで選択され、通常は <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> のコンストラクタを直接呼び出すよりも高いセキュリティレベルを表現します。</p>
<p><em>cafile</em>, <em>capath</em>, <em>cadata</em> は証明書の検証で信用するオプションの CA 証明書で、 <a class="reference internal" href="ssl.html#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations()</span></code></a> のものと同じです。これら 3 つすべてが <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> であれば、この関数は代わりにシステムのデフォルトの CA 証明書を信用して選択することができます。</p>
<p>The settings are: <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> or
<a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a>, <a class="reference internal" href="ssl.html#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv2</span></code></a>, and <a class="reference internal" href="ssl.html#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a>
with high encryption cipher suites without RC4 and
without unauthenticated cipher suites. Passing <a class="reference internal" href="ssl.html#ssl.Purpose.SERVER_AUTH" title="ssl.Purpose.SERVER_AUTH"><code class="xref py py-const docutils literal notranslate"><span class="pre">SERVER_AUTH</span></code></a>
as <em>purpose</em> sets <a class="reference internal" href="ssl.html#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-data docutils literal notranslate"><span class="pre">verify_mode</span></code></a> to <a class="reference internal" href="ssl.html#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>
and either loads CA certificates (when at least one of <em>cafile</em>, <em>capath</em> or
<em>cadata</em> is given) or uses <a class="reference internal" href="ssl.html#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_default_certs()</span></code></a> to load
default CA certificates.</p>
<p>When <a class="reference internal" href="ssl.html#ssl.SSLContext.keylog_filename" title="ssl.SSLContext.keylog_filename"><code class="xref py py-attr docutils literal notranslate"><span class="pre">keylog_filename</span></code></a> is supported and the environment
variable <span class="target" id="index-3"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">SSLKEYLOGFILE</span></code> is set, <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a>
enables key logging.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>プロトコル、オプション、暗号方式その他の設定は、事前に非推奨の状態にすることなく、もっと制限の強い値に変更される場合があります。これらの値は、互換性と安全性との妥当なバランスをとって決められます。</p>
<p>もしもあなたのアプリケーションが特定の設定を必要とする場合、 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> を作って自分自身で設定を適用すべきです。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>ある種の古いクライアントやサーバが接続しようと試みてきた場合に、この関数で作られた <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> が &quot;Protocol or cipher suite mismatch&quot; で始まるエラーを起こすのを目撃したらそれは、この関数が <a class="reference internal" href="ssl.html#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a> を使って除外している SSL 3.0 しかサポートしていないのでしょう。SSL 3.0 は <a class="reference external" href="https://en.wikipedia.org/wiki/POODLE">完璧にぶっ壊れている</a> ことが広く知られています。それでもまだこの関数を使って、ただし SSL 3.0 接続を許可したいと望むならば、これをこのように再有効化できます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">(</span><span class="n">Purpose</span><span class="o">.</span><span class="n">CLIENT_AUTH</span><span class="p">)</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">options</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ssl</span><span class="o">.</span><span class="n">OP_NO_SSLv3</span>
</pre></div>
</div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.4.4 で変更: </span>デフォルトの暗号設定から RC4 が除かれました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.6 で変更: </span>デフォルトの暗号化文字列に ChaCha20/Poly1305 が追加されました。</p>
<p>デフォルトの暗号化文字列から 3DES が除かれました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.8 で変更: </span>Support for key logging to <span class="target" id="index-4"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">SSLKEYLOGFILE</span></code> was added.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.10 で変更: </span>The context now uses <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> or
<a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a> protocol instead of generic
<a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="exceptions">
<h3>例外<a class="headerlink" href="ssl.html#exceptions" title="Link to this heading">¶</a></h3>
<dl class="py exception">
<dt class="sig sig-object py" id="ssl.SSLError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">SSLError</span></span><a class="headerlink" href="ssl.html#ssl.SSLError" title="Link to this definition">¶</a></dt>
<dd><p>(現在のところ OpenSSL ライブラリによって提供されている)下層の SSL 実装からのエラーを伝えるための例外です。このエラーは、低レベルなネットワークの上に載っている、高レベルな暗号化と認証レイヤーでの問題を通知します。このエラーは <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> のサブタイプです。 <a class="reference internal" href="ssl.html#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> インスタンスのエラーコードとメッセージは OpenSSL ライブラリによるものです。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.3 で変更: </span><a class="reference internal" href="ssl.html#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> は以前は <a class="reference internal" href="socket.html#socket.error" title="socket.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">socket.error</span></code></a> のサブタイプでした。</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLError.library">
<span class="sig-name descname"><span class="pre">library</span></span><a class="headerlink" href="ssl.html#ssl.SSLError.library" title="Link to this definition">¶</a></dt>
<dd><p>エラーが起こった OpenSSL サブモジュールを示すニーモニック文字列で、 <code class="docutils literal notranslate"><span class="pre">SSL</span></code>, <code class="docutils literal notranslate"><span class="pre">PEM</span></code>, <code class="docutils literal notranslate"><span class="pre">X509</span></code> などです。取り得る値は OpenSSL のバージョンに依存します。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLError.reason">
<span class="sig-name descname"><span class="pre">reason</span></span><a class="headerlink" href="ssl.html#ssl.SSLError.reason" title="Link to this definition">¶</a></dt>
<dd><p>エラーが起こった原因を示すニーモニック文字列で、 <code class="docutils literal notranslate"><span class="pre">CERTIFICATE_VERIFY_FAILED</span></code> などです。取り得る値は OpenSSL のバージョンに依存します。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ssl.SSLZeroReturnError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">SSLZeroReturnError</span></span><a class="headerlink" href="ssl.html#ssl.SSLZeroReturnError" title="Link to this definition">¶</a></dt>
<dd><p>読み出しあるいは書き込みを試みようとした際に SSL コネクションが行儀よく閉じられてしまった場合に送出される <a class="reference internal" href="ssl.html#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> サブクラス例外です。これは下層の転送(read TCP)が閉じたことは意味しないことに注意してください。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ssl.SSLWantReadError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">SSLWantReadError</span></span><a class="headerlink" href="ssl.html#ssl.SSLWantReadError" title="Link to this definition">¶</a></dt>
<dd><p>読み出しあるいは書き込みを試みようとした際に、リクエストが遂行される前に下層の TCP 転送で受け取る必要があるデータが不足した場合に <a class="reference internal" href="ssl.html#ssl-nonblocking"><span class="std std-ref">non-blocking SSL socket</span></a> によって送出される <a class="reference internal" href="ssl.html#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> サブクラス例外です。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ssl.SSLWantWriteError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">SSLWantWriteError</span></span><a class="headerlink" href="ssl.html#ssl.SSLWantWriteError" title="Link to this definition">¶</a></dt>
<dd><p>読み出しあるいは書き込みを試みようとした際に、リクエストが遂行される前に下層の TCP 転送が送信する必要があるデータが不足した場合に <a class="reference internal" href="ssl.html#ssl-nonblocking"><span class="std std-ref">non-blocking SSL socket</span></a> によって送出される <a class="reference internal" href="ssl.html#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> サブクラス例外です。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ssl.SSLSyscallError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">SSLSyscallError</span></span><a class="headerlink" href="ssl.html#ssl.SSLSyscallError" title="Link to this definition">¶</a></dt>
<dd><p>SSL ソケット上で操作を遂行しようとしていてシステムエラーが起こった場合に送出される <a class="reference internal" href="ssl.html#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> サブクラス例外です。残念ながら元となった errno 番号を調べる簡単な方法はありません。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ssl.SSLEOFError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">SSLEOFError</span></span><a class="headerlink" href="ssl.html#ssl.SSLEOFError" title="Link to this definition">¶</a></dt>
<dd><p>SSL コネクションが唐突に打ち切られた際に送出される <a class="reference internal" href="ssl.html#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> サブクラス例外です。一般的に、このエラーが起こったら下層の転送を再利用しようと試みるべきではありません。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ssl.SSLCertVerificationError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">SSLCertVerificationError</span></span><a class="headerlink" href="ssl.html#ssl.SSLCertVerificationError" title="Link to this definition">¶</a></dt>
<dd><p>A subclass of <a class="reference internal" href="ssl.html#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> raised when certificate validation has
failed.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLCertVerificationError.verify_code">
<span class="sig-name descname"><span class="pre">verify_code</span></span><a class="headerlink" href="ssl.html#ssl.SSLCertVerificationError.verify_code" title="Link to this definition">¶</a></dt>
<dd><p>A numeric error number that denotes the verification error.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLCertVerificationError.verify_message">
<span class="sig-name descname"><span class="pre">verify_message</span></span><a class="headerlink" href="ssl.html#ssl.SSLCertVerificationError.verify_message" title="Link to this definition">¶</a></dt>
<dd><p>A human readable string of the verification error.</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ssl.CertificateError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">CertificateError</span></span><a class="headerlink" href="ssl.html#ssl.CertificateError" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ssl.html#ssl.SSLCertVerificationError" title="ssl.SSLCertVerificationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLCertVerificationError</span></code></a> の別名です。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.7 で変更: </span>例外は <a class="reference internal" href="ssl.html#ssl.SSLCertVerificationError" title="ssl.SSLCertVerificationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLCertVerificationError</span></code></a> の別名になりました。</p>
</div>
</dd></dl>

</section>
<section id="random-generation">
<h3>乱数生成<a class="headerlink" href="ssl.html#random-generation" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="ssl.RAND_bytes">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">RAND_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.RAND_bytes" title="Link to this definition">¶</a></dt>
<dd><p>暗号学的に強固な擬似乱数の <em>num</em> バイトを返します。擬似乱数生成器に十分なデータでシードが与えられていない場合や、現在の RANDOM メソッドに操作がサポートされていない場合は <a class="reference internal" href="ssl.html#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a> を送出します。 <a class="reference internal" href="ssl.html#ssl.RAND_status" title="ssl.RAND_status"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_status()</span></code></a> を使って擬似乱数生成器の状態をチェックできます。
<a class="reference internal" href="ssl.html#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_add()</span></code></a> を使って擬似乱数生成器にシードを与えることができます。</p>
<p>ほとんどすべてのアプリケーションでは <a class="reference internal" href="os.html#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a> が望ましいです。</p>
<p>暗号論的に強い擬似乱数生成器に要求されることについては Wikipedia の記事 <a class="reference external" href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator">Cryptographically secure pseudorandom number generator (CSPRNG)</a> (日本語版: <a class="reference external" href="http://ja.wikipedia.org/wiki/%E6%9A%97%E5%8F%B7%E8%AB%96%E7%9A%84%E6%93%AC%E4%BC%BC%E4%B9%B1%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8">暗号論的擬似乱数生成器</a>) を参照してください。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ssl.RAND_status">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">RAND_status</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.RAND_status" title="Link to this definition">¶</a></dt>
<dd><p>SSL 擬似乱数生成器が十分なランダム性(randomness)を受け取っている時に <code class="docutils literal notranslate"><span class="pre">True</span></code> を、それ以外の場合は <cite>False</cite> を返します。 <code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.RAND_egd()</span></code> と <a class="reference internal" href="ssl.html#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.RAND_add()</span></code></a> を使って擬似乱数生成機にランダム性を加えることができます。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ssl.RAND_add">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">RAND_add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bytes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entropy</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.RAND_add" title="Link to this definition">¶</a></dt>
<dd><p>Mix the given <em>bytes</em> into the SSL pseudo-random number generator.  The
parameter <em>entropy</em> (a float) is a lower bound on the entropy contained in
string (so you can always use <code class="docutils literal notranslate"><span class="pre">0.0</span></code>).  See <span class="target" id="index-5"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1750.html"><strong>RFC 1750</strong></a> for more
information on sources of entropy.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.5 で変更: </span>書き込み可能な <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> を使用できるようになりました。</p>
</div>
</dd></dl>

</section>
<section id="certificate-handling">
<h3>証明書の取り扱い<a class="headerlink" href="ssl.html#certificate-handling" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="ssl.cert_time_to_seconds">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">cert_time_to_seconds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cert_time</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.cert_time_to_seconds" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">cert_time</span></code> として証明書内の &quot;notBefore&quot; や &quot;notAfter&quot; の <code class="docutils literal notranslate"><span class="pre">&quot;%b</span> <span class="pre">%d</span> <span class="pre">%H:%M:%S</span> <span class="pre">%Y</span> <span class="pre">%Z&quot;</span></code> strptime フォーマット (C locale) 日付を渡すと、エポックからの積算秒を返します。</p>
<p>例です。 :</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ssl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">cert_time_to_seconds</span><span class="p">(</span><span class="s2">&quot;Jan  5 09:34:43 2018 GMT&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timestamp</span>  
<span class="go">1515144883</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">utcfromtimestamp</span><span class="p">(</span><span class="n">timestamp</span><span class="p">))</span>  
<span class="go">2018-01-05 09:34:43</span>
</pre></div>
</div>
<p>&quot;notBefore&quot; や &quot;notAfter&quot; の日付には GMT を使わなければなりません(<span class="target" id="index-32"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5280.html"><strong>RFC 5280</strong></a>)。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.5 で変更: </span>入力文字列に指定された 'GMT' タイムゾーンを UTC として解釈するようになりました。以前はローカルタイムで解釈していました。また、整数を返すようになりました(入力に含まれる秒の端数を含まない)。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ssl.get_server_certificate">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">get_server_certificate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">addr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_version=PROTOCOL_TLS_CLIENT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ca_certs=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.get_server_certificate" title="Link to this definition">¶</a></dt>
<dd><p>Given the address <code class="docutils literal notranslate"><span class="pre">addr</span></code> of an SSL-protected server, as a (<em>hostname</em>,
<em>port-number</em>) pair, fetches the server's certificate, and returns it as a
PEM-encoded string.  If <code class="docutils literal notranslate"><span class="pre">ssl_version</span></code> is specified, uses that version of
the SSL protocol to attempt to connect to the server.  If <em>ca_certs</em> is
specified, it should be a file containing a list of root certificates, the
same format as used for the <em>cafile</em> parameter in
<a class="reference internal" href="ssl.html#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations()</span></code></a>.  The call will attempt to validate the
server certificate against that set of root certificates, and will fail
if the validation attempt fails.  A timeout can be specified with the
<code class="docutils literal notranslate"><span class="pre">timeout</span></code> parameter.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.3 で変更: </span>この関数はIPv6互換になりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.5 で変更: </span><em>ssl_version</em> のデフォルトが、最近のサーバへの最大限の互換性のために <a class="reference internal" href="ssl.html#ssl.PROTOCOL_SSLv3" title="ssl.PROTOCOL_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_SSLv3</span></code></a> から <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> に変更されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.10 で変更: </span><em>timeout</em> 引数が追加されました。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ssl.DER_cert_to_PEM_cert">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">DER_cert_to_PEM_cert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">DER_cert_bytes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.DER_cert_to_PEM_cert" title="Link to this definition">¶</a></dt>
<dd><p>DERエンコードされたバイト列として与えられた証明書から、 PEMエンコードされたバージョンの同じ証明書を返します。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ssl.PEM_cert_to_DER_cert">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">PEM_cert_to_DER_cert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">PEM_cert_string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.PEM_cert_to_DER_cert" title="Link to this definition">¶</a></dt>
<dd><p>PEM 形式のASCII文字列として与えられた証明書から、同じ証明書をDERエンコードしたバイト列を返します。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ssl.get_default_verify_paths">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">get_default_verify_paths</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.get_default_verify_paths" title="Link to this definition">¶</a></dt>
<dd><p>OpenSSL デフォルトの cafile, capath を指すパスを名前付きタプルで返します。パスは <a class="reference internal" href="ssl.html#ssl.SSLContext.set_default_verify_paths" title="ssl.SSLContext.set_default_verify_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_default_verify_paths()</span></code></a> で使われるものと同じです。戻り値は <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> <code class="docutils literal notranslate"><span class="pre">DefaultVerifyPaths</span></code> です:</p>
<ul class="simple">
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">cafile</span></code> - cafile の解決済みパス、またはファイルが存在しない場合は <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">capath</span></code> - capath の解決済みパス、またはディレクトリが存在しない場合は <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_cafile_env</span></code> - cafile を指す OpenSSL の環境変数</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_cafile</span></code> - OpenSSL にハードコードされた cafile のパス</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_capath_env</span></code> - capath を指す OpenSSL の環境変数</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_capath</span></code> - OpenSSL にハードコードされた capath のパス</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ssl.enum_certificates">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">enum_certificates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">store_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.enum_certificates" title="Link to this definition">¶</a></dt>
<dd><p>Windows のシステム証明書ストアより証明書を抽出します。 <em>store_name</em> は <code class="docutils literal notranslate"><span class="pre">CA</span></code>, <code class="docutils literal notranslate"><span class="pre">ROOT</span></code>, <code class="docutils literal notranslate"><span class="pre">MY</span></code> のうちどれか一つでしょう。Windows は追加の証明書ストアを提供しているかもしれません。</p>
<p>この関数はタプル (cert_bytes, encoding_type, trust) のリストで返します。encoding_type は cert_bytes のエンコーディングを表します。X.509 ASN.1 に対する <code class="xref py py-const docutils literal notranslate"><span class="pre">x509_asn</span></code> か PKCS#7 ASN.1 データに対する <code class="xref py py-const docutils literal notranslate"><span class="pre">pkcs_7_asn</span></code> のいずれかです。trust は、証明書の目的を、OIDS を内容に持つ set として表すか、または証明書がすべての目的で信頼できるならば <code class="docutils literal notranslate"><span class="pre">True</span></code> です。</p>
<p>以下はプログラム例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">enum_certificates</span><span class="p">(</span><span class="s2">&quot;CA&quot;</span><span class="p">)</span>
<span class="go">[(b&#39;data...&#39;, &#39;x509_asn&#39;, {&#39;1.3.6.1.5.5.7.3.1&#39;, &#39;1.3.6.1.5.5.7.3.2&#39;}),</span>
<span class="go"> (b&#39;data...&#39;, &#39;x509_asn&#39;, True)]</span>
</pre></div>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">利用可能な環境</span></a>: Windows 。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ssl.enum_crls">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">enum_crls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">store_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.enum_crls" title="Link to this definition">¶</a></dt>
<dd><p>Windows のシステム証明書ストアより CRLs を抽出します。 <em>store_name</em> は <code class="docutils literal notranslate"><span class="pre">CA</span></code>, <code class="docutils literal notranslate"><span class="pre">ROOT</span></code>, <code class="docutils literal notranslate"><span class="pre">MY</span></code> のうちどれか一つでしょう。Windows は追加の証明書ストアを提供しているかもしれません。</p>
<p>この関数はタプル (cert_bytes, encoding_type, trust) のリストで返します。encoding_type は cert_bytes のエンコーディングを表します。X.509 ASN.1 に対する <code class="xref py py-const docutils literal notranslate"><span class="pre">x509_asn</span></code> か PKCS#7 ASN.1 データに対する <code class="xref py py-const docutils literal notranslate"><span class="pre">pkcs_7_asn</span></code> のいずれかです。</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">利用可能な環境</span></a>: Windows 。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

</section>
<section id="constants">
<h3>定数<a class="headerlink" href="ssl.html#constants" title="Link to this heading">¶</a></h3>
<blockquote>
<div><p>すべての定数が <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> コレクションまたは <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a> コレクションになりました。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</div></blockquote>
<dl class="py data">
<dt class="sig sig-object py" id="ssl.CERT_NONE">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">CERT_NONE</span></span><a class="headerlink" href="ssl.html#ssl.CERT_NONE" title="Link to this definition">¶</a></dt>
<dd><p>Possible value for <a class="reference internal" href="ssl.html#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a>.
Except for <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a>,
it is the default mode.  With client-side sockets, just about any
cert is accepted.  Validation errors, such as untrusted or expired cert,
are ignored and do not abort the TLS/SSL handshake.</p>
<p>In server mode, no certificate is requested from the client, so the client
does not send any for client cert authentication.</p>
<p>このドキュメントの下の方の、 <a class="reference internal" href="ssl.html#ssl-security"><span class="std std-ref">セキュリティで考慮すべき点</span></a> に関する議論を参照してください。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.CERT_OPTIONAL">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">CERT_OPTIONAL</span></span><a class="headerlink" href="ssl.html#ssl.CERT_OPTIONAL" title="Link to this definition">¶</a></dt>
<dd><p>Possible value for <a class="reference internal" href="ssl.html#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a>.
In client mode, <a class="reference internal" href="ssl.html#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a>
has the same meaning as <a class="reference internal" href="ssl.html#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>. It is recommended to
use <a class="reference internal" href="ssl.html#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> for client-side sockets instead.</p>
<p>In server mode, a client certificate request is sent to the client.  The
client may either ignore the request or send a certificate in order
perform TLS client cert authentication.  If the client chooses to send
a certificate, it is verified.  Any verification error immediately aborts
the TLS handshake.</p>
<p>Use of this setting requires a valid set of CA certificates to
be passed to <a class="reference internal" href="ssl.html#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations()</span></code></a>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.CERT_REQUIRED">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">CERT_REQUIRED</span></span><a class="headerlink" href="ssl.html#ssl.CERT_REQUIRED" title="Link to this definition">¶</a></dt>
<dd><p>Possible value for <a class="reference internal" href="ssl.html#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a>.
In this mode, certificates are
required from the other side of the socket connection; an <a class="reference internal" href="ssl.html#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a>
will be raised if no certificate is provided, or if its validation fails.
This mode is <strong>not</strong> sufficient to verify a certificate in client mode as
it does not match hostnames.  <a class="reference internal" href="ssl.html#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> must be
enabled as well to verify the authenticity of a cert.
<a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> uses <a class="reference internal" href="ssl.html#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> and
enables <a class="reference internal" href="ssl.html#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> by default.</p>
<p>With server socket, this mode provides mandatory TLS client cert
authentication.  A client certificate request is sent to the client and
the client must provide a valid and trusted certificate.</p>
<p>Use of this setting requires a valid set of CA certificates to
be passed to <a class="reference internal" href="ssl.html#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations()</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ssl.VerifyMode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">VerifyMode</span></span><a class="headerlink" href="ssl.html#ssl.VerifyMode" title="Link to this definition">¶</a></dt>
<dd><p>CERT_* 定数の <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> コレクションです。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.VERIFY_DEFAULT">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">VERIFY_DEFAULT</span></span><a class="headerlink" href="ssl.html#ssl.VERIFY_DEFAULT" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ssl.html#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> に渡せる値です。このモードでは、証明書失効リスト(CRLs)はチェックされません。デフォルトでは OpenSSL は CRLs を必要ともしませんし検証にも使いません。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.VERIFY_CRL_CHECK_LEAF">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">VERIFY_CRL_CHECK_LEAF</span></span><a class="headerlink" href="ssl.html#ssl.VERIFY_CRL_CHECK_LEAF" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ssl.html#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> に渡せる値です。このモードでは、接続先の証明書のみがチェックされ、仲介の CA 証明書はチェックされません。接続先証明書の発行者(その CA の直接の祖先)によって署名された妥当な CRL が必要です。 <a class="reference internal" href="ssl.html#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations</span></code></a> で相応しい CRL をロードしていなければ、検証は失敗します。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.VERIFY_CRL_CHECK_CHAIN">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">VERIFY_CRL_CHECK_CHAIN</span></span><a class="headerlink" href="ssl.html#ssl.VERIFY_CRL_CHECK_CHAIN" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ssl.html#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> に渡せる値です。このモードでは、接続先の証明書チェイン内のすべての証明書についての CRLs がチェックされます。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.VERIFY_X509_STRICT">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">VERIFY_X509_STRICT</span></span><a class="headerlink" href="ssl.html#ssl.VERIFY_X509_STRICT" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ssl.html#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> に渡せる値で、壊れた X.509 証明書に対するワークアラウンドを無効にします。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.VERIFY_ALLOW_PROXY_CERTS">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">VERIFY_ALLOW_PROXY_CERTS</span></span><a class="headerlink" href="ssl.html#ssl.VERIFY_ALLOW_PROXY_CERTS" title="Link to this definition">¶</a></dt>
<dd><p>Possible value for <a class="reference internal" href="ssl.html#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> to enables proxy
certificate verification.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.VERIFY_X509_TRUSTED_FIRST">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">VERIFY_X509_TRUSTED_FIRST</span></span><a class="headerlink" href="ssl.html#ssl.VERIFY_X509_TRUSTED_FIRST" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ssl.html#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> に渡せる値です。OpenSSL に対し、証明書検証のために信頼チェインを構築する際、信頼できる証明書を選ぶように指示します。これはデフォルトで有効にされています。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.4.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.VERIFY_X509_PARTIAL_CHAIN">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">VERIFY_X509_PARTIAL_CHAIN</span></span><a class="headerlink" href="ssl.html#ssl.VERIFY_X509_PARTIAL_CHAIN" title="Link to this definition">¶</a></dt>
<dd><p>Possible value for <a class="reference internal" href="ssl.html#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a>. It instructs OpenSSL to
accept intermediate CAs in the trust store to be treated as trust-anchors,
in the same way as the self-signed root CA certificates. This makes it
possible to trust certificates issued by an intermediate CA without having
to trust its ancestor root CA.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ssl.VerifyFlags">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">VerifyFlags</span></span><a class="headerlink" href="ssl.html#ssl.VerifyFlags" title="Link to this definition">¶</a></dt>
<dd><p>VERIFY_* 定数の <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a> コレクションです。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.PROTOCOL_TLS">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">PROTOCOL_TLS</span></span><a class="headerlink" href="ssl.html#ssl.PROTOCOL_TLS" title="Link to this definition">¶</a></dt>
<dd><p>クライアントとサーバの両方がサポートするプロトコルバージョンのうち、最も大きなものを選択します。名前に反して、このオプションは &quot;SSL&quot; と &quot;TLS&quot; プロトコルのいずれも選択できます。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.10 で非推奨: </span>TLS clients and servers require different default settings for secure
communication. The generic TLS protocol constant is deprecated in
favor of <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> and <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.PROTOCOL_TLS_CLIENT">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">PROTOCOL_TLS_CLIENT</span></span><a class="headerlink" href="ssl.html#ssl.PROTOCOL_TLS_CLIENT" title="Link to this definition">¶</a></dt>
<dd><p>Auto-negotiate the highest protocol version that both the client and
server support, and configure the context client-side connections. The
protocol enables <a class="reference internal" href="ssl.html#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> and
<a class="reference internal" href="ssl.html#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> by default.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.PROTOCOL_TLS_SERVER">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">PROTOCOL_TLS_SERVER</span></span><a class="headerlink" href="ssl.html#ssl.PROTOCOL_TLS_SERVER" title="Link to this definition">¶</a></dt>
<dd><p>Auto-negotiate the highest protocol version that both the client and
server support, and configure the context server-side connections.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.PROTOCOL_SSLv23">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">PROTOCOL_SSLv23</span></span><a class="headerlink" href="ssl.html#ssl.PROTOCOL_SSLv23" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> のエイリアスです。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.6 で非推奨: </span>代わりに <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> を使用してください。</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.PROTOCOL_SSLv3">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">PROTOCOL_SSLv3</span></span><a class="headerlink" href="ssl.html#ssl.PROTOCOL_SSLv3" title="Link to this definition">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとしてSSLバージョン3を選択します。</p>
<p>このプロトコルは、 OpenSSL が <code class="docutils literal notranslate"><span class="pre">no-ssl3</span></code> オプションをつけてコンパイルされている場合には利用できません。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>SSL version 3 は非セキュアです。このプロトコルは強く非推奨です。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.6 で非推奨: </span>OpenSSL has deprecated all version specific protocols. Use the default
protocol <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a> or <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a>
with <a class="reference internal" href="ssl.html#ssl.SSLContext.minimum_version" title="ssl.SSLContext.minimum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.minimum_version</span></code></a> and
<a class="reference internal" href="ssl.html#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.maximum_version</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.PROTOCOL_TLSv1">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">PROTOCOL_TLSv1</span></span><a class="headerlink" href="ssl.html#ssl.PROTOCOL_TLSv1" title="Link to this definition">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとしてTLSバージョン1.0を選択します。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.6 で非推奨: </span>OpenSSL has deprecated all version specific protocols.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.PROTOCOL_TLSv1_1">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">PROTOCOL_TLSv1_1</span></span><a class="headerlink" href="ssl.html#ssl.PROTOCOL_TLSv1_1" title="Link to this definition">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとしてTLSバージョン1.1を選択します。 openssl version 1.0.1+ のみで利用可能です。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.6 で非推奨: </span>OpenSSL has deprecated all version specific protocols.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.PROTOCOL_TLSv1_2">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">PROTOCOL_TLSv1_2</span></span><a class="headerlink" href="ssl.html#ssl.PROTOCOL_TLSv1_2" title="Link to this definition">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとしてTLSバージョン 1.2 を選択します。 openssl version 1.0.1+ のみで利用可能です。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.6 で非推奨: </span>OpenSSL has deprecated all version specific protocols.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OP_ALL">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OP_ALL</span></span><a class="headerlink" href="ssl.html#ssl.OP_ALL" title="Link to this definition">¶</a></dt>
<dd><p>相手にする SSL 実装のさまざまなバグを回避するためのワークアラウンドを有効にします。このオプションはデフォルトで有効です。これを有効にする場合 OpenSSL 用の同じ意味のフラグ <code class="docutils literal notranslate"><span class="pre">SSL_OP_ALL</span></code> をセットする必要はありません。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OP_NO_SSLv2">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OP_NO_SSLv2</span></span><a class="headerlink" href="ssl.html#ssl.OP_NO_SSLv2" title="Link to this definition">¶</a></dt>
<dd><p>SSLv2 接続が行われないようにします。このオプションは <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> と組み合わされている場合にのみ適用されます。ピアがプロトコルバージョンとして SSLv2 を選択しないようにします。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.6 で非推奨: </span>SSLv2 は非推奨です</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OP_NO_SSLv3">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OP_NO_SSLv3</span></span><a class="headerlink" href="ssl.html#ssl.OP_NO_SSLv3" title="Link to this definition">¶</a></dt>
<dd><p>SSLv3 接続が行われないようにします。このオプションは <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> と組み合わされている場合にのみ適用されます。ピアがプロトコルバージョンとして SSLv3 を選択しないようにします。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.6 で非推奨: </span>SSLv3 は非推奨です</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OP_NO_TLSv1">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OP_NO_TLSv1</span></span><a class="headerlink" href="ssl.html#ssl.OP_NO_TLSv1" title="Link to this definition">¶</a></dt>
<dd><p>TLSv1 接続が行われないようにします。このオプションは <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> と組み合わされている場合にのみ適用されます。ピアがプロトコルバージョンとして TLSv1 を選択しないようにします。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.7 で非推奨: </span>The option is deprecated since OpenSSL 1.1.0, use the new
<a class="reference internal" href="ssl.html#ssl.SSLContext.minimum_version" title="ssl.SSLContext.minimum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.minimum_version</span></code></a> and
<a class="reference internal" href="ssl.html#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.maximum_version</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OP_NO_TLSv1_1">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OP_NO_TLSv1_1</span></span><a class="headerlink" href="ssl.html#ssl.OP_NO_TLSv1_1" title="Link to this definition">¶</a></dt>
<dd><p>TLSv1.1 接続が行われないようにします。このオプションは <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> と組み合わされている場合にのみ適用されます。ピアがプロトコルバージョンとして TLSv1.1 を選択しないようにします。openssl バージョン 1.0.1 以降でのみ利用できます。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.7 で非推奨: </span>The option is deprecated since OpenSSL 1.1.0.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OP_NO_TLSv1_2">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OP_NO_TLSv1_2</span></span><a class="headerlink" href="ssl.html#ssl.OP_NO_TLSv1_2" title="Link to this definition">¶</a></dt>
<dd><p>TLSv1.2 接続が行われないようにします。このオプションは <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> と組み合わされている場合にのみ適用されます。ピアがプロトコルバージョンとして TLSv1.2 を選択しないようにします。openssl バージョン 1.0.1 以降でのみ利用できます。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.7 で非推奨: </span>The option is deprecated since OpenSSL 1.1.0.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OP_NO_TLSv1_3">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OP_NO_TLSv1_3</span></span><a class="headerlink" href="ssl.html#ssl.OP_NO_TLSv1_3" title="Link to this definition">¶</a></dt>
<dd><p>Prevents a TLSv1.3 connection. This option is only applicable in conjunction
with <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>. It prevents the peers from choosing TLSv1.3 as
the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later.
When Python has been compiled against an older version of OpenSSL, the
flag defaults to <em>0</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.7 で非推奨: </span>The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15 and
3.6.3 for backwards compatibility with OpenSSL 1.0.2.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OP_NO_RENEGOTIATION">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OP_NO_RENEGOTIATION</span></span><a class="headerlink" href="ssl.html#ssl.OP_NO_RENEGOTIATION" title="Link to this definition">¶</a></dt>
<dd><p>Disable all renegotiation in TLSv1.2 and earlier. Do not send
HelloRequest messages, and ignore renegotiation requests via ClientHello.</p>
<p>このオプションは OpenSSL 1.1.0h 以降のみで使用できます。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OP_CIPHER_SERVER_PREFERENCE">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OP_CIPHER_SERVER_PREFERENCE</span></span><a class="headerlink" href="ssl.html#ssl.OP_CIPHER_SERVER_PREFERENCE" title="Link to this definition">¶</a></dt>
<dd><p>暗号の優先順位として、クライアントのものではなくサーバのものを使います。このオプションはクライアントソケットと SSLv2 のサーバソケットでは効果はありません。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OP_SINGLE_DH_USE">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OP_SINGLE_DH_USE</span></span><a class="headerlink" href="ssl.html#ssl.OP_SINGLE_DH_USE" title="Link to this definition">¶</a></dt>
<dd><p>Prevents reuse of the same DH key for distinct SSL sessions.  This
improves forward secrecy but requires more computational resources.
This option only applies to server sockets.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OP_SINGLE_ECDH_USE">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OP_SINGLE_ECDH_USE</span></span><a class="headerlink" href="ssl.html#ssl.OP_SINGLE_ECDH_USE" title="Link to this definition">¶</a></dt>
<dd><p>Prevents reuse of the same ECDH key for distinct SSL sessions.  This
improves forward secrecy but requires more computational resources.
This option only applies to server sockets.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OP_ENABLE_MIDDLEBOX_COMPAT">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OP_ENABLE_MIDDLEBOX_COMPAT</span></span><a class="headerlink" href="ssl.html#ssl.OP_ENABLE_MIDDLEBOX_COMPAT" title="Link to this definition">¶</a></dt>
<dd><p>Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make
a TLS 1.3 connection look more like a TLS 1.2 connection.</p>
<p>このオプションは OpenSSL 1.1.1 以降のみで使用できます。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OP_NO_COMPRESSION">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OP_NO_COMPRESSION</span></span><a class="headerlink" href="ssl.html#ssl.OP_NO_COMPRESSION" title="Link to this definition">¶</a></dt>
<dd><p>SSL チャネルでの圧縮を無効にします。これはアプリケーションのプロトコルが自身の圧縮方法をサポートする場合に有用です。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ssl.Options">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">Options</span></span><a class="headerlink" href="ssl.html#ssl.Options" title="Link to this definition">¶</a></dt>
<dd><p>OP_* 定数の <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a> コレクションです。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OP_NO_TICKET">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OP_NO_TICKET</span></span><a class="headerlink" href="ssl.html#ssl.OP_NO_TICKET" title="Link to this definition">¶</a></dt>
<dd><p>クライアントサイドがセッションチケットをリクエストしないようにします。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OP_IGNORE_UNEXPECTED_EOF">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OP_IGNORE_UNEXPECTED_EOF</span></span><a class="headerlink" href="ssl.html#ssl.OP_IGNORE_UNEXPECTED_EOF" title="Link to this definition">¶</a></dt>
<dd><p>Ignore unexpected shutdown of TLS connections.</p>
<p>このオプションは OpenSSL 3.0.0以降のみで使用できます。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OP_ENABLE_KTLS">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OP_ENABLE_KTLS</span></span><a class="headerlink" href="ssl.html#ssl.OP_ENABLE_KTLS" title="Link to this definition">¶</a></dt>
<dd><p>Enable the use of the kernel TLS. To benefit from the feature, OpenSSL must
have been compiled with support for it, and the negotiated cipher suites and
extensions must be supported by it (a list of supported ones may vary by
platform and kernel version).</p>
<p>Note that with enabled kernel TLS some cryptographic operations are
performed by the kernel directly and not via any available OpenSSL
Providers. This might be undesirable if, for example, the application
requires all cryptographic operations to be performed by the FIPS provider.</p>
<p>このオプションは OpenSSL 3.0.0以降のみで使用できます。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OP_LEGACY_SERVER_CONNECT">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OP_LEGACY_SERVER_CONNECT</span></span><a class="headerlink" href="ssl.html#ssl.OP_LEGACY_SERVER_CONNECT" title="Link to this definition">¶</a></dt>
<dd><p>Allow legacy insecure renegotiation between OpenSSL and unpatched servers
only.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.HAS_ALPN">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">HAS_ALPN</span></span><a class="headerlink" href="ssl.html#ssl.HAS_ALPN" title="Link to this definition">¶</a></dt>
<dd><p>OpenSSL ライブラリが、組み込みで <span class="target" id="index-33"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7301.html"><strong>RFC 7301</strong></a> で記述されている <em>Application-Layer Protocol Negotiation</em> TLS 拡張をサポートしているかどうか。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.HAS_NEVER_CHECK_COMMON_NAME">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">HAS_NEVER_CHECK_COMMON_NAME</span></span><a class="headerlink" href="ssl.html#ssl.HAS_NEVER_CHECK_COMMON_NAME" title="Link to this definition">¶</a></dt>
<dd><p>Whether the OpenSSL library has built-in support not checking subject
common name and <a class="reference internal" href="ssl.html#ssl.SSLContext.hostname_checks_common_name" title="ssl.SSLContext.hostname_checks_common_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.hostname_checks_common_name</span></code></a> is
writeable.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.HAS_ECDH">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">HAS_ECDH</span></span><a class="headerlink" href="ssl.html#ssl.HAS_ECDH" title="Link to this definition">¶</a></dt>
<dd><p>OpenSSL ライブラリが、組み込みの楕円曲線ディフィー・ヘルマン鍵共有をサポートしているかどうか。これは、ディストリビュータが明示的に無効にしていない限りは、真であるはずです。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.HAS_SNI">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">HAS_SNI</span></span><a class="headerlink" href="ssl.html#ssl.HAS_SNI" title="Link to this definition">¶</a></dt>
<dd><p>OpenSSL ライブラリが、組み込みで (<span class="target" id="index-34"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6066.html"><strong>RFC 6066</strong></a> で記述されている) <em>Server Name Indication</em> 拡張をサポートしているかどうか。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.HAS_NPN">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">HAS_NPN</span></span><a class="headerlink" href="ssl.html#ssl.HAS_NPN" title="Link to this definition">¶</a></dt>
<dd><p>OpenSSL ライブラリが、組み込みで、<a class="reference external" href="https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation">Application Layer Protocol Negotiation</a> で記述されている <em>Next Protocol Negotiation</em> をサポートしているかどうか。 true であれば、サポートしたいプロトコルを <a class="reference internal" href="ssl.html#ssl.SSLContext.set_npn_protocols" title="ssl.SSLContext.set_npn_protocols"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_npn_protocols()</span></code></a> メソッドで提示することができます。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.HAS_SSLv2">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">HAS_SSLv2</span></span><a class="headerlink" href="ssl.html#ssl.HAS_SSLv2" title="Link to this definition">¶</a></dt>
<dd><p>OpenSSL ライブラリが、組み込みで SSL 2.0 プロトコルをサポートしているかどうか。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.HAS_SSLv3">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">HAS_SSLv3</span></span><a class="headerlink" href="ssl.html#ssl.HAS_SSLv3" title="Link to this definition">¶</a></dt>
<dd><p>OpenSSL ライブラリが、組み込みで SSL 3.0 プロトコルをサポートしているかどうか。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.HAS_TLSv1">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">HAS_TLSv1</span></span><a class="headerlink" href="ssl.html#ssl.HAS_TLSv1" title="Link to this definition">¶</a></dt>
<dd><p>OpenSSL ライブラリが、組み込みで TLS 1.0 プロトコルをサポートしているかどうか。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.HAS_TLSv1_1">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">HAS_TLSv1_1</span></span><a class="headerlink" href="ssl.html#ssl.HAS_TLSv1_1" title="Link to this definition">¶</a></dt>
<dd><p>OpenSSL ライブラリが、組み込みで TLS 1.1 プロトコルをサポートしているかどうか。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.HAS_TLSv1_2">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">HAS_TLSv1_2</span></span><a class="headerlink" href="ssl.html#ssl.HAS_TLSv1_2" title="Link to this definition">¶</a></dt>
<dd><p>OpenSSL ライブラリが、組み込みで TLS 1.2 プロトコルをサポートしているかどうか。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.HAS_TLSv1_3">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">HAS_TLSv1_3</span></span><a class="headerlink" href="ssl.html#ssl.HAS_TLSv1_3" title="Link to this definition">¶</a></dt>
<dd><p>OpenSSL ライブラリが、組み込みで TLS 1.3 プロトコルをサポートしているかどうか。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.CHANNEL_BINDING_TYPES">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">CHANNEL_BINDING_TYPES</span></span><a class="headerlink" href="ssl.html#ssl.CHANNEL_BINDING_TYPES" title="Link to this definition">¶</a></dt>
<dd><p>サポートされている TLS のチャネルバインディングのタイプのリスト。リスト内の文字列は <a class="reference internal" href="ssl.html#ssl.SSLSocket.get_channel_binding" title="ssl.SSLSocket.get_channel_binding"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.get_channel_binding()</span></code></a> の引数に渡せます。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OPENSSL_VERSION">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OPENSSL_VERSION</span></span><a class="headerlink" href="ssl.html#ssl.OPENSSL_VERSION" title="Link to this definition">¶</a></dt>
<dd><p>インタプリタによってロードされた OpenSSL ライブラリのバージョン文字列:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION</span>
<span class="go">&#39;OpenSSL 1.0.2k  26 Jan 2017&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OPENSSL_VERSION_INFO">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OPENSSL_VERSION_INFO</span></span><a class="headerlink" href="ssl.html#ssl.OPENSSL_VERSION_INFO" title="Link to this definition">¶</a></dt>
<dd><p>OpenSSL ライブラリのバージョン情報を表す5つの整数のタプル:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_INFO</span>
<span class="go">(1, 0, 2, 11, 15)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.OPENSSL_VERSION_NUMBER">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">OPENSSL_VERSION_NUMBER</span></span><a class="headerlink" href="ssl.html#ssl.OPENSSL_VERSION_NUMBER" title="Link to this definition">¶</a></dt>
<dd><p>1つの整数の形式の、 OpenSSL ライブラリの生のバージョン番号:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_NUMBER</span>
<span class="go">268443839</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_NUMBER</span><span class="p">)</span>
<span class="go">&#39;0x100020bf&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">ALERT_DESCRIPTION_HANDSHAKE_FAILURE</span></span><a class="headerlink" href="ssl.html#ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR">
<span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">ALERT_DESCRIPTION_INTERNAL_ERROR</span></span><a class="headerlink" href="ssl.html#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ALERT_DESCRIPTION_*</span></span></dt>
<dd><p><span class="target" id="index-35"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5246.html"><strong>RFC 5246</strong></a> その他からのアラートの種類です。 <a class="reference external" href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-6">IANA TLS Alert Registry</a> にはこのリストとその意味が定義された RFC へのリファレンスが含まれています。</p>
<p><a class="reference internal" href="ssl.html#ssl.SSLContext.set_servername_callback" title="ssl.SSLContext.set_servername_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_servername_callback()</span></code></a> でのコールバック関数の戻り値として使われます。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ssl.AlertDescription">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">AlertDescription</span></span><a class="headerlink" href="ssl.html#ssl.AlertDescription" title="Link to this definition">¶</a></dt>
<dd><p>ALERT_DESCRIPTION_* 定数の <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> コレクションです。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.Purpose.SERVER_AUTH">
<span class="sig-prename descclassname"><span class="pre">Purpose.</span></span><span class="sig-name descname"><span class="pre">SERVER_AUTH</span></span><a class="headerlink" href="ssl.html#ssl.Purpose.SERVER_AUTH" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> と <a class="reference internal" href="ssl.html#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_default_certs()</span></code></a> に渡すオプションです。この値はコンテキストが web サーバの認証に使われることを示します (ですので、クライアントサイドのソケットを作るのに使うことになるでしょう)。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="ssl.Purpose.CLIENT_AUTH">
<span class="sig-prename descclassname"><span class="pre">Purpose.</span></span><span class="sig-name descname"><span class="pre">CLIENT_AUTH</span></span><a class="headerlink" href="ssl.html#ssl.Purpose.CLIENT_AUTH" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> と <a class="reference internal" href="ssl.html#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_default_certs()</span></code></a> に渡すオプションです。この値はコンテキストが web クライアントの認証に使われることを示します (ですので、サーバサイドのソケットを作るのに使うことになるでしょう)。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ssl.SSLErrorNumber">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">SSLErrorNumber</span></span><a class="headerlink" href="ssl.html#ssl.SSLErrorNumber" title="Link to this definition">¶</a></dt>
<dd><p>SSL_ERROR_* 定数の <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> コレクションです。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ssl.TLSVersion">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">TLSVersion</span></span><a class="headerlink" href="ssl.html#ssl.TLSVersion" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> collection of SSL and TLS versions for
<a class="reference internal" href="ssl.html#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.maximum_version</span></code></a> and <a class="reference internal" href="ssl.html#ssl.SSLContext.minimum_version" title="ssl.SSLContext.minimum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.minimum_version</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.TLSVersion.MINIMUM_SUPPORTED">
<span class="sig-prename descclassname"><span class="pre">TLSVersion.</span></span><span class="sig-name descname"><span class="pre">MINIMUM_SUPPORTED</span></span><a class="headerlink" href="ssl.html#ssl.TLSVersion.MINIMUM_SUPPORTED" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.TLSVersion.MAXIMUM_SUPPORTED">
<span class="sig-prename descclassname"><span class="pre">TLSVersion.</span></span><span class="sig-name descname"><span class="pre">MAXIMUM_SUPPORTED</span></span><a class="headerlink" href="ssl.html#ssl.TLSVersion.MAXIMUM_SUPPORTED" title="Link to this definition">¶</a></dt>
<dd><p>The minimum or maximum supported SSL or TLS version. These are magic
constants. Their values don't reflect the lowest and highest available
TLS/SSL versions.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.TLSVersion.SSLv3">
<span class="sig-prename descclassname"><span class="pre">TLSVersion.</span></span><span class="sig-name descname"><span class="pre">SSLv3</span></span><a class="headerlink" href="ssl.html#ssl.TLSVersion.SSLv3" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.TLSVersion.TLSv1">
<span class="sig-prename descclassname"><span class="pre">TLSVersion.</span></span><span class="sig-name descname"><span class="pre">TLSv1</span></span><a class="headerlink" href="ssl.html#ssl.TLSVersion.TLSv1" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.TLSVersion.TLSv1_1">
<span class="sig-prename descclassname"><span class="pre">TLSVersion.</span></span><span class="sig-name descname"><span class="pre">TLSv1_1</span></span><a class="headerlink" href="ssl.html#ssl.TLSVersion.TLSv1_1" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.TLSVersion.TLSv1_2">
<span class="sig-prename descclassname"><span class="pre">TLSVersion.</span></span><span class="sig-name descname"><span class="pre">TLSv1_2</span></span><a class="headerlink" href="ssl.html#ssl.TLSVersion.TLSv1_2" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.TLSVersion.TLSv1_3">
<span class="sig-prename descclassname"><span class="pre">TLSVersion.</span></span><span class="sig-name descname"><span class="pre">TLSv1_3</span></span><a class="headerlink" href="ssl.html#ssl.TLSVersion.TLSv1_3" title="Link to this definition">¶</a></dt>
<dd><p>SSL 3.0 to TLS 1.3.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.10 で非推奨: </span>All <a class="reference internal" href="ssl.html#ssl.TLSVersion" title="ssl.TLSVersion"><code class="xref py py-class docutils literal notranslate"><span class="pre">TLSVersion</span></code></a> members except <a class="reference internal" href="ssl.html#ssl.TLSVersion.TLSv1_2" title="ssl.TLSVersion.TLSv1_2"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TLSVersion.TLSv1_2</span></code></a> and
<a class="reference internal" href="ssl.html#ssl.TLSVersion.TLSv1_3" title="ssl.TLSVersion.TLSv1_3"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TLSVersion.TLSv1_3</span></code></a> are deprecated.</p>
</div>
</dd></dl>

</section>
</section>
<section id="ssl-sockets">
<h2>SSL ソケット<a class="headerlink" href="ssl.html#ssl-sockets" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="ssl.SSLSocket">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">SSLSocket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">socket.socket</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLSocket" title="Link to this definition">¶</a></dt>
<dd><p>SSL ソケットは <a class="reference internal" href="socket.html#socket-objects"><span class="std std-ref">socket オブジェクト</span></a> の以下のメソッドを提供します:</p>
<ul class="simple">
<li><p><a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.bind" title="socket.socket.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.close" title="socket.socket.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.detach" title="socket.socket.detach"><code class="xref py py-meth docutils literal notranslate"><span class="pre">detach()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.fileno" title="socket.socket.fileno"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fileno()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.getpeername" title="socket.socket.getpeername"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeername()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.getsockname" title="socket.socket.getsockname"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getsockname()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.getsockopt" title="socket.socket.getsockopt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getsockopt()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.setsockopt" title="socket.socket.setsockopt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setsockopt()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.gettimeout" title="socket.socket.gettimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gettimeout()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a>,
<a class="reference internal" href="socket.html#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setblocking()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv_into()</span></code></a> (非ゼロの <code class="docutils literal notranslate"><span class="pre">flags</span></code> は渡せません)</p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendall()</span></code></a> (非ゼロの <code class="docutils literal notranslate"><span class="pre">flags</span></code> は渡せません)</p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.sendfile" title="socket.socket.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendfile()</span></code></a> (ただし、 <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.sendfile</span></code></a> は平文ソケットにのみ使用されます。それ以外の場合には、 <a class="reference internal" href="socket.html#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> が使用されます。)</p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.shutdown" title="socket.socket.shutdown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shutdown()</span></code></a></p></li>
</ul>
<p>SSL(およびTLS)プロトコルは TCP の上に独自の枠組みを持っているので、SSLソケットの抽象化は、いくつかの点で通常の OSレベルのソケットの仕様から逸脱することがあります。特に <a class="reference internal" href="ssl.html#ssl-nonblocking"><span class="std std-ref">ノンブロッキングソケットについての注釈</span></a> を参照してください。</p>
<p><a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> のインスタンスは <a class="reference internal" href="ssl.html#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> メソッドを使用して作成されなければなりません。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.5 で変更: </span><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendfile()</span></code> メソッドが追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.5 で変更: </span><code class="xref py py-meth docutils literal notranslate"><span class="pre">shutdown()</span></code> は、バイトが送受信されるたびにソケットのタイムアウトをリセットしません。ソケットのタイムアウトは、シャットダウンの最大合計時間になりました。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.6 で非推奨: </span><a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> インスタンスを直接作成することは非推奨です。ソケットをラップするために <a class="reference internal" href="ssl.html#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> を使用してください。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.7 で変更: </span><a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> instances must to created with
<a class="reference internal" href="ssl.html#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>. In earlier versions, it was possible
to create instances directly. This was never documented or officially
supported.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.10 で変更: </span>Python now uses <code class="docutils literal notranslate"><span class="pre">SSL_read_ex</span></code> and <code class="docutils literal notranslate"><span class="pre">SSL_write_ex</span></code> internally. The
functions support reading and writing of data larger than 2 GB. Writing
zero-length data no longer fails with a protocol violation error.</p>
</div>
</dd></dl>

<p>SSL ソケットには、以下に示す追加のメソッドと属性もあります:</p>
<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLSocket.read">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">len</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1024</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLSocket.read" title="Link to this definition">¶</a></dt>
<dd><p>SSL ソケットからデータの <em>len</em> バイトまでを読み出し、読み出した結果を <code class="docutils literal notranslate"><span class="pre">bytes</span></code> インスタンスで返します。 <em>buffer</em> を指定すると、結果は代わりに buffer に読み込まれ、読み込んだバイト数を返します。</p>
<p>ソケットが <a class="reference internal" href="ssl.html#ssl-nonblocking"><span class="std std-ref">non-blocking</span></a> で読み出しがブロックすると、 <a class="reference internal" href="ssl.html#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> もしくは <a class="reference internal" href="ssl.html#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> が送出されます。</p>
<p>再ネゴシエーションがいつでも可能なので、 <a class="reference internal" href="ssl.html#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>  の呼び出しは書き込み操作も引き起こしえます。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.5 で変更: </span>ソケットのタイムアウトは、バイトが送受信されるたびにリセットされなくなりました。ソケットのタイムアウトは、最大 <em>len</em> バイトを読むのにかかる最大合計時間になりました。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.6 で非推奨: </span><a class="reference internal" href="ssl.html#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> の代わりに <code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code> を使用してください。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLSocket.write">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLSocket.write" title="Link to this definition">¶</a></dt>
<dd><p><em>buf</em> を SSL ソケットに書き込み、書き込んだバイト数を返します。 <em>buf</em> 引数はバッファインターフェイスをサポートするオブジェクトでなければなりません。</p>
<p>ソケットが <a class="reference internal" href="ssl.html#ssl-nonblocking"><span class="std std-ref">non-blocking</span></a> で書き込みがブロックすると、 <a class="reference internal" href="ssl.html#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> もしくは <a class="reference internal" href="ssl.html#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> が送出されます。</p>
<p>再ネゴシエーションがいつでも可能なので、 <a class="reference internal" href="ssl.html#ssl.SSLSocket.write" title="ssl.SSLSocket.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a>  の呼び出しは読み出し操作も引き起こしえます。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.5 で変更: </span>ソケットのタイムアウトは、バイトが送受信されるたびにリセットされなくなりました。ソケットのタイムアウトは、<em>buf</em> を書き込むのにかかる最大合計時間になりました。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.6 で非推奨: </span><a class="reference internal" href="ssl.html#ssl.SSLSocket.write" title="ssl.SSLSocket.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> の代わりに <code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code> を使用してください。</p>
</div>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><a class="reference internal" href="ssl.html#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>, <a class="reference internal" href="ssl.html#ssl.SSLSocket.write" title="ssl.SSLSocket.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> メソッドは下位レベルのメソッドであり、暗号化されていないアプリケーションレベルのデータを読み書きし、それを復号/暗号化して暗号化された書き込みレベルのデータにします。これらのメソッドはアクティブな SSL 接続つまり、ハンドシェイクが完了していて、 <a class="reference internal" href="ssl.html#ssl.SSLSocket.unwrap" title="ssl.SSLSocket.unwrap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.unwrap()</span></code></a> が呼ばれていないことを必要とします。</p>
<p>通常はこれらのメソッドの代わりに <a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a> や <a class="reference internal" href="socket.html#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> のようなソケット API メソッドを使うべきです。</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLSocket.do_handshake">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">do_handshake</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLSocket.do_handshake" title="Link to this definition">¶</a></dt>
<dd><p>SSL セットアップのハンドシェイクを実行します。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.4 で変更: </span>ソケットの <a class="reference internal" href="ssl.html#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal notranslate"><span class="pre">context</span></code></a> の属性 <a class="reference internal" href="ssl.html#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> が真の場合に、ハンドシェイクメソッドが <code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code> を実行するようになりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.5 で変更: </span>ソケットのタイムアウトは、バイトが送受信されるたびにリセットされなくなりました。ソケットのタイムアウトは、ハンドシェイクにかかる最大合計時間になりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.7 で変更: </span>Hostname or IP address is matched by OpenSSL during handshake. The
function <code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code> is no longer used. In case OpenSSL
refuses a hostname or IP address, the handshake is aborted early and
a TLS alert message is sent to the peer.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLSocket.getpeercert">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">getpeercert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binary_form</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLSocket.getpeercert" title="Link to this definition">¶</a></dt>
<dd><p>接続先に証明書が無い場合、 <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。SSL ハンドシェイクがまだ行われていない場合は、 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> が送出されます。</p>
<p><code class="docutils literal notranslate"><span class="pre">binary_form</span></code> が <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> で接続先から証明書を取得した場合、このメソッドは <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> のインスタンスを返します。証明書が認証されていない場合、辞書は空です。証明書が認証されていた場合いくつかのキーを持った辞書を返し、 <code class="docutils literal notranslate"><span class="pre">subject</span></code> (証明書が発行された principal), <code class="docutils literal notranslate"><span class="pre">issuer</span></code> (証明書を発行した principal) を含みます。証明書が <em>Subject Alternative Name</em> 拡張(<span class="target" id="index-36"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3280.html"><strong>RFC 3280</strong></a> を参照)のインスタンスを格納していた場合、 <code class="docutils literal notranslate"><span class="pre">subjectAltName</span></code> キーも辞書に含まれます。</p>
<p><code class="docutils literal notranslate"><span class="pre">subject</span></code>, <code class="docutils literal notranslate"><span class="pre">issuer</span></code> フィールドは、証明書のそれぞれのフィールドについてのデータ構造で与えられる RDN (relative distinguishued name) のシーケンスを格納したタプルで、各 RDN は name-value ペアのシーケンスです。現実世界での例をお見せします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;issuer&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s1">&#39;countryName&#39;</span><span class="p">,</span> <span class="s1">&#39;IL&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s1">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s1">&#39;StartCom Ltd.&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s1">&#39;organizationalUnitName&#39;</span><span class="p">,</span>
              <span class="s1">&#39;Secure Digital Certificate Signing&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s1">&#39;commonName&#39;</span><span class="p">,</span>
              <span class="s1">&#39;StartCom Class 2 Primary Intermediate Server CA&#39;</span><span class="p">),)),</span>
 <span class="s1">&#39;notAfter&#39;</span><span class="p">:</span> <span class="s1">&#39;Nov 22 08:15:19 2013 GMT&#39;</span><span class="p">,</span>
 <span class="s1">&#39;notBefore&#39;</span><span class="p">:</span> <span class="s1">&#39;Nov 21 03:09:52 2011 GMT&#39;</span><span class="p">,</span>
 <span class="s1">&#39;serialNumber&#39;</span><span class="p">:</span> <span class="s1">&#39;95F0&#39;</span><span class="p">,</span>
 <span class="s1">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s1">&#39;description&#39;</span><span class="p">,</span> <span class="s1">&#39;571208-SLe257oHY9fVQ07Z&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;countryName&#39;</span><span class="p">,</span> <span class="s1">&#39;US&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;stateOrProvinceName&#39;</span><span class="p">,</span> <span class="s1">&#39;California&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;localityName&#39;</span><span class="p">,</span> <span class="s1">&#39;San Francisco&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s1">&#39;Electronic Frontier Foundation, Inc.&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;commonName&#39;</span><span class="p">,</span> <span class="s1">&#39;*.eff.org&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;emailAddress&#39;</span><span class="p">,</span> <span class="s1">&#39;hostmaster@eff.org&#39;</span><span class="p">),)),</span>
 <span class="s1">&#39;subjectAltName&#39;</span><span class="p">:</span> <span class="p">((</span><span class="s1">&#39;DNS&#39;</span><span class="p">,</span> <span class="s1">&#39;*.eff.org&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;DNS&#39;</span><span class="p">,</span> <span class="s1">&#39;eff.org&#39;</span><span class="p">)),</span>
 <span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">binary_form</span></code> 引数が <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> だった場合、証明書が渡されていればこのメソッドはDERエンコードされた証明書全体をバイト列として返し、接続先が証明書を提示しなかった場合は <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> を返します。接続先が証明書を提供するかどうかは SSL ソケットの役割に依存します:</p>
<ul class="simple">
<li><p>クライアント SSL ソケットでは、認証が要求されているかどうかに関わらず、サーバは常に証明書を提供します。</p></li>
<li><p>サーバ SSL ソケットでは、クライアントはサーバによって認証が要求されている場合にのみ証明書を提供します。したがって、 (<a class="reference internal" href="ssl.html#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a> や <a class="reference internal" href="ssl.html#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> ではなく) <a class="reference internal" href="ssl.html#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a> を使用した場合 <a class="reference internal" href="ssl.html#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeercert()</span></code></a> は <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> を返します。</p></li>
</ul>
<p>See also <a class="reference internal" href="ssl.html#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.check_hostname</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.2 で変更: </span>返される辞書に <code class="docutils literal notranslate"><span class="pre">issuer</span></code>, <code class="docutils literal notranslate"><span class="pre">notBefore</span></code> のような追加アイテムを含むようになりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.4 で変更: </span>ハンドシェイクが済んでいなければ <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> を投げるようになりました。返される辞書に <code class="docutils literal notranslate"><span class="pre">crlDistributionPoints</span></code>, <code class="docutils literal notranslate"><span class="pre">caIssuers</span></code>, <code class="docutils literal notranslate"><span class="pre">OCSP</span></code> URI のような X509v3 拡張アイテムを含むようになりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.9 で変更: </span>IPv6 address strings no longer have a trailing new line.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLSocket.cipher">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">cipher</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLSocket.cipher" title="Link to this definition">¶</a></dt>
<dd><p>利用されている暗号の名前、その暗号の利用を定義しているSSLプロトコルのバージョン、利用されている鍵のbit長の3つの値を含むタプルを返します。もし接続が確立されていない場合、 <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLSocket.shared_ciphers">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">shared_ciphers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLSocket.shared_ciphers" title="Link to this definition">¶</a></dt>
<dd><p>クライアントとサーバーの両方で利用できる暗号方式のリストを返します。返されるリストの各要素は 3つの値を含むタプルで、その値はそれぞれ、暗号方式の名前、その暗号の利用を定義している SSL プロトコルのバージョン、暗号で使用される秘密鍵のビット長です。接続が確立されていないか、ソケットがクライアントソケットである場合、meth:<cite>~SSLSocket.shared_ciphers</cite> は <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLSocket.compression">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">compression</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLSocket.compression" title="Link to this definition">¶</a></dt>
<dd><p>使われている圧縮アルゴリズムを文字列で返します。接続が圧縮されていなければ <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。</p>
<p>上位レベルのプロトコルが自身で圧縮メカニズムをサポートする場合、SSL レベルでの圧縮を <a class="reference internal" href="ssl.html#ssl.OP_NO_COMPRESSION" title="ssl.OP_NO_COMPRESSION"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_COMPRESSION</span></code></a> を使って無効にできます。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLSocket.get_channel_binding">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">get_channel_binding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cb_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tls-unique'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLSocket.get_channel_binding" title="Link to this definition">¶</a></dt>
<dd><p>現在の接続におけるチャネルバインディングのデータを取得します。未接続あるいはハンドシェイクが完了していなければ <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。</p>
<p><em>cb_type</em> パラメータにより、望みのチャネルバインディングのタイプを選択できます。チャネルバインディングのタイプの妥当なものは <a class="reference internal" href="ssl.html#ssl.CHANNEL_BINDING_TYPES" title="ssl.CHANNEL_BINDING_TYPES"><code class="xref py py-data docutils literal notranslate"><span class="pre">CHANNEL_BINDING_TYPES</span></code></a> でリストされています。現在のところは <span class="target" id="index-37"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5929.html"><strong>RFC 5929</strong></a> で定義されている 'tls-unique' のみがサポートされています。未サポートのチャネルバインディングのタイプが要求された場合、 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> を送出します。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLSocket.selected_alpn_protocol">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">selected_alpn_protocol</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLSocket.selected_alpn_protocol" title="Link to this definition">¶</a></dt>
<dd><p>TLS ハンドシェイクで選択されたプロトコルを返します。 <a class="reference internal" href="ssl.html#ssl.SSLContext.set_alpn_protocols" title="ssl.SSLContext.set_alpn_protocols"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_alpn_protocols()</span></code></a> が呼ばれていない場合、相手側が ALPN をサポートしていない場合、クライアントが提案したプロトコルのどれもソケットがサポートしない場合、あるいはハンドシェイクがまだ行われていない場合には、 <code class="docutils literal notranslate"><span class="pre">None</span></code> が返されます。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLSocket.selected_npn_protocol">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">selected_npn_protocol</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLSocket.selected_npn_protocol" title="Link to this definition">¶</a></dt>
<dd><p>TLS/SSL ハンドシェイクで選択された上位レベルのプロトコルを返します。 <a class="reference internal" href="ssl.html#ssl.SSLContext.set_npn_protocols" title="ssl.SSLContext.set_npn_protocols"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_npn_protocols()</span></code></a> が呼ばれていない場合、相手側が NPN をサポートしていない場合、あるいはハンドシェイクがまだ行われていない場合には、 <code class="docutils literal notranslate"><span class="pre">None</span></code> が返されます。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.10 で非推奨: </span>NPN has been superseded by ALPN</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLSocket.unwrap">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">unwrap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLSocket.unwrap" title="Link to this definition">¶</a></dt>
<dd><p>SSLシャットダウンハンドシェイクを実行します。これは下位レイヤーのソケットからTLSレイヤーを取り除き、下位レイヤーのソケットオブジェクトを返します。これは暗号化されたオペレーションから暗号化されていない接続に移行するときに利用されます。以降の通信には、オリジナルのソケットではなくこのメソッドが返したソケットのみを利用するべきです。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLSocket.verify_client_post_handshake">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">verify_client_post_handshake</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLSocket.verify_client_post_handshake" title="Link to this definition">¶</a></dt>
<dd><p>Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA
can only be initiated for a TLS 1.3 connection from a server-side socket,
after the initial TLS handshake and with PHA enabled on both sides, see
<a class="reference internal" href="ssl.html#ssl.SSLContext.post_handshake_auth" title="ssl.SSLContext.post_handshake_auth"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.post_handshake_auth</span></code></a>.</p>
<p>The method does not perform a cert exchange immediately. The server-side
sends a CertificateRequest during the next write event and expects the
client to respond with a certificate on the next read event.</p>
<p>If any precondition isn't met (e.g. not TLS 1.3, PHA not enabled), an
<a class="reference internal" href="ssl.html#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> is raised.</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3
support, the method raises <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLSocket.version">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">version</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLSocket.version" title="Link to this definition">¶</a></dt>
<dd><p>コネクションによって実際にネゴシエイトされた SSL プロトコルバージョンを文字列で、または、セキュアなコネクションが確立していなければ <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。これを書いている時点では、 <code class="docutils literal notranslate"><span class="pre">&quot;SSLv2&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;SSLv3&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;TLSv1&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;TLSv1.1&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;TLSv1.2&quot;</span></code> などが返ります。最新の OpenSSL はもっと色々な値を定義しているかもしれません。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLSocket.pending">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">pending</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLSocket.pending" title="Link to this definition">¶</a></dt>
<dd><p>接続において既に復号済みで読み出し可能で保留になっているバイト列の数を返します。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLSocket.context">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">context</span></span><a class="headerlink" href="ssl.html#ssl.SSLSocket.context" title="Link to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> object this SSL socket is tied to.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLSocket.server_side">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">server_side</span></span><a class="headerlink" href="ssl.html#ssl.SSLSocket.server_side" title="Link to this definition">¶</a></dt>
<dd><p>サーバサイドのソケットに対して <code class="docutils literal notranslate"><span class="pre">True</span></code> 、クライアントサイドのソケットに対して <code class="docutils literal notranslate"><span class="pre">False</span></code> となる真偽値です。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLSocket.server_hostname">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">server_hostname</span></span><a class="headerlink" href="ssl.html#ssl.SSLSocket.server_hostname" title="Link to this definition">¶</a></dt>
<dd><p>サーバのホスト名: <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 型、またはサーバサイドのソケットの場合とコンストラクタで hostname が指定されなかった場合は <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.7 で変更: </span>The attribute is now always ASCII text. When <code class="docutils literal notranslate"><span class="pre">server_hostname</span></code> is
an internationalized domain name (IDN), this attribute now stores the
A-label form (<code class="docutils literal notranslate"><span class="pre">&quot;xn--pythn-mua.org&quot;</span></code>), rather than the U-label form
(<code class="docutils literal notranslate"><span class="pre">&quot;pythön.org&quot;</span></code>).</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLSocket.session">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">session</span></span><a class="headerlink" href="ssl.html#ssl.SSLSocket.session" title="Link to this definition">¶</a></dt>
<dd><p>この SSL 接続に対する <a class="reference internal" href="ssl.html#ssl.SSLSession" title="ssl.SSLSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSession</span></code></a> です。このセッションは、TLS ハンドシェイクの実行後、クライアントサイドとサーバサイドのソケットで使用できます。クライアントソケットでは、このセッションを <a class="reference internal" href="ssl.html#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_handshake()</span></code></a> が呼ばれる前に設定して、セッションを再利用できます。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLSocket.session_reused">
<span class="sig-prename descclassname"><span class="pre">SSLSocket.</span></span><span class="sig-name descname"><span class="pre">session_reused</span></span><a class="headerlink" href="ssl.html#ssl.SSLSocket.session_reused" title="Link to this definition">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

</section>
<section id="ssl-contexts">
<h2>SSL コンテキスト<a class="headerlink" href="ssl.html#ssl-contexts" title="Link to this heading">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
<p>SSL コンテキストは、SSL 構成オプション、証明書(群)や秘密鍵(群)などのような、一回の SSL 接続よりも長生きするさまざまなデータを保持します。これはサーバサイドソケットの SSL セッションのキャッシュも管理し、同じクライアントからの繰り返しの接続時の速度向上に一役買います。</p>
<dl class="py class">
<dt class="sig sig-object py" id="ssl.SSLContext">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">SSLContext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLContext" title="Link to this definition">¶</a></dt>
<dd><p>Create a new SSL context.  You may pass <em>protocol</em> which must be one
of the <code class="docutils literal notranslate"><span class="pre">PROTOCOL_*</span></code> constants defined in this module.  The parameter
specifies which version of the SSL protocol to use.  Typically, the
server chooses a particular protocol version, and the client must adapt
to the server's choice.  Most of the versions are not interoperable
with the other versions.  If not specified, the default is
<a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>; it provides the most compatibility with other
versions.</p>
<p>次のテーブルは、どのクライアントのバージョンがどのサーバのバージョンに接続できるかを示しています:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><em>client</em> / <strong>server</strong></p></td>
<td><p><strong>SSLv2</strong></p></td>
<td><p><strong>SSLv3</strong></p></td>
<td><p><strong>TLS</strong> <a class="footnote-reference brackets" href="ssl.html#id9" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p></td>
<td><p><strong>TLSv1</strong></p></td>
<td><p><strong>TLSv1.1</strong></p></td>
<td><p><strong>TLSv1.2</strong></p></td>
</tr>
<tr class="row-even"><td><p><em>SSLv2</em></p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no <a class="footnote-reference brackets" href="ssl.html#id7" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p><em>SSLv3</em></p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no <a class="footnote-reference brackets" href="ssl.html#id8" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p><em>TLS</em> (<em>SSLv23</em>) <a class="footnote-reference brackets" href="ssl.html#id9" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p></td>
<td><p>no <a class="footnote-reference brackets" href="ssl.html#id7" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p>no <a class="footnote-reference brackets" href="ssl.html#id8" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><p><em>TLSv1</em></p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p><em>TLSv1.1</em></p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p><em>TLSv1.2</em></p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
</tr>
</tbody>
</table>
<p class="rubric">脚注</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="ssl.html#id2">1</a>,<a role="doc-backlink" href="ssl.html#id5">2</a>)</span>
<p><a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> では、デフォルトで <a class="reference internal" href="ssl.html#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv2</span></code></a> によりSSLv2 が無効になっています。</p>
</aside>
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="ssl.html#id3">1</a>,<a role="doc-backlink" href="ssl.html#id6">2</a>)</span>
<p><a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> では、デフォルトで <a class="reference internal" href="ssl.html#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a> により SSLv3 が無効になっています。</p>
</aside>
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="ssl.html#id1">1</a>,<a role="doc-backlink" href="ssl.html#id4">2</a>)</span>
<p>TLS 1.3 protocol will be available with <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> in
OpenSSL &gt;= 1.1.1. There is no dedicated PROTOCOL constant for just
TLS 1.3.</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> は <a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> モジュールに、目的に合ったセキュリティ設定を選ばせます。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.6 で変更: </span>The context is created with secure default values. The options
<a class="reference internal" href="ssl.html#ssl.OP_NO_COMPRESSION" title="ssl.OP_NO_COMPRESSION"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_COMPRESSION</span></code></a>, <a class="reference internal" href="ssl.html#ssl.OP_CIPHER_SERVER_PREFERENCE" title="ssl.OP_CIPHER_SERVER_PREFERENCE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_CIPHER_SERVER_PREFERENCE</span></code></a>,
<a class="reference internal" href="ssl.html#ssl.OP_SINGLE_DH_USE" title="ssl.OP_SINGLE_DH_USE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_SINGLE_DH_USE</span></code></a>, <a class="reference internal" href="ssl.html#ssl.OP_SINGLE_ECDH_USE" title="ssl.OP_SINGLE_ECDH_USE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_SINGLE_ECDH_USE</span></code></a>,
<a class="reference internal" href="ssl.html#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv2</span></code></a>,
and <a class="reference internal" href="ssl.html#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a> (except for <a class="reference internal" href="ssl.html#ssl.PROTOCOL_SSLv3" title="ssl.PROTOCOL_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_SSLv3</span></code></a>) are
set by default. The initial cipher suite list contains only <code class="docutils literal notranslate"><span class="pre">HIGH</span></code>
ciphers, no <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ciphers and no <code class="docutils literal notranslate"><span class="pre">MD5</span></code> ciphers.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.10 で非推奨: </span><a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> without protocol argument is deprecated. The
context class will either require <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> or
<a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a> protocol in the future.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.10 で変更: </span>The default cipher suites now include only secure AES and ChaCha20
ciphers with forward secrecy and security level 2. RSA and DH keys with
less than 2048 bits and ECC keys with less than 224 bits are prohibited.
<a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>, <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a>, and
<a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a> use TLS 1.2 as minimum TLS version.</p>
</div>
</dd></dl>

<p><a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> オブジェクトは以下のメソッドと属性を持っています:</p>
<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLContext.cert_store_stats">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">cert_store_stats</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLContext.cert_store_stats" title="Link to this definition">¶</a></dt>
<dd><p>ロードされた X.509 証明書の数、CA 証明書で活性の X.509 証明書の数、証明書失効リストの数、についての統計情報を辞書として取得します。</p>
<p>一つの CA と他の一つの証明書を持ったコンテキストでの例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">cert_store_stats</span><span class="p">()</span>
<span class="go">{&#39;crl&#39;: 0, &#39;x509_ca&#39;: 1, &#39;x509&#39;: 2}</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLContext.load_cert_chain">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">load_cert_chain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">certfile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keyfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">password</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLContext.load_cert_chain" title="Link to this definition">¶</a></dt>
<dd><p>秘密鍵と対応する証明書をロードします。 <em>certfile</em> は、証明書と、証明書認証で必要とされる任意の数の CA 証明書を含む、PEM フォーマットの単一ファイルへのパスでなければなりません。 <em>keyfile</em> 文字列を指定する場合、秘密鍵が含まれるファイルを指すものでなければなりません。指定しない場合、秘密鍵も <em>certfile</em> から取得されます。 <em>certfile</em> への証明書の格納についての詳細は、 <a class="reference internal" href="ssl.html#ssl-certificates"><span class="std std-ref">証明書</span></a> の議論を参照してください。</p>
<p><em>password</em> 引数に、秘密鍵を復号するためのパスワードを返す関数を与えることができます。その関数は秘密鍵が暗号化されていて、なおかつパスワードが必要な場合にのみ呼び出されます。その関数は引数なしで呼び出され、string, bytes, または bytearray を返さなければなりません。戻り値が string の場合は鍵を復号化するのに使う前に UTF-8 でエンコードされます。string の代わりに bytes や bytearray を返した場合は <em>password</em> 引数に直接供給されます。秘密鍵が暗号化されていなかったりパスワードを必要としない場合は、指定は無視されます。</p>
<p><em>password</em> が与えられず、そしてパスワードが必要な場合には、OpenSSL 組み込みのパスワード問い合わせメカニズムが、ユーザに対話的にパスワードを問い合わせます。</p>
<p>秘密鍵が証明書に合致しなければ、 <a class="reference internal" href="ssl.html#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a> が送出されます。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.3 で変更: </span>新しいオプション引数 <em>password</em>。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLContext.load_default_certs">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">load_default_certs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">purpose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Purpose.SERVER_AUTH</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLContext.load_default_certs" title="Link to this definition">¶</a></dt>
<dd><p>デフォルトの場所から &quot;認証局&quot; (CA=certification authority) 証明書ファイル一式をロードします。Windows では、CA 証明書はシステム記憶域の <code class="docutils literal notranslate"><span class="pre">CA</span></code> と <code class="docutils literal notranslate"><span class="pre">ROOT</span></code> からロードします。全てのシステムでは、この関数は <a class="reference internal" href="ssl.html#ssl.SSLContext.set_default_verify_paths" title="ssl.SSLContext.set_default_verify_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_default_verify_paths()</span></code></a> を呼び出します。将来的にはこのメソッドは、他の場所からも CA 証明書をロードするかもしれません。</p>
<p>The <em>purpose</em> flag specifies what kind of CA certificates are loaded. The
default settings <a class="reference internal" href="ssl.html#ssl.Purpose.SERVER_AUTH" title="ssl.Purpose.SERVER_AUTH"><code class="xref py py-const docutils literal notranslate"><span class="pre">Purpose.SERVER_AUTH</span></code></a> loads certificates, that are
flagged and trusted for TLS web server authentication (client side
sockets). <a class="reference internal" href="ssl.html#ssl.Purpose.CLIENT_AUTH" title="ssl.Purpose.CLIENT_AUTH"><code class="xref py py-const docutils literal notranslate"><span class="pre">Purpose.CLIENT_AUTH</span></code></a> loads CA certificates for client
certificate verification on the server side.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLContext.load_verify_locations">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">load_verify_locations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cafile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">capath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cadata</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLContext.load_verify_locations" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ssl.html#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-data docutils literal notranslate"><span class="pre">verify_mode</span></code></a> が <a class="reference internal" href="ssl.html#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a> でない場合に接続先の証明書ファイルの正当性検証に使われる &quot;認証局&quot; (CA=certification authority) 証明書ファイル一式をロードします。少なくとも <em>cafile</em> か <em>capath</em> のどちらかは指定しなければなりません。</p>
<p>このメソッドは PEM または DER フォーマットの証明書失効リスト (CRLs=certification revocation lists)もロードできます。CRLs のために使うには、 <a class="reference internal" href="ssl.html#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> を適切に設定しなければなりません。</p>
<p><em>cafile</em> を指定する場合は、PEM フォーマットで CA 証明書が結合されたファイルへのパスを指定してください。このファイル内で証明書をどのように編成すれば良いのかについての詳しい情報については、 <a class="reference internal" href="ssl.html#ssl-certificates"><span class="std std-ref">証明書</span></a> の議論を参照してください。</p>
<p><em>capath</em> を指定する場合は、PEM フォーマットの CA 証明書が含まれる、 <a class="reference external" href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations.html">OpenSSL specific layout</a> に従ったディレクトリへのパスを指定してください。</p>
<p><em>cadata</em> オブジェクトを指定する場合は、PEM エンコードの証明書一つ以上の ASCII 文字列か、DER エンコードの証明書の <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> オブジェクトのどちらかを指定してください。PEM エンコードの証明書の周囲の余分な行は無視されますが、少なくとも一つの証明書が含まれている必要があります。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.4 で変更: </span>新しいオプション引数 <em>cadata</em> 。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLContext.get_ca_certs">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">get_ca_certs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binary_form</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLContext.get_ca_certs" title="Link to this definition">¶</a></dt>
<dd><p>ロードされた &quot;認証局&quot; (CA=certification authority) 証明書のリストを取得します。 <code class="docutils literal notranslate"><span class="pre">binary_form</span></code> 引数が <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> である場合、リストのそれぞれのエントリは <a class="reference internal" href="ssl.html#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a> が出力するような辞書になります。True である場合、このメソッドは、DER エンコード形式の証明書のリストを返します。返却されるリストには、 SSL 接続によって証明書がリクエストおよびロードされない限り、 <em>capath</em> からの証明書は含まれません。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>capath ディレクトリ内の証明書は一度でも使われない限りはロードされません。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLContext.get_ciphers">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">get_ciphers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLContext.get_ciphers" title="Link to this definition">¶</a></dt>
<dd><p>有効な暗号化のリストを取得します。リストは暗号化優先度順に並びます。<a class="reference internal" href="ssl.html#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_ciphers()</span></code></a> を参照してください。</p>
<p>以下はプログラム例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_SSLv23</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">set_ciphers</span><span class="p">(</span><span class="s1">&#39;ECDHE+AESGCM:!ECDSA&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">get_ciphers</span><span class="p">()</span>
<span class="go">[{&#39;aead&#39;: True,</span>
<span class="go">  &#39;alg_bits&#39;: 256,</span>
<span class="go">  &#39;auth&#39;: &#39;auth-rsa&#39;,</span>
<span class="go">  &#39;description&#39;: &#39;ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  &#39;</span>
<span class="go">                 &#39;Enc=AESGCM(256) Mac=AEAD&#39;,</span>
<span class="go">  &#39;digest&#39;: None,</span>
<span class="go">  &#39;id&#39;: 50380848,</span>
<span class="go">  &#39;kea&#39;: &#39;kx-ecdhe&#39;,</span>
<span class="go">  &#39;name&#39;: &#39;ECDHE-RSA-AES256-GCM-SHA384&#39;,</span>
<span class="go">  &#39;protocol&#39;: &#39;TLSv1.2&#39;,</span>
<span class="go">  &#39;strength_bits&#39;: 256,</span>
<span class="go">  &#39;symmetric&#39;: &#39;aes-256-gcm&#39;},</span>
<span class="go"> {&#39;aead&#39;: True,</span>
<span class="go">  &#39;alg_bits&#39;: 128,</span>
<span class="go">  &#39;auth&#39;: &#39;auth-rsa&#39;,</span>
<span class="go">  &#39;description&#39;: &#39;ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  &#39;</span>
<span class="go">                 &#39;Enc=AESGCM(128) Mac=AEAD&#39;,</span>
<span class="go">  &#39;digest&#39;: None,</span>
<span class="go">  &#39;id&#39;: 50380847,</span>
<span class="go">  &#39;kea&#39;: &#39;kx-ecdhe&#39;,</span>
<span class="go">  &#39;name&#39;: &#39;ECDHE-RSA-AES128-GCM-SHA256&#39;,</span>
<span class="go">  &#39;protocol&#39;: &#39;TLSv1.2&#39;,</span>
<span class="go">  &#39;strength_bits&#39;: 128,</span>
<span class="go">  &#39;symmetric&#39;: &#39;aes-128-gcm&#39;}]</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLContext.set_default_verify_paths">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">set_default_verify_paths</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLContext.set_default_verify_paths" title="Link to this definition">¶</a></dt>
<dd><p>デフォルトの &quot;認証局&quot; (CA=certification authority) 証明書を、OpenSSL ライブラリがビルドされた際に定義されたファイルシステム上のパスからロードします。残念ながらこのメソッドが成功したかどうかを知るための簡単な方法はありません: 証明書が見つからなくてもエラーは返りません。OpenSSL ライブラリがオペレーティングシステムの一部として提供されている際にはどうやら適切に構成できるようですが。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLContext.set_ciphers">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">set_ciphers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ciphers</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLContext.set_ciphers" title="Link to this definition">¶</a></dt>
<dd><p>このコンテキストによって作られるソケットで利用できる暗号を設定します。 <a class="reference external" href="https://www.openssl.org/docs/manmaster/man1/ciphers.html">OpenSSL cipher list format</a> に書かれている形式の文字列でなければなりません。 (OpenSSL のコンパイル時オプションや他の設定がそれらすべての暗号の使用を禁止しているなどの理由で) どの暗号も選べない場合、 <a class="reference internal" href="ssl.html#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a> が送出されます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>接続時に SSL ソケットの <a class="reference internal" href="ssl.html#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.cipher()</span></code></a> メソッドが、現在選択されているその暗号を使います。</p>
<p>TLS 1.3 cipher suites cannot be disabled with
<a class="reference internal" href="ssl.html#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_ciphers()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLContext.set_alpn_protocols">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">set_alpn_protocols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocols</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLContext.set_alpn_protocols" title="Link to this definition">¶</a></dt>
<dd><p>SSL/TLS ハンドシェイク時にソケットが提示すべきプロトコルを指定します。 <code class="docutils literal notranslate"><span class="pre">['http/1.1',</span> <span class="pre">'spdy/2']</span></code> のような推奨順に並べた ASCII 文字列のリストでなければなりません。プロトコルの選択は <span class="target" id="index-38"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7301.html"><strong>RFC 7301</strong></a> に従いハンドシェイク中に行われます。ハンドシェイクが正常に終了した後、 <a class="reference internal" href="ssl.html#ssl.SSLSocket.selected_alpn_protocol" title="ssl.SSLSocket.selected_alpn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.selected_alpn_protocol()</span></code></a> メソッドは合意されたプロトコルを返します。</p>
<p>このメソッドは <a class="reference internal" href="ssl.html#ssl.HAS_ALPN" title="ssl.HAS_ALPN"><code class="xref py py-data docutils literal notranslate"><span class="pre">HAS_ALPN</span></code></a> が <code class="docutils literal notranslate"><span class="pre">False</span></code> の場合 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> を送出します。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLContext.set_npn_protocols">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">set_npn_protocols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocols</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLContext.set_npn_protocols" title="Link to this definition">¶</a></dt>
<dd><p>SSL/TLS ハンドシェイク時にソケットが提示すべきプロトコルを指定します。 <code class="docutils literal notranslate"><span class="pre">['http/1.1',</span> <span class="pre">'spdy/2']</span></code> のような推奨順に並べた文字列のリストでなければなりません。プロトコルの選択は <a class="reference external" href="https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation">Application Layer Protocol Negotiation</a> に従いハンドシェイク中に行われます。ハンドシェイクが正常に終了した後、 <a class="reference internal" href="ssl.html#ssl.SSLSocket.selected_alpn_protocol" title="ssl.SSLSocket.selected_alpn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.selected_alpn_protocol()</span></code></a> メソッドは合意されたプロトコルを返します。</p>
<p>このメソッドは <a class="reference internal" href="ssl.html#ssl.HAS_NPN" title="ssl.HAS_NPN"><code class="xref py py-data docutils literal notranslate"><span class="pre">HAS_NPN</span></code></a> が <code class="docutils literal notranslate"><span class="pre">False</span></code> の場合 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> を送出します。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.10 で非推奨: </span>NPN has been superseded by ALPN</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLContext.sni_callback">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">sni_callback</span></span><a class="headerlink" href="ssl.html#ssl.SSLContext.sni_callback" title="Link to this definition">¶</a></dt>
<dd><p>TLS クライアントがサーバ名表示を指定した際の、SSL/TLS サーバによって TLS Client Hello ハンドシェイクメッセージが受け取られたあとで呼び出されるコールバック関数を登録します。サーバ名表示メカニズムは <span class="target" id="index-39"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6066.html"><strong>RFC 6066</strong></a> セクション 3 - Server Name Indication で述べられています。</p>
<p><code class="docutils literal notranslate"><span class="pre">SSLContext</span></code> ごとに一つだけコールバックをセットできます。 <em>sni_callback</em> を <code class="docutils literal notranslate"><span class="pre">None</span></code> にすればコールバックは無効になります。この関数を続けて呼ぶと、以前に登録されたコールバックを上書きします。</p>
<p>The callback function will be called with three
arguments; the first being the <a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a>, the second is a string
that represents the server name that the client is intending to communicate
(or <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> if the TLS Client Hello does not contain a server name)
and the third argument is the original <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>. The server name
argument is text. For internationalized domain name, the server
name is an IDN A-label (<code class="docutils literal notranslate"><span class="pre">&quot;xn--pythn-mua.org&quot;</span></code>).</p>
<p>このコールバックの典型的な利用方法は、 <a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> の <a class="reference internal" href="ssl.html#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLSocket.context</span></code></a> 属性を、サーバ名に合致する証明書チェインを持つ新しい <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> オブジェクトに変更することです。</p>
<p>Due to the early negotiation phase of the TLS connection, only limited
methods and attributes are usable like
<a class="reference internal" href="ssl.html#ssl.SSLSocket.selected_alpn_protocol" title="ssl.SSLSocket.selected_alpn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.selected_alpn_protocol()</span></code></a> and <a class="reference internal" href="ssl.html#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLSocket.context</span></code></a>.
The <a class="reference internal" href="ssl.html#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a>,
<a class="reference internal" href="ssl.html#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.cipher()</span></code></a> and <a class="reference internal" href="ssl.html#ssl.SSLSocket.compression" title="ssl.SSLSocket.compression"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.compression()</span></code></a> methods require that
the TLS connection has progressed beyond the TLS Client Hello and therefore
will not return meaningful values nor can they be called safely.</p>
<p>TLS ネゴシエーションを継続させるならば、 <em>sni_callback</em> 関数は <code class="docutils literal notranslate"><span class="pre">None</span></code> を返さなければなりません。TLS が失敗することを必要とするなら、 constant <a class="reference internal" href="ssl.html#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ALERT_DESCRIPTION_*</span></code></a> を返してください。ここにない値を返すと、致命エラー <a class="reference internal" href="ssl.html#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ALERT_DESCRIPTION_INTERNAL_ERROR</span></code></a> を引き起こします。</p>
<p><em>sni_callback</em> 関数が例外を送出した場合、TLS 接続は TLS の致命的アラートメッセージ <a class="reference internal" href="ssl.html#ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE" title="ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE"><code class="xref py py-const docutils literal notranslate"><span class="pre">ALERT_DESCRIPTION_HANDSHAKE_FAILURE</span></code></a> とともに終了します。</p>
<p>このメソッドは OpenSSL ライブラリが OPENSSL_NO_TLSEXT を定義してビルドされている場合、 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> を送出します。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLContext.set_servername_callback">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">set_servername_callback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">server_name_callback</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLContext.set_servername_callback" title="Link to this definition">¶</a></dt>
<dd><p>This is a legacy API retained for backwards compatibility. When possible,
you should use <a class="reference internal" href="ssl.html#ssl.SSLContext.sni_callback" title="ssl.SSLContext.sni_callback"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sni_callback</span></code></a> instead. The given <em>server_name_callback</em>
is similar to <em>sni_callback</em>, except that when the server hostname is an
IDN-encoded internationalized domain name, the <em>server_name_callback</em>
receives a decoded U-label (<code class="docutils literal notranslate"><span class="pre">&quot;pythön.org&quot;</span></code>).</p>
<p>サーバ名に対するデコードエラーがあれば、TLS 接続はクライアントに対する TLS の致命的アラートメッセージ <a class="reference internal" href="ssl.html#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ALERT_DESCRIPTION_INTERNAL_ERROR</span></code></a> とともに終了します。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLContext.load_dh_params">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">load_dh_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dhfile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLContext.load_dh_params" title="Link to this definition">¶</a></dt>
<dd><p>ディフィー・ヘルマン(DH)鍵交換のための鍵生成パラメータをロードします。DH 鍵交換を用いることは、(サーバ、クライアントともに)計算機リソースに高い処理負荷をかけますがセキュリティを向上させます。 <em>dhfile</em> パラメータは PEM フォーマットの DH パラメータを含んだファイルへのパスでなければなりません。</p>
<p>この設定はクライアントソケットには適用されません。さらにセキュリティを改善するのに <a class="reference internal" href="ssl.html#ssl.OP_SINGLE_DH_USE" title="ssl.OP_SINGLE_DH_USE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_SINGLE_DH_USE</span></code></a> オプションも利用できます。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLContext.set_ecdh_curve">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">set_ecdh_curve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">curve_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLContext.set_ecdh_curve" title="Link to this definition">¶</a></dt>
<dd><p>楕円曲線ディフィー・ヘルマン(ECDH)鍵交換の曲線名を指定します。ECDH はもとの DH に較べて、ほぼ間違いなく同程度に安全である一方で、顕著に高速です。 <em>curve_name</em> パラメータは既知の楕円曲線を表す文字列でなければなりません。例えば <code class="docutils literal notranslate"><span class="pre">prime256v1</span></code> が広くサポートされている曲線です。</p>
<p>この設定はクライアントソケットには適用されません。さらにセキュリティを改善するのに <a class="reference internal" href="ssl.html#ssl.OP_SINGLE_ECDH_USE" title="ssl.OP_SINGLE_ECDH_USE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_SINGLE_ECDH_USE</span></code></a> オプションも利用できます。</p>
<p>このメソッドは <a class="reference internal" href="ssl.html#ssl.HAS_ECDH" title="ssl.HAS_ECDH"><code class="xref py py-data docutils literal notranslate"><span class="pre">HAS_ECDH</span></code></a> が <code class="docutils literal notranslate"><span class="pre">False</span></code> の場合は利用できません。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<dl class="simple">
<dt><a class="reference external" href="https://vincent.bernat.ch/en/blog/2011-ssl-perfect-forward-secrecy">SSL/TLS &amp; Perfect Forward Secrecy</a></dt><dd><p>Vincent Bernat.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLContext.wrap_socket">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">wrap_socket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_handshake_on_connect</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suppress_ragged_eofs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">session</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLContext.wrap_socket" title="Link to this definition">¶</a></dt>
<dd><p>Wrap an existing Python socket <em>sock</em> and return an instance of
<a class="reference internal" href="ssl.html#ssl.SSLContext.sslsocket_class" title="ssl.SSLContext.sslsocket_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.sslsocket_class</span></code></a> (default <a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>). The
returned SSL socket is tied to the context, its settings and certificates.
<em>sock</em> must be a <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a> socket; other
socket types are unsupported.</p>
<p><code class="docutils literal notranslate"><span class="pre">server_side</span></code> 引数は真偽値で、このソケットがサーバサイドとクライアントサイドのどちらの動作をするのかを指定します。</p>
<p>クライアントサイドソケットにおいて、コンテキストの生成は遅延されます。つまり、低レイヤのソケットがまだ接続されていない場合、コンテキストの生成はそのソケットの <code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code> メソッドが呼ばれた後に行われます。サーバサイドソケットの場合、そのソケットに接続先が居なければそれは listen 用ソケットだと判断されます。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code> メソッドで生成されるクライアント接続に対してのサーバサイド SSLラップは自動的に行われます。メソッドは <a class="reference internal" href="ssl.html#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> を送出することがあります。</p>
<p>クライアントからの接続では、 <em>server_hostname</em> で接続先サービスのホスト名を指定できます。これは HTTP バーチャルホストにかなり似て、シングルサーバで複数の SSL ベースのサービスを別々の証明書でホストしているようなサーバに対して使えます。 <em>server_side</em> が True の場合に <em>server_hostname</em> を指定すると <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> を送出します。</p>
<p><code class="docutils literal notranslate"><span class="pre">do_handshake_on_connect</span></code> 引数は、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect()</span></code> の後に自動的に SSLハンドシェイクを行うか、それともアプリケーションが明示的に <a class="reference internal" href="ssl.html#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a> メソッドを実行するかを指定します。 <a class="reference internal" href="ssl.html#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a> を明示的に呼びだすことで、ハンドシェイクによるソケットI/Oのブロッキング動作を制御できます。</p>
<p><code class="docutils literal notranslate"><span class="pre">suppress_ragged_eofs</span></code> 引数は、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.recv()</span></code> メソッドが、接続先から予期しないEOF を受け取った時に通知する方法を指定します。 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> (デフォルト) の場合、下位のソケットレイヤーから予期せぬEOFエラーが来た場合、通常のEOF (空のバイト列オブジェクト)を返します。 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> の場合、呼び出し元に例外を投げて通知します。</p>
<p><em>session</em>, <a class="reference internal" href="ssl.html#ssl.SSLSocket.session" title="ssl.SSLSocket.session"><code class="xref py py-attr docutils literal notranslate"><span class="pre">session</span></code></a> を参照してください。</p>
<p>To wrap an <a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> in another <a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>, use
<a class="reference internal" href="ssl.html#ssl.SSLContext.wrap_bio" title="ssl.SSLContext.wrap_bio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_bio()</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.5 で変更: </span>OpenSSL が SNI をサポートしなくても server_hostname を許容するようになりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.6 で変更: </span><em>session</em> 引数が追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.7 で変更: </span>The method returns an instance of <a class="reference internal" href="ssl.html#ssl.SSLContext.sslsocket_class" title="ssl.SSLContext.sslsocket_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.sslsocket_class</span></code></a>
instead of hard-coded <a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLContext.sslsocket_class">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">sslsocket_class</span></span><a class="headerlink" href="ssl.html#ssl.SSLContext.sslsocket_class" title="Link to this definition">¶</a></dt>
<dd><p>The return type of <a class="reference internal" href="ssl.html#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>, defaults to
<a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>. The attribute can be overridden on instance of class
in order to return a custom subclass of <a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLContext.wrap_bio">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">wrap_bio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">incoming</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outgoing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">session</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLContext.wrap_bio" title="Link to this definition">¶</a></dt>
<dd><p>Wrap the BIO objects <em>incoming</em> and <em>outgoing</em> and return an instance of
<a class="reference internal" href="ssl.html#ssl.SSLContext.sslobject_class" title="ssl.SSLContext.sslobject_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.sslobject_class</span></code></a> (default <a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>). The SSL
routines will read input data from the incoming BIO and write data to the
outgoing BIO.</p>
<p><em>server_side</em>、 <em>server_hostname</em> 、 <em>session</em> 引数は、 <a class="reference internal" href="ssl.html#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> での意味と同じ意味を持ちます。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.6 で変更: </span><em>session</em> 引数が追加されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.7 で変更: </span>The method returns an instance of <a class="reference internal" href="ssl.html#ssl.SSLContext.sslobject_class" title="ssl.SSLContext.sslobject_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.sslobject_class</span></code></a>
instead of hard-coded <a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLContext.sslobject_class">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">sslobject_class</span></span><a class="headerlink" href="ssl.html#ssl.SSLContext.sslobject_class" title="Link to this definition">¶</a></dt>
<dd><p>The return type of <a class="reference internal" href="ssl.html#ssl.SSLContext.wrap_bio" title="ssl.SSLContext.wrap_bio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_bio()</span></code></a>, defaults to
<a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>. The attribute can be overridden on instance of class
in order to return a custom subclass of <a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.SSLContext.session_stats">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">session_stats</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.SSLContext.session_stats" title="Link to this definition">¶</a></dt>
<dd><p>このコンテキストによって作られた、または管理されている SSL セッションについての統計情報を取得します。 <a class="reference external" href="https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_sess_number.html">piece of information</a> のそれぞれの名前にそれらが持つ数値をマッピングした辞書を返します。例えば、以下は、コンテキスト作成以降のセッションキャッシュのキャッシュヒットとキャッシュミスの総計です。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">session_stats</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;hits&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;misses&#39;</span><span class="p">]</span>
<span class="go">(0, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLContext.check_hostname">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">check_hostname</span></span><a class="headerlink" href="ssl.html#ssl.SSLContext.check_hostname" title="Link to this definition">¶</a></dt>
<dd><p>Whether to match the peer cert's hostname in
<a class="reference internal" href="ssl.html#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a>. The context's
<a class="reference internal" href="ssl.html#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a> must be set to <a class="reference internal" href="ssl.html#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a> or
<a class="reference internal" href="ssl.html#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>, and you must pass <em>server_hostname</em> to
<a class="reference internal" href="ssl.html#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> in order to match the hostname.  Enabling
hostname checking automatically sets <a class="reference internal" href="ssl.html#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a> from
<a class="reference internal" href="ssl.html#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a> to <a class="reference internal" href="ssl.html#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>.  It cannot be set back to
<a class="reference internal" href="ssl.html#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a> as long as hostname checking is enabled. The
<a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> protocol enables hostname checking by default.
With other protocols, hostname checking must be enabled explicitly.</p>
<p>以下はプログラム例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLSv1_2</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">verify_mode</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span>
<span class="n">context</span><span class="o">.</span><span class="n">check_hostname</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_default_certs</span><span class="p">()</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">ssl_sock</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">server_hostname</span><span class="o">=</span><span class="s1">&#39;www.verisign.com&#39;</span><span class="p">)</span>
<span class="n">ssl_sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;www.verisign.com&#39;</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.7 で変更: </span><a class="reference internal" href="ssl.html#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a> is now automatically changed
to <a class="reference internal" href="ssl.html#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>  when hostname checking is enabled and
<a class="reference internal" href="ssl.html#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a> is <a class="reference internal" href="ssl.html#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a>. Previously
the same operation would have failed with a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLContext.keylog_filename">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">keylog_filename</span></span><a class="headerlink" href="ssl.html#ssl.SSLContext.keylog_filename" title="Link to this definition">¶</a></dt>
<dd><p>Write TLS keys to a keylog file, whenever key material is generated or
received. The keylog file is designed for debugging purposes only. The
file format is specified by NSS and used by many traffic analyzers such
as Wireshark. The log file is opened in append-only mode. Writes are
synchronized between threads, but not between processes.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLContext.maximum_version">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">maximum_version</span></span><a class="headerlink" href="ssl.html#ssl.SSLContext.maximum_version" title="Link to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="ssl.html#ssl.TLSVersion" title="ssl.TLSVersion"><code class="xref py py-class docutils literal notranslate"><span class="pre">TLSVersion</span></code></a> enum member representing the highest supported
TLS version. The value defaults to <a class="reference internal" href="ssl.html#ssl.TLSVersion.MAXIMUM_SUPPORTED" title="ssl.TLSVersion.MAXIMUM_SUPPORTED"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TLSVersion.MAXIMUM_SUPPORTED</span></code></a>.
The attribute is read-only for protocols other than <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-attr docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>,
<a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-attr docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a>, and <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-attr docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a>.</p>
<p>The attributes <a class="reference internal" href="ssl.html#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">maximum_version</span></code></a>,
<a class="reference internal" href="ssl.html#ssl.SSLContext.minimum_version" title="ssl.SSLContext.minimum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">minimum_version</span></code></a> and
<a class="reference internal" href="ssl.html#ssl.SSLContext.options" title="ssl.SSLContext.options"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.options</span></code></a> all affect the supported SSL
and TLS versions of the context. The implementation does not prevent
invalid combination. For example a context with
<a class="reference internal" href="ssl.html#ssl.OP_NO_TLSv1_2" title="ssl.OP_NO_TLSv1_2"><code class="xref py py-attr docutils literal notranslate"><span class="pre">OP_NO_TLSv1_2</span></code></a> in <a class="reference internal" href="ssl.html#ssl.SSLContext.options" title="ssl.SSLContext.options"><code class="xref py py-attr docutils literal notranslate"><span class="pre">options</span></code></a> and
<a class="reference internal" href="ssl.html#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">maximum_version</span></code></a> set to <a class="reference internal" href="ssl.html#ssl.TLSVersion.TLSv1_2" title="ssl.TLSVersion.TLSv1_2"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TLSVersion.TLSv1_2</span></code></a>
will not be able to establish a TLS 1.2 connection.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLContext.minimum_version">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">minimum_version</span></span><a class="headerlink" href="ssl.html#ssl.SSLContext.minimum_version" title="Link to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="ssl.html#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.maximum_version</span></code></a> except it is the lowest
supported version or <a class="reference internal" href="ssl.html#ssl.TLSVersion.MINIMUM_SUPPORTED" title="ssl.TLSVersion.MINIMUM_SUPPORTED"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TLSVersion.MINIMUM_SUPPORTED</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLContext.num_tickets">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">num_tickets</span></span><a class="headerlink" href="ssl.html#ssl.SSLContext.num_tickets" title="Link to this definition">¶</a></dt>
<dd><p>Control the number of TLS 1.3 session tickets of a
<a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-attr docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a> context. The setting has no impact on TLS
1.0 to 1.2 connections.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLContext.options">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="ssl.html#ssl.SSLContext.options" title="Link to this definition">¶</a></dt>
<dd><p>このコンテキストで有効になっている SSL オプションを表す整数。デフォルトの値は <a class="reference internal" href="ssl.html#ssl.OP_ALL" title="ssl.OP_ALL"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_ALL</span></code></a> ですが、 <a class="reference internal" href="ssl.html#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv2</span></code></a> のような他の値をビット OR 演算で指定できます。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.6 で変更: </span><a class="reference internal" href="ssl.html#ssl.SSLContext.options" title="ssl.SSLContext.options"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.options</span></code></a> は次のように <a class="reference internal" href="ssl.html#ssl.Options" title="ssl.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">Options</span></code></a> のフラグを返します。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span><span class="o">.</span><span class="n">options</span>  
<span class="go">&lt;Options.OP_ALL|OP_NO_SSLv3|OP_NO_SSLv2|OP_NO_COMPRESSION: 2197947391&gt;</span>
</pre></div>
</div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">バージョン 3.7 で非推奨: </span>All <code class="docutils literal notranslate"><span class="pre">OP_NO_SSL*</span></code> and <code class="docutils literal notranslate"><span class="pre">OP_NO_TLS*</span></code> options have been deprecated since
Python 3.7. Use <a class="reference internal" href="ssl.html#ssl.SSLContext.minimum_version" title="ssl.SSLContext.minimum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.minimum_version</span></code></a> and
<a class="reference internal" href="ssl.html#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.maximum_version</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLContext.post_handshake_auth">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">post_handshake_auth</span></span><a class="headerlink" href="ssl.html#ssl.SSLContext.post_handshake_auth" title="Link to this definition">¶</a></dt>
<dd><p>Enable TLS 1.3 post-handshake client authentication. Post-handshake auth
is disabled by default and a server can only request a TLS client
certificate during the initial handshake. When enabled, a server may
request a TLS client certificate at any time after the handshake.</p>
<p>When enabled on client-side sockets, the client signals the server that
it supports post-handshake authentication.</p>
<p>When enabled on server-side sockets, <a class="reference internal" href="ssl.html#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a> must
be set to <a class="reference internal" href="ssl.html#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a> or <a class="reference internal" href="ssl.html#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>, too. The
actual client cert exchange is delayed until
<a class="reference internal" href="ssl.html#ssl.SSLSocket.verify_client_post_handshake" title="ssl.SSLSocket.verify_client_post_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.verify_client_post_handshake()</span></code></a> is called and some I/O is
performed.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLContext.protocol">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">protocol</span></span><a class="headerlink" href="ssl.html#ssl.SSLContext.protocol" title="Link to this definition">¶</a></dt>
<dd><p>コンテキストの構築時に選択されたプロトコルバージョン。この属性は読み出し専用です。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLContext.hostname_checks_common_name">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">hostname_checks_common_name</span></span><a class="headerlink" href="ssl.html#ssl.SSLContext.hostname_checks_common_name" title="Link to this definition">¶</a></dt>
<dd><p>Whether <a class="reference internal" href="ssl.html#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> falls back to verify the cert's
subject common name in the absence of a subject alternative name
extension (default: true).</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.10 で変更: </span>The flag had no effect with OpenSSL before version 1.1.1l. Python 3.8.9,
3.9.3, and 3.10 include workarounds for previous versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLContext.security_level">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">security_level</span></span><a class="headerlink" href="ssl.html#ssl.SSLContext.security_level" title="Link to this definition">¶</a></dt>
<dd><p>An integer representing the <a class="reference external" href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_security_level.html">security level</a>
for the context. This attribute is read-only.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLContext.verify_flags">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">verify_flags</span></span><a class="headerlink" href="ssl.html#ssl.SSLContext.verify_flags" title="Link to this definition">¶</a></dt>
<dd><p>証明書の検証操作のためのフラグです。 <a class="reference internal" href="ssl.html#ssl.VERIFY_CRL_CHECK_LEAF" title="ssl.VERIFY_CRL_CHECK_LEAF"><code class="xref py py-data docutils literal notranslate"><span class="pre">VERIFY_CRL_CHECK_LEAF</span></code></a> などのフラグをビット OR 演算でセットできます。デフォルトでは OpenSSL は証明書失効リスト (CRLs) を必要としませんし検証にも使いません。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.6 で変更: </span><a class="reference internal" href="ssl.html#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> は次のように <a class="reference internal" href="ssl.html#ssl.VerifyFlags" title="ssl.VerifyFlags"><code class="xref py py-class docutils literal notranslate"><span class="pre">VerifyFlags</span></code></a> のフラグを返します。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span><span class="o">.</span><span class="n">verify_flags</span>  
<span class="go">&lt;VerifyFlags.VERIFY_X509_TRUSTED_FIRST: 32768&gt;</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLContext.verify_mode">
<span class="sig-prename descclassname"><span class="pre">SSLContext.</span></span><span class="sig-name descname"><span class="pre">verify_mode</span></span><a class="headerlink" href="ssl.html#ssl.SSLContext.verify_mode" title="Link to this definition">¶</a></dt>
<dd><p>接続先の証明書の検証を試みるかどうか、また、検証が失敗した場合にどのように振舞うべきかを制御します。この属性は <a class="reference internal" href="ssl.html#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a>, <a class="reference internal" href="ssl.html#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a>, <a class="reference internal" href="ssl.html#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> のうちどれか一つでなければなりません。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.6 で変更: </span><a class="reference internal" href="ssl.html#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a> は次のように <a class="reference internal" href="ssl.html#ssl.VerifyMode" title="ssl.VerifyMode"><code class="xref py py-class docutils literal notranslate"><span class="pre">VerifyMode</span></code></a> enum (列挙) を返します。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span><span class="o">.</span><span class="n">verify_mode</span>  
<span class="go">&lt;VerifyMode.CERT_REQUIRED: 2&gt;</span>
</pre></div>
</div>
</div>
</dd></dl>

</section>
<section id="certificates">
<span id="ssl-certificates"></span><span id="index-15"></span><span id="index-14"></span><h2>証明書<a class="headerlink" href="ssl.html#certificates" title="Link to this heading">¶</a></h2>
<p>証明書を大まかに説明すると、公開鍵/秘密鍵システムの一種です。このシステムでは、各 <em>principal</em> (これはマシン、人、組織などです) は、ユニークな2つの暗号鍵を割り当てられます。1つは公開され、 <em>公開鍵(public key)</em> と呼ばれます。もう一方は秘密にされ、 <em>秘密鍵(private key)</em> と呼ばれます。 2つの鍵は関連しており、片方の鍵で暗号化したメッセージは、もう片方の鍵 <strong>のみ</strong> で復号できます。</p>
<p>証明書は2つの principal の情報を含んでいます。証明書は <em>subject</em> 名とその公開鍵を含んでいます。また、もう一つの principal である <em>発行者(issuer)</em> からの、 subject が本人であることと、その公開鍵が正しいことの宣言(statement)を含んでいます。発行者からの宣言は、その発行者の秘密鍵で署名されています。発行者の秘密鍵は発行者しか知りませんが、誰もがその発行者の公開鍵を利用して宣言を復号し、証明書内の別の情報と比較することで認証することができます。証明書はまた、その証明書が有効である期限に関する情報も含んでいます。この期限は &quot;notBefore&quot; と &quot;notAfter&quot; と呼ばれる2つのフィールドで表現されています。</p>
<p>Python において証明書を利用する場合、クライアントもサーバーも自分を証明するために証明書を利用することができます。ネットワーク接続の相手側に証明書の提示を要求する事ができ、そのクライアントやサーバーが認証を必要とするならその証明書を認証することができます。認証が失敗した場合、接続は例外を発生させます。認証は下位層のOpenSSLフレームワークが自動的に行います。アプリケーションは認証機構について意識する必要はありません。しかし、アプリケーションは認証プロセスのために幾つかの証明書を提供する必要があるかもしれません。</p>
<p>Python は証明書を格納したファイルを利用します。そのファイルは &quot;PEM&quot; (<span class="target" id="index-40"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1422.html"><strong>RFC 1422</strong></a> 参照) フォーマットという、ヘッダー行とフッター行の間にbase-64エンコードされた形をとっている必要があります。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">PEM</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
<section id="certificate-chains">
<h3>証明書チェイン<a class="headerlink" href="ssl.html#certificate-chains" title="Link to this heading">¶</a></h3>
<p>Pythonが利用する証明書を格納したファイルは、ときには <em>証明書チェイン(certificate chain)</em> と呼ばれる証明書のシーケンスを格納します。このチェインの先頭には、まずクライアントやサーバーである principal の証明書を置き、それ以降には、その証明書の発行者(issuer)の証明書などを続け、最後に証明対象(subject)と発行者が同じ <em>自己署名(self-signed)</em> 証明書で終わります。この最後の証明書は <em>ルート証明書(root certificate</em> と呼ばれます。これらの証明書チェインは単純に1つの証明書ファイルに結合してください。例えば、3つの証明書からなる証明書チェインがある場合、私たちのサーバーの証明書から、私たちのサーバーに署名した認証局の証明書、そして認証局の証明書を発行した機関のルート証明書と続きます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="k">for</span> <span class="n">your</span> <span class="n">server</span><span class="p">)</span><span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">the</span> <span class="n">certificate</span> <span class="k">for</span> <span class="n">the</span> <span class="n">CA</span><span class="p">)</span><span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">the</span> <span class="n">root</span> <span class="n">certificate</span> <span class="k">for</span> <span class="n">the</span> <span class="n">CA</span><span class="s1">&#39;s issuer)...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
</section>
<section id="ca-certificates">
<h3>CA 証明書<a class="headerlink" href="ssl.html#ca-certificates" title="Link to this heading">¶</a></h3>
<p>もし相手から送られてきた証明書の認証をしたい場合、信頼している各発行者の証明書チェインが入った &quot;CA certs&quot; ファイルを提供する必要があります。繰り返しますが、このファイルは単純に、各チェインを結合しただけのものです。認証のために、Pythonはそのファイルの中の最初にマッチしたチェインを利用します。<a class="reference internal" href="ssl.html#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_default_certs()</span></code></a> を呼び出すことでプラットフォームの証明書ファイルも使われますが、これは <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> によって自動的に行われます。</p>
</section>
<section id="combined-key-and-certificate">
<h3>秘密鍵と証明書の組み合わせ<a class="headerlink" href="ssl.html#combined-key-and-certificate" title="Link to this heading">¶</a></h3>
<p>Often the private key is stored in the same file as the certificate; in this
case, only the <code class="docutils literal notranslate"><span class="pre">certfile</span></code> parameter to <a class="reference internal" href="ssl.html#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_cert_chain()</span></code></a>
needs to be passed.  If the private key is stored
with the certificate, it should come before the first certificate in
the certificate chain:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">private</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">PEM</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
</section>
<section id="self-signed-certificates">
<h3>自己署名証明書<a class="headerlink" href="ssl.html#self-signed-certificates" title="Link to this heading">¶</a></h3>
<p>SSL暗号化接続サービスを提供するサーバーを建てる場合、適切な証明書を取得するには、認証局から買うなどの幾つかの方法があります。また、自己署名証明書を作るケースもあります。 OpenSSLを使って自己署名証明書を作るには、次のようにします。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">openssl</span> <span class="n">req</span> <span class="o">-</span><span class="n">new</span> <span class="o">-</span><span class="n">x509</span> <span class="o">-</span><span class="n">days</span> <span class="mi">365</span> <span class="o">-</span><span class="n">nodes</span> <span class="o">-</span><span class="n">out</span> <span class="n">cert</span><span class="o">.</span><span class="n">pem</span> <span class="o">-</span><span class="n">keyout</span> <span class="n">cert</span><span class="o">.</span><span class="n">pem</span>
<span class="n">Generating</span> <span class="n">a</span> <span class="mi">1024</span> <span class="n">bit</span> <span class="n">RSA</span> <span class="n">private</span> <span class="n">key</span>
<span class="o">.......++++++</span>
<span class="o">.............................++++++</span>
<span class="n">writing</span> <span class="n">new</span> <span class="n">private</span> <span class="n">key</span> <span class="n">to</span> <span class="s1">&#39;cert.pem&#39;</span>
<span class="o">-----</span>
<span class="n">You</span> <span class="n">are</span> <span class="n">about</span> <span class="n">to</span> <span class="n">be</span> <span class="n">asked</span> <span class="n">to</span> <span class="n">enter</span> <span class="n">information</span> <span class="n">that</span> <span class="n">will</span> <span class="n">be</span> <span class="n">incorporated</span>
<span class="n">into</span> <span class="n">your</span> <span class="n">certificate</span> <span class="n">request</span><span class="o">.</span>
<span class="n">What</span> <span class="n">you</span> <span class="n">are</span> <span class="n">about</span> <span class="n">to</span> <span class="n">enter</span> <span class="ow">is</span> <span class="n">what</span> <span class="ow">is</span> <span class="n">called</span> <span class="n">a</span> <span class="n">Distinguished</span> <span class="n">Name</span> <span class="ow">or</span> <span class="n">a</span> <span class="n">DN</span><span class="o">.</span>
<span class="n">There</span> <span class="n">are</span> <span class="n">quite</span> <span class="n">a</span> <span class="n">few</span> <span class="n">fields</span> <span class="n">but</span> <span class="n">you</span> <span class="n">can</span> <span class="n">leave</span> <span class="n">some</span> <span class="n">blank</span>
<span class="n">For</span> <span class="n">some</span> <span class="n">fields</span> <span class="n">there</span> <span class="n">will</span> <span class="n">be</span> <span class="n">a</span> <span class="n">default</span> <span class="n">value</span><span class="p">,</span>
<span class="n">If</span> <span class="n">you</span> <span class="n">enter</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">the</span> <span class="n">field</span> <span class="n">will</span> <span class="n">be</span> <span class="n">left</span> <span class="n">blank</span><span class="o">.</span>
<span class="o">-----</span>
<span class="n">Country</span> <span class="n">Name</span> <span class="p">(</span><span class="mi">2</span> <span class="n">letter</span> <span class="n">code</span><span class="p">)</span> <span class="p">[</span><span class="n">AU</span><span class="p">]:</span><span class="n">US</span>
<span class="n">State</span> <span class="ow">or</span> <span class="n">Province</span> <span class="n">Name</span> <span class="p">(</span><span class="n">full</span> <span class="n">name</span><span class="p">)</span> <span class="p">[</span><span class="n">Some</span><span class="o">-</span><span class="n">State</span><span class="p">]:</span><span class="n">MyState</span>
<span class="n">Locality</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">city</span><span class="p">)</span> <span class="p">[]:</span><span class="n">Some</span> <span class="n">City</span>
<span class="n">Organization</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">company</span><span class="p">)</span> <span class="p">[</span><span class="n">Internet</span> <span class="n">Widgits</span> <span class="n">Pty</span> <span class="n">Ltd</span><span class="p">]:</span><span class="n">My</span> <span class="n">Organization</span><span class="p">,</span> <span class="n">Inc</span><span class="o">.</span>
<span class="n">Organizational</span> <span class="n">Unit</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">section</span><span class="p">)</span> <span class="p">[]:</span><span class="n">My</span> <span class="n">Group</span>
<span class="n">Common</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">YOUR</span> <span class="n">name</span><span class="p">)</span> <span class="p">[]:</span><span class="n">myserver</span><span class="o">.</span><span class="n">mygroup</span><span class="o">.</span><span class="n">myorganization</span><span class="o">.</span><span class="n">com</span>
<span class="n">Email</span> <span class="n">Address</span> <span class="p">[]:</span><span class="n">ops</span><span class="nd">@myserver</span><span class="o">.</span><span class="n">mygroup</span><span class="o">.</span><span class="n">myorganization</span><span class="o">.</span><span class="n">com</span>
<span class="o">%</span>
</pre></div>
</div>
<p>自己署名証明書の欠点は、それ自身がルート証明書であり、他の人はその証明書を持っていない (そして信頼しない)ことです。</p>
</section>
</section>
<section id="examples">
<h2>使用例<a class="headerlink" href="ssl.html#examples" title="Link to this heading">¶</a></h2>
<section id="testing-for-ssl-support">
<h3>SSLサポートをテストする<a class="headerlink" href="ssl.html#testing-for-ssl-support" title="Link to this heading">¶</a></h3>
<p>インストールされているPythonがSSLをサポートしているかどうかをテストするために、ユーザーコードは次のイディオムを利用することができます。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">ssl</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="k">else</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># do something that requires SSL support</span>
</pre></div>
</div>
</section>
<section id="client-side-operation">
<h3>クライアントサイドの処理<a class="headerlink" href="ssl.html#client-side-operation" title="Link to this heading">¶</a></h3>
<p>この例では、自動的に証明書の検証を行うことを含む望ましいセキュリティ設定でクライアントソケットの SSL コンテキストを作ります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span>
</pre></div>
</div>
<p>自分自身でセキュリティ設定を調整したい場合、コンテキストを一から作ることはできます (ただし、正しくない設定をしてしまいがちなことに注意してください):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLS_CLIENT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">load_verify_locations</span><span class="p">(</span><span class="s2">&quot;/etc/ssl/certs/ca-bundle.crt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>(このスニペットはすべての CA 証明書が <code class="docutils literal notranslate"><span class="pre">/etc/ssl/certs/ca-bundle.crt</span></code> にバンドルされていることを仮定しています; もし違っていればエラーになりますので、適宜修正してください)</p>
<p>The <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> protocol configures the context for cert
validation and hostname verification. <a class="reference internal" href="ssl.html#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a> is
set to <a class="reference internal" href="ssl.html#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> and <a class="reference internal" href="ssl.html#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> is set
to <code class="docutils literal notranslate"><span class="pre">True</span></code>. All other protocols create SSL contexts with insecure defaults.</p>
<p>When you use the context to connect to a server, <a class="reference internal" href="ssl.html#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>
and <a class="reference internal" href="ssl.html#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> validate the server certificate: it
ensures that the server certificate was signed with one of the CA
certificates, checks the signature for correctness, and verifies other
properties like validity and identity of the hostname:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">),</span>
<span class="gp">... </span>                           <span class="n">server_hostname</span><span class="o">=</span><span class="s2">&quot;www.python.org&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s2">&quot;www.python.org&quot;</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span>
</pre></div>
</div>
<p>そして証明書を持ってくることができます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cert</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">getpeercert</span><span class="p">()</span>
</pre></div>
</div>
<p>証明書が、期待しているサービス (つまり、 HTTPS ホスト <code class="docutils literal notranslate"><span class="pre">www.python.org</span></code>) の身元を特定していることを視覚的に点検してみましょう:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">cert</span><span class="p">)</span>
<span class="go">{&#39;OCSP&#39;: (&#39;http://ocsp.digicert.com&#39;,),</span>
<span class="go"> &#39;caIssuers&#39;: (&#39;http://cacerts.digicert.com/DigiCertSHA2ExtendedValidationServerCA.crt&#39;,),</span>
<span class="go"> &#39;crlDistributionPoints&#39;: (&#39;http://crl3.digicert.com/sha2-ev-server-g1.crl&#39;,</span>
<span class="go">                           &#39;http://crl4.digicert.com/sha2-ev-server-g1.crl&#39;),</span>
<span class="go"> &#39;issuer&#39;: (((&#39;countryName&#39;, &#39;US&#39;),),</span>
<span class="go">            ((&#39;organizationName&#39;, &#39;DigiCert Inc&#39;),),</span>
<span class="go">            ((&#39;organizationalUnitName&#39;, &#39;www.digicert.com&#39;),),</span>
<span class="go">            ((&#39;commonName&#39;, &#39;DigiCert SHA2 Extended Validation Server CA&#39;),)),</span>
<span class="go"> &#39;notAfter&#39;: &#39;Sep  9 12:00:00 2016 GMT&#39;,</span>
<span class="go"> &#39;notBefore&#39;: &#39;Sep  5 00:00:00 2014 GMT&#39;,</span>
<span class="go"> &#39;serialNumber&#39;: &#39;01BB6F00122B177F36CAB49CEA8B6B26&#39;,</span>
<span class="go"> &#39;subject&#39;: (((&#39;businessCategory&#39;, &#39;Private Organization&#39;),),</span>
<span class="go">             ((&#39;1.3.6.1.4.1.311.60.2.1.3&#39;, &#39;US&#39;),),</span>
<span class="go">             ((&#39;1.3.6.1.4.1.311.60.2.1.2&#39;, &#39;Delaware&#39;),),</span>
<span class="go">             ((&#39;serialNumber&#39;, &#39;3359300&#39;),),</span>
<span class="go">             ((&#39;streetAddress&#39;, &#39;16 Allen Rd&#39;),),</span>
<span class="go">             ((&#39;postalCode&#39;, &#39;03894-4801&#39;),),</span>
<span class="go">             ((&#39;countryName&#39;, &#39;US&#39;),),</span>
<span class="go">             ((&#39;stateOrProvinceName&#39;, &#39;NH&#39;),),</span>
<span class="go">             ((&#39;localityName&#39;, &#39;Wolfeboro&#39;),),</span>
<span class="go">             ((&#39;organizationName&#39;, &#39;Python Software Foundation&#39;),),</span>
<span class="go">             ((&#39;commonName&#39;, &#39;www.python.org&#39;),)),</span>
<span class="go"> &#39;subjectAltName&#39;: ((&#39;DNS&#39;, &#39;www.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;pypi.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;docs.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;testpypi.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;bugs.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;wiki.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;hg.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;mail.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;packaging.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;pythonhosted.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;www.pythonhosted.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;test.pythonhosted.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;us.pycon.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;id.python.org&#39;)),</span>
<span class="go"> &#39;version&#39;: 3}</span>
</pre></div>
</div>
<p>SSL チャネルは今や確立されて証明書が検証されているので、サーバとのお喋りを続けることができます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;HEAD / HTTP/1.0</span><span class="se">\r\n</span><span class="s2">Host: linuxfr.org</span><span class="se">\r\n\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">))</span>
<span class="go">[b&#39;HTTP/1.1 200 OK&#39;,</span>
<span class="go"> b&#39;Date: Sat, 18 Oct 2014 18:27:20 GMT&#39;,</span>
<span class="go"> b&#39;Server: nginx&#39;,</span>
<span class="go"> b&#39;Content-Type: text/html; charset=utf-8&#39;,</span>
<span class="go"> b&#39;X-Frame-Options: SAMEORIGIN&#39;,</span>
<span class="go"> b&#39;Content-Length: 45679&#39;,</span>
<span class="go"> b&#39;Accept-Ranges: bytes&#39;,</span>
<span class="go"> b&#39;Via: 1.1 varnish&#39;,</span>
<span class="go"> b&#39;Age: 2188&#39;,</span>
<span class="go"> b&#39;X-Served-By: cache-lcy1134-LCY&#39;,</span>
<span class="go"> b&#39;X-Cache: HIT&#39;,</span>
<span class="go"> b&#39;X-Cache-Hits: 11&#39;,</span>
<span class="go"> b&#39;Vary: Cookie&#39;,</span>
<span class="go"> b&#39;Strict-Transport-Security: max-age=63072000; includeSubDomains&#39;,</span>
<span class="go"> b&#39;Connection: close&#39;,</span>
<span class="go"> b&#39;&#39;,</span>
<span class="go"> b&#39;&#39;]</span>
</pre></div>
</div>
<p>このドキュメントの下の方の、 <a class="reference internal" href="ssl.html#ssl-security"><span class="std std-ref">セキュリティで考慮すべき点</span></a> に関する議論を参照してください。</p>
</section>
<section id="server-side-operation">
<h3>サーバサイドの処理<a class="headerlink" href="ssl.html#server-side-operation" title="Link to this heading">¶</a></h3>
<p>サーバサイドの処理では、通常、サーバー証明書と秘密鍵がそれぞれファイルに格納された形で必要です。最初に秘密鍵と証明書が保持されたコンテキストを作成し、クライアントがあなたの信憑性をチェックできるようにします。そののちにソケットを開き、ポートにバインドし、そのソケットの <code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code> を呼び、クライアントからの接続を待ちます。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">Purpose</span><span class="o">.</span><span class="n">CLIENT_AUTH</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_cert_chain</span><span class="p">(</span><span class="n">certfile</span><span class="o">=</span><span class="s2">&quot;mycertfile&quot;</span><span class="p">,</span> <span class="n">keyfile</span><span class="o">=</span><span class="s2">&quot;mykeyfile&quot;</span><span class="p">)</span>

<span class="n">bindsocket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;myaddr.example.com&#39;</span><span class="p">,</span> <span class="mi">10023</span><span class="p">))</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>クライアントが接続してきた場合、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code> を呼んで新しいソケットを作成し、接続のためにサーバサイドの SSL ソケットを、コンテキストの <a class="reference internal" href="ssl.html#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> メソッドで作ります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">newsocket</span><span class="p">,</span> <span class="n">fromaddr</span> <span class="o">=</span> <span class="n">bindsocket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
    <span class="n">connstream</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">newsocket</span><span class="p">,</span> <span class="n">server_side</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">connstream</span><span class="o">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SHUT_RDWR</span><span class="p">)</span>
        <span class="n">connstream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>そして、 <code class="docutils literal notranslate"><span class="pre">connstream</span></code> からデータを読み、クライアントと切断する(あるいはクライアントが切断してくる)まで何か処理をします。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="c1"># empty data means the client is finished with us</span>
    <span class="k">while</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">do_something</span><span class="p">(</span><span class="n">connstream</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
            <span class="c1"># we&#39;ll assume do_something returns False</span>
            <span class="c1"># when we&#39;re finished with client</span>
            <span class="k">break</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="c1"># finished with client</span>
</pre></div>
</div>
<p>そして新しいクライアント接続のために listen に戻ります。 (もちろん現実のサーバは、おそらく個々のクライアント接続ごとに別のスレッドで処理するか、ソケットを <a class="reference internal" href="ssl.html#ssl-nonblocking"><span class="std std-ref">ノンブロッキングモード</span></a> にし、イベントループを使うでしょう。)</p>
</section>
</section>
<section id="notes-on-non-blocking-sockets">
<span id="ssl-nonblocking"></span><h2>ノンブロッキングソケットについての注意事項<a class="headerlink" href="ssl.html#notes-on-non-blocking-sockets" title="Link to this heading">¶</a></h2>
<p>SSL ソケットはノンブロッキングモードにおいては、普通のソケットとは少し違った振る舞いをします。ですのでノンブロッキングソケットとともに使う場合、いくつか気をつけなければならない事項があります:</p>
<ul>
<li><p>ほとんどの <a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> のメソッドは I/O 操作がブロックすると <a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BlockingIOError</span></code></a> ではなく <a class="reference internal" href="ssl.html#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> か <a class="reference internal" href="ssl.html#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> のどちらかを送出します。 <a class="reference internal" href="ssl.html#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> は下層のソケットで読み出しが必要な場合に送出され、 <a class="reference internal" href="ssl.html#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> は下層のソケットで書き込みが必要な場合に送出されます。SSL ソケットに対して <em>書き込み</em> を試みると下層のソケットから最初に <em>読み出す</em> 必要があるかもしれず、SSL ソケットに対して <em>読み出し</em> を試みると下層のソケットに先に <em>書き込む</em> 必要があるかもしれないことに注意してください。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.5 で変更: </span>以前の Python バージョンでは、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.send()</span></code> メソッドは <a class="reference internal" href="ssl.html#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> または <a class="reference internal" href="ssl.html#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> を送出するのではなく、ゼロを返していました。</p>
</div>
</li>
<li><p><a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 呼び出しは OS レベルでのソケットが読み出し可能(または書き込み可能)になったことを教えてくれますが、上位の SSL レイヤーでの十分なデータがあることを意味するわけではありません。例えば、SSL フレームの一部が届いただけかもしれません。ですから、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.recv()</span></code> と <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.send()</span></code> の失敗を処理することに備え、ほかの <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 呼び出し後にリトライしなければなりません。</p></li>
<li><p>反対に、SSL レイヤーは独自の枠組みを持っているため、<a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> が気付かない読み出し可能なデータを SSL ソケットが持っている場合があります。したがって、入手可能な可能性のあるデータをすべて引き出すために最初に <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.recv()</span></code> を呼び出し、次にそれでもまだ必要な場合にだけ <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 呼び出しでブロックすべきです。</p>
<p>(当然のことながら、ほかのプリミティブ、例えば <a class="reference internal" href="select.html#select.poll" title="select.poll"><code class="xref py py-func docutils literal notranslate"><span class="pre">poll()</span></code></a> や <a class="reference internal" href="selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal notranslate"><span class="pre">selectors</span></code></a> モジュール内のものを使う際にも似た但し書きが付きます)</p>
</li>
<li><p>SSL ハンドシェイクそのものがノンブロッキングになります: <a class="reference internal" href="ssl.html#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a> メソッドは成功するまでリトライしなければなりません。 <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> を用いてソケットの準備が整うのを待つためには、およそ以下のようにします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">do_handshake</span><span class="p">()</span>
        <span class="k">break</span>
    <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLWantReadError</span><span class="p">:</span>
        <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">sock</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[])</span>
    <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLWantWriteError</span><span class="p">:</span>
        <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([],</span> <span class="p">[</span><span class="n">sock</span><span class="p">],</span> <span class="p">[])</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> モジュールは <a class="reference internal" href="ssl.html#ssl-nonblocking"><span class="std std-ref">ノンブロッキング SSL ソケット</span></a> をサポートし、より高いレベルの API を提供しています。 <a class="reference internal" href="selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal notranslate"><span class="pre">selectors</span></code></a> モジュールを使ってイベントを poll し、 <a class="reference internal" href="ssl.html#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a>, <a class="reference internal" href="ssl.html#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a>, <a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BlockingIOError</span></code></a> 例外を処理します。SSL ハンドシェイクも非同期に実行します。</p>
</div>
</section>
<section id="memory-bio-support">
<h2>メモリ BIO サポート<a class="headerlink" href="ssl.html#memory-bio-support" title="Link to this heading">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<p>Python 2.6 で SSL モジュールが導入されて以降、<a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> クラスは、以下の互いに関連するが別々の機能を提供してきました。</p>
<ul class="simple">
<li><p>SSL プロトコル処理</p></li>
<li><p>ネットワーク IO</p></li>
</ul>
<p>ネットワーク IO API は、<a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> が提供するものと同じです。<a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> も、そのクラスから継承しています。これにより、SSL ソケットは標準のソケットをそっくりそのまま置き換えるものとして使用できるため、既存のアプリケーションを SSL に対応させるのが非常に簡単になります。</p>
<p>SSL プロトコルの処理とネットワーク IO を組み合わせた場合、通常は問題なく動作しますが、問題が発生する場合があります。一例を挙げると、非同期 IO フレームワークが別の多重化モデルを使用する場合、これは <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> と内部 OpenSSL ソケット IO ルーティンが想定する「ファイル記述子上の select/poll」モデル（準備状態ベース）とは異なります。これは、このモデルが非効率的になる Windows などのプラットフォームに主に該当します。そのため、スコープを限定した <a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> の変種、 <a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> が提供されています。</p>
<dl class="py class">
<dt class="sig sig-object py" id="ssl.SSLObject">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">SSLObject</span></span><a class="headerlink" href="ssl.html#ssl.SSLObject" title="Link to this definition">¶</a></dt>
<dd><p>ネットワーク IO メソッドを含まない SSL プロトコルインスタンスを表す、スコープを限定した <a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> の変種です。一般的にこ、のクラスを使用するのは、メモリバッファを通じて SSL のための非同期 IO を実装するフレームワーク作成者です。</p>
<p>このクラスは、OpenSSL が実装する低水準 SSL オブジェクトの上にインターフェースを実装します。このオブジェクトは SSL 接続の状態をキャプチャしますが、ネットワーク IO 自体は提供しません。IO は、OpenSSL の IO 抽象レイヤである別の「BIO」オブジェクトを通じて実行する必要があります。</p>
<p>このクラスには公開されたコンストラクタがありません。<a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> インスタンスは、 <a class="reference internal" href="ssl.html#ssl.SSLContext.wrap_bio" title="ssl.SSLContext.wrap_bio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_bio()</span></code></a> メソッドを使用して作成しなければなりません。このメソッドは、<a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> インスタンスを作成し、2 つの BIO に束縛します。<em>incoming</em> BIO は、Python から SSL プロトコルインスタンスにデータを渡すために使用され、<em>outgoing</em> BIO は、データを反対向きに渡すために使用されます。</p>
<p>次のメソッドがサポートされています:</p>
<ul class="simple">
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal notranslate"><span class="pre">context</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.server_side" title="ssl.SSLSocket.server_side"><code class="xref py py-attr docutils literal notranslate"><span class="pre">server_side</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.server_hostname" title="ssl.SSLSocket.server_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">server_hostname</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.session" title="ssl.SSLSocket.session"><code class="xref py py-attr docutils literal notranslate"><span class="pre">session</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.session_reused" title="ssl.SSLSocket.session_reused"><code class="xref py py-attr docutils literal notranslate"><span class="pre">session_reused</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.write" title="ssl.SSLSocket.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeercert()</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.selected_alpn_protocol" title="ssl.SSLSocket.selected_alpn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">selected_alpn_protocol()</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.selected_npn_protocol" title="ssl.SSLSocket.selected_npn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">selected_npn_protocol()</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cipher()</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.shared_ciphers" title="ssl.SSLSocket.shared_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shared_ciphers()</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.compression" title="ssl.SSLSocket.compression"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compression()</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.pending" title="ssl.SSLSocket.pending"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pending()</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_handshake()</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.verify_client_post_handshake" title="ssl.SSLSocket.verify_client_post_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verify_client_post_handshake()</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.unwrap" title="ssl.SSLSocket.unwrap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unwrap()</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.get_channel_binding" title="ssl.SSLSocket.get_channel_binding"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_channel_binding()</span></code></a></p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.version" title="ssl.SSLSocket.version"><code class="xref py py-meth docutils literal notranslate"><span class="pre">version()</span></code></a></p></li>
</ul>
<p><a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> と比較すると、このオブジェクトでは以下の機能が不足しています。</p>
<ul class="simple">
<li><p>Any form of network IO; <code class="docutils literal notranslate"><span class="pre">recv()</span></code> and <code class="docutils literal notranslate"><span class="pre">send()</span></code> read and write only to
the underlying <a class="reference internal" href="ssl.html#ssl.MemoryBIO" title="ssl.MemoryBIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryBIO</span></code></a> buffers.</p></li>
<li><p><em>do_handshake_on_connect</em> 機構はありません。必ず手動で <a class="reference internal" href="ssl.html#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_handshake()</span></code></a> を呼んで、ハンドシェイクを開始する必要があります。</p></li>
<li><p><em>suppress_ragged_eofs</em> は処理されません。プロトコルに違反するファイル末尾状態は、 <a class="reference internal" href="ssl.html#ssl.SSLEOFError" title="ssl.SSLEOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLEOFError</span></code></a> 例外を通じて報告されます。</p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.unwrap" title="ssl.SSLSocket.unwrap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unwrap()</span></code></a> メソッドの呼び出しは、下層のソケットを返す SSL ソケットとは異なり、何も返しません。</p></li>
<li><p><a class="reference internal" href="ssl.html#ssl.SSLContext.set_servername_callback" title="ssl.SSLContext.set_servername_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_servername_callback()</span></code></a> に渡される <em>server_name_callback</em> コールバックは、1 つ目の引数として <a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> インスタンスではなく <a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> インスタンスを受け取ります。</p></li>
</ul>
<p><a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> の使用に関する注意:</p>
<ul class="simple">
<li><p><a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> 上のすべての IO は <a class="reference internal" href="ssl.html#ssl-nonblocking"><span class="std std-ref">non-blocking</span></a> です。例えば、<a class="reference internal" href="ssl.html#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> は入力 BIO が持つデータよりも多くのデータを必要とする場合、<a class="reference internal" href="ssl.html#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> を送出します。</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.7 で変更: </span><a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> instances must be created with
<a class="reference internal" href="ssl.html#ssl.SSLContext.wrap_bio" title="ssl.SSLContext.wrap_bio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_bio()</span></code></a>. In earlier versions, it was possible to
create instances directly. This was never documented or officially
supported.</p>
</div>
</dd></dl>

<p>SSLObject は、メモリバッファを使用して外界と通信します。<a class="reference internal" href="ssl.html#ssl.MemoryBIO" title="ssl.MemoryBIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryBIO</span></code></a> クラスは、以下のように OpenSSL メモリ BIO (Basic IO) オブジェクトをラップし、この目的に使用できるメモリバッファを提供します。</p>
<dl class="py class">
<dt class="sig sig-object py" id="ssl.MemoryBIO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">MemoryBIO</span></span><a class="headerlink" href="ssl.html#ssl.MemoryBIO" title="Link to this definition">¶</a></dt>
<dd><p>Python と SSL プロトコルインスタンス間でデータをやり取りするために使用できるメモリバッファ。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.MemoryBIO.pending">
<span class="sig-name descname"><span class="pre">pending</span></span><a class="headerlink" href="ssl.html#ssl.MemoryBIO.pending" title="Link to this definition">¶</a></dt>
<dd><p>現在メモリバッファ中にあるバイト数を返します。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.MemoryBIO.eof">
<span class="sig-name descname"><span class="pre">eof</span></span><a class="headerlink" href="ssl.html#ssl.MemoryBIO.eof" title="Link to this definition">¶</a></dt>
<dd><p>メモリ BIOが現在ファイルの末尾にあるかを表す真偽値です。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.MemoryBIO.read">
<span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.MemoryBIO.read" title="Link to this definition">¶</a></dt>
<dd><p>メモリバッファから最大 <em>n</em> 読み取ります。<em>n</em> が指定されていないか、負値の場合、すべてのバイトが返されます。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.MemoryBIO.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.MemoryBIO.write" title="Link to this definition">¶</a></dt>
<dd><p><em>buf</em> からメモリ BIO にバイトを書き込みます。<em>buf</em> 引数は、バッファプロトコルをサポートするオブジェクトでなければなりません。</p>
<p>戻り値は、書き込まれるバイト数であり、常に <em>buf</em> の長さと等しくなります。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ssl.MemoryBIO.write_eof">
<span class="sig-name descname"><span class="pre">write_eof</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="ssl.html#ssl.MemoryBIO.write_eof" title="Link to this definition">¶</a></dt>
<dd><p>EOF マーカーをメモリ BIO に書き込みます。このメソッドが呼び出された後に <a class="reference internal" href="ssl.html#ssl.MemoryBIO.write" title="ssl.MemoryBIO.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> を呼ぶことはできません。<a class="reference internal" href="ssl.html#ssl.MemoryBIO.eof" title="ssl.MemoryBIO.eof"><code class="xref py py-attr docutils literal notranslate"><span class="pre">eof</span></code></a> 属性は、バッファ内のすべてのデータが読み出された後に True になります。</p>
</dd></dl>

</dd></dl>

</section>
<section id="ssl-session">
<h2>SSL セッション<a class="headerlink" href="ssl.html#ssl-session" title="Link to this heading">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="ssl.SSLSession">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ssl.</span></span><span class="sig-name descname"><span class="pre">SSLSession</span></span><a class="headerlink" href="ssl.html#ssl.SSLSession" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ssl.html#ssl.SSLSocket.session" title="ssl.SSLSocket.session"><code class="xref py py-attr docutils literal notranslate"><span class="pre">session</span></code></a> が使用するセッションオブジェクトです。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLSession.id">
<span class="sig-name descname"><span class="pre">id</span></span><a class="headerlink" href="ssl.html#ssl.SSLSession.id" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLSession.time">
<span class="sig-name descname"><span class="pre">time</span></span><a class="headerlink" href="ssl.html#ssl.SSLSession.time" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLSession.timeout">
<span class="sig-name descname"><span class="pre">timeout</span></span><a class="headerlink" href="ssl.html#ssl.SSLSession.timeout" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLSession.ticket_lifetime_hint">
<span class="sig-name descname"><span class="pre">ticket_lifetime_hint</span></span><a class="headerlink" href="ssl.html#ssl.SSLSession.ticket_lifetime_hint" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ssl.SSLSession.has_ticket">
<span class="sig-name descname"><span class="pre">has_ticket</span></span><a class="headerlink" href="ssl.html#ssl.SSLSession.has_ticket" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="security-considerations">
<span id="ssl-security"></span><h2>セキュリティで考慮すべき点<a class="headerlink" href="ssl.html#security-considerations" title="Link to this heading">¶</a></h2>
<section id="best-defaults">
<h3>最善のデフォルト値<a class="headerlink" href="ssl.html#best-defaults" title="Link to this heading">¶</a></h3>
<p><strong>クライアントでの使用</strong> では、セキュリティポリシーによる特殊な要件がない限りは、 <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> 関数を使用して SSL コンテキストを作成することを強くお勧めします。この関数は、システムの信頼済み CA 証明書をロードし、証明書の検証とホスト名のチェックを有効化し、十分にセキュアなプロトコルと暗号を選択しようとします。</p>
<p>例として、 <a class="reference internal" href="smtplib.html#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">smtplib.SMTP</span></code></a> クラスを使用して SMTP サーバーに対して信頼できるセキュアな接続を行う方法を以下に示します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ssl</span><span class="o">,</span> <span class="nn">smtplib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smtp</span> <span class="o">=</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="s2">&quot;mail.python.org&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">587</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smtp</span><span class="o">.</span><span class="n">starttls</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
<span class="go">(220, b&#39;2.0.0 Ready to start TLS&#39;)</span>
</pre></div>
</div>
<p>接続にクライアントの証明書が必要な場合、 <a class="reference internal" href="ssl.html#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_cert_chain()</span></code></a> によって追加できます。</p>
<p>対照的に、自分自身で <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> クラスのコンストラクタを呼び出すことによって SSL コンテキストを作ると、デフォルトでは証明書検証もホスト名チェックも有効になりません。自分で設定を行う場合は、十分なセキュリティレベルを達成するために、以下のパラグラフをお読みください。</p>
</section>
<section id="manual-settings">
<h3>手動での設定<a class="headerlink" href="ssl.html#manual-settings" title="Link to this heading">¶</a></h3>
<section id="verifying-certificates">
<h4>証明書の検証<a class="headerlink" href="ssl.html#verifying-certificates" title="Link to this heading">¶</a></h4>
<p>When calling the <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> constructor directly,
<a class="reference internal" href="ssl.html#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a> is the default.  Since it does not authenticate the other
peer, it can be insecure, especially in client mode where most of time you
would like to ensure the authenticity of the server you're talking to.
Therefore, when in client mode, it is highly recommended to use
<a class="reference internal" href="ssl.html#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>.  However, it is in itself not sufficient; you also
have to check that the server certificate, which can be obtained by calling
<a class="reference internal" href="ssl.html#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a>, matches the desired service.  For many
protocols and applications, the service can be identified by the hostname.
This common check is automatically performed when
<a class="reference internal" href="ssl.html#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.check_hostname</span></code></a> is enabled.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.7 で変更: </span>Hostname matchings is now performed by OpenSSL. Python no longer uses
<code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code>.</p>
</div>
<p>サーバモードにおいて、(より上位のレベルでの認証メカニズムではなく) SSL レイヤーを使ってあなたのクライアントを認証したいならば、 <a class="reference internal" href="ssl.html#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> を指定して同じようにクライアントの証明書を検証すべきでしょう。</p>
</section>
<section id="protocol-versions">
<h4>プロトコルのバージョン<a class="headerlink" href="ssl.html#protocol-versions" title="Link to this heading">¶</a></h4>
<p>SSL バージョン 2 と 3 は安全性に欠けると考えられており、使用するのは危険です。クライアントとサーバ間の互換性を最大限に確保したい場合、プロトコルバージョンとして <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> または <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a> を使用してください。 SSLv2 と SSLv3 はデフォルトで無効になっています。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client_context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLS_CLIENT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client_context</span><span class="o">.</span><span class="n">minimum_version</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">TLSVersion</span><span class="o">.</span><span class="n">TLSv1_3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client_context</span><span class="o">.</span><span class="n">maximum_version</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">TLSVersion</span><span class="o">.</span><span class="n">TLSv1_3</span>
</pre></div>
</div>
<p>The SSL context created above will only allow TLSv1.3 and later (if
supported by your system) connections to a server. <a class="reference internal" href="ssl.html#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a>
implies certificate validation and hostname checks by default. You have to
load certificates into the context.</p>
</section>
<section id="cipher-selection">
<h4>暗号の選択<a class="headerlink" href="ssl.html#cipher-selection" title="Link to this heading">¶</a></h4>
<p>高度なセキュリティが要求されている場合、SSL セッションのネゴシエーションで有効になる暗号の微調整が <a class="reference internal" href="ssl.html#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_ciphers()</span></code></a> によって可能です。Python 3.2.3 以降、 ssl モジュールではデフォルトで特定の弱い暗号化が無効になっていますが、暗号方式の選択をさらに厳しく制限したい場合もあるでしょう。OpenSSL ドキュメントの <a class="reference external" href="https://www.openssl.org/docs/man1.1.1/man1/ciphers.html#CIPHER-LIST-FORMAT">cipher list format</a> を注意深く読んでください。与えられた暗号方式リストによって有効になる暗号方式をチェックするには、<a class="reference internal" href="ssl.html#ssl.SSLContext.get_ciphers" title="ssl.SSLContext.get_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.get_ciphers()</span></code></a> メソッドまたは <code class="docutils literal notranslate"><span class="pre">openssl</span> <span class="pre">ciphers</span></code> コマンドをシステム上で実行してください。</p>
</section>
</section>
<section id="multi-processing">
<h3>マルチプロセス化<a class="headerlink" href="ssl.html#multi-processing" title="Link to this heading">¶</a></h3>
<p>If using this module as part of a multi-processed application (using,
for example the <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> or <a class="reference internal" href="concurrent.futures.html#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code class="xref py py-mod docutils literal notranslate"><span class="pre">concurrent.futures</span></code></a> modules),
be aware that OpenSSL's internal random number generator does not properly
handle forked processes.  Applications must change the PRNG state of the
parent process if they use any SSL feature with <a class="reference internal" href="os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a>.  Any
successful call of <a class="reference internal" href="ssl.html#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_add()</span></code></a> or <a class="reference internal" href="ssl.html#ssl.RAND_bytes" title="ssl.RAND_bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_bytes()</span></code></a> is
sufficient.</p>
</section>
</section>
<section id="tls-1-3">
<span id="ssl-tlsv1-3"></span><h2>TLS 1.3<a class="headerlink" href="ssl.html#tls-1-3" title="Link to this heading">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
<p>The TLS 1.3 protocol behaves slightly differently than previous version
of TLS/SSL. Some new TLS 1.3 features are not yet available.</p>
<ul class="simple">
<li><p>TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and
ChaCha20 cipher suites are enabled by default.  The method
<a class="reference internal" href="ssl.html#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_ciphers()</span></code></a> cannot enable or disable any TLS 1.3
ciphers yet, but <a class="reference internal" href="ssl.html#ssl.SSLContext.get_ciphers" title="ssl.SSLContext.get_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.get_ciphers()</span></code></a> returns them.</p></li>
<li><p>Session tickets are no longer sent as part of the initial handshake and
are handled differently.  <a class="reference internal" href="ssl.html#ssl.SSLSocket.session" title="ssl.SSLSocket.session"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLSocket.session</span></code></a> and <a class="reference internal" href="ssl.html#ssl.SSLSession" title="ssl.SSLSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSession</span></code></a>
are not compatible with TLS 1.3.</p></li>
<li><p>Client-side certificates are also no longer verified during the initial
handshake.  A server can request a certificate at any time.  Clients
process certificate requests while they send or receive application data
from the server.</p></li>
<li><p>TLS 1.3 features like early data, deferred TLS client cert request,
signature algorithm configuration, and rekeying are not supported yet.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<dl class="simple">
<dt><a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> クラス</dt><dd><p>下位レイヤーの <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> クラスのドキュメント</p>
</dd>
<dt><a class="reference external" href="https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html">SSL/TLS Strong Encryption: An Introduction</a></dt><dd><p>Apache HTTPサーバのドキュメンテーションのイントロ</p>
</dd>
<dt><span class="target" id="index-17"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1422.html"><strong>RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: Certificate-Based Key Management</strong></a></dt><dd><p>Steve Kent</p>
</dd>
<dt><span class="target" id="index-18"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4086.html"><strong>RFC 4086: Randomness Requirements for Security</strong></a></dt><dd><p>Donald E., Jeffrey I. Schiller</p>
</dd>
<dt><span class="target" id="index-19"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5280.html"><strong>RFC 5280: Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</strong></a></dt><dd><p>D. Cooper</p>
</dd>
<dt><span class="target" id="index-20"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5246.html"><strong>RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2</strong></a></dt><dd><p>T. Dierks et. al.</p>
</dd>
<dt><span class="target" id="index-21"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6066.html"><strong>RFC 6066: Transport Layer Security (TLS) Extensions</strong></a></dt><dd><p>D. Eastlake</p>
</dd>
<dt><a class="reference external" href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xml">IANA TLS: Transport Layer Security (TLS) Parameters</a></dt><dd><p>IANA</p>
</dd>
<dt><span class="target" id="index-22"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7525.html"><strong>RFC 7525: Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</strong></a></dt><dd><p>IETF</p>
</dd>
<dt><a class="reference external" href="https://wiki.mozilla.org/Security/Server_Side_TLS">Mozilla's Server Side TLS recommendations</a></dt><dd><p>Mozilla</p>
</dd>
</dl>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="ssl.html#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code> --- ソケットオブジェクト用の TLS/SSL ラッパー</a><ul>
<li><a class="reference internal" href="ssl.html#functions-constants-and-exceptions">関数、定数、例外</a><ul>
<li><a class="reference internal" href="ssl.html#socket-creation">ソケットの作成</a></li>
<li><a class="reference internal" href="ssl.html#context-creation">コンテキストの作成</a></li>
<li><a class="reference internal" href="ssl.html#exceptions">例外</a></li>
<li><a class="reference internal" href="ssl.html#random-generation">乱数生成</a></li>
<li><a class="reference internal" href="ssl.html#certificate-handling">証明書の取り扱い</a></li>
<li><a class="reference internal" href="ssl.html#constants">定数</a></li>
</ul>
</li>
<li><a class="reference internal" href="ssl.html#ssl-sockets">SSL ソケット</a></li>
<li><a class="reference internal" href="ssl.html#ssl-contexts">SSL コンテキスト</a></li>
<li><a class="reference internal" href="ssl.html#certificates">証明書</a><ul>
<li><a class="reference internal" href="ssl.html#certificate-chains">証明書チェイン</a></li>
<li><a class="reference internal" href="ssl.html#ca-certificates">CA 証明書</a></li>
<li><a class="reference internal" href="ssl.html#combined-key-and-certificate">秘密鍵と証明書の組み合わせ</a></li>
<li><a class="reference internal" href="ssl.html#self-signed-certificates">自己署名証明書</a></li>
</ul>
</li>
<li><a class="reference internal" href="ssl.html#examples">使用例</a><ul>
<li><a class="reference internal" href="ssl.html#testing-for-ssl-support">SSLサポートをテストする</a></li>
<li><a class="reference internal" href="ssl.html#client-side-operation">クライアントサイドの処理</a></li>
<li><a class="reference internal" href="ssl.html#server-side-operation">サーバサイドの処理</a></li>
</ul>
</li>
<li><a class="reference internal" href="ssl.html#notes-on-non-blocking-sockets">ノンブロッキングソケットについての注意事項</a></li>
<li><a class="reference internal" href="ssl.html#memory-bio-support">メモリ BIO サポート</a></li>
<li><a class="reference internal" href="ssl.html#ssl-session">SSL セッション</a></li>
<li><a class="reference internal" href="ssl.html#security-considerations">セキュリティで考慮すべき点</a><ul>
<li><a class="reference internal" href="ssl.html#best-defaults">最善のデフォルト値</a></li>
<li><a class="reference internal" href="ssl.html#manual-settings">手動での設定</a><ul>
<li><a class="reference internal" href="ssl.html#verifying-certificates">証明書の検証</a></li>
<li><a class="reference internal" href="ssl.html#protocol-versions">プロトコルのバージョン</a></li>
<li><a class="reference internal" href="ssl.html#cipher-selection">暗号の選択</a></li>
</ul>
</li>
<li><a class="reference internal" href="ssl.html#multi-processing">マルチプロセス化</a></li>
</ul>
</li>
<li><a class="reference internal" href="ssl.html#tls-1-3">TLS 1.3</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="socket.html"
                          title="前の章へ"><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code> --- 低水準ネットワークインターフェース</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="select.html"
                          title="次の章へ"><code class="xref py py-mod docutils literal notranslate"><span class="pre">select</span></code> --- I/O 完了の待機</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/ssl.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="サイドバーをたたむ">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="select.html" title="select --- I/O 完了の待機"
             >次へ</a> |</li>
        <li class="right" >
          <a href="socket.html" title="socket --- 低水準ネットワークインターフェース"
             >前へ</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >ネットワーク通信とプロセス間通信</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="ssl.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code> --- ソケットオブジェクト用の TLS/SSL ラッパー</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" id="search-box" />
          <input type="submit" value="検索" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    Copyright
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="../../../license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最終更新: Jun 11, 2024 (04:44 UTC)
    
      <a href="../../../bugs.html">Found a bug</a>?
    
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>

    <script type="text/javascript" src="../_static/switchers.js"></script>
  </body>
</html>