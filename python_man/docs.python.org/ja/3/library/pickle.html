<!DOCTYPE html>

<html lang="ja" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="pickle --- Python オブジェクトの直列化" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/pickle.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="ソースコード: Lib/pickle.py pickle モジュールは Python オブジェクトの直列化および直列化されたオブジェクトの復元のためのバイナリプロトコルを実装しています。&quot;Pickle 化&quot; は Python オブジェクト階層をバイトストリームに変換する処理、&quot;非 pickle 化&quot; は ( バイナリファイル または バイトライクオブジェクト から) バイトストリームをオブジ..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="ソースコード: Lib/pickle.py pickle モジュールは Python オブジェクトの直列化および直列化されたオブジェクトの復元のためのバイナリプロトコルを実装しています。&quot;Pickle 化&quot; は Python オブジェクト階層をバイトストリームに変換する処理、&quot;非 pickle 化&quot; は ( バイナリファイル または バイトライクオブジェクト から) バイトストリームをオブジ..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>pickle --- Python オブジェクトの直列化 &#8212; Python 3.12.4 ドキュメント</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css%3Fv=80d5e7a1.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css%3Fv=bb723527.css" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css%3Fv=b20cc3f5.css" />
    
    <script src="../_static/documentation_options.js%3Fv=7e11ab17"></script>
    <script src="../_static/doctools.js%3Fv=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js%3Fv=dc90522c"></script>
    <script src="../_static/translations.js%3Fv=4dbe4bdc"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.12.4 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="copyreg --- pickle サポート関数を登録する" href="copyreg.html" />
    <link rel="prev" title="データの永続化" href="persistence.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="../../../3/library/pickle.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" />
                <input type="submit" value="検索"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="pickle.html#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code> --- Python オブジェクトの直列化</a><ul>
<li><a class="reference internal" href="pickle.html#relationship-to-other-python-modules">他の Python モジュールとの関係</a><ul>
<li><a class="reference internal" href="pickle.html#comparison-with-marshal"><code class="docutils literal notranslate"><span class="pre">marshal</span></code> との比較</a></li>
<li><a class="reference internal" href="pickle.html#comparison-with-json"><code class="docutils literal notranslate"><span class="pre">json</span></code> との比較</a></li>
</ul>
</li>
<li><a class="reference internal" href="pickle.html#data-stream-format">データストリームの形式</a></li>
<li><a class="reference internal" href="pickle.html#module-interface">モジュールインターフェース</a></li>
<li><a class="reference internal" href="pickle.html#what-can-be-pickled-and-unpickled">pickle 化、非 pickle 化できるもの</a></li>
<li><a class="reference internal" href="pickle.html#pickling-class-instances">クラスインスタンスの pickle 化</a><ul>
<li><a class="reference internal" href="pickle.html#persistence-of-external-objects">外部オブジェクトの永続化</a></li>
<li><a class="reference internal" href="pickle.html#dispatch-tables">ディスパッチテーブル</a></li>
<li><a class="reference internal" href="pickle.html#handling-stateful-objects">状態を持つオブジェクトの扱い</a></li>
</ul>
</li>
<li><a class="reference internal" href="pickle.html#custom-reduction-for-types-functions-and-other-objects">型、関数、その他のオブジェクトに対するリダクションのカスタマイズ</a></li>
<li><a class="reference internal" href="pickle.html#out-of-band-buffers">アウトオブバウンドバッファ</a><ul>
<li><a class="reference internal" href="pickle.html#provider-api">生産者 API</a></li>
<li><a class="reference internal" href="pickle.html#consumer-api">消費者 API</a></li>
<li><a class="reference internal" href="pickle.html#example">使用例</a></li>
</ul>
</li>
<li><a class="reference internal" href="pickle.html#restricting-globals">グローバル変数を制限する</a></li>
<li><a class="reference internal" href="pickle.html#performance">性能</a></li>
<li><a class="reference internal" href="pickle.html#examples">使用例</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="persistence.html"
                          title="前の章へ">データの永続化</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="copyreg.html"
                          title="次の章へ"><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code> --- <code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code> サポート関数を登録する</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/pickle.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="copyreg.html" title="copyreg --- pickle サポート関数を登録する"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="persistence.html" title="データの永続化"
             accesskey="P">前へ</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="persistence.html" accesskey="U">データの永続化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="pickle.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code> --- Python オブジェクトの直列化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" id="search-box" />
          <input type="submit" value="検索" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-pickle">
<span id="pickle-python-object-serialization"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code> --- Python オブジェクトの直列化<a class="headerlink" href="pickle.html#module-pickle" title="Link to this heading">¶</a></h1>
<p><strong>ソースコード:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/pickle.py">Lib/pickle.py</a></p>
<hr class="docutils" id="index-0" />
<p><a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> モジュールは Python オブジェクトの直列化および直列化されたオブジェクトの復元のためのバイナリプロトコルを実装しています。<em>&quot;Pickle 化&quot;</em> は Python オブジェクト階層をバイトストリームに変換する処理、<em>&quot;非 pickle 化&quot;</em> は (<a class="reference internal" href="../glossary.html#term-binary-file"><span class="xref std std-term">バイナリファイル</span></a> または <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">バイトライクオブジェクト</span></a> から) バイトストリームをオブジェクト階層に復元する処理を意味します。pickle 化 (および非 pickle 化) は &quot;直列化 (serialization)&quot;、&quot;整列化 (marshalling)&quot;、あるいは <a class="footnote-reference brackets" href="pickle.html#id7" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> &quot;平坦化 (flattening)&quot; とも呼ばれますが、混乱を避けるため、ここでは &quot;Pickle 化&quot;、&quot;非 pickle 化&quot; で統一します。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p><code class="docutils literal notranslate"><span class="pre">pickle</span></code> モジュールは <strong>安全ではありません</strong> 。信頼できるデータのみを非 pickle 化してください。</p>
<p><strong>非 pickle 化の過程で任意のコードを実行する</strong> ような、悪意ある pickle オブジェクトを生成することが可能です。信頼できない提供元からのデータや、改竄された可能性のあるデータの非 pickle 化は絶対に行わないでください。</p>
<p>データが改竄されていないことを保証したい場合は、 <a class="reference internal" href="hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a> による鍵付きハッシュ化を検討してください。</p>
<p>信頼できないデータを処理する場合 <a class="reference internal" href="json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a> のようなより安全な直列化形式の方が適切でしょう。 <a class="reference internal" href="pickle.html#comparison-with-json"><span class="std std-ref">json との比較</span></a> を参照してください。</p>
</div>
<section id="relationship-to-other-python-modules">
<h2>他の Python モジュールとの関係<a class="headerlink" href="pickle.html#relationship-to-other-python-modules" title="Link to this heading">¶</a></h2>
<section id="comparison-with-marshal">
<h3><code class="docutils literal notranslate"><span class="pre">marshal</span></code> との比較<a class="headerlink" href="pickle.html#comparison-with-marshal" title="Link to this heading">¶</a></h3>
<p>Python には <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> と呼ばれるより原始的な直列化モジュールがありますが、一般的に Python オブジェクトを直列化する方法としては <a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> を選ぶべきです。 <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> は基本的に <code class="file docutils literal notranslate"><span class="pre">.pyc</span></code> ファイルをサポートするために存在しています。</p>
<p><a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> モジュールはいくつかの点で <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> と明確に異なります:</p>
<ul>
<li><p><a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> モジュールでは、同じオブジェクトが再度直列化されることのないよう、すでに直列化されたオブジェクトについて追跡情報を保持します。 <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> はこれを行いません。</p>
<p>この機能は再帰的オブジェクトと共有オブジェクトの両方に重要な関わりをもっています。再帰的オブジェクトとは自分自身に対する参照を持っているオブジェクトです。再帰的オブジェクトは marshal で扱うことができず、実際、再帰的オブジェクトを marshal 化しようとすると Python インタプリタをクラッシュさせてしまいます。共有オブジェクトは、直列化しようとするオブジェクト階層の異なる複数の場所で同じオブジェクトに対する参照が存在する場合に生じます。<a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> はそのようなオブジェクトを一度だけ保存し、その他全ての参照がそのマスターコピーを指し示すことを保証します。共有オブジェクトを共有のままにしておくことは、変更可能なオブジェクトの場合には非常に重要です。</p>
</li>
<li><p><a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> はユーザ定義クラスやそのインスタンスを直列化するために使うことができません。 <a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> はクラスインスタンスを透過的に保存したり復元したりすることができますが、クラス定義をインポートすることが可能で、かつオブジェクトが保存された際と同じモジュールで定義されていなければなりません。</p></li>
<li><p><a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> の直列化形式は Python のバージョン間での移植性を保証していません。  <code class="file docutils literal notranslate"><span class="pre">.pyc</span></code> ファイルをサポートすることが主な役割であるため、 Python 開発者は必要があれば直列化形式に非互換な変更を加える権利を有しています。 いっぽう <a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> の直列化形式は、互換性のあるプロトコルを選ぶという条件のもとで Python リリース間の後方互換性が保証されます。また処理すべきデータが Python 2 と Python 3 の間で非互換な型を含む場合も、 pickle 化および非 pickle 化のコードはそのような互換性を破る言語の境界を適切に取り扱います。</p></li>
</ul>
</section>
<section id="comparison-with-json">
<span id="id2"></span><h3><code class="docutils literal notranslate"><span class="pre">json</span></code> との比較<a class="headerlink" href="pickle.html#comparison-with-json" title="Link to this heading">¶</a></h3>
<p>pickle プロトコルと <a class="reference external" href="https://json.org">JSON (JavaScript Object Notation)</a> との基本的な違いは以下のとおりです:</p>
<ul class="simple">
<li><p>JSON はテキストの直列化フォーマット (大抵の場合 <code class="docutils literal notranslate"><span class="pre">utf-8</span></code> にエンコードされますが、その出力は Unicode 文字列です) で、pickle はバイナリの直列化フォーマットです;</p></li>
<li><p>JSON は人間が読める形式ですが、pickle はそうではありません;</p></li>
<li><p>JSON は相互運用可能で Python 以外でも広く使用されていますが、pickle は Python 固有です;</p></li>
<li><p>JSON は、デフォルトでは Python の組み込み型の一部しか表現することができず、カスタムクラスに対しても行えません; pickle は極めて多くの Python 組み込み型を表現できます (その多くは賢い Python 内省機構によって自動的に行われます; 複雑なケースでは <a class="reference internal" href="pickle.html#pickle-inst"><span class="std std-ref">固有のオブジェクト API</span></a> によって対応できます)。</p></li>
<li><p>pickleとは異なり、信頼できないJSONを復元するだけでは、任意のコードを実行できる脆弱性は発生しません。</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference internal" href="json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a> モジュール: JSON への直列化および復元を行うための標準ライブラリモジュール。</p>
</div>
</section>
</section>
<section id="data-stream-format">
<span id="pickle-protocols"></span><h2>データストリームの形式<a class="headerlink" href="pickle.html#data-stream-format" title="Link to this heading">¶</a></h2>
<p id="index-1">The data format used by <a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> is Python-specific.  This has the
advantage that there are no restrictions imposed by external standards such as
JSON or XDR (which can't represent pointer sharing); however it means that
non-Python programs may not be able to reconstruct pickled Python objects.</p>
<p>デフォルトでは、<a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> データフォーマットは比較的コンパクトなバイナリ表現を使用します。サイズの抑制目的の最適化が必要なら、pickle されたデータを効率的に <a class="reference internal" href="archiving.html"><span class="doc">圧縮する</span></a> ことができます。</p>
<p><a class="reference internal" href="pickletools.html#module-pickletools" title="pickletools: Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickletools</span></code></a> モジュールには <a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> によって生成されたデータストリームを解析するためのツールが含まれます。<a class="reference internal" href="pickletools.html#module-pickletools" title="pickletools: Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickletools</span></code></a> のソースコードには、pickle プロトコルで使用される命令コードに関する詳細なコメントがあります。</p>
<p>現在 pickle 化には 6 種類のプロトコルを使用できます。より高いプロトコルを使用するほど、作成された pickle を読み込むためにより高い Python のバージョンが必要になります。</p>
<ul class="simple">
<li><p>プロトコルバージョン 0 はオリジナルの「人間に判読可能な」プロトコルで、Python の初期のバージョンとの後方互換性を持ちます。</p></li>
<li><p>プロトコルバージョン 1 は旧形式のバイナリフォーマットで、これも Python の初期バージョンと互換性があります。</p></li>
<li><p>プロトコルバージョン 2 は Python 2.3 で導入されました。このバージョンでは <a class="reference internal" href="../glossary.html#term-new-style-class"><span class="xref std std-term">新方式のクラス</span></a> のより効率的な pickle 化を提供しました。プロトコル 2 による改良に関する情報は <span class="target" id="index-14"></span><a class="pep reference external" href="https://peps.python.org/pep-0307/"><strong>PEP 307</strong></a> を参照してください。</p></li>
<li><p>プロトコルバージョン 3 は Python 3 で追加されました。 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> オブジェクトを明示的にサポートしており、 Python 2.x で unpickle することはできません。これは Python 3.0から3.7のデフォルトプロトコルでした。</p></li>
<li><p>プロトコルバージョン 4 は Python 3.4 で追加されました。このバージョンでは巨大なオブジェクトのサポート、より多くの種類のオブジェクトの pickle 化、および一部のデータ形式の最適化が行われました。これはPython 3.8からのデフォルトプロトコルです。プロトコル 4 による改良に関する情報は <span class="target" id="index-15"></span><a class="pep reference external" href="https://peps.python.org/pep-3154/"><strong>PEP 3154</strong></a> を参照してください。</p></li>
<li><p>プロトコルバージョン 5 は Python 3.8 で追加されました。このバージョンでは帯域外データのサポートが追加され、また帯域内データに対するパフォーマンスが向上します。プロトコルバージョン 5 によってもたらされる改善についての情報は <span class="target" id="index-16"></span><a class="pep reference external" href="https://peps.python.org/pep-0574/"><strong>PEP 574</strong></a> を参照してください。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>直列化は永続性より原始的な概念です。 <a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> はファイルオブジェクトの読み書きを行いますが、永続オブジェクトの命名に関する問題にも、(さらに困難な) 永続オブジェクトへの並列アクセスに関する問題にも対応しません。<a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> モジュールは複雑なオブジェクトをバイトストリームに変換し、バイトストリームから同じ内部構造のオブジェクトに復元することができます。これらのバイトストリームはファイルに出力されることが多いでしょうが、ネットワークを介して送信したり、データベースに格納することもありえます。<a class="reference internal" href="shelve.html#module-shelve" title="shelve: Python object persistence."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shelve</span></code></a> モジュールは、オブジェクトを DBM 方式のデータベースファイル上で pickle 化および非 pickle 化するシンプルなインターフェースを提供します。</p>
</div>
</section>
<section id="module-interface">
<h2>モジュールインターフェース<a class="headerlink" href="pickle.html#module-interface" title="Link to this heading">¶</a></h2>
<p>オブジェクト階層を直列化するには、<a class="reference internal" href="pickle.html#pickle.dumps" title="pickle.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">dumps()</span></code></a> 関数を呼ぶだけです。同様に、データストリームを復元するには、<a class="reference internal" href="pickle.html#pickle.loads" title="pickle.loads"><code class="xref py py-func docutils literal notranslate"><span class="pre">loads()</span></code></a> 関数を呼びます。しかし、直列化および復元に対してより多くのコントロールを行いたい場合、それぞれ <a class="reference internal" href="pickle.html#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> または <a class="reference internal" href="pickle.html#pickle.Unpickler" title="pickle.Unpickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unpickler</span></code></a> オブジェクトを作成することができます。</p>
<p><a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> モジュールは以下の定数を提供しています:</p>
<dl class="py data">
<dt class="sig sig-object py" id="pickle.HIGHEST_PROTOCOL">
<span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">HIGHEST_PROTOCOL</span></span><a class="headerlink" href="pickle.html#pickle.HIGHEST_PROTOCOL" title="Link to this definition">¶</a></dt>
<dd><p>利用可能なうち最も高い <a class="reference internal" href="pickle.html#pickle-protocols"><span class="std std-ref">プロトコルバージョン</span></a> (整数)。この値は <em>protocol</em> 値として関数 <a class="reference internal" href="pickle.html#pickle.dump" title="pickle.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a>  および <a class="reference internal" href="pickle.html#pickle.dumps" title="pickle.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">dumps()</span></code></a> と、<a class="reference internal" href="pickle.html#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> コンストラクターに渡すことができます。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="pickle.DEFAULT_PROTOCOL">
<span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">DEFAULT_PROTOCOL</span></span><a class="headerlink" href="pickle.html#pickle.DEFAULT_PROTOCOL" title="Link to this definition">¶</a></dt>
<dd><p>pickle化に使われるデフォルトの <a class="reference internal" href="pickle.html#pickle-protocols"><span class="std std-ref">プロトコルバージョン</span></a> (整数)。<cite>HIGHEST_PROTOCOL</cite> よりも小さい場合があります。現在のデフォルトプロトコルは4です。このプロトコルはPython3.4で初めて導入され、その前のバージョンとは互換性がありません。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.0 で変更: </span>デフォルトプロトコルは 3 です。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.8 で変更: </span>デフォルトプロトコルは 4 です。</p>
</div>
</dd></dl>

<p>この pickle 化の手続きを便利にするために、 <a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> モジュールでは以下の関数を提供しています:</p>
<dl class="py function">
<dt class="sig sig-object py" id="pickle.dump">
<span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">dump</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protocol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_imports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer_callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#pickle.dump" title="Link to this definition">¶</a></dt>
<dd><p>オブジェクト <em>obj</em> を pickle 化し、すでにオープンしている <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">ファイルオブジェクト</span></a> <em>file</em> に書き込みます。<code class="docutils literal notranslate"><span class="pre">Pickler(file,</span> <span class="pre">protocol).dump(obj)</span></code> と等価です。</p>
<p>引数 <em>file</em>, <em>protocol</em>, <em>fix_imports</em> および <em>buffer_callback</em> は <a class="reference internal" href="pickle.html#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> のコンストラクタと同じ意味になります。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.8 で変更: </span><em>buffer_callback</em> 引数が追加されました。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pickle.dumps">
<span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">dumps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protocol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_imports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer_callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#pickle.dumps" title="Link to this definition">¶</a></dt>
<dd><p>ファイルに書く代わりに、<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> オブジェクトとしてオブジェクト <em>obj</em> の pickle 表現を返します。</p>
<p>引数 <em>protocol</em>, <em>fix_imports</em> および <em>buffer_callback</em> は <a class="reference internal" href="pickle.html#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> のコンストラクタと同じ意味になります。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.8 で変更: </span><em>buffer_callback</em> 引数が追加されました。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pickle.load">
<span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_imports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ASCII'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#pickle.load" title="Link to this definition">¶</a></dt>
<dd><p>あるオブジェクトの pickle 化表現を、オープンしている <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">ファイルオブジェクト</span></a> <em>file</em> から読み込み、その中で指定されているオブジェクト階層に再構成して返します。これは <code class="docutils literal notranslate"><span class="pre">Unpickler(file).load()</span></code> と等価です。</p>
<p>pickle のプロトコルバージョンは自動的に検出されます。したがって protocol 引数は必要ありません。pickle 化オブジェクト表現より後のバイト列は無視されます。</p>
<p>引数 <em>file</em>, <em>fix_imports</em>, <em>encoding</em>, <em>errors</em>, <em>strict</em> および <em>buffers</em> は <a class="reference internal" href="pickle.html#pickle.Unpickler" title="pickle.Unpickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unpickler</span></code></a> のコンストラクタと同じ意味になります。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.8 で変更: </span><em>buffers</em> 引数が追加されました。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pickle.loads">
<span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">loads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_imports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ASCII'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#pickle.loads" title="Link to this definition">¶</a></dt>
<dd><p>オブジェクトのピックル化表現 <em>data</em> から再構成されたオブジェクト階層を返します。 <em>data</em> は バイトライクオブジェクト (<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>) でなければなりません。</p>
<p>pickle のプロトコルバージョンは自動的に検出されます。したがって protocol 引数は必要ありません。pickle 化オブジェクト表現より後のバイト列は無視されます。</p>
<p>引数 <em>fix_imports</em>, <em>encoding</em>, <em>errors</em>, <em>strict</em> および <em>buffers</em> は <a class="reference internal" href="pickle.html#pickle.Unpickler" title="pickle.Unpickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unpickler</span></code></a> のコンストラクタと同じ意味になります。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.8 で変更: </span><em>buffers</em> 引数が追加されました。</p>
</div>
</dd></dl>

<p><a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> モジュールでは 3 つの例外を定義しています:</p>
<dl class="py exception">
<dt class="sig sig-object py" id="pickle.PickleError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">PickleError</span></span><a class="headerlink" href="pickle.html#pickle.PickleError" title="Link to this definition">¶</a></dt>
<dd><p>他の pickle 化例外の共通基底クラス。<a class="reference internal" href="exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> を継承しています。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="pickle.PicklingError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">PicklingError</span></span><a class="headerlink" href="pickle.html#pickle.PicklingError" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="pickle.html#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> が pickle 化不可能なオブジェクトに遭遇したときに送出されるエラー。<a class="reference internal" href="pickle.html#pickle.PickleError" title="pickle.PickleError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PickleError</span></code></a> を継承しています。</p>
<p>どんな種類のオブジェクトが pickle 化できるのか確認するには <a class="reference internal" href="pickle.html#pickle-picklable"><span class="std std-ref">pickle 化、非 pickle 化できるもの</span></a> を参照してください。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="pickle.UnpicklingError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">UnpicklingError</span></span><a class="headerlink" href="pickle.html#pickle.UnpicklingError" title="Link to this definition">¶</a></dt>
<dd><p>データ破損やセキュリティ違反のような、オブジェクトを非 pickle 化するのに問題がある場合に送出されるエラー。<a class="reference internal" href="pickle.html#pickle.PickleError" title="pickle.PickleError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PickleError</span></code></a> を継承します。</p>
<p>非 picke 化の最中に他の例外が送出されることもあるので注意してください。これには AttributeError, EOFError, ImportError, IndexError が含まれます (ただし必ずしもこれらに限定されません)。</p>
</dd></dl>

<p><a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> モジュールでは、3 つのクラス <a class="reference internal" href="pickle.html#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a>, <a class="reference internal" href="pickle.html#pickle.Unpickler" title="pickle.Unpickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unpickler</span></code></a> および <a class="reference internal" href="pickle.html#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> を提供しています:</p>
<dl class="py class">
<dt class="sig sig-object py" id="pickle.Pickler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">Pickler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protocol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_imports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer_callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#pickle.Pickler" title="Link to this definition">¶</a></dt>
<dd><p>pickle 化されたオブジェクトのデータストリームを書き込むためのバイナリファイルを引数にとります。</p>
<p>任意の引数 <em>protocol</em> は、整数で、pickle 化で使用するプロトコルを指定します; サポートされているプロトコルは 0 から <a class="reference internal" href="pickle.html#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code class="xref py py-data docutils literal notranslate"><span class="pre">HIGHEST_PROTOCOL</span></code></a> までになります。指定されない場合、<a class="reference internal" href="pickle.html#pickle.DEFAULT_PROTOCOL" title="pickle.DEFAULT_PROTOCOL"><code class="xref py py-data docutils literal notranslate"><span class="pre">DEFAULT_PROTOCOL</span></code></a> が使用されます。負数が与えられた場合、<a class="reference internal" href="pickle.html#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code class="xref py py-data docutils literal notranslate"><span class="pre">HIGHEST_PROTOCOL</span></code></a> が使用されます。</p>
<p>引数 <em>file</em> は、1 バイトの引数一つを受け付ける write() メソッドを持たなければなりません。すなわち、<em>file</em> には、バイナリの書き込み用にオープンされたファイルオブジェクト、<a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> オブジェクト、このインターフェースに適合するその他のカスタムオブジェクトをとることができます。</p>
<p><em>fix_imports</em> が真であり、かつ、<em>protocol</em> が 3 未満の場合、pickle は新しい Python 3 の名前と Python 2 で使用されていた古いモジュール名との対応付けを試みるので、pickle データストリームは Python 2 でも読み込み可能です。</p>
<p>If <em>buffer_callback</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), buffer views are
serialized into <em>file</em> as part of the pickle stream.</p>
<p>If <em>buffer_callback</em> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, then it can be called any number
of times with a buffer view.  If the callback returns a false value
(such as <code class="docutils literal notranslate"><span class="pre">None</span></code>), the given buffer is <a class="reference internal" href="pickle.html#pickle-oob"><span class="std std-ref">out-of-band</span></a>;
otherwise the buffer is serialized in-band, i.e. inside the pickle stream.</p>
<p>It is an error if <em>buffer_callback</em> is not <code class="docutils literal notranslate"><span class="pre">None</span></code> and <em>protocol</em> is
<code class="docutils literal notranslate"><span class="pre">None</span></code> or smaller than 5.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.8 で変更: </span><em>buffer_callback</em> 引数が追加されました。</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pickle.Pickler.dump">
<span class="sig-name descname"><span class="pre">dump</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#pickle.Pickler.dump" title="Link to this definition">¶</a></dt>
<dd><p><em>obj</em> の pickle 化表現を、コンストラクターで与えられた、すでにオープンしているファイルオブジェクトに書き込みます。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pickle.Pickler.persistent_id">
<span class="sig-name descname"><span class="pre">persistent_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#pickle.Pickler.persistent_id" title="Link to this definition">¶</a></dt>
<dd><p>デフォルトでは何もしません。このメソッドはサブクラスがオーバーライドできるように存在します。</p>
<p><a class="reference internal" href="pickle.html#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_id()</span></code></a> が <code class="docutils literal notranslate"><span class="pre">None</span></code> を返す場合、通常通り <em>obj</em> が pickle 化されます。それ以外の値を返した場合、<a class="reference internal" href="pickle.html#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> がその値を <em>obj</em> のために永続的な ID として出力するようになります。この永続的な ID の意味は <a class="reference internal" href="pickle.html#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Unpickler.persistent_load()</span></code></a> によって定義されています。<a class="reference internal" href="pickle.html#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_id()</span></code></a> によって返された値自身は永続的な ID を持つことができないことに注意してください。</p>
<p>詳細および使用例については <a class="reference internal" href="pickle.html#pickle-persistent"><span class="std std-ref">外部オブジェクトの永続化</span></a> を参照してください。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pickle.Pickler.dispatch_table">
<span class="sig-name descname"><span class="pre">dispatch_table</span></span><a class="headerlink" href="pickle.html#pickle.Pickler.dispatch_table" title="Link to this definition">¶</a></dt>
<dd><p>pickler オブジェクトのディスパッチテーブルは <a class="reference internal" href="copyreg.html#copyreg.pickle" title="copyreg.pickle"><code class="xref py py-func docutils literal notranslate"><span class="pre">copyreg.pickle()</span></code></a> を使用して宣言できる種類の <em>reduction functions</em> のレジストリです。これはキーがクラスでその値が減少関数のマッピング型オブジェクトです。減少関数は関連するクラスの引数を 1 個とり、<a class="reference internal" href="pickle.html#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> メソッドと同じインターフェースでなければなりません。</p>
<p>デフォルトでは、pickler オブジェクトは <a class="reference internal" href="pickle.html#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a> 属性を持たず、代わりに <a class="reference internal" href="copyreg.html#module-copyreg" title="copyreg: Register pickle support functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code></a> モジュールによって管理されるグローバルなディスパッチテーブルを使用します。しかし、特定の pickler オブジェクトによる pickle 化をカスタマイズするために <a class="reference internal" href="pickle.html#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a> 属性に dict-like オブジェクトを設定することができます。あるいは、<a class="reference internal" href="pickle.html#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> のサブクラスが <a class="reference internal" href="pickle.html#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a> 属性を持てば、そのクラスのインスタンスに対するデフォルトのディスパッチテーブルとして使用されます。</p>
<p>使用例については <a class="reference internal" href="pickle.html#pickle-dispatch"><span class="std std-ref">ディスパッチテーブル</span></a> を参照してください。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pickle.Pickler.reducer_override">
<span class="sig-name descname"><span class="pre">reducer_override</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#pickle.Pickler.reducer_override" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="pickle.html#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> のサブクラスで定義可能な特殊なリデューサ (reducer) です。このメソッドは <a class="reference internal" href="pickle.html#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a> 内のいかなるリデューサよりも優先されます。このメソッドは <a class="reference internal" href="pickle.html#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> メソッドのインターフェースと適合していなければなりません。また、メソッドが <a class="reference internal" href="constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> を返すことにより、 <a class="reference internal" href="pickle.html#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a> に登録されたリデューサにフォールバックして <code class="docutils literal notranslate"><span class="pre">obj</span></code> を直列化することもできます。</p>
<p>詳細な例については、 <a class="reference internal" href="pickle.html#reducer-override"><span class="std std-ref">型、関数、その他のオブジェクトに対するリダクションのカスタマイズ</span></a> を参照してください。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pickle.Pickler.fast">
<span class="sig-name descname"><span class="pre">fast</span></span><a class="headerlink" href="pickle.html#pickle.Pickler.fast" title="Link to this definition">¶</a></dt>
<dd><p>廃止予定です。真値が設定されれば高速モードを有効にします。高速モードは、メモの使用を無効にします。それにより余分な PUT 命令コードを生成しなくなるので pickle 化処理が高速化します。自己参照オブジェクトに対しては使用すべきではありません。さもなければ <a class="reference internal" href="pickle.html#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> に無限再帰を起こさせるでしょう。</p>
<p>よりコンパクトな pickle 化を必要とする場合は、<a class="reference internal" href="pickletools.html#pickletools.optimize" title="pickletools.optimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">pickletools.optimize()</span></code></a> を使用してください。</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pickle.Unpickler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">Unpickler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_imports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ASCII'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#pickle.Unpickler" title="Link to this definition">¶</a></dt>
<dd><p>これは pickle データストリームの読み込みのためにバイナリファイルをとります。</p>
<p>pickle のプロトコルバージョンは自動的に検出されます。したがって protocol 引数は必要ありません。</p>
<p>引数 <em>file</em> は <a class="reference internal" href="io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedIOBase</span></code></a> のインターフェースと同様に、整数を引数にとる read() 、バッファを引数にとる readinto() 、引数を取らない readline() の3つのメソッドを持たなければなりません。したがって、 <em>file</em> はバイナリ読み込みモードでオープンされたディスク上のファイル、 <a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> オブジェクト、または上記インターフェース要件を満たす任意のカスタムオブジェクトのいずれかです。</p>
<p>オプション引数 <em>fix_imports</em>, <em>encoding</em> および <em>errors</em> はPython 2で生成された pickle ストリームに対する互換性サポートを制御するために使われます。 <em>fix_imports</em> が真の場合、 pickle は古い Python 2 の名前を Python 3 の新しい名前に対応づけようとします。 <em>encoding</em> と <em>errors</em> は pickle に Python 2 で  pickle 化された 8 ビット文字列をデコードする方法を指定します; これらの引数のデフォルト値はそれぞれ 'ASCII' と 'strict' です。 <em>encoding</em> は 8 ビット文字列インスタンスをバイトオブジェクトとして読み込む場合は 'bytes' を指定します。  Python 2 で pickle 化された NumPy 配列および <a class="reference internal" href="datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a>, <a class="reference internal" href="datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code></a>, <a class="reference internal" href="datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal notranslate"><span class="pre">time</span></code></a> の各インスタンスを非 pickle 化するためには <code class="docutils literal notranslate"><span class="pre">encoding='latin1'</span></code> を使う必要があります。</p>
<p>If <em>buffers</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), then all data necessary for
deserialization must be contained in the pickle stream.  This means
that the <em>buffer_callback</em> argument was <code class="docutils literal notranslate"><span class="pre">None</span></code> when a <a class="reference internal" href="pickle.html#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a>
was instantiated (or when <a class="reference internal" href="pickle.html#pickle.dump" title="pickle.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a> or <a class="reference internal" href="pickle.html#pickle.dumps" title="pickle.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">dumps()</span></code></a> was called).</p>
<p>If <em>buffers</em> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, it should be an iterable of buffer-enabled
objects that is consumed each time the pickle stream references
an <a class="reference internal" href="pickle.html#pickle-oob"><span class="std std-ref">out-of-band</span></a> buffer view.  Such buffers have been
given in order to the <em>buffer_callback</em> of a Pickler object.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.8 で変更: </span><em>buffers</em> 引数が追加されました。</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pickle.Unpickler.load">
<span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#pickle.Unpickler.load" title="Link to this definition">¶</a></dt>
<dd><p>コンストラクターで与えられたオープンしたファイルオブジェクトからオブジェクトの pickle 化表現を読み込み、その中で指定されたオブジェクト階層に再構成して返します。オブジェクトの pickle 化表現より後のバイト列は無視されます。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pickle.Unpickler.persistent_load">
<span class="sig-name descname"><span class="pre">persistent_load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#pickle.Unpickler.persistent_load" title="Link to this definition">¶</a></dt>
<dd><p>デフォルトで <a class="reference internal" href="pickle.html#pickle.UnpicklingError" title="pickle.UnpicklingError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnpicklingError</span></code></a> を送出します。</p>
<p>もし定義されていれば、<a class="reference internal" href="pickle.html#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_load()</span></code></a> は永続的な ID <em>pid</em> によって指定されたオブジェクトを返す必要があります。永続的な ID が無効な場合、<a class="reference internal" href="pickle.html#pickle.UnpicklingError" title="pickle.UnpicklingError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnpicklingError</span></code></a> を送出しなければなりません。</p>
<p>詳細および使用例については <a class="reference internal" href="pickle.html#pickle-persistent"><span class="std std-ref">外部オブジェクトの永続化</span></a> を参照してください。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pickle.Unpickler.find_class">
<span class="sig-name descname"><span class="pre">find_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#pickle.Unpickler.find_class" title="Link to this definition">¶</a></dt>
<dd><p>必要なら <em>module</em> をインポートして、そこから <em>name</em> という名前のオブジェクトを返します。ここで <em>module</em> および <em>name</em> 引数は <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> オブジェクトです。その名前が示唆することに反して <a class="reference internal" href="pickle.html#pickle.Unpickler.find_class" title="pickle.Unpickler.find_class"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_class()</span></code></a> は関数を探すためにも使われることに注意してください。</p>
<p>サブクラスは、どんな型のオブジェクトを、どのようにロードするか (潜在的にはセキュリティリスクの減少) に関する制御を得るためにこれをオーバーライドすることができます。詳細に関しては <a class="reference internal" href="pickle.html#pickle-restrict"><span class="std std-ref">グローバル変数を制限する</span></a> を参照してください。</p>
<p class="audit-hook">引数 <code class="docutils literal notranslate"><span class="pre">modulet</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code> を指定して <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">監査イベント</span></a> <code class="docutils literal notranslate"><span class="pre">pickle.find_class</span></code> を送出します。</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pickle.PickleBuffer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">PickleBuffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#pickle.PickleBuffer" title="Link to this definition">¶</a></dt>
<dd><p>pickle 可能なデータをあらわすバッファのラッパーです。 <em>buffer</em> はバッファライクなオブジェクト (<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>) や N 次元配列のような <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">バッファ機能を提供する</span></a> オブジェクトでなければなりません。</p>
<p><a class="reference internal" href="pickle.html#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> はそれ自身バッファ機能を提供します。したがってこのクラスのインスタンスを、バッファ機能を提供するオブジェクトを期待する <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> など他の API に渡すことが可能です。</p>
<p><a class="reference internal" href="pickle.html#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> オブジェクトはプロトコル 5 以上でのみ直列化可能で、 <a class="reference internal" href="pickle.html#pickle-oob"><span class="std std-ref">アウトオブバウンド (out-of-band) の直列化</span></a> に対応しています。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pickle.PickleBuffer.raw">
<span class="sig-name descname"><span class="pre">raw</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#pickle.PickleBuffer.raw" title="Link to this definition">¶</a></dt>
<dd><p>このバッファの背後にあるメモリ領域への <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> を返します。戻り値のオブジェクトはフォーマット <code class="docutils literal notranslate"><span class="pre">B</span></code> (符号なしバイト) の C-連続な1次元のメモリビューです。バッファが C-連続でも Fortran-連続でもない場合 <a class="reference internal" href="exceptions.html#BufferError" title="BufferError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BufferError</span></code></a> 例外が送出されます。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pickle.PickleBuffer.release">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#pickle.PickleBuffer.release" title="Link to this definition">¶</a></dt>
<dd><p>PickleBuffer オブジェクトを通じてアクセスされる背後のバッファを解放します。</p>
</dd></dl>

</dd></dl>

</section>
<section id="what-can-be-pickled-and-unpickled">
<span id="pickle-picklable"></span><h2>pickle 化、非 pickle 化できるもの<a class="headerlink" href="pickle.html#what-can-be-pickled-and-unpickled" title="Link to this heading">¶</a></h2>
<p>以下の型は pickle 化できます:</p>
<ul class="simple">
<li><p>組み込み定数(<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code>, と <a class="reference internal" href="constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>)</p></li>
<li><p>整数、浮動小数点数、複素数</p></li>
<li><p>文字列、バイト列、バイト配列</p></li>
<li><p>pickle 化可能なオブジェクトからなるタプル、リスト、集合および辞書</p></li>
<li><p>モジュールのトップレベルで定義された関数 (<a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a> で定義されたもののみで <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> で定義されたものは含まない)</p></li>
<li><p>モジュールのトップレベルで定義されているクラス</p></li>
<li><p><a class="reference internal" href="pickle.html#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a> メソッドを呼び出した結果が pickle 化可能であるようなクラスのインスタンス (詳細は <a class="reference internal" href="pickle.html#pickle-inst"><span class="std std-ref">クラスインスタンスの pickle 化</span></a> を参照)。</p></li>
</ul>
<p>pickle 化できないオブジェクトを pickle 化しようとすると、<a class="reference internal" href="pickle.html#pickle.PicklingError" title="pickle.PicklingError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PicklingError</span></code></a> 例外が送出されます。この例外が起きたとき、すでに元のファイルには未知の長さのバイト列が書き込まれている場合があります。極端に再帰的なデータ構造を pickle 化しようとした場合には再帰の深さ制限を越えてしまうかもしれず、この場合には <a class="reference internal" href="exceptions.html#RecursionError" title="RecursionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RecursionError</span></code></a> が送出されます。この制限は、<a class="reference internal" href="sys.html#sys.setrecursionlimit" title="sys.setrecursionlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setrecursionlimit()</span></code></a> で慎重に上げていくことは可能です。</p>
<p>関数 (組込みおよびユーザー定義) は、値ではなく、完全 <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">修飾名</span></a> で pickle 化されます。<a class="footnote-reference brackets" href="pickle.html#id8" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>  これは、関数名のみがそれを含んでいるモジュールおよびクラスの名前をともなって pickle 化されることを意味します。関数のコードやその属性は pickle 化されません。すなわち、非 pickle 化する環境で定義したモジュールがインポート可能な状態になっており、そのモジュール内に関数名のオブジェクトが含まれていなければなりません。この条件を満たさなかった場合は例外が送出されます。<a class="footnote-reference brackets" href="pickle.html#id9" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p>
<p>クラスも同様に完全修飾名で pickle 化されるので、unpickle 化環境には同じ制限が課せられます。クラス中のコードやデータは何も pickle 化されないので、以下の例ではクラス属性 <code class="docutils literal notranslate"><span class="pre">attr</span></code> が unpickle 化環境で復元されないことに注意してください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="n">attr</span> <span class="o">=</span> <span class="s1">&#39;A class attribute&#39;</span>

<span class="n">picklestring</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>
</pre></div>
</div>
<p>pickle 化可能な関数やクラスがモジュールのトップレベルで定義されていなければならないのはこれらの制限のためです。</p>
<p>同様に、クラスのインスタンスが pickle 化された際、そのクラスのコードおよびデータはオブジェクトと一緒に pickle 化されることはありません。インスタンスのデータのみが pickle 化されます。この仕様は、クラス内のバグを修正したりメソッドを追加した後でも、そのクラスの以前のバージョンで作られたオブジェクトを読み出せるように意図的に行われています。あるクラスの多くのバージョンで使われるような長命なオブジェクトを作ろうと計画しているなら、そのクラスの <a class="reference internal" href="pickle.html#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> メソッドによって適切な変換が行われるようにオブジェクトのバージョン番号を入れておくとよいかもしれません。</p>
</section>
<section id="pickling-class-instances">
<span id="pickle-inst"></span><h2>クラスインスタンスの pickle 化<a class="headerlink" href="pickle.html#pickling-class-instances" title="Link to this heading">¶</a></h2>
<p>この節では、クラスインスタンスがどのように pickle 化または非 pickle 化されるのかを定義したり、カスタマイズしたり、コントロールしたりするのに利用可能な一般的機構について説明します。</p>
<p>ほとんどの場合、インスタンスを pickle 化できるようにするために追加のコードは必要ありません。デフォルトで、pickle はインスタンスのクラスと属性を内省によって検索します。クラスインスタンスが非 pickle 化される場合、通常その <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> メソッドは実行 <em>されません</em> 。デフォルトの振る舞いは、最初に初期化されていないインスタンスを作成して、次に保存された属性を復元します。次のコードはこの振る舞いの実装を示しています:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">restore</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attributes</span><span class="p">):</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span>
</pre></div>
</div>
<p>クラスは、いくつかの特殊メソッドを提供することによって、デフォルトの振る舞いを変更することができます:</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__getnewargs_ex__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getnewargs_ex__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#object.__getnewargs_ex__" title="Link to this definition">¶</a></dt>
<dd><p>プロトコル 2 以上の場合、 <a class="reference internal" href="pickle.html#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a> メソッドを実装したクラスは <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> メソッドに渡された値の非 pickle 化の方法を指示することができます。このメソッドは、オブジェクトの生成に必要な位置引数のタプル <em>args</em> と名前付き引数の辞書 <em>kwargs</em> のペア <code class="docutils literal notranslate"><span class="pre">(args,</span> <span class="pre">kwargs)</span></code> を返さなければなりません。これらは非 pickle 化に際して <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> メソッドに渡されます。</p>
<p>クラスの <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> メソッドがキーワード専用引数を求める場合はこのメソッドを実装すべきです。
そうしない場合、互換性のため <a class="reference internal" href="pickle.html#object.__getnewargs__" title="object.__getnewargs__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs__()</span></code></a> メソッドの実装を推奨します。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.6 で変更: </span><a class="reference internal" href="pickle.html#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a> がプロトコル 2 と 3 でも使われるようになりました。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__getnewargs__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getnewargs__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#object.__getnewargs__" title="Link to this definition">¶</a></dt>
<dd><p>このメソッドは <a class="reference internal" href="pickle.html#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a> と同じような機能を提供しますが、位置引数のみをサポートします。このメソッドは引数のタプル <code class="docutils literal notranslate"><span class="pre">args</span></code> を返さなければならず、戻り値は非 pickle 化に際して <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> メソッドに渡されます。</p>
<p><a class="reference internal" href="pickle.html#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a> が定義されていると <a class="reference internal" href="pickle.html#object.__getnewargs__" title="object.__getnewargs__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs__()</span></code></a> は呼び出しません。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.6 で変更: </span>Python 3.6以前のプロトコル 2 と 3 では、<a class="reference internal" href="pickle.html#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a> の代わりに <a class="reference internal" href="pickle.html#object.__getnewargs__" title="object.__getnewargs__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs__()</span></code></a> が呼び出されていました。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__getstate__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getstate__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#object.__getstate__" title="Link to this definition">¶</a></dt>
<dd><p>Classes can further influence how their instances are pickled by overriding
the method <a class="reference internal" href="pickle.html#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a>.  It is called and the returned object
is pickled as the contents for the instance, instead of a default state.
There are several cases:</p>
<ul class="simple">
<li><p>For a class that has no instance <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> and no
<a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>, the default state is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p>For a class that has an instance <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> and no
<a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>, the default state is <code class="docutils literal notranslate"><span class="pre">self.__dict__</span></code>.</p></li>
<li><p>For a class that has an instance <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> and
<a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>, the default state is a tuple consisting of two
dictionaries:  <code class="docutils literal notranslate"><span class="pre">self.__dict__</span></code>, and a dictionary mapping slot
names to slot values.  Only slots that have a value are
included in the latter.</p></li>
<li><p>For a class that has <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> and no instance
<a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>, the default state is a tuple whose first item
is <code class="docutils literal notranslate"><span class="pre">None</span></code> and whose second item is a dictionary mapping slot names
to slot values described in the previous bullet.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.11 で変更: </span>Added the default implementation of the <code class="docutils literal notranslate"><span class="pre">__getstate__()</span></code> method in the
<a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> class.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__setstate__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__setstate__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#object.__setstate__" title="Link to this definition">¶</a></dt>
<dd><p>非 pickle 化に際して、クラスが <a class="reference internal" href="pickle.html#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> を定義している場合、それは非 pickle 化された状態とともに呼び出されます。その場合、状態オブジェクトが辞書でなければならないという要求はありません。そうでなければ、 pickle された状態は辞書で、その要素は新しいインスタンスの辞書に割り当てられます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>If <a class="reference internal" href="pickle.html#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> returns a state with value <code class="docutils literal notranslate"><span class="pre">None</span></code> at pickling,
the <a class="reference internal" href="pickle.html#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> method will not be called upon unpickling.</p>
</div>
</dd></dl>

<p><a class="reference internal" href="pickle.html#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a> および <a class="reference internal" href="pickle.html#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> メソッドの使い方に関する詳細な情報については <a class="reference internal" href="pickle.html#pickle-state"><span class="std std-ref">状態を持つオブジェクトの扱い</span></a> 節を参照してください。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>非 pickle 化に際しては、 <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a>, または <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> といったメソッドがインスタンスに対して呼ばれることがあります。これらのメソッドが何らかの内部の不変な条件が真であることを必要とする場合、その型は <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> メソッドを実装してそのような不変な条件を構築すべきです。なぜならばインスタンスの非 pickle 化においては <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> メソッドは呼ばれないからです。</p>
</div>
<p id="index-5">これらから見るように、pickle は上記のメソッドを直接使用しません。実際には、これらのメソッドは <a class="reference internal" href="pickle.html#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 特殊メソッドを実装するコピープロトコルの一部です。コピープロトコルは、pickle 化とオブジェクトのコピーに必要な、データを取得するための統一されたインターフェースを提供します。 <a class="footnote-reference brackets" href="pickle.html#id10" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p>
<p>強力ですが、クラスに <a class="reference internal" href="pickle.html#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> メソッドを直接実装することはエラーを起こしやすくなります。この理由のため、クラスの設計者は可能なかぎり高レベルインターフェース (<a class="reference internal" href="pickle.html#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a>、<a class="reference internal" href="pickle.html#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a> および <a class="reference internal" href="pickle.html#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a>) を使用するべきです。公開はしているものの、<code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code> の使用は、あくまでオプションとして、より効果的な pickle 化につながる場合、あるいはその両方の場合のみにしてください。</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__reduce__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__reduce__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#object.__reduce__" title="Link to this definition">¶</a></dt>
<dd><p>このインターフェースは現在、以下のように定義されています。 <a class="reference internal" href="pickle.html#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> メソッドは引数を取らず、文字列あるいは (こちらの方が好まれますが) タプルのいずれかを返すべきです (返されたオブジェクトは、しばしば &quot;reduce value&quot; と呼ばれます)。</p>
<p>文字列が返された場合、その文字列はグローバル変数の名前として解釈されます。それはオブジェクトのモジュールから見たローカル名であるべきです; pickle モジュールは、オブジェクトのモジュールを決定するためにモジュールの名前空間を検索します。この振る舞いは、典型的にシングルトンで便利です。</p>
<p>タプルが返された場合、それは 2〜6 要素長でなければなりません。オプションのアイテムは省略することができます。あるいはそれらの値として <code class="docutils literal notranslate"><span class="pre">None</span></code> を渡すことができます。各要素の意味は順に:</p>
<ul>
<li><p>オブジェクトの初期バージョンを作成するために呼ばれる呼び出し可能オブジェクト。</p></li>
<li><p>呼出し可能オブジェクトに対する引数のタプル。呼出し可能オブジェクトが引数を受け取らない場合、空のタプルが与えられなければなりません。</p></li>
<li><p>任意で、前述のオブジェクトの <a class="reference internal" href="pickle.html#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> メソッドに渡されるオブジェクトの状態。オブジェクトがそのようなメソッドを持たない場合、値は辞書でなければならず、それはオブジェクトの <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性に追加されます。</p></li>
<li><p>任意で、連続した要素を yield する (シーケンスではなく) イテレーター。これらの要素は <code class="docutils literal notranslate"><span class="pre">obj.append(item)</span></code> を使用して、あるいはバッチでは <code class="docutils literal notranslate"><span class="pre">obj.extend(list_of_items)</span></code> を使用して、オブジェクトに追加されます。これは主としてリストのサブクラスに対して使用されますが、適切なシグネチャを持つ <a class="reference internal" href="stdtypes.html#typesseq-common"><span class="std std-ref">append と extend メソッド</span></a>  があるかぎり、他のクラスで使用することもできます。 (<code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code> または <code class="xref py py-meth docutils literal notranslate"><span class="pre">extend()</span></code> のどちらが使用されるかは、どの pickle プロトコルバージョンが使われるかに加えて追加されるアイテムの数にも依存します。したがって、両方をサポートする必要があります)</p></li>
<li><p>任意で、連続する key-value ペアを yield する (シーケンスでなく) イテレーター。これらの要素は <code class="docutils literal notranslate"><span class="pre">obj[key]</span> <span class="pre">=</span> <span class="pre">value</span></code> を使用して、オブジェクトに格納されます。これは主として辞書のサブクラスに対して使用されますが、<a class="reference internal" href="../reference/datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a> を実装しているかぎり他のクラスで使用することもできます。</p></li>
<li><p>任意で、シグネチャが <code class="docutils literal notranslate"><span class="pre">(obj,</span> <span class="pre">state)</span></code> である呼び出し可能オブジェクト。このオブジェクトは、 <code class="docutils literal notranslate"><span class="pre">obj</span></code> のスタティックな <a class="reference internal" href="pickle.html#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> メソッドの代わりに、ユーザーがオブジェクトの状態を更新する方法をプログラム的に制御することを許します。 <code class="docutils literal notranslate"><span class="pre">None</span></code> 以外の場合、この呼び出し可能オブジェクトは <code class="docutils literal notranslate"><span class="pre">obj</span></code> の <a class="reference internal" href="pickle.html#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> メソッドに優先します。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8: </span>任意の6番目のタプル要素 <code class="docutils literal notranslate"><span class="pre">(obj,</span> <span class="pre">state)</span></code> が追加されました。</p>
</div>
</li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__reduce_ex__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__reduce_ex__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="pickle.html#object.__reduce_ex__" title="Link to this definition">¶</a></dt>
<dd><p>別の方法として、<a class="reference internal" href="pickle.html#object.__reduce_ex__" title="object.__reduce_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce_ex__()</span></code></a> メソッドを定義することもできます。唯一の違いは、このメソッドは単一の整数引数、プロトコルバージョンを取る必要があるということです。もし定義された場合、pickle は <a class="reference internal" href="pickle.html#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> メソッドよりもこのメソッドを優先します。さらに、<a class="reference internal" href="pickle.html#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> は自動的に拡張版の同義語になります。このメソッドの主な用途は、古い Python リリースに対して後方互換性のある reduce value を提供することです。</p>
</dd></dl>

<section id="persistence-of-external-objects">
<span id="pickle-persistent"></span><h3>外部オブジェクトの永続化<a class="headerlink" href="pickle.html#persistence-of-external-objects" title="Link to this heading">¶</a></h3>
<p id="index-6">オブジェクトの永続化のために、<a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> モジュールは、pickle データストリーム外のオブジェクトに対する参照の概念をサポートしています。そのようなオブジェクトは永続的 ID によって参照されます。それは、英数文字の文字列 (プロトコル 0 に対して) <a class="footnote-reference brackets" href="pickle.html#id11" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> あるいは単に任意のオブジェクト (より新しい任意のプロトコルに対して) のいずれかです。</p>
<p>そのような永続的 ID の分解能は <a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> モジュールでは定義されていません; これはこの分解能を pickler および unpickler のそれぞれ <a class="reference internal" href="pickle.html#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_id()</span></code></a> および <a class="reference internal" href="pickle.html#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_load()</span></code></a> 上でのユーザー定義メソッドに移譲します。</p>
<p>外部の永続的 ID を持つ pickle オブジェクトの pickler は、引数にオブジェクトを取り、<code class="docutils literal notranslate"><span class="pre">None</span></code> かオブジェクトの永続的 ID を返すカスタム <a class="reference internal" href="pickle.html#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_id()</span></code></a> メソッドを持たなくてはなりません。<code class="docutils literal notranslate"><span class="pre">None</span></code> を返す場合、pickler は通常通りマーカーとともにオブジェクトを pickle 化するため、unpickler はそれを永続的 ID として認識します。</p>
<p>外部オブジェクトを非 pickle 化するには、unpickler は永続的 ID オブジェクトを取り被参照オブジェクトを返すカスタム <a class="reference internal" href="pickle.html#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_load()</span></code></a> メソッドを持たなくてはなりません。</p>
<p>これは、外部のオブジェクトを参照によって pickle 化するために永続的 ID をどのように使用するかを示す包括的な例です。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Simple example presenting how persistent ID can be used to pickle</span>
<span class="c1"># external objects by reference.</span>

<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="c1"># Simple class representing a record in our database.</span>
<span class="n">MemoRecord</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;MemoRecord&quot;</span><span class="p">,</span> <span class="s2">&quot;key, task&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DBPickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Pickler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">persistent_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="c1"># Instead of pickling MemoRecord as a regular class instance, we emit a</span>
        <span class="c1"># persistent ID.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">MemoRecord</span><span class="p">):</span>
            <span class="c1"># Here, our persistent ID is simply a tuple, containing a tag and a</span>
            <span class="c1"># key, which refers to a specific record in the database.</span>
            <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;MemoRecord&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If obj does not have a persistent ID, return None. This means obj</span>
            <span class="c1"># needs to be pickled as usual.</span>
            <span class="k">return</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">DBUnpickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Unpickler</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="n">connection</span>

    <span class="k">def</span> <span class="nf">persistent_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pid</span><span class="p">):</span>
        <span class="c1"># This method is invoked whenever a persistent ID is encountered.</span>
        <span class="c1"># Here, pid is the tuple returned by DBPickler.</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        <span class="n">type_tag</span><span class="p">,</span> <span class="n">key_id</span> <span class="o">=</span> <span class="n">pid</span>
        <span class="k">if</span> <span class="n">type_tag</span> <span class="o">==</span> <span class="s2">&quot;MemoRecord&quot;</span><span class="p">:</span>
            <span class="c1"># Fetch the referenced record from the database and return it.</span>
            <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM memos WHERE key=?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key_id</span><span class="p">),))</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">task</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">MemoRecord</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Always raises an error if you cannot return the correct object.</span>
            <span class="c1"># Otherwise, the unpickler will think None is the object referenced</span>
            <span class="c1"># by the persistent ID.</span>
            <span class="k">raise</span> <span class="n">pickle</span><span class="o">.</span><span class="n">UnpicklingError</span><span class="p">(</span><span class="s2">&quot;unsupported persistent object&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">io</span>
    <span class="kn">import</span> <span class="nn">pprint</span>

    <span class="c1"># Initialize and populate our database.</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE memos(key INTEGER PRIMARY KEY, task TEXT)&quot;</span><span class="p">)</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;give food to fish&#39;</span><span class="p">,</span>
        <span class="s1">&#39;prepare group meeting&#39;</span><span class="p">,</span>
        <span class="s1">&#39;fight with a zebra&#39;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
        <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;INSERT INTO memos VALUES(NULL, ?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">task</span><span class="p">,))</span>

    <span class="c1"># Fetch the records to be pickled.</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM memos&quot;</span><span class="p">)</span>
    <span class="n">memos</span> <span class="o">=</span> <span class="p">[</span><span class="n">MemoRecord</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">]</span>
    <span class="c1"># Save the records using our custom DBPickler.</span>
    <span class="n">file</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
    <span class="n">DBPickler</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">memos</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Pickled records:&quot;</span><span class="p">)</span>
    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">memos</span><span class="p">)</span>

    <span class="c1"># Update a record, just for good measure.</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;UPDATE memos SET task=&#39;learn italian&#39; WHERE key=1&quot;</span><span class="p">)</span>

    <span class="c1"># Load the records from the pickle data stream.</span>
    <span class="n">file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">memos</span> <span class="o">=</span> <span class="n">DBUnpickler</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unpickled records:&quot;</span><span class="p">)</span>
    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">memos</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="dispatch-tables">
<span id="pickle-dispatch"></span><h3>ディスパッチテーブル<a class="headerlink" href="pickle.html#dispatch-tables" title="Link to this heading">¶</a></h3>
<p>pickle 化に依存する他のコードの邪魔をせずに、一部のクラスの pickle 化だけをカスタマイズしたい場合、プライベートのディスパッチテーブルを持つ pickler を作成することができます。</p>
<p><a class="reference internal" href="copyreg.html#module-copyreg" title="copyreg: Register pickle support functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code></a> モジュールによって管理されるグローバルなディスパッチテーブルは <code class="xref py py-data docutils literal notranslate"><span class="pre">copyreg.dispatch_table</span></code> として利用可能です。したがって、<code class="xref py py-data docutils literal notranslate"><span class="pre">copyreg.dispatch_table</span></code> の修正済のコピーをプライベートのディスパッチテーブルとして使用することを選択できます。</p>
<p>例えば</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">Pickler</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">dispatch_table</span> <span class="o">=</span> <span class="n">copyreg</span><span class="o">.</span><span class="n">dispatch_table</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">p</span><span class="o">.</span><span class="n">dispatch_table</span><span class="p">[</span><span class="n">SomeClass</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_SomeClass</span>
</pre></div>
</div>
<p>これは <code class="docutils literal notranslate"><span class="pre">SomeClass</span></code> クラスを特別に扱うプライベートのディスパッチテーブルを持つ <a class="reference internal" href="pickle.html#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">pickle.Pickler</span></code></a> のインスタンスを作成します。あるいは、次のコード</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyPickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Pickler</span><span class="p">):</span>
    <span class="n">dispatch_table</span> <span class="o">=</span> <span class="n">copyreg</span><span class="o">.</span><span class="n">dispatch_table</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">dispatch_table</span><span class="p">[</span><span class="n">SomeClass</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_SomeClass</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">MyPickler</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>does the same but all instances of <code class="docutils literal notranslate"><span class="pre">MyPickler</span></code> will by default
share the private dispatch table.  On the other hand, the code</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">copyreg</span><span class="o">.</span><span class="n">pickle</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="n">reduce_SomeClass</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">Pickler</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>modifies the global dispatch table shared by all users of the <a class="reference internal" href="copyreg.html#module-copyreg" title="copyreg: Register pickle support functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code></a> module.</p>
</section>
<section id="handling-stateful-objects">
<span id="pickle-state"></span><h3>状態を持つオブジェクトの扱い<a class="headerlink" href="pickle.html#handling-stateful-objects" title="Link to this heading">¶</a></h3>
<p id="index-7">Here's an example that shows how to modify pickling behavior for a class.
The <code class="xref py py-class docutils literal notranslate"><span class="pre">TextReader</span></code> class below opens a text file, and returns the line number and
line contents each time its <code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code> method is called. If a
<code class="xref py py-class docutils literal notranslate"><span class="pre">TextReader</span></code> instance is pickled, all attributes <em>except</em> the file object
member are saved. When the instance is unpickled, the file is reopened, and
reading resumes from the last location. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code> methods are used to implement this behavior.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TextReader</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Print and number lines in a text file.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineno</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineno</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%i</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Copy the object&#39;s state from self.__dict__ which contains</span>
        <span class="c1"># all our instance attributes. Always use the dict.copy()</span>
        <span class="c1"># method to avoid modifying the original state.</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Remove the unpicklable entries.</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># Restore instance attributes (i.e., filename and lineno).</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="c1"># Restore the previously opened file&#39;s state. To do so, we need to</span>
        <span class="c1"># reopen it and read from it until the line count is restored.</span>
        <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lineno</span><span class="p">):</span>
            <span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="c1"># Finally, save the file.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span>
</pre></div>
</div>
<p>使用例は以下のようになるでしょう:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span> <span class="o">=</span> <span class="n">TextReader</span><span class="p">(</span><span class="s2">&quot;hello.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;1: Hello world!&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;2: I am line number two.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_reader</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">reader</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;3: Goodbye!&#39;</span>
</pre></div>
</div>
</section>
</section>
<section id="custom-reduction-for-types-functions-and-other-objects">
<span id="reducer-override"></span><h2>型、関数、その他のオブジェクトに対するリダクションのカスタマイズ<a class="headerlink" href="pickle.html#custom-reduction-for-types-functions-and-other-objects" title="Link to this heading">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<p><a class="reference internal" href="pickle.html#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a> は、ときにその柔軟性が十分でないがことあります。特に、オブジェクトの型以外の別の条件で pickle 化をカスタマイズしたい場合や、関数やクラスを使って pickle 化をカスタマイズしたい場合などです。</p>
<p>そのような場合、 <a class="reference internal" href="pickle.html#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> クラスから派生したサブクラスで <a class="reference internal" href="pickle.html#pickle.Pickler.reducer_override" title="pickle.Pickler.reducer_override"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reducer_override()</span></code></a> メソッドを実装することができます。このメソッドは任意のリダクション用タプルを返すことができます  (<a class="reference internal" href="pickle.html#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> を参照してください)。もしくは、従来の振る舞いにフォールバックするために <a class="reference internal" href="constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> を返すこともできます。</p>
<p><a class="reference internal" href="pickle.html#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a> と <a class="reference internal" href="pickle.html#pickle.Pickler.reducer_override" title="pickle.Pickler.reducer_override"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reducer_override()</span></code></a> の両方が定義されている場合、 <a class="reference internal" href="pickle.html#pickle.Pickler.reducer_override" title="pickle.Pickler.reducer_override"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reducer_override()</span></code></a> メソッドが優先されます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>パフォーマンス上の理由により、次に挙げるオブジェクトに対しては <a class="reference internal" href="pickle.html#pickle.Pickler.reducer_override" title="pickle.Pickler.reducer_override"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reducer_override()</span></code></a> が呼ばれないことがあります: <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code>, および <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>, <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> の厳密なインスタンス。</p>
</div>
<p>以下は特定のクラスを pickle 化して再構成する単純な例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="n">my_attribute</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">class</span> <span class="nc">MyPickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Pickler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">reducer_override</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Custom reducer for MyClass.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;MyClass&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">,</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">,</span>
                          <span class="p">{</span><span class="s1">&#39;my_attribute&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">my_attribute</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For any other object, fallback to usual reduction</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">MyPickler</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span>

<span class="k">del</span> <span class="n">MyClass</span>

<span class="n">unpickled_class</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>

<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unpickled_class</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">unpickled_class</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;MyClass&quot;</span>
<span class="k">assert</span> <span class="n">unpickled_class</span><span class="o">.</span><span class="n">my_attribute</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
</section>
<section id="out-of-band-buffers">
<span id="pickle-oob"></span><h2>アウトオブバウンドバッファ<a class="headerlink" href="pickle.html#out-of-band-buffers" title="Link to this heading">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<p>ある状況では、 <a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> モジュールは大量のデータを転送するために使われます。 そのため、メモリのコピーを最小限に抑えてパフォーマンスとリソースの消費を良好な状態に保つことが重要になることがあります。 しかし、オブジェクトのグラフ的構造をシーケンシャルなバイトストリームに変換する <a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> モジュールの通常の処理は、本質的に pickle ストリームへの、または pickle ストリームからのデータのコピーを伴います。</p>
<p>この制約は、生産者 <em>provider</em> (変換されるオブジェクトの型の実装) と消費者 <em>consumer</em> (通信システムの実装) が pickle プロトコル5以上で提供されるアウトオブバウンドのデータ転送機能をサポートしていれば回避できます。</p>
<section id="provider-api">
<h3>生産者 API<a class="headerlink" href="pickle.html#provider-api" title="Link to this heading">¶</a></h3>
<p>pickle 化される大きなサイズのデータオブジェクトは、プロトコル5以上でサポートされた <a class="reference internal" href="pickle.html#object.__reduce_ex__" title="object.__reduce_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce_ex__()</span></code></a> メソッドを実装しなければなりません。このメソッドは大きなデータに対して (<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> オブジェクトなどの代わりに) <a class="reference internal" href="pickle.html#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> インスタンスを返します。</p>
<p><a class="reference internal" href="pickle.html#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> オブジェクトは背後にあるバッファがアウトオブバウンドのデータ転送に適合していることを <em>知らせます</em> 。これらのオブジェクトは <a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> モジュールの通常の使い方との互換性を保っています。しかし、消費者側で <a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> モジュールに対してそれらのバッファを自身で処理することを事前に知らせることもできます。</p>
</section>
<section id="consumer-api">
<h3>消費者 API<a class="headerlink" href="pickle.html#consumer-api" title="Link to this heading">¶</a></h3>
<p>通信システムは、オブジェクトグラフを直列化するときに生成された <a class="reference internal" href="pickle.html#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> オブジェクトのカスタマイズされた処理を有効化することができます。</p>
<p>送信側は <em>buffer_callback</em> 引数を <a class="reference internal" href="pickle.html#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> (または <a class="reference internal" href="pickle.html#pickle.dump" title="pickle.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a> や <a class="reference internal" href="pickle.html#pickle.dumps" title="pickle.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">dumps()</span></code></a> 関数) に渡す必要があります。この関数はオブジェクトグラフを pickle 化するときに生成されるそれぞれの <a class="reference internal" href="pickle.html#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> を引数として呼ばれます。 <em>buffer_callback</em> によって蓄積されたバッファは、それが保持するデータのコピーを pickle ストリームに送らず、軽量なマーカーが挿入されるだけです。</p>
<p>受信側は <em>buffers</em> 引数を <a class="reference internal" href="pickle.html#pickle.Unpickler" title="pickle.Unpickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unpickler</span></code></a> (または <a class="reference internal" href="pickle.html#pickle.load" title="pickle.load"><code class="xref py py-func docutils literal notranslate"><span class="pre">load()</span></code></a> や <a class="reference internal" href="pickle.html#pickle.loads" title="pickle.loads"><code class="xref py py-func docutils literal notranslate"><span class="pre">loads()</span></code></a> 関数) に渡す必要があります。これは <em>buffer_callback</em> に渡されたバッファのイテラブルです。このイテラブルは  <em>buffer_callback</em> に渡されたのと同じ順番でバッファを返さなければなりません。これらのバッファは、pickle 化処理によって <a class="reference internal" href="pickle.html#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> オブジェクトを生成したオブジェクトの再構築処理で期待されるデータを提供します。</p>
<p>送信側と受信側の間で、通信システムはアウトオブバウンドバッファの独自の転送メカニズムを自由に実装することができます。見込みのある最適化としては、共有メモリの利用や、データタイプ依存のデータ圧縮などが考えられます。</p>
</section>
<section id="example">
<h3>使用例<a class="headerlink" href="pickle.html#example" title="Link to this heading">¶</a></h3>
<p>以下は、アウトオブバウンドのバッファを使った pickle 処理に関与することができるサブクラス <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> を実装したささいな例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ZeroCopyByteArray</span><span class="p">(</span><span class="nb">bytearray</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__reduce_ex__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protocol</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">protocol</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_reconstruct</span><span class="p">,</span> <span class="p">(</span><span class="n">PickleBuffer</span><span class="p">(</span><span class="bp">self</span><span class="p">),),</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># PickleBuffer is forbidden with pickle protocols &lt;= 4.</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_reconstruct</span><span class="p">,</span> <span class="p">(</span><span class="nb">bytearray</span><span class="p">(</span><span class="bp">self</span><span class="p">),)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_reconstruct</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
            <span class="c1"># Get a handle over the original buffer object</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">obj</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">cls</span><span class="p">:</span>
                <span class="c1"># Original buffer object is a ZeroCopyByteArray, return it</span>
                <span class="c1"># as-is.</span>
                <span class="k">return</span> <span class="n">obj</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<p>再構成関数 (<code class="docutils literal notranslate"><span class="pre">_reconstruct</span></code> クラスメソッド) は、受け取ったバッファが持っているオブジェクトを、それが正しい型であれば、そのまま返します。これは、このおもちゃのような例において、ゼロコピーの挙動を模擬的に行う簡単な方法です。</p>
<p>消費者側では、これらのオブジェクトを通常の方法で pickle 化することができます。この場合非直列化処理は元のオブジェクトのコピーを返します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">ZeroCopyByteArray</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">new_b</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">new_b</span><span class="p">)</span>  <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span> <span class="ow">is</span> <span class="n">new_b</span><span class="p">)</span>  <span class="c1"># False: a copy was made</span>
</pre></div>
</div>
<p>いっぽう直列化において <em>buffer_callback</em> を設定し、非直列化において蓄積されたバッファを渡した場合、コピーではなく元のオブジェクトを得ることができます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">ZeroCopyByteArray</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="n">buffers</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">buffer_callback</span><span class="o">=</span><span class="n">buffers</span><span class="o">.</span><span class="n">append</span><span class="p">)</span>
<span class="n">new_b</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">buffers</span><span class="o">=</span><span class="n">buffers</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">new_b</span><span class="p">)</span>  <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span> <span class="ow">is</span> <span class="n">new_b</span><span class="p">)</span>  <span class="c1"># True: no copy was made</span>
</pre></div>
</div>
<p>この例では <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> がそれ自身メモリを割り当てるという性質による制限があります: すなわち、他のオブジェクトのメモリを参照する <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> を生成することはできません。しかし、 NumPy 配列のようなサードパーティのデータ型ではそのような制限はなく、異なるプロセス間または異なるシステム間で、ゼロコピー (または最小限のコピー) でのpickle 処理の利用が可能です。</p>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><span class="target" id="index-17"></span><a class="pep reference external" href="https://peps.python.org/pep-0574/"><strong>PEP 574</strong></a> -- Pickle プロトコルバージョン 5 による帯域外データ</p>
</div>
</section>
</section>
<section id="restricting-globals">
<span id="pickle-restrict"></span><h2>グローバル変数を制限する<a class="headerlink" href="pickle.html#restricting-globals" title="Link to this heading">¶</a></h2>
<p id="index-9">デフォルトで、非 pickle 化は pickle データ内で見つけたあらゆるクラスや関数をインポートします。多くのアプリケーションでは、この振る舞いは受け入れられません。なぜなら、それによって unpickler が任意のコードをインポートして実行することが可能になるからです。この手の巧妙に作られた pickle データストリームがロードされたときに何を行うかをちょっと考えてみてください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;cos</span><span class="se">\n</span><span class="s2">system</span><span class="se">\n</span><span class="s2">(S&#39;echo hello world&#39;</span><span class="se">\n</span><span class="s2">tR.&quot;</span><span class="p">)</span>
<span class="go">hello world</span>
<span class="go">0</span>
</pre></div>
</div>
<p>この例において、unpickler は <a class="reference internal" href="os.html#os.system" title="os.system"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.system()</span></code></a> 関数をインポートして、次に文字列の引数 &quot;echo hello world&quot; を適用しています。この例は無害ですが、システムを破壊する例を想像するのは難しくありません。</p>
<p>この理由のため、<a class="reference internal" href="pickle.html#pickle.Unpickler.find_class" title="pickle.Unpickler.find_class"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Unpickler.find_class()</span></code></a> をカスタマイズすることで非 pickle 化で何を得るかを制御したくなるかもしれません。その名前が示唆するのと異なり、<a class="reference internal" href="pickle.html#pickle.Unpickler.find_class" title="pickle.Unpickler.find_class"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Unpickler.find_class()</span></code></a> はグローバル (クラスや関数) が必要とした時にはいつでも呼びだされます。したがって、グローバルを完全に禁止することも安全なサブセットに制限することも可能です。</p>
<p>これは、一部の安全なクラスについてのみ <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> モジュールからロードすることを許可する unpickler の例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">builtins</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="n">safe_builtins</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;range&#39;</span><span class="p">,</span>
    <span class="s1">&#39;complex&#39;</span><span class="p">,</span>
    <span class="s1">&#39;set&#39;</span><span class="p">,</span>
    <span class="s1">&#39;frozenset&#39;</span><span class="p">,</span>
    <span class="s1">&#39;slice&#39;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">RestrictedUnpickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Unpickler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">find_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># Only allow safe classes from builtins.</span>
        <span class="k">if</span> <span class="n">module</span> <span class="o">==</span> <span class="s2">&quot;builtins&quot;</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">safe_builtins</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">builtins</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="c1"># Forbid everything else.</span>
        <span class="k">raise</span> <span class="n">pickle</span><span class="o">.</span><span class="n">UnpicklingError</span><span class="p">(</span><span class="s2">&quot;global &#39;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&#39; is forbidden&quot;</span> <span class="o">%</span>
                                     <span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">restricted_loads</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">RestrictedUnpickler</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
</pre></div>
</div>
<p>この unpickler が働く使用例は次のように意図されます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">restricted_loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">)]))</span>
<span class="go">[1, 2, range(0, 15)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">restricted_loads</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;cos</span><span class="se">\n</span><span class="s2">system</span><span class="se">\n</span><span class="s2">(S&#39;echo hello world&#39;</span><span class="se">\n</span><span class="s2">tR.&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">pickle.UnpicklingError</span>: <span class="n">global &#39;os.system&#39; is forbidden</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">restricted_loads</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;cbuiltins</span><span class="se">\n</span><span class="s1">eval</span><span class="se">\n</span><span class="s1">&#39;</span>
<span class="gp">... </span>                 <span class="sa">b</span><span class="s1">&#39;(S</span><span class="se">\&#39;</span><span class="s1">getattr(__import__(&quot;os&quot;), &quot;system&quot;)&#39;</span>
<span class="gp">... </span>                 <span class="sa">b</span><span class="s1">&#39;(&quot;echo hello world&quot;)</span><span class="se">\&#39;\n</span><span class="s1">tR.&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">pickle.UnpicklingError</span>: <span class="n">global &#39;builtins.eval&#39; is forbidden</span>
</pre></div>
</div>
<p>この例が示すように、非 pickle 化を認めるものに注意しなければなりません。したがって、セキュリティが重要な場合は <a class="reference internal" href="xmlrpc.client.html#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpc.client</span></code></a> の marshal API や、サードパーティのソリューションのような別の選択肢を考慮した方がよいでしょう。</p>
</section>
<section id="performance">
<h2>性能<a class="headerlink" href="pickle.html#performance" title="Link to this heading">¶</a></h2>
<p>pickle プロトコルの最近のバージョン (プロトコル 2 以降) は一部の一般的な機能と組み込みデータ型を効率的にバイナリにエンコードするよう考慮されています。また、<a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> モジュールは C 言語で書かれた透過的オプティマイザーを持っています。</p>
</section>
<section id="examples">
<span id="pickle-example"></span><h2>使用例<a class="headerlink" href="pickle.html#examples" title="Link to this heading">¶</a></h2>
<p>最も単純なコードでは、<a class="reference internal" href="pickle.html#pickle.dump" title="pickle.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a> および <a class="reference internal" href="pickle.html#pickle.load" title="pickle.load"><code class="xref py py-func docutils literal notranslate"><span class="pre">load()</span></code></a> 関数を使用してください。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>

<span class="c1"># An arbitrary collection of objects supported by pickle.</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="n">j</span><span class="p">],</span>
    <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;character string&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;byte string&quot;</span><span class="p">),</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.pickle&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="c1"># Pickle the &#39;data&#39; dictionary using the highest protocol available.</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
</pre></div>
</div>
<p>次の例は、pickle 化されたデータを読み込みます。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.pickle&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="c1"># The protocol version used is detected automatically, so we do not</span>
    <span class="c1"># have to specify it.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<dl class="simple">
<dt><a class="reference internal" href="copyreg.html#module-copyreg" title="copyreg: Register pickle support functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code></a> モジュール</dt><dd><p>拡張型を登録するための Pickle インターフェース構成機構。</p>
</dd>
<dt><a class="reference internal" href="pickletools.html#module-pickletools" title="pickletools: Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickletools</span></code></a> モジュール</dt><dd><p>pickle データの処理や分析を行うためのツール。</p>
</dd>
<dt><a class="reference internal" href="shelve.html#module-shelve" title="shelve: Python object persistence."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shelve</span></code></a> モジュール</dt><dd><p>オブジェクトのインデクス付きデータベース; <a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> を使います。</p>
</dd>
<dt><a class="reference internal" href="copy.html#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copy</span></code></a> モジュール</dt><dd><p>オブジェクトの浅いコピーおよび深いコピー。</p>
</dd>
<dt><a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> モジュール</dt><dd><p>組み込み型の高性能な直列化。</p>
</dd>
</dl>
</div>
<p class="rubric">脚注</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="pickle.html#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> モジュールと間違えないように注意してください。</p>
</aside>
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="pickle.html#id3">2</a><span class="fn-bracket">]</span></span>
<p>なぜ <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 関数を pickle 化できないかというと、すべての <code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code> 関数は同じ名前: <code class="docutils literal notranslate"><span class="pre">&lt;lambda&gt;</span></code> を共有しているからです。</p>
</aside>
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="pickle.html#id4">3</a><span class="fn-bracket">]</span></span>
<p>送出される例外は <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> や <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> になるはずですが、他の例外も起こりえます。</p>
</aside>
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="pickle.html#id5">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference internal" href="copy.html#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copy</span></code></a> モジュールは、浅いコピーと深いコピーの操作にこのプロトコルを使用します。</p>
</aside>
<aside class="footnote brackets" id="id11" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="pickle.html#id6">5</a><span class="fn-bracket">]</span></span>
<p>英数文字に関する制限は、プロトコル 0 では永続的な ID が改行文字によって区切られるという事実によります。そのため、永続的な ID に何らかの改行文字が含まれると、結果として生じる pickle 化されたデータは判読不能になります。</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="pickle.html#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code> --- Python オブジェクトの直列化</a><ul>
<li><a class="reference internal" href="pickle.html#relationship-to-other-python-modules">他の Python モジュールとの関係</a><ul>
<li><a class="reference internal" href="pickle.html#comparison-with-marshal"><code class="docutils literal notranslate"><span class="pre">marshal</span></code> との比較</a></li>
<li><a class="reference internal" href="pickle.html#comparison-with-json"><code class="docutils literal notranslate"><span class="pre">json</span></code> との比較</a></li>
</ul>
</li>
<li><a class="reference internal" href="pickle.html#data-stream-format">データストリームの形式</a></li>
<li><a class="reference internal" href="pickle.html#module-interface">モジュールインターフェース</a></li>
<li><a class="reference internal" href="pickle.html#what-can-be-pickled-and-unpickled">pickle 化、非 pickle 化できるもの</a></li>
<li><a class="reference internal" href="pickle.html#pickling-class-instances">クラスインスタンスの pickle 化</a><ul>
<li><a class="reference internal" href="pickle.html#persistence-of-external-objects">外部オブジェクトの永続化</a></li>
<li><a class="reference internal" href="pickle.html#dispatch-tables">ディスパッチテーブル</a></li>
<li><a class="reference internal" href="pickle.html#handling-stateful-objects">状態を持つオブジェクトの扱い</a></li>
</ul>
</li>
<li><a class="reference internal" href="pickle.html#custom-reduction-for-types-functions-and-other-objects">型、関数、その他のオブジェクトに対するリダクションのカスタマイズ</a></li>
<li><a class="reference internal" href="pickle.html#out-of-band-buffers">アウトオブバウンドバッファ</a><ul>
<li><a class="reference internal" href="pickle.html#provider-api">生産者 API</a></li>
<li><a class="reference internal" href="pickle.html#consumer-api">消費者 API</a></li>
<li><a class="reference internal" href="pickle.html#example">使用例</a></li>
</ul>
</li>
<li><a class="reference internal" href="pickle.html#restricting-globals">グローバル変数を制限する</a></li>
<li><a class="reference internal" href="pickle.html#performance">性能</a></li>
<li><a class="reference internal" href="pickle.html#examples">使用例</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="persistence.html"
                          title="前の章へ">データの永続化</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="copyreg.html"
                          title="次の章へ"><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code> --- <code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code> サポート関数を登録する</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/pickle.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="サイドバーをたたむ">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="copyreg.html" title="copyreg --- pickle サポート関数を登録する"
             >次へ</a> |</li>
        <li class="right" >
          <a href="persistence.html" title="データの永続化"
             >前へ</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="persistence.html" >データの永続化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="pickle.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code> --- Python オブジェクトの直列化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" id="search-box" />
          <input type="submit" value="検索" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    Copyright
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="../../../license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最終更新: Jun 11, 2024 (04:44 UTC)
    
      <a href="../../../bugs.html">Found a bug</a>?
    
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>

    <script type="text/javascript" src="../_static/switchers.js"></script>
  </body>
</html>