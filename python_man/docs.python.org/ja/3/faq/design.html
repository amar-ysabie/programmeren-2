<!DOCTYPE html>

<html lang="ja" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="デザインと歴史 FAQ" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/faq/design.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="目次: デザインと歴史 FAQ- Python はなぜ文のグループ化にインデントを使うのですか？, なぜ単純な算術演算が奇妙な結果になるのですか？, なぜ浮動小数点数の計算はこんなに不正確なんですか？, なぜ Python の文字列はイミュータブルなのですか？, なぜメソッドの定義や呼び出しにおいて 'self' を明示しなければならないのですか？, 式中で代入ができないのはなぜですか？, ..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="目次: デザインと歴史 FAQ- Python はなぜ文のグループ化にインデントを使うのですか？, なぜ単純な算術演算が奇妙な結果になるのですか？, なぜ浮動小数点数の計算はこんなに不正確なんですか？, なぜ Python の文字列はイミュータブルなのですか？, なぜメソッドの定義や呼び出しにおいて 'self' を明示しなければならないのですか？, 式中で代入ができないのはなぜですか？, ..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>デザインと歴史 FAQ &#8212; Python 3.12.4 ドキュメント</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css%3Fv=80d5e7a1.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css%3Fv=bb723527.css" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css%3Fv=b20cc3f5.css" />
    
    <script src="../_static/documentation_options.js%3Fv=7e11ab17"></script>
    <script src="../_static/doctools.js%3Fv=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js%3Fv=dc90522c"></script>
    <script src="../_static/translations.js%3Fv=4dbe4bdc"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.12.4 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="ライブラリと拡張 FAQ" href="library.html" />
    <link rel="prev" title="プログラミング FAQ" href="programming.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="../../../3/faq/design.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" />
                <input type="submit" value="検索"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="design.html#">デザインと歴史 FAQ</a><ul>
<li><a class="reference internal" href="design.html#why-does-python-use-indentation-for-grouping-of-statements">Python はなぜ文のグループ化にインデントを使うのですか？</a></li>
<li><a class="reference internal" href="design.html#why-am-i-getting-strange-results-with-simple-arithmetic-operations">なぜ単純な算術演算が奇妙な結果になるのですか？</a></li>
<li><a class="reference internal" href="design.html#why-are-floating-point-calculations-so-inaccurate">なぜ浮動小数点数の計算はこんなに不正確なんですか？</a></li>
<li><a class="reference internal" href="design.html#why-are-python-strings-immutable">なぜ Python の文字列はイミュータブルなのですか？</a></li>
<li><a class="reference internal" href="design.html#why-must-self-be-used-explicitly-in-method-definitions-and-calls">なぜメソッドの定義や呼び出しにおいて 'self' を明示しなければならないのですか？</a></li>
<li><a class="reference internal" href="design.html#why-can-t-i-use-an-assignment-in-an-expression">式中で代入ができないのはなぜですか？</a></li>
<li><a class="reference internal" href="design.html#why-does-python-use-methods-for-some-functionality-e-g-list-index-but-functions-for-other-e-g-len-list">Python にメソッドを使う機能 (list.index() 等) と関数を使う機能 (len(list) 等) があるのはなぜですか？</a></li>
<li><a class="reference internal" href="design.html#why-is-join-a-string-method-instead-of-a-list-or-tuple-method">join() がリストやタプルのメソッドではなく文字列のメソッドなのはなぜですか？</a></li>
<li><a class="reference internal" href="design.html#how-fast-are-exceptions">例外はどれくらい速いのですか？</a></li>
<li><a class="reference internal" href="design.html#why-isn-t-there-a-switch-or-case-statement-in-python">Python に switch や case 文がないのはなぜですか？</a></li>
<li><a class="reference internal" href="design.html#can-t-you-emulate-threads-in-the-interpreter-instead-of-relying-on-an-os-specific-thread-implementation">OS 特有のスレッド実装に依らずにインタプリタでスレッドをエミュレートすることはできないのですか？</a></li>
<li><a class="reference internal" href="design.html#why-can-t-lambda-expressions-contain-statements">なぜラムダ式は文を含むことができないのですか?</a></li>
<li><a class="reference internal" href="design.html#can-python-be-compiled-to-machine-code-c-or-some-other-language">Python は C やその他の言語のように機械語にコンパイルできますか？</a></li>
<li><a class="reference internal" href="design.html#how-does-python-manage-memory">Python はメモリをどのように管理するのですか？</a></li>
<li><a class="reference internal" href="design.html#why-doesn-t-cpython-use-a-more-traditional-garbage-collection-scheme">CPython はなぜ伝統的なガベージコレクションスキームを使わないのですか？</a></li>
<li><a class="reference internal" href="design.html#why-isn-t-all-memory-freed-when-cpython-exits">なぜ CPython の終了時にすべてのメモリが解放されるわけではないのですか？</a></li>
<li><a class="reference internal" href="design.html#why-are-there-separate-tuple-and-list-data-types">なぜタプルとリストという別のデータ型が用意されているのですか？</a></li>
<li><a class="reference internal" href="design.html#how-are-lists-implemented-in-cpython">CPythonでリストはどのように実装されているのですか？</a></li>
<li><a class="reference internal" href="design.html#how-are-dictionaries-implemented-in-cpython">CPythonで辞書はどのように実装されていますか？</a></li>
<li><a class="reference internal" href="design.html#why-must-dictionary-keys-be-immutable">なぜ辞書のキーはイミュータブルでなくてはならないのですか？</a></li>
<li><a class="reference internal" href="design.html#why-doesn-t-list-sort-return-the-sorted-list">なぜ list.sort() はソートされたリストを返さないのですか？</a></li>
<li><a class="reference internal" href="design.html#how-do-you-specify-and-enforce-an-interface-spec-in-python">Python ではどのようにインターフェース仕様を特定し適用するのですか？</a></li>
<li><a class="reference internal" href="design.html#why-is-there-no-goto">なぜ goto が無いのですか？</a></li>
<li><a class="reference internal" href="design.html#why-can-t-raw-strings-r-strings-end-with-a-backslash">なぜ raw 文字列 (r-strings) はバックスラッシュで終わってはいけないのですか？</a></li>
<li><a class="reference internal" href="design.html#why-doesn-t-python-have-a-with-statement-for-attribute-assignments">属性の代入に &quot;with&quot; 文が使えないのはなぜですか？</a></li>
<li><a class="reference internal" href="design.html#why-don-t-generators-support-the-with-statement">なぜジェネレータは with 文をサポートしないのですか？</a></li>
<li><a class="reference internal" href="design.html#why-are-colons-required-for-the-if-while-def-class-statements">if/while/def/class 文にコロンが必要なのはなぜですか？</a></li>
<li><a class="reference internal" href="design.html#why-does-python-allow-commas-at-the-end-of-lists-and-tuples">なぜ Python ではリストやタプルの最後にカンマがあっても良いのですか？</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="programming.html"
                          title="前の章へ">プログラミング FAQ</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="library.html"
                          title="次の章へ">ライブラリと拡張 FAQ</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/faq/design.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="library.html" title="ライブラリと拡張 FAQ"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="programming.html" title="プログラミング FAQ"
             accesskey="P">前へ</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python よくある質問</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="design.html">デザインと歴史 FAQ</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" id="search-box" />
          <input type="submit" value="検索" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="design-and-history-faq">
<h1><a class="toc-backref" href="design.html#id3" role="doc-backlink">デザインと歴史 FAQ</a><a class="headerlink" href="design.html#design-and-history-faq" title="Link to this heading">¶</a></h1>
<nav class="contents" id="id1">
<p class="topic-title">目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="design.html#design-and-history-faq" id="id3">デザインと歴史 FAQ</a></p>
<ul>
<li><p><a class="reference internal" href="design.html#why-does-python-use-indentation-for-grouping-of-statements" id="id4">Python はなぜ文のグループ化にインデントを使うのですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-am-i-getting-strange-results-with-simple-arithmetic-operations" id="id5">なぜ単純な算術演算が奇妙な結果になるのですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-are-floating-point-calculations-so-inaccurate" id="id6">なぜ浮動小数点数の計算はこんなに不正確なんですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-are-python-strings-immutable" id="id7">なぜ Python の文字列はイミュータブルなのですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-must-self-be-used-explicitly-in-method-definitions-and-calls" id="id8">なぜメソッドの定義や呼び出しにおいて 'self' を明示しなければならないのですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-can-t-i-use-an-assignment-in-an-expression" id="id9">式中で代入ができないのはなぜですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-does-python-use-methods-for-some-functionality-e-g-list-index-but-functions-for-other-e-g-len-list" id="id10">Python にメソッドを使う機能 (list.index() 等) と関数を使う機能 (len(list) 等) があるのはなぜですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-is-join-a-string-method-instead-of-a-list-or-tuple-method" id="id11">join() がリストやタプルのメソッドではなく文字列のメソッドなのはなぜですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#how-fast-are-exceptions" id="id12">例外はどれくらい速いのですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-isn-t-there-a-switch-or-case-statement-in-python" id="id13">Python に switch や case 文がないのはなぜですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#can-t-you-emulate-threads-in-the-interpreter-instead-of-relying-on-an-os-specific-thread-implementation" id="id14">OS 特有のスレッド実装に依らずにインタプリタでスレッドをエミュレートすることはできないのですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-can-t-lambda-expressions-contain-statements" id="id15">なぜラムダ式は文を含むことができないのですか?</a></p></li>
<li><p><a class="reference internal" href="design.html#can-python-be-compiled-to-machine-code-c-or-some-other-language" id="id16">Python は C やその他の言語のように機械語にコンパイルできますか？</a></p></li>
<li><p><a class="reference internal" href="design.html#how-does-python-manage-memory" id="id17">Python はメモリをどのように管理するのですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-doesn-t-cpython-use-a-more-traditional-garbage-collection-scheme" id="id18">CPython はなぜ伝統的なガベージコレクションスキームを使わないのですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-isn-t-all-memory-freed-when-cpython-exits" id="id19">なぜ CPython の終了時にすべてのメモリが解放されるわけではないのですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-are-there-separate-tuple-and-list-data-types" id="id20">なぜタプルとリストという別のデータ型が用意されているのですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#how-are-lists-implemented-in-cpython" id="id21">CPythonでリストはどのように実装されているのですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#how-are-dictionaries-implemented-in-cpython" id="id22">CPythonで辞書はどのように実装されていますか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-must-dictionary-keys-be-immutable" id="id23">なぜ辞書のキーはイミュータブルでなくてはならないのですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-doesn-t-list-sort-return-the-sorted-list" id="id24">なぜ list.sort() はソートされたリストを返さないのですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#how-do-you-specify-and-enforce-an-interface-spec-in-python" id="id25">Python ではどのようにインターフェース仕様を特定し適用するのですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-is-there-no-goto" id="id26">なぜ goto が無いのですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-can-t-raw-strings-r-strings-end-with-a-backslash" id="id27">なぜ raw 文字列 (r-strings) はバックスラッシュで終わってはいけないのですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-doesn-t-python-have-a-with-statement-for-attribute-assignments" id="id28">属性の代入に &quot;with&quot; 文が使えないのはなぜですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-don-t-generators-support-the-with-statement" id="id29">なぜジェネレータは with 文をサポートしないのですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-are-colons-required-for-the-if-while-def-class-statements" id="id30">if/while/def/class 文にコロンが必要なのはなぜですか？</a></p></li>
<li><p><a class="reference internal" href="design.html#why-does-python-allow-commas-at-the-end-of-lists-and-tuples" id="id31">なぜ Python ではリストやタプルの最後にカンマがあっても良いのですか？</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="why-does-python-use-indentation-for-grouping-of-statements">
<h2><a class="toc-backref" href="design.html#id4" role="doc-backlink">Python はなぜ文のグループ化にインデントを使うのですか？</a><a class="headerlink" href="design.html#why-does-python-use-indentation-for-grouping-of-statements" title="Link to this heading">¶</a></h2>
<p>Guido van Rossum の信じるところによれば、インデントによるグループ化は非常にエレガントで、普通の Python プログラムを大いに読みやすくします。しばらくすればほとんどの人はこの仕様を気に入るようになります。</p>
<p>開始/終了の括弧がないので、構文解析器と人間の読者の間にグループ化の解釈の違いは起こりえません。時折、C のプログラマはこのようなコード片に出くわします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">x</span><span class="o">++</span><span class="p">;</span>
        <span class="n">y</span><span class="o">--</span><span class="p">;</span>
<span class="n">z</span><span class="o">++</span><span class="p">;</span>
</pre></div>
</div>
<p>条件式が真のとき、 <code class="docutils literal notranslate"><span class="pre">x++</span></code> 行のみが実行されます。しかしインデントによって、多くの人が別のことを考えてしまいます。経験豊富なCプログラマでさえ、 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> なのに <code class="docutils literal notranslate"><span class="pre">y</span></code> がデクリメントされるのはなぜだろうと、このコードをしばらく凝視することがあります。</p>
<p>Python は開始/終了の括弧がないので、コーディングスタイルの争いに余り影響されません。C言語では中括弧の置き方についてさまざまな流儀があります。特定のスタイルを使ってコードを読み書きするのに慣れたあと、別のスタイルでコードを読んだり(あるいは書く必要に迫られたり)するときに、何となく心配になるのはよくあることです。</p>
<p>多くのコーディングスタイルは begin/end の括弧にそれぞれ一行を使います。これではプログラムは冗長になって画面を浪費し、プログラムの見通しが悪くなります。一つの関数は一画面 (例えば 20 から 30 行) に収めるのが理想です。20 行の Python は 20 行の C よりもはるかに多くの作業ができます。これは begin/end の括弧がないからだけではありません -- 宣言が不要なことや高レベルなデータ型もその理由です -- が、インデントに基づく構文は確かに役に立っています。</p>
</section>
<section id="why-am-i-getting-strange-results-with-simple-arithmetic-operations">
<h2><a class="toc-backref" href="design.html#id5" role="doc-backlink">なぜ単純な算術演算が奇妙な結果になるのですか？</a><a class="headerlink" href="design.html#why-am-i-getting-strange-results-with-simple-arithmetic-operations" title="Link to this heading">¶</a></h2>
<p>次の質問を参照してください。</p>
</section>
<section id="why-are-floating-point-calculations-so-inaccurate">
<h2><a class="toc-backref" href="design.html#id6" role="doc-backlink">なぜ浮動小数点数の計算はこんなに不正確なんですか？</a><a class="headerlink" href="design.html#why-are-floating-point-calculations-so-inaccurate" title="Link to this heading">¶</a></h2>
<p>ユーザーはよく次のような結果に驚きます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">1.2</span> <span class="o">-</span> <span class="mf">1.0</span>
<span class="go">0.19999999999999996</span>
</pre></div>
</div>
<p>そしてこれが Python のバグだと考えます。が、これはバグではありません。この結果に Python はほとんど関与しておらず、むしろ基底のプラットフォームによる浮動小数点数の扱い方が関与しています。</p>
<p>CPython における <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 型は記憶に C 言語の <code class="docutils literal notranslate"><span class="pre">double</span></code> 型を使います。 <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> オブジェクトの値は固定精度 (典型的には 53 bit) の 2 進浮動小数点数として格納され、 Python はプロセッサのハードウェアが実装している C 言語上の演算を使います。つまり、浮動小数点数に関して Python は C 言語や Java のような多くの一般的な言語と同じように振る舞います。</p>
<p>10 進数で簡単に書ける多くの数が、2 進浮動小数点数では正確に表すことができません。例えばこうすると:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mf">1.2</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">x</span></code> に保存された値は 10 進数の <code class="docutils literal notranslate"><span class="pre">1.2</span></code> の (とても高い精度の) 近似値であって、厳密な <code class="docutils literal notranslate"><span class="pre">1.2</span></code> ではありません。一般的なコンピューターでは、実際に格納される値は:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="mf">1.0011001100110011001100110011001100110011001100110011</span> <span class="p">(</span><span class="n">binary</span><span class="p">)</span>
</pre></div>
</div>
<p>で、正確には次の値です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="mf">1.1999999999999999555910790149937383830547332763671875</span> <span class="p">(</span><span class="n">decimal</span><span class="p">)</span>
</pre></div>
</div>
<p>53bit の典型的な精度は、Python の float に 10 進数で 15〜16桁の精度を与えます。</p>
<p>詳しくは、Python チュートリアルの <a class="reference internal" href="../tutorial/floatingpoint.html#tut-fp-issues"><span class="std std-ref">floating point arithmetic</span></a> の章を参照してください。</p>
</section>
<section id="why-are-python-strings-immutable">
<h2><a class="toc-backref" href="design.html#id7" role="doc-backlink">なぜ Python の文字列はイミュータブルなのですか？</a><a class="headerlink" href="design.html#why-are-python-strings-immutable" title="Link to this heading">¶</a></h2>
<p>これにはいくつかの利点があります。</p>
<p>一つはパフォーマンスです。文字列がイミュータブルなら、生成時に領域を割り当てることができるので、必要な記憶域は固定されて、変更されません。これはタプルとリストを区別する理由の一つでもあります。</p>
<p>他の利点は、Python の文字列は数と同じくらい &quot;基本的&quot; なものと考えられることです。8 という値を他の何かに変える手段が無いように、文字列 &quot;eight&quot; を他の何かに変える手段も無いのです。</p>
</section>
<section id="why-must-self-be-used-explicitly-in-method-definitions-and-calls">
<span id="why-self"></span><h2><a class="toc-backref" href="design.html#id8" role="doc-backlink">なぜメソッドの定義や呼び出しにおいて 'self' を明示しなければならないのですか？</a><a class="headerlink" href="design.html#why-must-self-be-used-explicitly-in-method-definitions-and-calls" title="Link to this heading">¶</a></h2>
<p>このアイデアは Modula-3 から取り入れられました。これは様々な理由からとても便利だと言えます。</p>
<p>まず、ローカル変数ではなく、メソッドやインスタンス属性を扱っていることがより明確になります。 <code class="docutils literal notranslate"><span class="pre">self.x</span></code> や <code class="docutils literal notranslate"><span class="pre">self.meth()</span></code> と書いてあれば、そのクラスの定義を憶えていなくても、それがインスタンス変数やメソッドであることは明らかです。C++ では、(グローバルが滅多になかったり、簡単に見分けがつくなら) ローカル変数宣言がないことからある程度わかるでしょう。-- しかし Python にはローカル変数宣言がないので、クラス定義を調べて確かめなくてはなりません。C++ や Java のコーディングスタンダードに、インスタンス属性に <code class="docutils literal notranslate"><span class="pre">m_</span></code> 接頭辞をつけるものがあるので、この明示性はそれらの言語においても有用です。</p>
<p>第二に、特定のクラスからメソッドを明示的に参照または呼び出ししたい時に、特別な構文が必要なくなります。C++ では、派生クラスでオーバーライドされた基底クラスからメソッドを使うには、 <code class="docutils literal notranslate"><span class="pre">::</span></code> 演算子を使わなければなりません。 -- Python では、 <code class="docutils literal notranslate"><span class="pre">baseclass.methodname(self,</span> <span class="pre">&lt;argument</span> <span class="pre">list&gt;)</span></code> と書けます。これは特に、 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> メソッドに便利ですし、派生クラスのメソッドが、基底クラスにある同じ名前のメソッドを拡張するために、基底クラスのメソッドをどうにかして呼び出したい時にも便利です。</p>
<p>最後に、インスタンス変数に対する、代入の構文の問題を解決できます。Python のローカル変数は、関数の中で (global が明示的に宣言されることなく) 値が代入された変数 (と定義されています！) です。なので、ある代入が意図するのが、ローカル変数へではなくインスタンス変数への代入であると、インタプリタが判断する手段が必要です。そしてそれは構文を見るだけで分かる方が (効率が) 良いのです。C++ ではその区別を宣言時に行いますが、Python では宣言がないので、この方法でしか区別できなかったら残念です。 <code class="docutils literal notranslate"><span class="pre">self.var</span></code> を明示すればうまく解決できます。同様に、インスタンス変数を使うのにも <code class="docutils literal notranslate"><span class="pre">self.var</span></code> と書かなければならないので、メソッドの中の self が付いていない名前への参照は、そのインスタンスのディレクトリを検索するまでもなくローカル変数とわかります。別の言い方をすれば、ローカル変数とインスタンス変数は二つの異なる名前空間に存在し、Python にどちらの名前空間を使うかを伝えなくてはならないのです。</p>
</section>
<section id="why-can-t-i-use-an-assignment-in-an-expression">
<span id="id2"></span><h2><a class="toc-backref" href="design.html#id9" role="doc-backlink">式中で代入ができないのはなぜですか？</a><a class="headerlink" href="design.html#why-can-t-i-use-an-assignment-in-an-expression" title="Link to this heading">¶</a></h2>
<p>Python 3.8 以降ならできるよ!</p>
<p>セイウチ演算子 <code class="docutils literal notranslate"><span class="pre">:=</span></code> を使った代入式は、式の中で変数に代入します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">chunk</span> <span class="o">:=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">200</span><span class="p">):</span>
   <span class="nb">print</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
</pre></div>
</div>
<p>より詳しくは <span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0572/"><strong>PEP 572</strong></a> を参照してください。</p>
</section>
<section id="why-does-python-use-methods-for-some-functionality-e-g-list-index-but-functions-for-other-e-g-len-list">
<h2><a class="toc-backref" href="design.html#id10" role="doc-backlink">Python にメソッドを使う機能 (list.index() 等) と関数を使う機能 (len(list) 等) があるのはなぜですか？</a><a class="headerlink" href="design.html#why-does-python-use-methods-for-some-functionality-e-g-list-index-but-functions-for-other-e-g-len-list" title="Link to this heading">¶</a></h2>
<p>Guidoいわく：</p>
<blockquote>
<div><p>(a) 幾つかの演算では、接頭辞は接尾辞よりも単純に読みやすいからです。接頭辞（そして接中辞！）による演算は数学において長い歴史があり、そこでは課題に対する数学者の思考を視覚的に助けるような記法が好まれます。x*(a+b)をx*a + x*bに書き換える容易さと、それと同じことを純粋なオブジェクト指向の記法で行う煩わしさを比較してみてください。</p>
<p>(b) len(x)というコードを読んだ時、私はそれが何かの長さを問うているのだなと知ることができます。これは私に2つの事を知らせています。一つは結果が整数であること、そして引数は何らかのコンテナであることです。対して、x.len()を目にした場合、私はその時点でxが何らかのコンテナであり、それが標準のlen()を持っているクラスを継承しているか、インターフェースを実装していることを知っている必要があります。mappingを実装していないクラスがget()やkeys()メソッドを持っていたり、fileでない何かがwrite()メソッドを持っているような混乱は時折見かけます。</p>
<p class="attribution">—<a class="reference external" href="https://mail.python.org/pipermail/python-3000/2006-November/004643.html">https://mail.python.org/pipermail/python-3000/2006-November/004643.html</a></p>
</div></blockquote>
</section>
<section id="why-is-join-a-string-method-instead-of-a-list-or-tuple-method">
<h2><a class="toc-backref" href="design.html#id11" role="doc-backlink">join() がリストやタプルのメソッドではなく文字列のメソッドなのはなぜですか？</a><a class="headerlink" href="design.html#why-is-join-a-string-method-instead-of-a-list-or-tuple-method" title="Link to this heading">¶</a></h2>
<p>文字列は Python 1.6 から他の標準型に大きく近づきました。それ以前は常に string モジュールの関数を使ってできていたことと同等の機能を持つメソッドがこの時に追加されました。その新しいメソッドの多くは広く受け入れられましたが、一部のプログラマに不快を感じさせていると思われるものがこれで:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">,</span> <span class="s1">&#39;8&#39;</span><span class="p">,</span> <span class="s1">&#39;16&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>結果はこうなります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;1, 2, 4, 8, 16&quot;</span>
</pre></div>
</div>
<p>この使い方には二つの議論があります。</p>
<p>一つ目は、「文字列リテラル (文字列定数) のメソッドを使うのは醜すぎる」というようなものです。確かにそうかも知れませんが、文字列リテラルは単なる固定された値に過ぎないというのが答えです。文字列に束縛された名前にメソッドが許されるなら、リテラルに使えないようにする論理的な理由はないでしょう。</p>
<p>二つ目の反対理由は、典型的には「私は実際、要素を文字列定数とともに結合させるよう、シーケンスに命じているのだ」というものです。残念ながら、そうではないのです。いくつかの理由から <a class="reference internal" href="../library/stdtypes.html#str.split" title="str.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> を文字列のメソッドとしておいた方がはるかに簡単です。これを見ると分かりやすいでしょう</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;1, 2, 4, 8, 16&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>これは文字列リテラルに対する、与えられたセパレータ (または、デフォルトでは任意の空白文字の連続) で区切られた部分文字列を返せという指示です。</p>
<p><a class="reference internal" href="../library/stdtypes.html#str.join" title="str.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a> は、セパレータ文字列に、文字列のシーケンスをイテレートして隣り合う要素の間に自身を挿入するように指示しているので、文字列のメソッドです。このメソッドは、独自に定義された新しいクラスを含め、シーケンスの規則を満たすいかなる引数にも使えます。バイト列やバイト配列にも同様のメソッドがあります。</p>
</section>
<section id="how-fast-are-exceptions">
<h2><a class="toc-backref" href="design.html#id12" role="doc-backlink">例外はどれくらい速いのですか？</a><a class="headerlink" href="design.html#how-fast-are-exceptions" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>/<a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> ブロックは例外が送出されなければ極端に効率的です。実際に例外を捕捉するのは高価です。Python 2.0 より前のバージョンでは、このイディオムを使うのが一般的でした:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
    <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">getvalue</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</pre></div>
</div>
<p>これは、辞書がほとんどの場合にキーを持っていると予想できるときにのみ意味をなします。そうでなければ、このように書きます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mydict</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">getvalue</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
<p>この特殊な場合では <code class="docutils literal notranslate"><span class="pre">value</span> <span class="pre">=</span> <span class="pre">dict.setdefault(key,</span> <span class="pre">getvalue(key))</span></code> も使えますが、これは <code class="docutils literal notranslate"><span class="pre">getvalue()</span></code> 呼び出しが十分安価な場合に限ります。なぜならそれが全ての場合に評価されるからです。</p>
</section>
<section id="why-isn-t-there-a-switch-or-case-statement-in-python">
<h2><a class="toc-backref" href="design.html#id13" role="doc-backlink">Python に switch や case 文がないのはなぜですか？</a><a class="headerlink" href="design.html#why-isn-t-there-a-switch-or-case-statement-in-python" title="Link to this heading">¶</a></h2>
<p>一般的に、構造化された switch 文は、式が特定の値または値の集合を持つとき、１つのコードブロックを実行します。 Python 3.10 以降では、リテラル値や名前空間内の定数を、 <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">...</span> <span class="pre">case</span></code> 文で簡単にマッチさせることができます。より古い手段は一連の <code class="docutils literal notranslate"><span class="pre">if...</span> <span class="pre">elif...</span> <span class="pre">elif...</span> <span class="pre">else</span></code> です。</p>
<p>非常に大きな数の選択肢から選ぶとき、値を呼び出す関数に対応づける辞書を作れます。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">functions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">function_1</span><span class="p">,</span>
             <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="n">function_2</span><span class="p">,</span>
             <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">method_1</span><span class="p">}</span>

<span class="n">func</span> <span class="o">=</span> <span class="n">functions</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
<span class="n">func</span><span class="p">()</span>
</pre></div>
</div>
<p>オブジェクトのメソッドを呼び出すには、さらに単純に <a class="reference internal" href="../library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 組み込み関数で特定の名前のメソッドを検索できます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyVisitor</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">visit_a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="s1">&#39;visit_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)</span>
        <span class="n">method</span><span class="p">()</span>
</pre></div>
</div>
<p>メソッドの名前にこの例の <code class="docutils literal notranslate"><span class="pre">visit_</span></code> のような接頭辞を使うことを勧めます。このような接頭辞がないと、信頼できないソースから値が与えられたときに、オブジェクトの任意のメソッドを呼び出す攻撃をされる可能性があります。</p>
<p>C の switch-case-default のような、フォールスルーのある switch を模倣することもできますが、はるかに難しいうえに必要性も少ないでしょう。</p>
</section>
<section id="can-t-you-emulate-threads-in-the-interpreter-instead-of-relying-on-an-os-specific-thread-implementation">
<h2><a class="toc-backref" href="design.html#id14" role="doc-backlink">OS 特有のスレッド実装に依らずにインタプリタでスレッドをエミュレートすることはできないのですか？</a><a class="headerlink" href="design.html#can-t-you-emulate-threads-in-the-interpreter-instead-of-relying-on-an-os-specific-thread-implementation" title="Link to this heading">¶</a></h2>
<p>答 1: 残念なことに、インタプリタは Python のスタックフレームごとに少なくとも一つの C のスタックフレームを push します。同様に、拡張もほとんどランダムなときに Python にコールバックすることがあります。よって、完全なスレッド実装には C のスレッドサポートが必要です。</p>
<p>答 2: 幸運なことに、<a class="reference external" href="https://github.com/stackless-dev/stackless/wiki">Stackless Python</a> があります。これは完全に再デザインされたインタープリタで、Cのスタックを回避しています。</p>
</section>
<section id="why-can-t-lambda-expressions-contain-statements">
<h2><a class="toc-backref" href="design.html#id15" role="doc-backlink">なぜラムダ式は文を含むことができないのですか?</a><a class="headerlink" href="design.html#why-can-t-lambda-expressions-contain-statements" title="Link to this heading">¶</a></h2>
<p>Python のラムダ式が文を含むことができないのは、Python の文法的な枠組みが式の中にネストされた文を扱うことができないからです。しかし、Python では、これは深刻な問題ではありません。他の言語のラムダに機能が追加されているのと違い、Python のラムダは単なる、関数を定義するのが面倒すぎる場合のための簡略な記法に過ぎないのです。</p>
<p>関数は既に Python の第一級オブジェクトで、ローカルスコープ内で宣言できます。従って、ローカルで定義された関数ではなくラムダを使う利点は、関数の名前を考える必要が無いことだけです -- しかし、(ラムダ式が生み出すオブジェクトと厳密に同じ型の) 関数オブジェクトが代入される先はただのローカル変数です！</p>
</section>
<section id="can-python-be-compiled-to-machine-code-c-or-some-other-language">
<h2><a class="toc-backref" href="design.html#id16" role="doc-backlink">Python は C やその他の言語のように機械語にコンパイルできますか？</a><a class="headerlink" href="design.html#can-python-be-compiled-to-machine-code-c-or-some-other-language" title="Link to this heading">¶</a></h2>
<p><a class="reference external" href="https://cython.org/">Cython</a> は オプションのアノテーション付きのPythonの修正版を C拡張へ変換します。<a class="reference external" href="https://www.nuitka.net/">Nuitka</a> はPythonをC++コードへ変換する将来有望なPythonコンパイラで、完全なPython言語をサポートすることを目的としています。</p>
</section>
<section id="how-does-python-manage-memory">
<h2><a class="toc-backref" href="design.html#id17" role="doc-backlink">Python はメモリをどのように管理するのですか？</a><a class="headerlink" href="design.html#how-does-python-manage-memory" title="Link to this heading">¶</a></h2>
<p>Python のメモリ管理の詳細は実装に依ります。Python の標準の C 実装 <a class="reference internal" href="../glossary.html#term-CPython"><span class="xref std std-term">CPython</span></a> は参照カウントを使って、アクセスできないオブジェクトを探します。また別のメカニズムを使って参照サイクルを集めます。これはサイクル検出アルゴリズムを定期的に実行し、アクセスできないサイクルを探し、巻き込まれたオブジェクトを削除します。 <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> モジュールの関数で、ガベージコレクションを実行し、デバッグ統計を取得し、コレクタのパラメタを変更できます。</p>
<p>ただし、他の実装 (例えば <a class="reference external" href="https://www.jython.org">Jython</a> や <a class="reference external" href="https://www.pypy.org">PyPy</a>) は本格的 (full-blown) なガベージコレクタのような別のメカニズムに依存するかもしれません。あなたの Python コードが参照カウントの実装の振る舞いに依存する場合、この違いが微妙な移植上の問題を引き起こすでしょう。</p>
<p>Python の実装によっては、以下の (CPython では通る) コードはおそらく、ファイルディスクリプタを使い果たすでしょう:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">very_long_list_of_files</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>実際、CPython の参照カウントとデストラクタのスキームを使えば <code class="docutils literal notranslate"><span class="pre">f</span></code> への新しい代入ごとにファイルは閉じられます。しかし、伝統的な GC を使うと、これらのファイルオブジェクトが回収され (て閉じられる) までに不定な、場合によっては長い、間隔が空くことがあります。</p>
<p>Python の実装に依らずに動くコードを書くには、ファイルを明示的に閉じるか、 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 文を使ってください。これでメモリ管理のスキームに関係なく動きます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">very_long_list_of_files</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="why-doesn-t-cpython-use-a-more-traditional-garbage-collection-scheme">
<h2><a class="toc-backref" href="design.html#id18" role="doc-backlink">CPython はなぜ伝統的なガベージコレクションスキームを使わないのですか？</a><a class="headerlink" href="design.html#why-doesn-t-cpython-use-a-more-traditional-garbage-collection-scheme" title="Link to this heading">¶</a></h2>
<p>まず、それは C の標準的な機能ではないのでポータブルではありません。(確かに Boehm GC ライブラリはあります。しかし、これにはアセンブリコードが含まれ、<em>ほとんどの</em> 有名なプラットフォームに対応していますが全てではありません。また、ほとんど透過的ですが、完全に透過的ではありません。Python を対応させるにはパッチが必要です。)</p>
<p>伝統的な GC は Python が他のアプリケーションに組み込まれるときにも問題となります。スタンドアロンの Python で動く限りでは、標準の <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> と <code class="docutils literal notranslate"><span class="pre">free()</span></code> を GC ライブラリから提供されるものに置き換えても問題ありませんが、Python を実装したアプリケーションは Python のものではない <em>独自の</em> 代替品を使おうとするかもしれません。現在のようにすることで、CPython は <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> と <code class="docutils literal notranslate"><span class="pre">free()</span></code> が適切に実装されている限りどんなものにも対応させられます。</p>
</section>
<section id="why-isn-t-all-memory-freed-when-cpython-exits">
<h2><a class="toc-backref" href="design.html#id19" role="doc-backlink">なぜ CPython の終了時にすべてのメモリが解放されるわけではないのですか？</a><a class="headerlink" href="design.html#why-isn-t-all-memory-freed-when-cpython-exits" title="Link to this heading">¶</a></h2>
<p>Python モジュールのグローバルな名前空間から参照されるオブジェクトは、Python の終了時にメモリの割り当てを解除されるとは限りません。これは、循環参照があるときに起こりえます。解放できない C ライブラリ (例えば、Purify のようなツールなどが当てはまります) によって割り当てられたいくらかのメモリも含まれます。しかし、Python は終了時にメモリをクリーンアップすることには積極的で、全ての単一のオブジェクトを破棄しようとします。</p>
<p>再割り当て時に Python が特定のものを削除するように強制したいときは、 <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> モジュールを使って削除を強制する関数を実行してください。</p>
</section>
<section id="why-are-there-separate-tuple-and-list-data-types">
<h2><a class="toc-backref" href="design.html#id20" role="doc-backlink">なぜタプルとリストという別のデータ型が用意されているのですか？</a><a class="headerlink" href="design.html#why-are-there-separate-tuple-and-list-data-types" title="Link to this heading">¶</a></h2>
<p>リストとタプルは、多くの点で似ていますが、一般には本質的に異なる方法で使われます。タプルは、Pascal の <code class="docutils literal notranslate"><span class="pre">レコード</span></code> や C の　<code class="docutils literal notranslate"><span class="pre">構造体</span></code> と同様なものと考えられます。型が異なっても良い関連するデータの小さな集合で、グループとして演算されます。例えば、デカルト座標は 2 つや 3 つの数のタプルとして適切に表せます。</p>
<p>一方、リストは、もっと他の言語の配列に近いものです。全て同じ型の可変数のオブジェクトを持ち、それらが一つ一つ演算される傾向にあります。例えば、 <a class="reference internal" href="../library/os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.listdir('.')</span></code></a> はカレントディレクトリ内にあるファイルの文字列表現のリストを返します。この出力を演算する関数は一般に、ディレクトリに一つや二つの別のファイルを加えても壊れません。</p>
<p>タプルはイミュータブルなので、一度タプルが生成されたら、そのどの要素も新しい値に置き換えられません。リストはミュータブルなので、リストの要素はいつでも変更できます。イミュータブルな要素だけが辞書のキーとして使えるので、リストではなくタプルだけがキーとして使えます。</p>
</section>
<section id="how-are-lists-implemented-in-cpython">
<h2><a class="toc-backref" href="design.html#id21" role="doc-backlink">CPythonでリストはどのように実装されているのですか？</a><a class="headerlink" href="design.html#how-are-lists-implemented-in-cpython" title="Link to this heading">¶</a></h2>
<p>CPythonのリストは実際に変数分の長さの配列で、Lispスタイルの連結リストではありません。この実装は他のオブジェクトへの参照の連続した配列を使用していて、この配列へのポインタおよび配列長はリストの先頭の構造体に保存されています。</p>
<p>これにより、リストのインデクシング <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> は、リストの大きさやインデクスの値に依存しないコストで演算できます。</p>
<p>要素が追加または挿入されるとき、この参照の配列は大きさが変更されます。要素追加の繰り返しのパフォーマンスを上げるために、少し工夫されています。配列が大きくなるとき、次の何回かは実際に大きさを変更する必要がないように、いくらかの追加の領域が割り当てられます。</p>
</section>
<section id="how-are-dictionaries-implemented-in-cpython">
<h2><a class="toc-backref" href="design.html#id22" role="doc-backlink">CPythonで辞書はどのように実装されていますか？</a><a class="headerlink" href="design.html#how-are-dictionaries-implemented-in-cpython" title="Link to this heading">¶</a></h2>
<p>CPython の辞書は大きさを変更できるハッシュテーブルとして実装されています。B 木と比べて、ほとんどの条件下で (特に一般的な演算である) 探索のパフォーマンスが良いですし、実装も単純です。</p>
<p>辞書は、辞書に保存されているそれぞれのキーに対応するハッシュコードを <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> ビルトイン関数で計算することで機能します。このハッシュコードはキーやプロセスごとのシードによって大きく変化します。例えば、 <code class="docutils literal notranslate"><span class="pre">'Python'</span></code> のハッシュ値は <code class="docutils literal notranslate"><span class="pre">-539294296</span></code> ですが、ビットが一つ違うだけの文字列 <code class="docutils literal notranslate"><span class="pre">'python'</span></code> のハッシュ値は <code class="docutils literal notranslate"><span class="pre">1142331976</span></code> です。そしてこのハッシュコードは、値が保存される内部配列での位置を計算するために使われます。保存しているキーのハッシュ値が全て異なるとすれば、一定の時間 − Big-O 記法では <em>O</em>(1) − でキーを検索できることになります。</p>
</section>
<section id="why-must-dictionary-keys-be-immutable">
<h2><a class="toc-backref" href="design.html#id23" role="doc-backlink">なぜ辞書のキーはイミュータブルでなくてはならないのですか？</a><a class="headerlink" href="design.html#why-must-dictionary-keys-be-immutable" title="Link to this heading">¶</a></h2>
<p>辞書のハッシュテーブルの実装は、キーを見つけるために、キー値から計算されたハッシュ値を使います。もしキーがミュータブルなオブジェクトだったら、その値は変えられ、それによりハッシュ値も変わってしまいます。しかし、キーオブジェクトを変更したのが何者であれ、値が辞書のキーとして使われていたと気付けないので、辞書の中のエントリを適切な場所に動かせません。そして、同じオブジェクトを探そうとしても、ハッシュ値が違うため見つかりません。古い値を探そうとしても、そのハッシュバイナリから見つかるオブジェクトの値は異なるでしょうから、これも見つかりません。</p>
<p>リストでインデクシングされた辞書が必要なら、まず単純にリストをタプルに変換してください。関数 <code class="docutils literal notranslate"><span class="pre">tuple(L)</span></code> は、リスト <code class="docutils literal notranslate"><span class="pre">L</span></code> と同じエントリのタプルを生成します。タプルはイミュータブルなので、辞書のキーとして使えます。</p>
<p>いくつかの受け入れられなかった提案:</p>
<ul>
<li><p>アドレス (オブジェクト ID) のハッシュリスト。これは、同じ値の新しいリストを作っても見つからないので駄目です。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">mydict</span> <span class="o">=</span> <span class="p">{[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span> <span class="s1">&#39;12&#39;</span><span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mydict</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2]</span></code> の2行目のidは1行目のそれと異なってしまうために <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> 例外を送出するでしょう。言い換えれば、辞書のキーは <code class="docutils literal notranslate"><span class="pre">==</span></code> を使って比較されるべきであり、 <a class="reference internal" href="../reference/expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> ではないということです。</p>
</li>
<li><p>リストをキーとして使うときにコピーを作る。リストはミュータブルなので、自分自身への参照を含むことができ、コードをコピーするときに無限ループにハマる可能性があるので、これは駄目です。</p></li>
<li><p>リストをキーとして使うことを認めるが、ユーザにそれを変更させないように伝える。もしユーザが忘れたり、偶然にリストが変更されてしまったりしたら、追跡困難なバグの可能性を生じてしまいます。またこれは、 <code class="docutils literal notranslate"><span class="pre">d.keys()</span></code> のすべての値は辞書のキーとして使えるという、辞書の重要な不変性も潰してしまいます。</p></li>
<li><p>リストが一旦辞書のキーとして使われたら、読み出し専用のマークを付ける。問題は、値を変えられるのはトップレベルオブジェクトだけではないことです。リストを含むタプルもキーとして使えます。全てを辞書のキーとして導入すると、そこから到達可能な全てのオブジェクトに読み出し専用のマークを付ける必要があります -- そして再び、自己参照オブジェクトが無限ループを引き起こします。</p></li>
</ul>
<p>必要ならばこれを回避する方法がありますが、自己責任のもとで行ってください。ミュータブルな構造を、 <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> と <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> メソッドの両方を持つクラスインスタンスに含めることができます。その時、辞書 (またはハッシュに基づく別の構造体) に属するような全てのラッパーオブジェクトのハッシュ値が、そのオブジェクトが辞書 (その他の構造体) 中にある間固定され続けることを確実にしてください。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ListWrapper</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">the_list</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">the_list</span> <span class="o">=</span> <span class="n">the_list</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">the_list</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">the_list</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">the_list</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">98767</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">*</span><span class="mi">555</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="o">%</span> <span class="mi">9999999</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1001</span> <span class="o">+</span> <span class="n">i</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">%</span> <span class="mi">7777777</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">333</span>
        <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>なお、リストのメンバーの中にハッシュ化できないものがある可能性や、算術オーバーフローの可能性から、ハッシュ計算は複雑になります。</p>
<p>さらに、そのオブジェクトが辞書に含まれるか否かにかかわらず、 <code class="docutils literal notranslate"><span class="pre">o1</span> <span class="pre">==</span> <span class="pre">o2</span></code> (すなわち <code class="docutils literal notranslate"><span class="pre">o1.__eq__(o2)</span> <span class="pre">is</span> <span class="pre">True</span></code>) ならばいつでも <code class="docutils literal notranslate"><span class="pre">hash(o1)</span> <span class="pre">==</span> <span class="pre">hash(o2)</span></code> (すなわち <code class="docutils literal notranslate"><span class="pre">o1.__hash__()</span> <span class="pre">==</span> <span class="pre">o2.__hash__()</span></code>) でなくてはなりません。その制限に適合できなければ、辞書やその他のハッシュに基づく構造体は間違いを起こします。</p>
<p>この <code class="xref py py-class docutils literal notranslate"><span class="pre">ListWrapper</span></code> の例では、異常を避けるため、ラッパオブジェクトが辞書内にある限りラップされたリストが変更されてはなりません。この条件と満たせなかった時の結果について知恵を絞る覚悟がない限り、これをしてはいけません。よく考えてください。</p>
</section>
<section id="why-doesn-t-list-sort-return-the-sorted-list">
<h2><a class="toc-backref" href="design.html#id24" role="doc-backlink">なぜ list.sort() はソートされたリストを返さないのですか？</a><a class="headerlink" href="design.html#why-doesn-t-list-sort-return-the-sorted-list" title="Link to this heading">¶</a></h2>
<p>パフォーマンスが問題となる状況では、ソートするためだけにリストのコピーを作るのは無駄が多いです。そこで、 <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> はインプレースにリストをソートします。このことを忘れないため、この関数はソートされたリストを返しません。こうすることで、ソートされたコピーが必要で、ソートされていないものも残しておきたいときに、うっかり上書きしてしまうようなことがなくなります。</p>
<p>新しいリストを返したいなら、代わりに組み込みの <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> 関数を使ってください。この関数は、与えられたイテレート可能オブジェクトから新しいリストを生成し、ソートして返します。例えば、辞書のキーをソートされた順序でイテレートする方法は:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mydict</span><span class="p">):</span>
    <span class="o">...</span>  <span class="c1"># do whatever with mydict[key]...</span>
</pre></div>
</div>
</section>
<section id="how-do-you-specify-and-enforce-an-interface-spec-in-python">
<h2><a class="toc-backref" href="design.html#id25" role="doc-backlink">Python ではどのようにインターフェース仕様を特定し適用するのですか？</a><a class="headerlink" href="design.html#how-do-you-specify-and-enforce-an-interface-spec-in-python" title="Link to this heading">¶</a></h2>
<p>C++ や Java のような言語が提供するような、モジュールに対するインターフェース仕様の特定は、モジュールのメソッドや関数の原型を表現します。インターフェースの特定がコンパイル時に適用されることが、大きなプログラムの構成に役立つと、広く感じられています。</p>
<p>Python 2.6 で、抽象基底クラス (Abstract Base Class, ABC) が定義できるようになる <a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> モジュールが追加されました。なので <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> と <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> を使って、インスタンスやクラスが、ある ABC を実装しているかどうかチェックできます。<a class="reference internal" href="../library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> モジュールでは、 <a class="reference internal" href="../library/collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a> 、 <a class="reference internal" href="../library/collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">Container</span></code></a> 、 <a class="reference internal" href="../library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></a> などの便利な ABC が定義されています。</p>
<p>Pythonでは、インターフェース仕様の多くの利点は、コンポーネントへの適切なテスト規律により得られます。</p>
<p>モジュールのための適切なテストスイートは、回帰テストを提供し、モジュールのインターフェース仕様や用例集としても役立ちます。多くの Python モジュールは、簡単な「自己テスト」を提供するスクリプトとして実行できます。複雑な外部インターフェースを使うモジュールさえ、外部インターフェースの細かい「スタブ」エミュレーションで単独にテストできることが多いです。 <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> や <a class="reference internal" href="../library/unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> モジュール、あるいはサードパーティのテストフレームワークで、モジュールのコードの全ての行に及ぶ徹底的なテストスイートを構成できます。</p>
<p>Python で大きくて複雑なアプリケーションを構築するとき、インターフェース仕様と同様に、適切なテスト規律も役立ちます。実際には、インターフェース仕様ではテストできないプログラムの属性もあるので、それ以上にもなりえます。例えば、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">list.append()</span></code> メソッドは新しい要素をある内部リストの終わりに加えます。インターフェース仕様ではこの <code class="xref py py-meth docutils literal notranslate"><span class="pre">list.append()</span></code> の実装が実際にこれを行うかをテストできませんが、テストスイートならこの機能を簡単に確かめられます。</p>
<p>テストスイートを書くことはとても有用ですし、簡単にテストできるコード設計を心がけると良いでしょう。人気を博している開発手法の一つ、テスト駆動開発は、実際のコードを記述するよりも先に、まずテストスイートの部分を記述するよう求めています。ご心配なく、Python は、あなたがいい加減でもテストケースを全く書かなくても構いません。</p>
</section>
<section id="why-is-there-no-goto">
<h2><a class="toc-backref" href="design.html#id26" role="doc-backlink">なぜ goto が無いのですか？</a><a class="headerlink" href="design.html#why-is-there-no-goto" title="Link to this heading">¶</a></h2>
<p>1970年代、人々は気付きました。秩序なき goto は、理解するのも手直しするのも困難という厄介な&quot;スパゲッティ&quot;コードに陥りがちであると。
高水準言語では、分岐とループの手段があれば goto は不要です。
(Pythonだと、分岐には <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 文及び <a class="reference internal" href="../reference/expressions.html#or"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code></a> ・ <a class="reference internal" href="../reference/expressions.html#and"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code></a> ・ <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>/<a class="reference internal" href="../reference/compound_stmts.html#else"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></a> 式を使います。ループには <a class="reference internal" href="../reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> 文と <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 文を使い、 ループ内に <a class="reference internal" href="../reference/simple_stmts.html#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> ・ <a class="reference internal" href="../reference/simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a> を含むことがあります)</p>
<p>関数の呼び出しをまたいでも動作する &quot;構造化された goto&quot; をまかなうものとして例外を使えます。C、Fortran、その他の言語での <code class="docutils literal notranslate"><span class="pre">go</span></code> あるいは <code class="docutils literal notranslate"><span class="pre">goto</span></code> 構造の適切な用途は全て、例外で同じようなことをすれば便利であると、広く感じられています。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">label</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># declare a label</span>

<span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">if</span> <span class="n">condition</span><span class="p">:</span> <span class="k">raise</span> <span class="n">label</span><span class="p">()</span>  <span class="c1"># goto label</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="n">label</span><span class="p">:</span>  <span class="c1"># where to goto</span>
    <span class="k">pass</span>
<span class="o">...</span>
</pre></div>
</div>
<p>例外ではループ内へ跳ぶことはできませんが、どちらにしてもそれは <code class="docutils literal notranslate"><span class="pre">goto</span></code> の乱用と見なされるものです。使うのは控えてください。</p>
</section>
<section id="why-can-t-raw-strings-r-strings-end-with-a-backslash">
<h2><a class="toc-backref" href="design.html#id27" role="doc-backlink">なぜ raw 文字列 (r-strings) はバックスラッシュで終わってはいけないのですか？</a><a class="headerlink" href="design.html#why-can-t-raw-strings-r-strings-end-with-a-backslash" title="Link to this heading">¶</a></h2>
<p>正確には、奇数個のバックスラッシュで終わってはいけません。終わりの対になっていないバックスラッシュは、閉じ引用文字をエスケープし、終っていない文字列を残してしまいます。</p>
<p>raw 文字列は、独自にバックスラッシュの処理をしようとするプロセッサ (主に正規表現エンジン) への入力を生成しやすいように設計されたものです。このようなプロセッサは、終端の対になっていないバックスラッシュを結局エラーとみなすので、raw 文字列はそれを認めません。その代わりに、バックスラッシュでエスケープすることで、引用文字を文字列として渡すことができます。r-string が意図された目的に使われるときに、この規則が役に立つのです。</p>
<p>Windows のパス名を構築するときには、Windows のシステムコールは普通のスラッシュも受け付けることを憶えておいてください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/mydir/file.txt&quot;</span><span class="p">)</span>  <span class="c1"># works fine!</span>
</pre></div>
</div>
<p>DOS コマンドのパス名を構築するときには、例えばこの中のどれかを試してください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">dir</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\this\is\my\dos\dir&quot;</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span>
<span class="nb">dir</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\this\is\my\dos\dir\ &quot;</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">dir</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">this</span><span class="se">\\</span><span class="s2">is</span><span class="se">\\</span><span class="s2">my</span><span class="se">\\</span><span class="s2">dos</span><span class="se">\\</span><span class="s2">dir</span><span class="se">\\</span><span class="s2">&quot;</span>
</pre></div>
</div>
</section>
<section id="why-doesn-t-python-have-a-with-statement-for-attribute-assignments">
<h2><a class="toc-backref" href="design.html#id28" role="doc-backlink">属性の代入に &quot;with&quot; 文が使えないのはなぜですか？</a><a class="headerlink" href="design.html#why-doesn-t-python-have-a-with-statement-for-attribute-assignments" title="Link to this heading">¶</a></h2>
<p>Python には、ブロックの実行を包む <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 文があり、ブロックに入るときとブロックから出るときに、コードを呼び出します。以下のような構造を持つ言語があります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">obj</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>               <span class="c1"># equivalent to obj.a = 1</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">total</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1"># obj.total = obj.total + 1</span>
</pre></div>
</div>
<p>Python では、このような構造は曖昧になるでしょう。</p>
<p>Object Pascal、Delphi、C++のような他の言語では、静的な型を使うので、曖昧な方法でも、どのメンバに代入されているのか分かります。これが静的型付けの要点です -- コンパイラは <em>いつでも</em> コンパイル時にすべての変数のスコープを知るのです。</p>
<p>Python は動的な型を使います。実行時にどの属性が参照されるか事前に分かりません。動作中にメンバ属性が追加あるいは除去されるかもしれません。これでは、単純に読むだけではどのアトリビュートが参照されているか分かりません。ローカルなのか、グローバルなのか、メンバ属性なのか？</p>
<p>例えば、以下の不完全なコード片を考えましょう:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">a</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>このコード片では、<code class="docutils literal notranslate"><span class="pre">a</span></code> は <code class="docutils literal notranslate"><span class="pre">x</span></code>. というメンバ属性を持っていると仮定されています。しかし、Python ではインタプリタにはこの仮定を伝えられる仕組みはありません。 <code class="docutils literal notranslate"><span class="pre">a</span></code> が、例えば整数だったら、どうなってしまうでしょうか。 <code class="docutils literal notranslate"><span class="pre">x</span></code> という名前のグローバル変数があったら、それが <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> ブロックの中で使われるのでしょうか。この通り、Python の動的な特質から、このような選択はとても難しい物になっています。</p>
<p>しかし、<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> やそれに類する言語の機能の一番の利点 (コード量の削減) は、 Python では代入により簡単に手に入れられます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">function</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">mydict</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">function</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">mydict</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">function</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">mydict</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">63</span>
</pre></div>
</div>
<p>こう書いてください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ref</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">mydict</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
<span class="n">ref</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">ref</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">ref</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">63</span>
</pre></div>
</div>
<p>Python では実行時に名前束縛が解決され、後者はその解決が一度で済むため、これには実行速度をあげる副作用もあります。</p>
<p>似た提案として、「先頭のドット」を使うなどして さらにコード量を減らす構文は、明白さを優先をして却下されました (<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2016-May/040070.html">https://mail.python.org/pipermail/python-ideas/2016-May/040070.html</a> 参照)。</p>
</section>
<section id="why-don-t-generators-support-the-with-statement">
<h2><a class="toc-backref" href="design.html#id29" role="doc-backlink">なぜジェネレータは with 文をサポートしないのですか？</a><a class="headerlink" href="design.html#why-don-t-generators-support-the-with-statement" title="Link to this heading">¶</a></h2>
<p>技術的な理由で、ジェネレータは直接コンテキストマネージャとして使ってもうまく動きません。最も一般的なように、ジェネレータが最後まで回りきるイテレータとして使われる場合、クローズ処理は不要です。必要な場合は、 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 文で <a class="reference internal" href="../library/contextlib.html#contextlib.closing" title="contextlib.closing"><code class="xref py py-func docutils literal notranslate"><span class="pre">contextlib.closing(generator)</span></code></a> のようにラップします。</p>
</section>
<section id="why-are-colons-required-for-the-if-while-def-class-statements">
<h2><a class="toc-backref" href="design.html#id30" role="doc-backlink">if/while/def/class 文にコロンが必要なのはなぜですか？</a><a class="headerlink" href="design.html#why-are-colons-required-for-the-if-while-def-class-statements" title="Link to this heading">¶</a></h2>
<p>主に可読性を高めるため (実験的な ABC 言語の結果の一つ) に、コロンが必要です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>と:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>を考えれば、後者のほうが少し読みやすいでしょう。さらに言えば、この FAQ の解答例は次のようになるでしょう。これは、英語の標準的な用法です。</p>
<p>他の小さな理由は、コロンによってエディタがシンタックスハイライトをしやすくなることです。プログラムテキストの手の込んだ解析をしなくても、コロンを探せばいつインデントを増やすべきかを決められます。</p>
</section>
<section id="why-does-python-allow-commas-at-the-end-of-lists-and-tuples">
<h2><a class="toc-backref" href="design.html#id31" role="doc-backlink">なぜ Python ではリストやタプルの最後にカンマがあっても良いのですか？</a><a class="headerlink" href="design.html#why-does-python-allow-commas-at-the-end-of-lists-and-tuples" title="Link to this heading">¶</a></h2>
<p>Python では、リスト、タプル、辞書の最後の要素の後端にカンマをつけても良いことになっています:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,]</span>
<span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,)</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
    <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>  <span class="c1"># last trailing comma is optional but good style</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これを許すのには、いくつかの理由があります。</p>
<p>リストやタプルや辞書のリテラルが複数行に渡っているときに、前の行にカンマを追加するのを覚えておく必要が無いため、要素を追加するのが楽になります。また、文法エラーを起こすこと無く、行の並べ替えを行うことができます。</p>
<p>間違えてカンマを落としてしまうと、診断しづらいエラーにつながります。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s2">&quot;fee&quot;</span><span class="p">,</span>
  <span class="s2">&quot;fie&quot;</span>
  <span class="s2">&quot;foo&quot;</span><span class="p">,</span>
  <span class="s2">&quot;fum&quot;</span>
<span class="p">]</span>
</pre></div>
</div>
<p>このリストには4つの要素があるように見えますが、実際には3つしかありません。
&quot;fee&quot;、&quot;fiefoo&quot;、&quot;fum&quot; です。
常にカンマを付けるようにすれば、この種のエラーが避けられます。</p>
<p>後端にカンマをつけても良いことにすれば、プログラムによるコード生成も簡単になります。</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="design.html#">デザインと歴史 FAQ</a><ul>
<li><a class="reference internal" href="design.html#why-does-python-use-indentation-for-grouping-of-statements">Python はなぜ文のグループ化にインデントを使うのですか？</a></li>
<li><a class="reference internal" href="design.html#why-am-i-getting-strange-results-with-simple-arithmetic-operations">なぜ単純な算術演算が奇妙な結果になるのですか？</a></li>
<li><a class="reference internal" href="design.html#why-are-floating-point-calculations-so-inaccurate">なぜ浮動小数点数の計算はこんなに不正確なんですか？</a></li>
<li><a class="reference internal" href="design.html#why-are-python-strings-immutable">なぜ Python の文字列はイミュータブルなのですか？</a></li>
<li><a class="reference internal" href="design.html#why-must-self-be-used-explicitly-in-method-definitions-and-calls">なぜメソッドの定義や呼び出しにおいて 'self' を明示しなければならないのですか？</a></li>
<li><a class="reference internal" href="design.html#why-can-t-i-use-an-assignment-in-an-expression">式中で代入ができないのはなぜですか？</a></li>
<li><a class="reference internal" href="design.html#why-does-python-use-methods-for-some-functionality-e-g-list-index-but-functions-for-other-e-g-len-list">Python にメソッドを使う機能 (list.index() 等) と関数を使う機能 (len(list) 等) があるのはなぜですか？</a></li>
<li><a class="reference internal" href="design.html#why-is-join-a-string-method-instead-of-a-list-or-tuple-method">join() がリストやタプルのメソッドではなく文字列のメソッドなのはなぜですか？</a></li>
<li><a class="reference internal" href="design.html#how-fast-are-exceptions">例外はどれくらい速いのですか？</a></li>
<li><a class="reference internal" href="design.html#why-isn-t-there-a-switch-or-case-statement-in-python">Python に switch や case 文がないのはなぜですか？</a></li>
<li><a class="reference internal" href="design.html#can-t-you-emulate-threads-in-the-interpreter-instead-of-relying-on-an-os-specific-thread-implementation">OS 特有のスレッド実装に依らずにインタプリタでスレッドをエミュレートすることはできないのですか？</a></li>
<li><a class="reference internal" href="design.html#why-can-t-lambda-expressions-contain-statements">なぜラムダ式は文を含むことができないのですか?</a></li>
<li><a class="reference internal" href="design.html#can-python-be-compiled-to-machine-code-c-or-some-other-language">Python は C やその他の言語のように機械語にコンパイルできますか？</a></li>
<li><a class="reference internal" href="design.html#how-does-python-manage-memory">Python はメモリをどのように管理するのですか？</a></li>
<li><a class="reference internal" href="design.html#why-doesn-t-cpython-use-a-more-traditional-garbage-collection-scheme">CPython はなぜ伝統的なガベージコレクションスキームを使わないのですか？</a></li>
<li><a class="reference internal" href="design.html#why-isn-t-all-memory-freed-when-cpython-exits">なぜ CPython の終了時にすべてのメモリが解放されるわけではないのですか？</a></li>
<li><a class="reference internal" href="design.html#why-are-there-separate-tuple-and-list-data-types">なぜタプルとリストという別のデータ型が用意されているのですか？</a></li>
<li><a class="reference internal" href="design.html#how-are-lists-implemented-in-cpython">CPythonでリストはどのように実装されているのですか？</a></li>
<li><a class="reference internal" href="design.html#how-are-dictionaries-implemented-in-cpython">CPythonで辞書はどのように実装されていますか？</a></li>
<li><a class="reference internal" href="design.html#why-must-dictionary-keys-be-immutable">なぜ辞書のキーはイミュータブルでなくてはならないのですか？</a></li>
<li><a class="reference internal" href="design.html#why-doesn-t-list-sort-return-the-sorted-list">なぜ list.sort() はソートされたリストを返さないのですか？</a></li>
<li><a class="reference internal" href="design.html#how-do-you-specify-and-enforce-an-interface-spec-in-python">Python ではどのようにインターフェース仕様を特定し適用するのですか？</a></li>
<li><a class="reference internal" href="design.html#why-is-there-no-goto">なぜ goto が無いのですか？</a></li>
<li><a class="reference internal" href="design.html#why-can-t-raw-strings-r-strings-end-with-a-backslash">なぜ raw 文字列 (r-strings) はバックスラッシュで終わってはいけないのですか？</a></li>
<li><a class="reference internal" href="design.html#why-doesn-t-python-have-a-with-statement-for-attribute-assignments">属性の代入に &quot;with&quot; 文が使えないのはなぜですか？</a></li>
<li><a class="reference internal" href="design.html#why-don-t-generators-support-the-with-statement">なぜジェネレータは with 文をサポートしないのですか？</a></li>
<li><a class="reference internal" href="design.html#why-are-colons-required-for-the-if-while-def-class-statements">if/while/def/class 文にコロンが必要なのはなぜですか？</a></li>
<li><a class="reference internal" href="design.html#why-does-python-allow-commas-at-the-end-of-lists-and-tuples">なぜ Python ではリストやタプルの最後にカンマがあっても良いのですか？</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="programming.html"
                          title="前の章へ">プログラミング FAQ</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="library.html"
                          title="次の章へ">ライブラリと拡張 FAQ</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/faq/design.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="サイドバーをたたむ">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="library.html" title="ライブラリと拡張 FAQ"
             >次へ</a> |</li>
        <li class="right" >
          <a href="programming.html" title="プログラミング FAQ"
             >前へ</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python よくある質問</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="design.html">デザインと歴史 FAQ</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" id="search-box" />
          <input type="submit" value="検索" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    Copyright
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="../../../license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最終更新: Jun 11, 2024 (04:44 UTC)
    
      <a href="../../../bugs.html">Found a bug</a>?
    
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>

    <script type="text/javascript" src="../_static/switchers.js"></script>
  </body>
</html>