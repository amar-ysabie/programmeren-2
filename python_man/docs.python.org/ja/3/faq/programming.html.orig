<!DOCTYPE html>

<html lang="ja" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="プログラミング FAQ" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/faq/programming.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="目次: プログラミング FAQ- 一般的な質問- ブレークポイントやシングルステップ実行などを備えたソースコードレベルデバッガはありますか？, バグの発見や静的解析に役立つツールはありますか？, どうしたら Python スクリプトからスタンドアロンバイナリを作れますか？, Python プログラムのためのコーディングスタンダードやスタイルガイドはありますか？., コア言語- なぜ変数に値が..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="目次: プログラミング FAQ- 一般的な質問- ブレークポイントやシングルステップ実行などを備えたソースコードレベルデバッガはありますか？, バグの発見や静的解析に役立つツールはありますか？, どうしたら Python スクリプトからスタンドアロンバイナリを作れますか？, Python プログラムのためのコーディングスタンダードやスタイルガイドはありますか？., コア言語- なぜ変数に値が..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>プログラミング FAQ &#8212; Python 3.12.4 ドキュメント</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=bb723527" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=b20cc3f5" />
    
    <script src="../_static/documentation_options.js?v=7e11ab17"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=4dbe4bdc"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.12.4 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="デザインと歴史 FAQ" href="design.html" />
    <link rel="prev" title="一般 Python FAQ" href="general.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="https://docs.python.org/3/faq/programming.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" />
                <input type="submit" value="検索"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="#">プログラミング FAQ</a><ul>
<li><a class="reference internal" href="#general-questions">一般的な質問</a></li>
<li><a class="reference internal" href="#core-language">コア言語</a></li>
<li><a class="reference internal" href="#numbers-and-strings">数と文字列</a></li>
<li><a class="reference internal" href="#performance">性能</a></li>
<li><a class="reference internal" href="#sequences-tuples-lists">シーケンス(タプル/リスト)</a></li>
<li><a class="reference internal" href="#objects">オブジェクト</a></li>
<li><a class="reference internal" href="#modules">モジュール</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="general.html"
                          title="前の章へ">一般 Python FAQ</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="design.html"
                          title="次の章へ">デザインと歴史 FAQ</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/faq/programming.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="design.html" title="デザインと歴史 FAQ"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="general.html" title="一般 Python FAQ"
             accesskey="P">前へ</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python よくある質問</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">プログラミング FAQ</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" id="search-box" />
          <input type="submit" value="検索" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="programming-faq">
<h1><a class="toc-backref" href="#id3" role="doc-backlink">プログラミング FAQ</a><a class="headerlink" href="#programming-faq" title="Link to this heading">¶</a></h1>
<nav class="contents" id="id1">
<p class="topic-title">目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#programming-faq" id="id3">プログラミング FAQ</a></p>
<ul>
<li><p><a class="reference internal" href="#general-questions" id="id4">一般的な質問</a></p>
<ul>
<li><p><a class="reference internal" href="#is-there-a-source-code-level-debugger-with-breakpoints-single-stepping-etc" id="id5">ブレークポイントやシングルステップ実行などを備えたソースコードレベルデバッガはありますか？</a></p></li>
<li><p><a class="reference internal" href="#are-there-tools-to-help-find-bugs-or-perform-static-analysis" id="id6">バグの発見や静的解析に役立つツールはありますか？</a></p></li>
<li><p><a class="reference internal" href="#how-can-i-create-a-stand-alone-binary-from-a-python-script" id="id7">どうしたら Python スクリプトからスタンドアロンバイナリを作れますか？</a></p></li>
<li><p><a class="reference internal" href="#are-there-coding-standards-or-a-style-guide-for-python-programs" id="id8">Python プログラムのためのコーディングスタンダードやスタイルガイドはありますか？</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#core-language" id="id9">コア言語</a></p>
<ul>
<li><p><a class="reference internal" href="#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" id="id10">なぜ変数に値があるのに UnboundLocalError が出るのですか？</a></p></li>
<li><p><a class="reference internal" href="#what-are-the-rules-for-local-and-global-variables-in-python" id="id11">Python のローカルとグローバル変数のルールは何ですか？</a></p></li>
<li><p><a class="reference internal" href="#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" id="id12">ループの中で異なる値で定義されたラムダ式が、同じ値を返すのはなぜですか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-share-global-variables-across-modules" id="id13">グローバル変数をモジュール間で共有するにはどうしたらいいですか？</a></p></li>
<li><p><a class="reference internal" href="#what-are-the-best-practices-for-using-import-in-a-module" id="id14">モジュールで import を使う際の「ベストプラクティス」は何ですか？</a></p></li>
<li><p><a class="reference internal" href="#why-are-default-values-shared-between-objects" id="id15">なぜオブジェクト間でデフォルト値が共有されるのですか？</a></p></li>
<li><p><a class="reference internal" href="#how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another" id="id16">オプションパラメータやキーワードパラメータを関数から関数へ渡すにはどうしたらいいですか？</a></p></li>
<li><p><a class="reference internal" href="#what-is-the-difference-between-arguments-and-parameters" id="id17">実引数と仮引数の違いは何ですか?</a></p></li>
<li><p><a class="reference internal" href="#why-did-changing-list-y-also-change-list-x" id="id18">なぜ list 'y' を変更すると list 'x' も変更されるのですか?</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-write-a-function-with-output-parameters-call-by-reference" id="id19">出力引数のある関数 (参照渡し) はどのように書きますか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-you-make-a-higher-order-function-in-python" id="id20">Python で高次関数はどのようにつくりますか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-copy-an-object-in-python" id="id21">Python のオブジェクトはどのようにコピーしますか？</a></p></li>
<li><p><a class="reference internal" href="#how-can-i-find-the-methods-or-attributes-of-an-object" id="id22">オブジェクトのメソッドや属性はどのように見つけますか？</a></p></li>
<li><p><a class="reference internal" href="#how-can-my-code-discover-the-name-of-an-object" id="id23">コードはどのようにオブジェクトの名前を見つけるのですか？</a></p></li>
<li><p><a class="reference internal" href="#what-s-up-with-the-comma-operator-s-precedence" id="id24">カンマ演算子はなぜ優先されるのですか？</a></p></li>
<li><p><a class="reference internal" href="#is-there-an-equivalent-of-c-s-ternary-operator" id="id25">C の &quot;?:&quot; 三項演算子と等価なものはありますか？</a></p></li>
<li><p><a class="reference internal" href="#is-it-possible-to-write-obfuscated-one-liners-in-python" id="id26">Python で解し難いワンライナーを書くことはできますか？</a></p></li>
<li><p><a class="reference internal" href="#what-does-the-slash-in-the-parameter-list-of-a-function-mean" id="id27">関数の引数リストにあるスラッシュ (/) は何を意味しますか？</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#numbers-and-strings" id="id28">数と文字列</a></p>
<ul>
<li><p><a class="reference internal" href="#how-do-i-specify-hexadecimal-and-octal-integers" id="id29">十六進数や八進数を指定するにはどうしたらいいですか？</a></p></li>
<li><p><a class="reference internal" href="#why-does-22-10-return-3" id="id30">なぜ -22 // 10 は -3 を返すのですか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-get-int-literal-attribute-instead-of-syntaxerror" id="id31">どうすれば SyntaxError を起こさずに整数リテラルの属性を得られますか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-convert-a-string-to-a-number" id="id32">文字列を数に変換するにはどうしたらいいですか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-convert-a-number-to-a-string" id="id33">数を文字列に変換するにはどうしたらいいですか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-modify-a-string-in-place" id="id34">文字列をインプレースに変更するにはどうしたらいいですか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-use-strings-to-call-functions-methods" id="id35">関数やメソッドを呼ぶのに文字列を使うにはどうしたらいいですか？</a></p></li>
<li><p><a class="reference internal" href="#is-there-an-equivalent-to-perl-s-chomp-for-removing-trailing-newlines-from-strings" id="id36">文字列から後端の改行を取り除く Perl の chomp() に相当するものはありますか？</a></p></li>
<li><p><a class="reference internal" href="#is-there-a-scanf-or-sscanf-equivalent" id="id37">scanf() や sscanf() と同等なものはありますか？</a></p></li>
<li><p><a class="reference internal" href="#what-does-unicodedecodeerror-or-unicodeencodeerror-error-mean" id="id38">'UnicodeDecodeError' や 'UnicodeEncodeError' はどういう意味ですか？</a></p></li>
<li><p><a class="reference internal" href="#can-i-end-a-raw-string-with-an-odd-number-of-backslashes" id="id39">raw string を奇数個のバックスラッシュで終えることはできますか？</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#performance" id="id40">性能</a></p>
<ul>
<li><p><a class="reference internal" href="#my-program-is-too-slow-how-do-i-speed-it-up" id="id41">プログラムが遅すぎます。どうしたら速くなりますか？</a></p></li>
<li><p><a class="reference internal" href="#what-is-the-most-efficient-way-to-concatenate-many-strings-together" id="id42">多くの文字列を結合するのに最も効率的な方法は何ですか？</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#sequences-tuples-lists" id="id43">シーケンス(タプル/リスト)</a></p>
<ul>
<li><p><a class="reference internal" href="#how-do-i-convert-between-tuples-and-lists" id="id44">タプル、リスト間の変更はどのようにするのですか？</a></p></li>
<li><p><a class="reference internal" href="#what-s-a-negative-index" id="id45">負の添え字は何ですか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-iterate-over-a-sequence-in-reverse-order" id="id46">シーケンスを逆順にイテレートするにはどうしたらいいですか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-you-remove-duplicates-from-a-list" id="id47">リストから重複を取り除くにはどうしますか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-you-remove-multiple-items-from-a-list" id="id48">リストから複数のアイテムを取り除く方法</a></p></li>
<li><p><a class="reference internal" href="#how-do-you-make-an-array-in-python" id="id49">Python で配列を作るにはどうしますか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-create-a-multidimensional-list" id="id50">多次元のリストを作るにはどうしますか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-apply-a-method-or-function-to-a-sequence-of-objects" id="id51">オブジェクトのシーケンスにメソッドや関数を適用するにはどうしますか？</a></p></li>
<li><p><a class="reference internal" href="#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works" id="id52">なぜ加算はされるのに a_tuple[i] += ['item'] は例外を送出するのですか?</a></p></li>
<li><p><a class="reference internal" href="#i-want-to-do-a-complicated-sort-can-you-do-a-schwartzian-transform-in-python" id="id53">複雑なソートがしたいのですが、Python でシュワルツ変換はできますか？</a></p></li>
<li><p><a class="reference internal" href="#how-can-i-sort-one-list-by-values-from-another-list" id="id54">リストを別のリストの値によってソートするにはどうしますか？</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#objects" id="id55">オブジェクト</a></p>
<ul>
<li><p><a class="reference internal" href="#what-is-a-class" id="id56">クラスとは何ですか？</a></p></li>
<li><p><a class="reference internal" href="#what-is-a-method" id="id57">メソッドとは何ですか？</a></p></li>
<li><p><a class="reference internal" href="#what-is-self" id="id58">self とは何ですか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-check-if-an-object-is-an-instance-of-a-given-class-or-of-a-subclass-of-it" id="id59">あるオブジェクトが、与えられたクラスやそのサブクラスのインスタンスであるかを調べるにはどうしますか？</a></p></li>
<li><p><a class="reference internal" href="#what-is-delegation" id="id60">委譲とは何ですか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-call-a-method-defined-in-a-base-class-from-a-derived-class-that-extends-it" id="id61">基底クラスで定義されたメソッドを、そのクラスを継承した派生クラスから呼び出すにはどうしますか？</a></p></li>
<li><p><a class="reference internal" href="#how-can-i-organize-my-code-to-make-it-easier-to-change-the-base-class" id="id62">基底クラスの名前を変えやすいコードを書くにはどうしますか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-create-static-class-data-and-static-class-methods" id="id63">静的なクラスデータや静的なクラスメソッドを作るにはどうしますか？</a></p></li>
<li><p><a class="reference internal" href="#how-can-i-overload-constructors-or-methods-in-python" id="id64">Python でコンストラクタ(やメソッド)をオーバーロードするにはどうしたらいいですか？</a></p></li>
<li><p><a class="reference internal" href="#i-try-to-use-spam-and-i-get-an-error-about-someclassname-spam" id="id65">__spam を使おうとしたら _SomeClassName__spam からエラーがでました。</a></p></li>
<li><p><a class="reference internal" href="#my-class-defines-del-but-it-is-not-called-when-i-delete-the-object" id="id66">クラスに __del__ メソッドを定義しているのですが、オブジェクトを削除したときに呼ばれません。</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-get-a-list-of-all-instances-of-a-given-class" id="id67">与えられたクラスのすべてのインスタンスのリストを得るにはどうしますか？</a></p></li>
<li><p><a class="reference internal" href="#why-does-the-result-of-id-appear-to-be-not-unique" id="id68">なぜ <code class="docutils literal notranslate"><span class="pre">id()</span></code> の結果は一意でないように見えるのですか?</a></p></li>
<li><p><a class="reference internal" href="#when-can-i-rely-on-identity-tests-with-the-is-operator" id="id69">いつ <em>is</em> 演算子での同一性テストが頼れますか？</a></p></li>
<li><p><a class="reference internal" href="#how-can-a-subclass-control-what-data-is-stored-in-an-immutable-instance" id="id70">どうすればサブクラスはイミュータブルなインスタンスに格納されたデータを制御できますか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-cache-method-calls" id="id71">メソッド呼び出しをキャッシュするには どうしたらいいですか？</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#modules" id="id72">モジュール</a></p>
<ul>
<li><p><a class="reference internal" href="#how-do-i-create-a-pyc-file" id="id73">.pyc ファイルを作るにはどうしますか？</a></p></li>
<li><p><a class="reference internal" href="#how-do-i-find-the-current-module-name" id="id74">現在のモジュール名を知るにはどうしますか？</a></p></li>
<li><p><a class="reference internal" href="#how-can-i-have-modules-that-mutually-import-each-other" id="id75">相互にインポートしあうモジュールを作るにはどうしたらいいですか？</a></p></li>
<li><p><a class="reference internal" href="#import-x-y-z-returns-module-x-how-do-i-get-z" id="id76">__import__('x.y.z') は &lt;module 'x'&gt; を返しますが、z を得るためにはどうしますか？</a></p></li>
<li><p><a class="reference internal" href="#when-i-edit-an-imported-module-and-reimport-it-the-changes-don-t-show-up-why-does-this-happen" id="id77">インポートされたモジュールを編集してから再インポートしましたが、変化が現れません。なぜですか？</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="general-questions">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">一般的な質問</a><a class="headerlink" href="#general-questions" title="Link to this heading">¶</a></h2>
<section id="is-there-a-source-code-level-debugger-with-breakpoints-single-stepping-etc">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">ブレークポイントやシングルステップ実行などを備えたソースコードレベルデバッガはありますか？</a><a class="headerlink" href="#is-there-a-source-code-level-debugger-with-breakpoints-single-stepping-etc" title="Link to this heading">¶</a></h3>
<p>はい。</p>
<p>Python 用のデバッガについては次に解説してあり、組み込みの <a class="reference internal" href="../library/functions.html#breakpoint" title="breakpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">breakpoint()</span></code></a> 関数でそれらのデバッガに処理を移せます。</p>
<p>pdb モジュールは簡素にして十分な Python のコンソールモードデバッガです。これは Python の標準ライブラリに含まれているもので、 <a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ライブラリリファレンスマニュアルにドキュメントがあります</span></code></a> 。 pdb のコードを手本にして自分用のデバッガを書くこともできます。</p>
<p>Python に同梱されている統合開発環境の IDLE は通常の Python の配布形態の一部 (普通は  <a class="reference external" href="https://github.com/python/cpython/blob/main/Tools/scripts/idle3">Tools/scripts/idle3</a> から利用可能) であり、グラフィカルなデバッガを含んでいます。</p>
<p>PythonWin は、pdb をベースとした GUI デバッガを含む Python IDE です。Pythonwin デバッガは、ブレークポイントの色付けや非 PythonWin プログラムのデバッグなどの素敵な機能をたくさん持っています。PythonWin は  <a class="reference external" href="https://github.com/mhammond/pywin32">pywin32</a> プロジェクトの一部、あるいは <a class="reference external" href="https://www.activestate.com/products/python/">ActivePython</a> ディストリビューションの一部として利用可能です。</p>
<p><a class="reference external" href="https://eric-ide.python-projects.org/">Eric</a> は PyQt や Scintilla editing component をもとにした IDE です。</p>
<p><a class="reference external" href="https://github.com/rocky/python3-trepan/">trepan3k</a> は gdbライクなデバッガです。</p>
<p><a class="reference external" href="https://code.visualstudio.com/">Visual Studio Code</a> はバージョン管理ソフトと一緒になったデバッグツールを備えた IDE です</p>
<p>商業のグラフィカルデバッガ付き Python IDE もあります。例えば:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://wingware.com/">Wing IDE</a></p></li>
<li><p><a class="reference external" href="https://www.activestate.com/products/komodo-ide/">Komodo IDE</a></p></li>
<li><p><a class="reference external" href="https://www.jetbrains.com/pycharm/">PyCharm</a></p></li>
</ul>
</section>
<section id="are-there-tools-to-help-find-bugs-or-perform-static-analysis">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">バグの発見や静的解析に役立つツールはありますか？</a><a class="headerlink" href="#are-there-tools-to-help-find-bugs-or-perform-static-analysis" title="Link to this heading">¶</a></h3>
<p>はい。</p>
<p><a class="reference external" href="https://pylint.pycqa.org/en/latest/index.html">Pylint</a> と <a class="reference external" href="https://github.com/PyCQA/pyflakes">Pyflakes</a> は、バグの早期発見に役立つ基本的なチェックを行います。</p>
<p><a class="reference external" href="https://mypy-lang.org/">Mypy</a>, <a class="reference external" href="https://pyre-check.org/">Pyre</a>, <a class="reference external" href="https://github.com/google/pytype">Pytype</a> などの静的型チェッカーは、 Python ソースコードにある型ヒントをチェックできます。</p>
</section>
<section id="how-can-i-create-a-stand-alone-binary-from-a-python-script">
<span id="faq-create-standalone-binary"></span><h3><a class="toc-backref" href="#id7" role="doc-backlink">どうしたら Python スクリプトからスタンドアロンバイナリを作れますか？</a><a class="headerlink" href="#how-can-i-create-a-stand-alone-binary-from-a-python-script" title="Link to this heading">¶</a></h3>
<p>ユーザがダウンロードでき、Python ディストリビューションをインストールせずに実行できるようなスタンドアロンプログラムだけでいいなら、Python を C コードにコンパイルできなくても構いません。プログラムに対して必要なモジュールを選び、そのモジュールを Python バイナリに束縛して一つの実行可能ファイルにまとめる多くのツールがあります。</p>
<p>一つは freeze ツールで、Python ソースツリーに <a class="reference external" href="https://github.com/python/cpython/tree/main/Tools/freeze">Tools/freeze</a> として含まれています。これは Python バイトコードを C 配列に変換します。すべてのモジュールを新しいプログラムに埋め込む C コンパイラで、そのプログラムは Python モジュールにリンクされます。</p>
<p>これはあなたのソースの (両方の形式の) import 文を再帰的にスキャンし、import されたモジュールを標準の Python パスと (組み込みモジュールのある) ソースディレクトリから探します。そして Python で書かれたモジュールのバイトコードを C コード (marshal モジュールでコードオブジェクトに変換できる配列) に変換し、実際にそのプログラム内で使われている組み込みモジュールだけが含まれたカスタムメイドの設定ファイルを作成します。そして生成された C コードをコンパイルして Python インタプリタの残りとリンクし、元のスクリプトと全く同じように動作する自己完結的なバイナリを形成します。</p>
<p>以下のパッケージはコンソールやGUIの実行ファイル作成に役立ちます。</p>
<ul class="simple">
<li><p><a class="reference external" href="https://nuitka.net/">Nuitka</a> (Cross-platform)</p></li>
<li><p><a class="reference external" href="https://pyinstaller.org/">PyInstaller</a> (Cross-platform)</p></li>
<li><p><a class="reference external" href="https://pyoxidizer.readthedocs.io/en/stable/">PyOxidizer</a> (Cross-platform)</p></li>
<li><p><a class="reference external" href="https://marcelotduarte.github.io/cx_Freeze/">cx_Freeze</a> (Cross-platform)</p></li>
<li><p><a class="reference external" href="https://github.com/ronaldoussoren/py2app">py2app</a> (macOS only)</p></li>
<li><p><a class="reference external" href="https://www.py2exe.org/">py2exe</a> (Windows only)</p></li>
</ul>
</section>
<section id="are-there-coding-standards-or-a-style-guide-for-python-programs">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Python プログラムのためのコーディングスタンダードやスタイルガイドはありますか？</a><a class="headerlink" href="#are-there-coding-standards-or-a-style-guide-for-python-programs" title="Link to this heading">¶</a></h3>
<p>はい。標準ライブラリモジュールに求められるコーディングスタイルは <span class="target" id="index-9"></span><a class="pep reference external" href="https://peps.python.org/pep-0008/"><strong>PEP 8</strong></a> として文書化されています。</p>
</section>
</section>
<section id="core-language">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">コア言語</a><a class="headerlink" href="#core-language" title="Link to this heading">¶</a></h2>
<section id="why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value">
<span id="faq-unboundlocalerror"></span><h3><a class="toc-backref" href="#id10" role="doc-backlink">なぜ変数に値があるのに UnboundLocalError が出るのですか？</a><a class="headerlink" href="#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" title="Link to this heading">¶</a></h3>
<p>もともと動いていたコードが、関数の本体のどこかに代入文を加えるという変更をしたら <a class="reference internal" href="../library/exceptions.html#UnboundLocalError" title="UnboundLocalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnboundLocalError</span></code></a> を出すのには驚くかもしれません。</p>
<p>このコード:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="p">()</span>
<span class="go">10</span>
</pre></div>
</div>
<p>は動きますが、このコード:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>は <code class="xref py py-exc docutils literal notranslate"><span class="pre">UnboundLocalError</span></code> になります:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">UnboundLocalError</span>: <span class="n">local variable &#39;x&#39; referenced before assignment</span>
</pre></div>
</div>
<p>これは、あるスコープの中で変数に代入を行うとき、その変数はそのスコープに対してローカルになり、外のスコープにある同じ名前の変数を隠すからです。foo の最後の文が <code class="docutils literal notranslate"><span class="pre">x</span></code> に新しい値を代入しているので、コンパイラはこれをローカル変数であると認識します。その結果、先の <code class="docutils literal notranslate"><span class="pre">print(x)</span></code> が初期化されていないローカル変数を表示しようとして結果はエラーとなります。</p>
<p>上の例では、グローバルであると宣言することで外のスコープにアクセスできます:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foobar</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">global</span> <span class="n">x</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foobar</span><span class="p">()</span>
<span class="go">10</span>
</pre></div>
</div>
<p>この明示的な宣言は (表面的には似ているクラスとインスタンス変数の例とは違って) あなたは実際は他のスコープの変数の値を変えようとしているのだ、ということを知らせるのに必要です:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">11</span>
</pre></div>
</div>
<p>同様のことを、ネストされたスコープで <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> 予約語を使うことでもできます:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">... </span>   <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
<span class="gp">... </span>       <span class="k">nonlocal</span> <span class="n">x</span>
<span class="gp">... </span>       <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>       <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>   <span class="n">bar</span><span class="p">()</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">()</span>
<span class="go">10</span>
<span class="go">11</span>
</pre></div>
</div>
</section>
<section id="what-are-the-rules-for-local-and-global-variables-in-python">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Python のローカルとグローバル変数のルールは何ですか？</a><a class="headerlink" href="#what-are-the-rules-for-local-and-global-variables-in-python" title="Link to this heading">¶</a></h3>
<p>Python では、関数内で参照されるだけの変数は暗黙的にグローバルとなります。
関数の本体のどこかで値が変数に代入されたなら、それは明示的にグローバルであると宣言されない限り、ローカルであるとみなされます。</p>
<p>最初はちょっと驚くでしょうが、少し考えると納得できます。一方では、代入された変数に <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> を要求することで、意図しない副作用を防げます。他方では、グローバルな参照の度に <code class="docutils literal notranslate"><span class="pre">global</span></code> が要求されてしまうと、 <code class="docutils literal notranslate"><span class="pre">global</span></code> を使ってばかりになってしまいます。ビルトイン関数やインポートされたモジュールの内容を参照するたびにグローバル宣言をしなければならないのです。その乱雑さは副作用を特定するための <code class="docutils literal notranslate"><span class="pre">global</span></code> 宣言の便利さよりも重大です。</p>
</section>
<section id="why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">ループの中で異なる値で定義されたラムダ式が、同じ値を返すのはなぜですか？</a><a class="headerlink" href="#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result" title="Link to this heading">¶</a></h3>
<p>for ループを使って、少しずつ異なるラムダを定義 (もしくは簡単な関数) するとします。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">squares</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>これで <code class="docutils literal notranslate"><span class="pre">x**2</span></code> を計算する 5 つのラムダのリストが得られます。それらを呼び出したとき、それぞれ <code class="docutils literal notranslate"><span class="pre">0</span></code>、<code class="docutils literal notranslate"><span class="pre">1</span></code>、<code class="docutils literal notranslate"><span class="pre">4</span></code>、<code class="docutils literal notranslate"><span class="pre">9</span></code>、<code class="docutils literal notranslate"><span class="pre">16</span></code> を返すと予想するかもしれません。しかし実際にやってみると、全て <code class="docutils literal notranslate"><span class="pre">16</span></code> が返ってくるのを目にするでしょう:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">2</span><span class="p">]()</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">4</span><span class="p">]()</span>
<span class="go">16</span>
</pre></div>
</div>
<p>これは、<code class="docutils literal notranslate"><span class="pre">x</span></code> がラムダにとってのローカル変数ではなく外側のスコープで定義されていて、ラムダが定義されたときでなく呼び出されたときにアクセスされるために起こります。ループが終わった時点では <code class="docutils literal notranslate"><span class="pre">x</span></code> は <code class="docutils literal notranslate"><span class="pre">4</span></code> であり、従って、全ての関数は <code class="docutils literal notranslate"><span class="pre">4**2</span></code> つまり <code class="docutils literal notranslate"><span class="pre">16</span></code> を返します。このことは <code class="docutils literal notranslate"><span class="pre">x</span></code> の値を変えてみることで検証でき、ラムダの返り値がどのように変わるのか観察できます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">2</span><span class="p">]()</span>
<span class="go">64</span>
</pre></div>
</div>
<p>これを避けるためには、グローバルの <code class="docutils literal notranslate"><span class="pre">x</span></code> の値に依存しないために、ラムダにとってのローカル変数に値を保存する必要があります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">squares</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="o">=</span><span class="n">x</span><span class="p">:</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>ここで、<code class="docutils literal notranslate"><span class="pre">n=x</span></code> は新しいラムダにとってのローカル変数 <code class="docutils literal notranslate"><span class="pre">n</span></code> を作成し、ラムダが定義されるときに計算されるので、ループのその時点での <code class="docutils literal notranslate"><span class="pre">x</span></code> と同じ値を持っています。これは、1 つ目のラムダでは <code class="docutils literal notranslate"><span class="pre">n</span></code> の値は <code class="docutils literal notranslate"><span class="pre">0</span></code> になり、2 つ目では <code class="docutils literal notranslate"><span class="pre">1</span></code>、3 つ目では <code class="docutils literal notranslate"><span class="pre">2</span></code> 以下同様、となることを意味します。従って、それぞれのラムダは今や正しい値を返すようになりました:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">2</span><span class="p">]()</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span><span class="p">[</span><span class="mi">4</span><span class="p">]()</span>
<span class="go">16</span>
</pre></div>
</div>
<p>この動作はラムダに特有なものではなく、通常の関数にも適用されることに注意してください。</p>
</section>
<section id="how-do-i-share-global-variables-across-modules">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">グローバル変数をモジュール間で共有するにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-share-global-variables-across-modules" title="Link to this heading">¶</a></h3>
<p>一つのプログラムのモジュール間で情報を共有する正準な方法は、特別なモジュール (しばしば config や cfg と呼ばれる) を作ることです。単に設定モジュールをアプリケーションのすべてのモジュールにインポートしてください。このモジュールはグローバルな名前として使えます。それぞれのモジュールのただ一つのインスタンスがあるので、設定モジュールオブジェクトに対するいかなる変更も全体に反映されます。例えば:</p>
<p>config.py:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># Default value of the &#39;x&#39; configuration setting</span>
</pre></div>
</div>
<p>mod.py:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">config</span>
<span class="n">config</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>main.py:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">config</span>
<span class="kn">import</span> <span class="nn">mod</span>
<span class="nb">print</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>なお、同じ理由から、モジュールを使うということは、シングルトンデザインパターンを実装することの基礎でもあります。</p>
</section>
<section id="what-are-the-best-practices-for-using-import-in-a-module">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">モジュールで import を使う際の「ベストプラクティス」は何ですか？</a><a class="headerlink" href="#what-are-the-best-practices-for-using-import-in-a-module" title="Link to this heading">¶</a></h3>
<p>一般的に <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">modulename</span> <span class="pre">import</span> <span class="pre">*</span></code> を使ってはいけません。そのようにするとインポータの名前空間は汚染され、linter が未定義の名前を発見することが難しくなります。</p>
<p>モジュールはファイルの先頭でインポートしてください。これによってコードが必要とする他のモジュールが明確になり、モジュール名がスコープに含まれるかどうかに迷わなくなります。行に一つのインポートにすると、モジュールのインポートの追加と削除が容易になりますが、行に複数のインポートにすると画面の領域が少なく済みます。</p>
<p>次の手順でモジュールをインポートするのが、良い習慣になります:</p>
<ol class="arabic simple">
<li><p>標準ライブラリモジュール -- 例 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>、<a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a>、<a class="reference internal" href="../library/argparse.html#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">argparse</span></code></a>、<a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a></p></li>
<li><p>サードパーティのライブラリモジュール (Python の site-packages ディレクトリにあるもの) -- 例 <code class="xref py py-mod docutils literal notranslate"><span class="pre">dateutil</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">requests</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">PIL.Image</span></code>、など</p></li>
<li><p>自前で開発したモジュール</p></li>
</ol>
<p>循環参照の問題を避けるために、インポートを関数やクラスに移すことが必要なときもあります。Gordon McMillan によれば:</p>
<blockquote>
<div><p>循環参照は両方のモジュールが &quot;import &lt;module&gt;&quot; 形式のインポートを使っていれば大丈夫です。二つ目のモジュールが最初のモジュールから名前を確保しようとして (&quot;from module import name&quot;)、そのインポートがトップレベルにあると駄目です。最初のモジュールが二つ目のモジュールをインポートするのに忙しくて、最初のモジュールの名前が利用可能になっていないからです。</p>
</div></blockquote>
<p>この状況では、二つ目のモジュールが一つの関数の中でのみ使われているならば、そのインポートは簡単に関数の中に移せます。インポートが呼ばれたとき、最初のモジュールは初期化を完了していて、二つ目のモジュールは自分のインポートをできます。</p>
<p>プラットフォーム依存のモジュールがあるときには、インポートをトップレベルの外に動かすことも必要です。この場合、ファイルの先頭ではすべてのモジュールをインポートすることさえできないかもしれません。この場合は、対応するプラットフォームに合わせたコードで正しいモジュールをインポートすることを選ぶと良いです。</p>
<p>循環参照の問題を避けたりモジュールの初期化にかかる時間を減らしたりしたいなら、単にインポートを関数定義の中などのローカルなスコープに移してください。この手法は多くのインポートがプログラムがどのように実行されるかに依存しなくてよいときに特に有効です。ある関数の中でのみモジュールが使われるのなら、インポートをその関数の中に移すことを考えてもいいでしょう。なお、モジュールを読み込む最初の回はモジュールの初期化の時間のために高価になりえますが、複数回目にモジュールを読み込むのは事実上無料、辞書探索の数回のコストだけで済みます。モジュール名がスコープから外れてさえ、そのモジュールはおそらく <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> から利用できるでしょう。</p>
</section>
<section id="why-are-default-values-shared-between-objects">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">なぜオブジェクト間でデフォルト値が共有されるのですか？</a><a class="headerlink" href="#why-are-default-values-shared-between-objects" title="Link to this heading">¶</a></h3>
<p>この種のバグがよく初心者プログラマに噛み付きます。この関数を考えてみてください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="p">{}):</span>  <span class="c1"># Danger: shared reference to one dict for all calls</span>
    <span class="o">...</span> <span class="n">compute</span> <span class="n">something</span> <span class="o">...</span>
    <span class="n">mydict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">mydict</span>
</pre></div>
</div>
<p>初めてこの関数を呼び出した時、<code class="docutils literal notranslate"><span class="pre">mydict</span></code> には一つの要素があります。二回目には、<code class="docutils literal notranslate"><span class="pre">foo()</span></code> が実行されるときに <code class="docutils literal notranslate"><span class="pre">mydict</span></code> には初めから一つの要素をすでに持っているので、<code class="docutils literal notranslate"><span class="pre">mydict</span></code> には二つの要素があります。</p>
<p>関数の呼び出しによって、デフォルトの値に対する新しいオブジェクトが作られるのだと予想しがちです。実はそうなりません。デフォルト値は、関数が定義されたときに一度だけ生成されます。この例の辞書のように、そのオブジェクトが変更されたとき、その後の関数の呼び出しは変更後のオブジェクトを参照します。</p>
<p>定義の時に、数、文字列、タプル、<code class="docutils literal notranslate"><span class="pre">None</span></code> など、イミュータブルなオブジェクトを使うと変更される危険がありません。辞書、リスト、クラスインスタンスなどのミュータブルなオブジェクトは混乱のもとです。</p>
<p>この性質から、ミュータブルなオブジェクトをデフォルト値として使わないプログラミング手法がいいです。代わりに、<code class="docutils literal notranslate"><span class="pre">None</span></code> をデフォルト値に使い、そのパラメタが <code class="docutils literal notranslate"><span class="pre">None</span></code> である時にだけ、関数の内部で新しいリスト/辞書/その他をつくるようにしてください。例えば、こう書かずに:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="p">{}):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>代わりに:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mydict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">mydict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mydict</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># create a new dict for local namespace</span>
</pre></div>
</div>
<p>この性質が便利なこともあります。時間のかかる計算を行う関数があるときに使われる一般的な技法は、関数が呼び出されるごとにパラメタと結果の値をキャッシュし、再び同じ値が要求されたらキャッシュされた値を返すというものです。これは &quot;memoizing&quot; と呼ばれ、このように実装されます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Callers can only provide two parameters and optionally pass _cache by keyword</span>
<span class="k">def</span> <span class="nf">expensive</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">_cache</span><span class="o">=</span><span class="p">{}):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_cache</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_cache</span><span class="p">[(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)]</span>

    <span class="c1"># Calculate the value</span>
    <span class="n">result</span> <span class="o">=</span> <span class="o">...</span> <span class="n">expensive</span> <span class="n">computation</span> <span class="o">...</span>
    <span class="n">_cache</span><span class="p">[(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result</span>           <span class="c1"># Store result in the cache</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>デフォルト値の代わりに、辞書を含むグローバル変数も使えます。これは好みの問題です。</p>
</section>
<section id="how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">オプションパラメータやキーワードパラメータを関数から関数へ渡すにはどうしたらいいですか？</a><a class="headerlink" href="#how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another" title="Link to this heading">¶</a></h3>
<p>関数のパラメータリストに引数を <code class="docutils literal notranslate"><span class="pre">*</span></code> と <code class="docutils literal notranslate"><span class="pre">**</span></code> 指定子 (specifier) で集めてください。そうすれば、位置引数をタプルとして、キーワード引数を辞書として得られます。これで、他の関数を呼び出すときに <code class="docutils literal notranslate"><span class="pre">*</span></code> と <code class="docutils literal notranslate"><span class="pre">**</span></code> を使ってそれらの引数を渡せます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;14.3c&#39;</span>
    <span class="o">...</span>
    <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="what-is-the-difference-between-arguments-and-parameters">
<span id="faq-argument-vs-parameter"></span><span id="index-1"></span><h3><a class="toc-backref" href="#id17" role="doc-backlink">実引数と仮引数の違いは何ですか?</a><a class="headerlink" href="#what-is-the-difference-between-arguments-and-parameters" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">仮引数 (parameter)</span></a> は関数定義に表れる名前で定義されるのに対し、 <a class="reference internal" href="../glossary.html#term-argument"><span class="xref std std-term">実引数 (argument)</span></a> は関数を呼び出すときに実際に渡す値のことです。仮引数は関数が受け取ることの出来る <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">実引数の型</span></a> を定義します。例えば、以下のような関数定義があったとして:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p><em>foo</em>、<em>bar</em>、<em>kwargs</em> は <code class="docutils literal notranslate"><span class="pre">func</span></code> の仮引数です。一方、<code class="docutils literal notranslate"><span class="pre">func</span></code> を呼び出すときには、例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">func</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">314</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">somevar</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">42</span></code>、<code class="docutils literal notranslate"><span class="pre">314</span></code>、<code class="docutils literal notranslate"><span class="pre">somevar</span></code> という値は実引数です。</p>
</section>
<section id="why-did-changing-list-y-also-change-list-x">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">なぜ list 'y' を変更すると list 'x' も変更されるのですか?</a><a class="headerlink" href="#why-did-changing-list-y-also-change-list-x" title="Link to this heading">¶</a></h3>
<p>次のようなコードを書いたとします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">[10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">[10]</span>
</pre></div>
</div>
<p>どうして <code class="docutils literal notranslate"><span class="pre">y</span></code> への要素の追加が <code class="docutils literal notranslate"><span class="pre">x</span></code> も変更してしまうのか疑問に思うかもしれません。</p>
<p>このような結果になる2つの要因があります:</p>
<ol class="arabic simple">
<li><p>変数とは、単にオブジェクトを参照するための名前に過ぎません。 <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">x</span></code> とすることは、リストのコピーを作りません -- それは <code class="docutils literal notranslate"><span class="pre">x</span></code> が参照するのと同じオブジェクトを参照する新しい変数 <code class="docutils literal notranslate"><span class="pre">y</span></code> を作ります。つまり、あるのは一つのオブジェクト(この場合リスト)だけであって、 <code class="docutils literal notranslate"><span class="pre">x</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span></code> の両方がそれを参照しているのです。</p></li>
<li><p>リストは <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">mutable</span></a> です。内容を変更出来る、ということです。</p></li>
</ol>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code> 呼び出しの後、ミュータブルオブジェクトの内容が <code class="docutils literal notranslate"><span class="pre">[]</span></code> から <code class="docutils literal notranslate"><span class="pre">[10]</span></code> に変わります。 変数が同じオブジェクトを参照しているので、どちらの名前であっても変更された値 <code class="docutils literal notranslate"><span class="pre">[10]</span></code> にアクセスします。</p>
<p>代わりに <code class="docutils literal notranslate"><span class="pre">x</span></code> にイミュータブルを代入すると:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># ints are immutable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># 5 can&#39;t be mutated, we are creating a new object here</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">5</span>
</pre></div>
</div>
<p>この場合ご覧の通り <code class="docutils literal notranslate"><span class="pre">x</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span></code> はまったく同じではありませんね。これは整数が <a class="reference internal" href="../glossary.html#term-immutable"><span class="xref std std-term">immutable</span></a> だからで、 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> は整数の <code class="docutils literal notranslate"><span class="pre">5</span></code> の値を変更しているのではありません; 代わりに新しいオブジェクト(整数 <code class="docutils literal notranslate"><span class="pre">6</span></code>)を作って <code class="docutils literal notranslate"><span class="pre">x</span></code> に代入しています (つまり <code class="docutils literal notranslate"><span class="pre">x</span></code> が参照するオブジェクトが変わります)。この代入の後では私たちは 2 つのオブジェクト(整数の <code class="docutils literal notranslate"><span class="pre">6</span></code> と <code class="docutils literal notranslate"><span class="pre">5</span></code>)を持っていて、2 つの変数はそれらを参照しています(<code class="docutils literal notranslate"><span class="pre">x</span></code> はいまや <code class="docutils literal notranslate"><span class="pre">6</span></code> を参照していますが <code class="docutils literal notranslate"><span class="pre">y</span></code> は <code class="docutils literal notranslate"><span class="pre">5</span></code> を参照したままです)。</p>
<p>ある演算 (たとえば <code class="docutils literal notranslate"><span class="pre">y.append(10)</span></code>, <code class="docutils literal notranslate"><span class="pre">y.sort()</span></code>) がオブジェクトを変更する一方で、外見上は似た演算 (たとえば <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">[10]</span></code>, <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted(y)</span></code></a>) は新しいオブジェクトを作ります。Python では一般に (そして標準ライブラリの全てのケースで)、このような 2 つのタイプの演算にまつわる混乱を避けるために、オブジェクトを変更するメソッドは <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。ですからもしあなたが誤って <code class="docutils literal notranslate"><span class="pre">y</span></code> の複製の並び替えをするつもりで <code class="docutils literal notranslate"><span class="pre">y.sort()</span></code> と書いた場合に結果手にするのは <code class="docutils literal notranslate"><span class="pre">None</span></code> でしょうから、あなたのプログラムは簡単に診断出来るエラーを起こすでしょう。</p>
<p>しかしながら、同じ操作が型ごとに異なる振る舞いをする演算の種類が一つあります: 累算代入演算です。例えば <code class="docutils literal notranslate"><span class="pre">+=</span></code> はリストを変更しますが、タプルや整数は変更しません(<code class="docutils literal notranslate"><span class="pre">a_list</span> <span class="pre">+=</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> は <code class="docutils literal notranslate"><span class="pre">a_list.extend([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></code> と同じ意味で、そして <code class="docutils literal notranslate"><span class="pre">a_list</span></code> を変更しますが、 <code class="docutils literal notranslate"><span class="pre">some_tuple</span> <span class="pre">+=</span> <span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></code> と <code class="docutils literal notranslate"><span class="pre">some_int</span> <span class="pre">+=</span> <span class="pre">1</span></code> は新しいオブジェクトを作ります)。</p>
<p>言い換えると:</p>
<ul class="simple">
<li><p>ミュータブルなオブジェクト(<a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, 等)を持っている場合、私たちはその内容を変更するある種の演算を使うことが出来、それを参照している全ての変数はその変化を見ることになるでしょう。</p></li>
<li><p>イミュータブルなオブジェクト(<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, 等)を持っている場合、それを参照している全ての変数は同じ値を参照しているでしょうが、持っている値を新しい値に変換する演算はいつでも新しいオブジェクトを返します。</p></li>
</ul>
<p>2つの変数が同じオブジェクトを参照しているかどうかが知りたければ、 <a class="reference internal" href="../reference/expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> 演算子や組み込み関数 <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> が使えます。</p>
</section>
<section id="how-do-i-write-a-function-with-output-parameters-call-by-reference">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">出力引数のある関数 (参照渡し) はどのように書きますか？</a><a class="headerlink" href="#how-do-i-write-a-function-with-output-parameters-call-by-reference" title="Link to this heading">¶</a></h3>
<p>前提として、Python では引数は代入によって渡されます。代入はオブジェクトへの参照を作るだけなので、呼び出し元と呼び出し先にある引数名の間にエイリアスはありませんし、参照渡しそれ自体はありません。望む効果を得るためには幾つかの方法があります。</p>
<ol class="arabic">
<li><p>結果のタプルを返すことによって:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;new-value&#39;</span>        <span class="c1"># a and b are local names</span>
<span class="gp">... </span>    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span>              <span class="c1"># assigned to new objects</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>            <span class="c1"># return new values</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="s1">&#39;old-value&#39;</span><span class="p">,</span> <span class="mi">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">(&#39;new-value&#39;, 100)</span>
</pre></div>
</div>
<p>これはたいてい一番明確な方法です。</p>
</li>
<li><p>グローバル変数を使って。これはスレッドセーフでないので、推奨されません。</p></li>
<li><p>ミュータブルな (インプレースに変更可能な) オブジェクトを渡すことによって:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func2</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;new-value&#39;</span>     <span class="c1"># &#39;a&#39; references a mutable list</span>
<span class="gp">... </span>    <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>        <span class="c1"># changes a shared object</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;old-value&#39;</span><span class="p">,</span> <span class="mi">99</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func2</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span>
<span class="go">[&#39;new-value&#39;, 100]</span>
</pre></div>
</div>
</li>
<li><p>変更される辞書に渡すことによって:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func3</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">args</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;new-value&#39;</span>     <span class="c1"># args is a mutable dictionary</span>
<span class="gp">... </span>    <span class="n">args</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1"># change it in-place</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;old-value&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">99</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func3</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span>
<span class="go">{&#39;a&#39;: &#39;new-value&#39;, &#39;b&#39;: 100}</span>
</pre></div>
</div>
</li>
<li><p>または、クラスインスタンスに値を同梱することによって:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Namespace</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">... </span>            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func4</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">args</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;new-value&#39;</span>        <span class="c1"># args is a mutable Namespace</span>
<span class="gp">... </span>    <span class="n">args</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span>         <span class="c1"># change object in-place</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span> <span class="o">=</span> <span class="n">Namespace</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s1">&#39;old-value&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func4</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">vars</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: &#39;new-value&#39;, &#39;b&#39;: 100}</span>
</pre></div>
</div>
<p>このような複雑なことをする理由はめったに無いでしょう。</p>
</li>
</ol>
<p>一番の選択は、複数の結果を含むタプルを返すことです。</p>
</section>
<section id="how-do-you-make-a-higher-order-function-in-python">
<h3><a class="toc-backref" href="#id20" role="doc-backlink">Python で高次関数はどのようにつくりますか？</a><a class="headerlink" href="#how-do-you-make-a-higher-order-function-in-python" title="Link to this heading">¶</a></h3>
<p>二つの方法があります: ネストされたスコープを使う方法と、呼び出し可能オブジェクトを使う方法です。例えば、<code class="docutils literal notranslate"><span class="pre">a*x+b</span></code> の値を計算する <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> 関数を返す <code class="docutils literal notranslate"><span class="pre">linear(a,b)</span></code> を定義したいとします。ネストされたスコープを使うと:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">linear</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">result</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>また、呼び出し可能オブジェクトを使うと:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">linear</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>
</pre></div>
</div>
<p>どちらの場合でも、</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">taxes</span> <span class="o">=</span> <span class="n">linear</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>とすれば、<code class="docutils literal notranslate"><span class="pre">taxes(10e6)</span> <span class="pre">==</span> <span class="pre">0.3</span> <span class="pre">*</span> <span class="pre">10e6</span> <span class="pre">+</span> <span class="pre">2</span></code> となるような呼び出し可能オブジェクトを得られます。</p>
<p>呼び出し可能オブジェクトを使う方法は、少し遅くなり、わずかにコードが長くなるという短所があります。ですが、継承を使って呼び出し可能オブジェクト同士で記号を共有することもできます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">exponential</span><span class="p">(</span><span class="n">linear</span><span class="p">):</span>
    <span class="c1"># __init__ inherited</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>オブジェクトはいくつかのメソッドに状態をカプセル化できます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">counter</span><span class="p">:</span>

    <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">up</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">down</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">count</span> <span class="o">=</span> <span class="n">counter</span><span class="p">()</span>
<span class="n">inc</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">reset</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="n">up</span><span class="p">,</span> <span class="n">count</span><span class="o">.</span><span class="n">down</span><span class="p">,</span> <span class="n">count</span><span class="o">.</span><span class="n">set</span>
</pre></div>
</div>
<p>ここで、<code class="docutils literal notranslate"><span class="pre">inc()</span></code>、<code class="docutils literal notranslate"><span class="pre">dec()</span></code>、<code class="docutils literal notranslate"><span class="pre">reset()</span></code> は同じカウント変数を共有する関数のようにふるまいます。</p>
</section>
<section id="how-do-i-copy-an-object-in-python">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">Python のオブジェクトはどのようにコピーしますか？</a><a class="headerlink" href="#how-do-i-copy-an-object-in-python" title="Link to this heading">¶</a></h3>
<p>一般的に、普通は <a class="reference internal" href="../library/copy.html#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a> や <a class="reference internal" href="../library/copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a> を試してください。何でもコピーできるとは限りませんが、たいていはできます。</p>
<p>もっと簡単にコピーできるオブジェクトもあります。辞書には <a class="reference internal" href="../library/stdtypes.html#dict.copy" title="dict.copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code></a> メソッドがあります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">newdict</span> <span class="o">=</span> <span class="n">olddict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
<p>シーケンスはスライシングでコピーできます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">new_l</span> <span class="o">=</span> <span class="n">l</span><span class="p">[:]</span>
</pre></div>
</div>
</section>
<section id="how-can-i-find-the-methods-or-attributes-of-an-object">
<h3><a class="toc-backref" href="#id22" role="doc-backlink">オブジェクトのメソッドや属性はどのように見つけますか？</a><a class="headerlink" href="#how-can-i-find-the-methods-or-attributes-of-an-object" title="Link to this heading">¶</a></h3>
<p>ユーザー定義クラスのインスタンス <code class="docutils literal notranslate"><span class="pre">x</span></code> で、<a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir(x)</span></code></a>,&lt; はインスタンス属性とそのクラスで定義されたメソッドや属性を含む名前のアルファベット順リストを返します。</p>
</section>
<section id="how-can-my-code-discover-the-name-of-an-object">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">コードはどのようにオブジェクトの名前を見つけるのですか？</a><a class="headerlink" href="#how-can-my-code-discover-the-name-of-an-object" title="Link to this heading">¶</a></h3>
<p>概して、オブジェクトは本当は名前を持たないので、見つけることはできません。本質的には、代入とはいつも値に名前を束縛することです。<code class="docutils literal notranslate"><span class="pre">def</span></code> と <code class="docutils literal notranslate"><span class="pre">class</span></code> 文も同じですが、この場合は値はコーラブルです。以下のコードを考えてみましょう:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">&lt;__main__.A object at 0x16D07CC&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;__main__.A object at 0x16D07CC&gt;</span>
</pre></div>
</div>
<p>おそらく、このクラスには名前があります。このクラスは二つの名前に縛られて、名前 <code class="docutils literal notranslate"><span class="pre">B</span></code> を通して呼び出されますが、それでもクラス <code class="docutils literal notranslate"><span class="pre">A</span></code> のインスタンスとして報告されるのです。しかし、両方の名前が同じ値に束縛されている以上、このインスタンスの名前が <code class="docutils literal notranslate"><span class="pre">a</span></code> か <code class="docutils literal notranslate"><span class="pre">b</span></code> か決めることはできないのです。</p>
<p>概して、コードにとってある値の「名前を知っている」事は重要ではありません。あなたがわざと内省的なコードを書いているのでない限り、方針を変えた方がいいかもしれないということになるでしょう。</p>
<p>comp.lang.python で、Fredrik Lundh はこの問題の答えとして素晴らしい喩えをしてくれました:</p>
<blockquote>
<div><p>玄関にいた猫の名前を知るのと同じ方法です: その猫 (オブジェクト) 自体はその名前を言うことができないし、それは実は問題ではありません -- その猫が何と呼ばれているかを知る唯一の方法は、すべての隣人 (名前空間) にその猫 (オブジェクト) が何と呼ばれているかを聞くことです。</p>
<p>……そして、その猫が沢山の名前で知られていたり、逆に全く名前が無かったりしても驚かないでください！</p>
</div></blockquote>
</section>
<section id="what-s-up-with-the-comma-operator-s-precedence">
<h3><a class="toc-backref" href="#id24" role="doc-backlink">カンマ演算子はなぜ優先されるのですか？</a><a class="headerlink" href="#what-s-up-with-the-comma-operator-s-precedence" title="Link to this heading">¶</a></h3>
<p>カンマは Python では演算子ではありません。このセッションを考えてください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;a&quot;</span> <span class="ow">in</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span>
<span class="go">(False, &#39;a&#39;)</span>
</pre></div>
</div>
<p>カンマは演算子ではなく、式の分離子なので、上の式は次の式と同じように評価されます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="s2">&quot;a&quot;</span> <span class="ow">in</span> <span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="s2">&quot;a&quot;</span>
</pre></div>
</div>
<p>こうではありません:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;a&quot;</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>他のさまざまな演算子(<code class="docutils literal notranslate"><span class="pre">=</span></code>、<code class="docutils literal notranslate"><span class="pre">+=</span></code> など)も同じです。これらは真の演算子ではありませんが、代入文の構文上のデリミタです。</p>
</section>
<section id="is-there-an-equivalent-of-c-s-ternary-operator">
<h3><a class="toc-backref" href="#id25" role="doc-backlink">C の &quot;?:&quot; 三項演算子と等価なものはありますか？</a><a class="headerlink" href="#is-there-an-equivalent-of-c-s-ternary-operator" title="Link to this heading">¶</a></h3>
<p>はい、あります。構文は以下のようになります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">on_true</span><span class="p">]</span> <span class="k">if</span> <span class="p">[</span><span class="n">expression</span><span class="p">]</span> <span class="k">else</span> <span class="p">[</span><span class="n">on_false</span><span class="p">]</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">25</span>
<span class="n">small</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">else</span> <span class="n">y</span>
</pre></div>
</div>
<p>この構文が導入された 2.5 以前のバージョンに関しては、論理演算子を使ったこのイディオムが一般的でした:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">expression</span><span class="p">]</span> <span class="ow">and</span> <span class="p">[</span><span class="n">on_true</span><span class="p">]</span> <span class="ow">or</span> <span class="p">[</span><span class="n">on_false</span><span class="p">]</span>
</pre></div>
</div>
<p>しかし、このイディオムは安全ではありません。<em>on_true</em> のブール値が偽であるときに間違った結果を与えることがあります。ですから、いつでも <code class="docutils literal notranslate"><span class="pre">...</span> <span class="pre">if</span> <span class="pre">...</span> <span class="pre">else</span> <span class="pre">...</span></code> 形式を使ったほうが良いです。</p>
</section>
<section id="is-it-possible-to-write-obfuscated-one-liners-in-python">
<h3><a class="toc-backref" href="#id26" role="doc-backlink">Python で解し難いワンライナーを書くことはできますか？</a><a class="headerlink" href="#is-it-possible-to-write-obfuscated-one-liners-in-python" title="Link to this heading">¶</a></h3>
<p>はい。そういうものはたいてい、 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code> の中に <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> がネストされています。Ulf Bartelt によるものを少しアレンジした下の３つの例を見てください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>

<span class="c1"># Primes &lt; 1000</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span><span class="n">y</span><span class="o">*</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">!=</span><span class="mi">0</span><span class="p">,</span>
<span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">:</span><span class="n">y</span><span class="o">%</span><span class="n">x</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))),</span><span class="mi">1</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1000</span><span class="p">)))))</span>

<span class="c1"># First 10 Fibonacci numbers</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="p">:(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">f</span><span class="p">)</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">f</span><span class="p">))</span> <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span><span class="p">:</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))))</span>

<span class="c1"># Mandelbrot set</span>
<span class="nb">print</span><span class="p">((</span><span class="k">lambda</span> <span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="p">,</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="p">,</span><span class="n">IM</span><span class="p">,</span><span class="n">Sx</span><span class="p">,</span><span class="n">Sy</span><span class="p">:</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="n">y</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">,</span>
<span class="n">Iu</span><span class="o">=</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="o">=</span><span class="n">Io</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span><span class="n">Sy</span><span class="o">=</span><span class="n">Sy</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="k">lambda</span> <span class="n">yc</span><span class="p">,</span><span class="n">Iu</span><span class="o">=</span><span class="n">Iu</span><span class="p">,</span><span class="n">Io</span><span class="o">=</span><span class="n">Io</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">IM</span><span class="p">,</span>
<span class="n">Sx</span><span class="o">=</span><span class="n">Sx</span><span class="p">,</span><span class="n">Sy</span><span class="o">=</span><span class="n">Sy</span><span class="p">:</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">xc</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">yc</span><span class="o">=</span><span class="n">yc</span><span class="p">,</span><span class="n">Ru</span><span class="o">=</span><span class="n">Ru</span><span class="p">,</span><span class="n">Ro</span><span class="o">=</span><span class="n">Ro</span><span class="p">,</span>
<span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">Sx</span><span class="o">=</span><span class="n">Sx</span><span class="p">,</span><span class="n">F</span><span class="o">=</span><span class="k">lambda</span> <span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="k">lambda</span> <span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="p">:(</span><span class="n">k</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span><span class="ow">or</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span>
<span class="o">&gt;=</span><span class="mf">4.0</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">1</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">xc</span><span class="p">,</span><span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">yc</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">f</span><span class="p">):</span><span class="n">f</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">f</span><span class="p">):</span><span class="nb">chr</span><span class="p">(</span>
<span class="mi">64</span><span class="o">+</span><span class="n">F</span><span class="p">(</span><span class="n">Ru</span><span class="o">+</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">Ro</span><span class="o">-</span><span class="n">Ru</span><span class="p">)</span><span class="o">/</span><span class="n">Sx</span><span class="p">,</span><span class="n">yc</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">)),</span><span class="nb">range</span><span class="p">(</span><span class="n">Sx</span><span class="p">))):</span><span class="n">L</span><span class="p">(</span><span class="n">Iu</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">Io</span><span class="o">-</span><span class="n">Iu</span><span class="p">)</span><span class="o">/</span><span class="n">Sy</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Sy</span>
<span class="p">))))(</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">24</span><span class="p">))</span>
<span class="c1">#    \___ ___/  \___ ___/  |   |   |__ lines on screen</span>
<span class="c1">#        V          V      |   |______ columns on screen</span>
<span class="c1">#        |          |      |__________ maximum of &quot;iterations&quot;</span>
<span class="c1">#        |          |_________________ range on y axis</span>
<span class="c1">#        |____________________________ range on x axis</span>
</pre></div>
</div>
<p>よい子はまねしないでね！</p>
</section>
<section id="what-does-the-slash-in-the-parameter-list-of-a-function-mean">
<span id="faq-positional-only-arguments"></span><h3><a class="toc-backref" href="#id27" role="doc-backlink">関数の引数リストにあるスラッシュ (/) は何を意味しますか？</a><a class="headerlink" href="#what-does-the-slash-in-the-parameter-list-of-a-function-mean" title="Link to this heading">¶</a></h3>
<p>パラメータ関数の仮引数にあるスラッシュは、それより前にある仮引数は位置専用引数であることを示します。
位置専用引数は、外で使える名前を持たない仮引数です。
位置専用引数を受け付ける関数の呼び出しにおいて、実引数はその位置だけに基づいて仮引数に対応付けられます。
例えば、 <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> は位置専用引数を受け付けます。
そのドキュメントは次のようになります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="nb">divmod</span><span class="p">)</span>
<span class="go">Help on built-in function divmod in module builtins:</span>

<span class="go">divmod(x, y, /)</span>
<span class="go">    Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.</span>
</pre></div>
</div>
<p>この引数リストの末尾にスラッシュは、この2つの仮引数が両方とも位置専用引数であることを意味します。
したがって、<a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> をキーワード引数を使って呼び出すとエラーになります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">divmod</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">divmod() takes no keyword arguments</span>
</pre></div>
</div>
</section>
</section>
<section id="numbers-and-strings">
<h2><a class="toc-backref" href="#id28" role="doc-backlink">数と文字列</a><a class="headerlink" href="#numbers-and-strings" title="Link to this heading">¶</a></h2>
<section id="how-do-i-specify-hexadecimal-and-octal-integers">
<h3><a class="toc-backref" href="#id29" role="doc-backlink">十六進数や八進数を指定するにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-specify-hexadecimal-and-octal-integers" title="Link to this heading">¶</a></h3>
<p>八進数を指定するには、八進数での値の先頭に 0 と &quot;o&quot; (小文字または大文字) を加えてください。たとえば、変数 &quot;a&quot; に八進数での &quot;10&quot; (十進数での&quot;8&quot;) を代入するには、こう打ってください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mo">0o10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">8</span>
</pre></div>
</div>
<p>十六進数も簡単です。ただ十六進数での値の先頭に 0 と &quot;x&quot; (小文字または大文字) を加えてください。十六進数は小文字でも大文字でも指定できます。たとえば、Python インタプリタで:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mh">0xa5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">165</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mh">0XB2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">178</span>
</pre></div>
</div>
</section>
<section id="why-does-22-10-return-3">
<h3><a class="toc-backref" href="#id30" role="doc-backlink">なぜ -22 // 10 は -3 を返すのですか？</a><a class="headerlink" href="#why-does-22-10-return-3" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></code> が <code class="docutils literal notranslate"><span class="pre">j</span></code> と同じ符号であってほしいことに基づいています。それに加えて以下のようにもしたいとすると:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="n">i</span> <span class="o">//</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
<p>整数除算は床を返すことになります。C にも C の一貫性があって、<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></code> が <code class="docutils literal notranslate"><span class="pre">i</span></code> と同じ符号を持つように <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">//</span> <span class="pre">j</span></code> を丸めています。</p>
<p><code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></code> は、<code class="docutils literal notranslate"><span class="pre">j</span></code> が負の時には実際にはほとんど使いません。<code class="docutils literal notranslate"><span class="pre">j</span></code> が正なら、たくさん使います。その事実上すべての場合、<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">j</span></code> は <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">0</span></code> となる方が便利です。時計が 10 時を指している時、その 200 時間前は何時でしょうか。<code class="docutils literal notranslate"><span class="pre">-190</span> <span class="pre">%</span> <span class="pre">12</span> <span class="pre">==</span> <span class="pre">2</span></code> となるのが便利です。<code class="docutils literal notranslate"><span class="pre">-190</span> <span class="pre">%</span> <span class="pre">12</span> <span class="pre">==</span> <span class="pre">-10</span></code> は噛み付きかねないバグです。</p>
</section>
<section id="how-do-i-get-int-literal-attribute-instead-of-syntaxerror">
<h3><a class="toc-backref" href="#id31" role="doc-backlink">どうすれば SyntaxError を起こさずに整数リテラルの属性を得られますか？</a><a class="headerlink" href="#how-do-i-get-int-literal-attribute-instead-of-syntaxerror" title="Link to this heading">¶</a></h3>
<p>ふつうの方法で <code class="docutils literal notranslate"><span class="pre">int</span></code> リテラルの属性を探そうとすると、ピリオドが小数点とみなされ、<a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> となります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">1.</span><span class="vm">__class__</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="gr">  1.__class__</span>
<span class="gr">   ^</span>
<span class="gr">SyntaxError</span>: <span class="n">invalid decimal literal</span>
</pre></div>
</div>
<p>解決策は、リテラルとピリオドを スペースや括弧で分けることです。</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;class &#39;int&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;class &#39;int&#39;&gt;</span>
</pre></div>
</div>
</section>
<section id="how-do-i-convert-a-string-to-a-number">
<h3><a class="toc-backref" href="#id32" role="doc-backlink">文字列を数に変換するにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-convert-a-string-to-a-number" title="Link to this heading">¶</a></h3>
<p>整数に変換するには、組み込みの <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 型コンストラクタを使ってください。例えば、 <code class="docutils literal notranslate"><span class="pre">int('144')</span> <span class="pre">==</span> <span class="pre">144</span></code> です。同様に、 <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> は浮動小数点に変換します。例えば、 <code class="docutils literal notranslate"><span class="pre">float('144')</span> <span class="pre">==</span> <span class="pre">144.0</span></code> です。</p>
<p>デフォルトでは、これらは数を十進数として解釈するので、 <code class="docutils literal notranslate"><span class="pre">int('0144')</span> <span class="pre">==</span> <span class="pre">144</span></code> は成立しますが <code class="docutils literal notranslate"><span class="pre">int('0x144')</span></code> は <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> を送出します。 <code class="docutils literal notranslate"><span class="pre">int(string,</span> <span class="pre">base)</span></code> はオプションの第二引数をとって変換元の基数にします。つまり <code class="docutils literal notranslate"><span class="pre">int(</span> <span class="pre">'0x144',</span> <span class="pre">16)</span> <span class="pre">==</span> <span class="pre">324</span></code> です。基数が 0 と指定された場合、その数は Python の基準によって解釈されます。先頭が '0o' なら八進数で、'0x' なら十六進数を表します。</p>
<p>文字列を数に変換するだけのために <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> を使わないでください。 <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> は特に遅いですし、セキュリティ上のリスクもあります。求められない副作用を持つような Python の式を渡そうとする人がいるかも知れません。例えば、あなたのホームディレクトリを消去する <code class="docutils literal notranslate"><span class="pre">__import__('os').system(&quot;rm</span> <span class="pre">-rf</span> <span class="pre">$HOME&quot;)</span></code> を渡そうとする人がいるかも知れません。</p>
<p><a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> にも数を Python の式として解釈する機能があります。だから例えば、 <code class="docutils literal notranslate"><span class="pre">eval('09')</span></code> は構文エラー起こします。Python は ('0' 以外の) 十進数を '0' で始めてはならないからです。</p>
</section>
<section id="how-do-i-convert-a-number-to-a-string">
<h3><a class="toc-backref" href="#id33" role="doc-backlink">数を文字列に変換するにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-convert-a-number-to-a-string" title="Link to this heading">¶</a></h3>
<p>例えば、<code class="docutils literal notranslate"><span class="pre">144</span></code> という数を <code class="docutils literal notranslate"><span class="pre">'144'</span></code> という文字列に変換したいなら、組み込み型のコンストラクタ <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> を使ってください。
十六進数や八進数にしたければ、組み込み関数の <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a> や <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a> を使ってください。
手の込んだフォーマット形式を使うなら、 <a class="reference internal" href="../reference/lexical_analysis.html#f-strings"><span class="std std-ref">f-strings</span></a> と <a class="reference internal" href="../library/string.html#formatstrings"><span class="std std-ref">書式指定文字列の文法</span></a> の節を参照してください。
例えば、 <code class="docutils literal notranslate"><span class="pre">&quot;{:04d}&quot;.format(144)</span></code> は <code class="docutils literal notranslate"><span class="pre">'0144'</span></code> になり、 <code class="docutils literal notranslate"><span class="pre">&quot;{:.3f}&quot;.format(1.0/3.0)</span></code> は <code class="docutils literal notranslate"><span class="pre">'0.333'</span></code> になります。</p>
</section>
<section id="how-do-i-modify-a-string-in-place">
<h3><a class="toc-backref" href="#id34" role="doc-backlink">文字列をインプレースに変更するにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-modify-a-string-in-place" title="Link to this heading">¶</a></h3>
<p>文字列はイミュータブルなので、それはできません。殆どの場合、組み立てたい個別の部品から単純に新しい文字列を構成するべきです。しかし、Unicode データをインプレースに変更できるオブジェクトが必要なら、 <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> モジュールの <a class="reference internal" href="../library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> オブジェクトを試してください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Hello, world&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="go">&#39;Hello, world&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;there!&quot;</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sio</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="go">&#39;Hello, there!&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array(&#39;u&#39;, &#39;Hello, world&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array(&#39;u&#39;, &#39;yello, world&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">tounicode</span><span class="p">()</span>
<span class="go">&#39;yello, world&#39;</span>
</pre></div>
</div>
</section>
<section id="how-do-i-use-strings-to-call-functions-methods">
<h3><a class="toc-backref" href="#id35" role="doc-backlink">関数やメソッドを呼ぶのに文字列を使うにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-use-strings-to-call-functions-methods" title="Link to this heading">¶</a></h3>
<p>様々なテクニックがあります。</p>
<ul>
<li><p>一番いいのは、文字列を関数に対応させる辞書を使うことです。このテクニックの一番の利点は、文字列が関数の名前と同じ必要がないことです。この方法は case 構造をエミュレートするための一番のテクニックでもあります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">a</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">b</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="n">dispatch</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;go&#39;</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">:</span> <span class="n">b</span><span class="p">}</span>  <span class="c1"># Note lack of parens for funcs</span>

<span class="n">dispatch</span><span class="p">[</span><span class="n">get_input</span><span class="p">()]()</span>  <span class="c1"># Note trailing parens to call function</span>
</pre></div>
</div>
</li>
<li><p>組み込み関数の <a class="reference internal" href="../library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> を使う方法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">foo</span>
<span class="nb">getattr</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)()</span>
</pre></div>
</div>
<p>なお、 <a class="reference internal" href="../library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> はクラス、クラスインスタンス、モジュールなど、どんなオブジェクトにも使えます。</p>
<p>これは標準ライブラリでも何箇所か使われています。このように:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">do_foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">do_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">foo_instance</span><span class="p">,</span> <span class="s1">&#39;do_&#39;</span> <span class="o">+</span> <span class="n">opname</span><span class="p">)</span>
<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
</li>
<li><p><a class="reference internal" href="../library/functions.html#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> を使って関数名を決める方法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">myFunc</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>

<span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;myFunc&quot;</span>

<span class="n">f</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">fname</span><span class="p">]</span>
<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="is-there-an-equivalent-to-perl-s-chomp-for-removing-trailing-newlines-from-strings">
<h3><a class="toc-backref" href="#id36" role="doc-backlink">文字列から後端の改行を取り除く Perl の chomp() に相当するものはありますか？</a><a class="headerlink" href="#is-there-an-equivalent-to-perl-s-chomp-for-removing-trailing-newlines-from-strings" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">S.rstrip(&quot;\r\n&quot;)</span></code> を使って文字列 <code class="docutils literal notranslate"><span class="pre">S</span></code> の終端から他の空白文字を取り除くことなくすべての行末記号を取り除くことができます。文字列 <code class="docutils literal notranslate"><span class="pre">S</span></code> が複数行を表し、終端に空行があるとき、そのすべての空行も取り除かれます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;line 1 </span><span class="se">\r\n</span><span class="s2">&quot;</span>
<span class="gp">... </span>         <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span>
<span class="gp">... </span>         <span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\r</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&#39;line 1 &#39;</span>
</pre></div>
</div>
<p>これは典型的に一度に一行ずつテキストを読みたい時にのみ使われるので、<code class="docutils literal notranslate"><span class="pre">S.rstrip()</span></code> をこの方法で使うとうまくいきます。</p>
</section>
<section id="is-there-a-scanf-or-sscanf-equivalent">
<h3><a class="toc-backref" href="#id37" role="doc-backlink">scanf() や sscanf() と同等なものはありますか？</a><a class="headerlink" href="#is-there-a-scanf-or-sscanf-equivalent" title="Link to this heading">¶</a></h3>
<p>そのようなものはありません。</p>
<p>簡単な入力解析で、多くの場合に一番簡単な方法は、文字列オブジェクトの <a class="reference internal" href="../library/stdtypes.html#str.split" title="str.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> メソッドで行を空白文字で区切られた単語に分け、十進数の文字列を <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> や <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> で数値に変換することです。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code> にはオプションの &quot;sep&quot; 変数があり、行に空白文字以外の区切りを使っているときに便利です。</p>
<p>もっと複雑な入力解析をしたいなら、C の <code class="docutils literal notranslate"><span class="pre">sscanf</span></code> よりも正規表現の方が便利ですし、この処理に向いています。</p>
</section>
<section id="what-does-unicodedecodeerror-or-unicodeencodeerror-error-mean">
<h3><a class="toc-backref" href="#id38" role="doc-backlink">'UnicodeDecodeError' や 'UnicodeEncodeError' はどういう意味ですか？</a><a class="headerlink" href="#what-does-unicodedecodeerror-or-unicodeencodeerror-error-mean" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="../howto/unicode.html#unicode-howto"><span class="std std-ref">Unicode HOWTO</span></a> を参照して下さい。</p>
</section>
<section id="can-i-end-a-raw-string-with-an-odd-number-of-backslashes">
<span id="faq-programming-raw-string-backslash"></span><h3><a class="toc-backref" href="#id39" role="doc-backlink">raw string を奇数個のバックスラッシュで終えることはできますか？</a><a class="headerlink" href="#can-i-end-a-raw-string-with-an-odd-number-of-backslashes" title="Link to this heading">¶</a></h3>
<p>奇数個のバックスラッシュで終わる raw string は文字列のクォートをエスケープします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">r</span><span class="s1">&#39;C:\this\will\not\work</span><span class="se">\&#39;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="w">    </span><span class="sa">r</span><span class="s1">&#39;C:\this\will\not\work</span><span class="se">\&#39;</span>
<span class="w">         </span><span class="pm">^</span>
<span class="gr">SyntaxError</span>: <span class="n">unterminated string literal (detected at line 1)</span>
</pre></div>
</div>
<p>これにはいくつかの回避策があります。ひとつは通常文字列と二重バックスラッシュを使うことです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;C:</span><span class="se">\\</span><span class="s1">this</span><span class="se">\\</span><span class="s1">will</span><span class="se">\\</span><span class="s1">work</span><span class="se">\\</span><span class="s1">&#39;</span>
<span class="go">&#39;C:\\this\\will\\work\\&#39;</span>
</pre></div>
</div>
<p>もうひとつは、エスケープされたバックスラッシュを含む通常の文字列を、 raw string に連結します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">r</span><span class="s1">&#39;C:\this\will\work&#39;</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span>
<span class="go">&#39;C:\\this\\will\\work\\&#39;</span>
</pre></div>
</div>
<p>Windowsでは、 <a class="reference internal" href="../library/os.path.html#os.path.join" title="os.path.join"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.path.join()</span></code></a> を使ってバックスラッシュを追加することもできます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;C:\this\will\work&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="go">&#39;C:\\this\\will\\work\\&#39;</span>
</pre></div>
</div>
<p>注意点として、バックスラッシュは raw string 終端のクォートを「エスケープ」しますが、 raw string の値を解釈する際にはエスケープが生じません。つまり、バックスラッシュは raw string 値の中に残ったままになります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">r</span><span class="s1">&#39;backslash</span><span class="se">\&#39;</span><span class="s1">preserved&#39;</span>
<span class="go">&quot;backslash\\&#39;preserved&quot;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/lexical_analysis.html#strings"><span class="std std-ref">言語リファレンス</span></a> の仕様も参照してください。</p>
</section>
</section>
<section id="performance">
<h2><a class="toc-backref" href="#id40" role="doc-backlink">性能</a><a class="headerlink" href="#performance" title="Link to this heading">¶</a></h2>
<section id="my-program-is-too-slow-how-do-i-speed-it-up">
<h3><a class="toc-backref" href="#id41" role="doc-backlink">プログラムが遅すぎます。どうしたら速くなりますか？</a><a class="headerlink" href="#my-program-is-too-slow-how-do-i-speed-it-up" title="Link to this heading">¶</a></h3>
<p>これは、一般的に難しい問題です。まず、先に進む前に覚えておいて欲しいことをここに挙げます:</p>
<ul class="simple">
<li><p>性能の傾向は Python 実装によって変わります。この FAQ では <a class="reference internal" href="../glossary.html#term-CPython"><span class="xref std std-term">CPython</span></a> に焦点を当てます。</p></li>
<li><p>振る舞いはオペレーティングシステムによって変わりえます。特に、I/O やマルチスレッドに関しては顕著です。</p></li>
<li><p>常に、コードの最適化を始める <em>前に</em> プログラムのホットスポットを見つけるべきです (<a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a> モジュールを参照してください)。</p></li>
<li><p>ベンチマークスクリプトを書くことで、改善箇所の捜索を素早く繰り返せます (<a class="reference internal" href="../library/timeit.html#module-timeit" title="timeit: Measure the execution time of small code snippets."><code class="xref py py-mod docutils literal notranslate"><span class="pre">timeit</span></code></a> モジュールを参照してください)。</p></li>
<li><p>洗練された最適化に隠れたリグレッションの可能性を生む前に、(ユニットテストやその他の技法で) コードカバレッジを上げることを強く推奨します。</p></li>
</ul>
<p>とは言っても、Python コードを高速化する技法はたくさんあります。ここでは、満足な性能のレベルにたどり着くまでの長い道のりを進む、一般的な方針を示します:</p>
<ul class="simple">
<li><p>コード中に細かい最適化の技法をばらまこうとするよりも、アルゴリズムを高速化 (または高速なアルゴリズムに変更) するほうが、大きな利益を生むことがあります。</p></li>
<li><p>適切なデータ構造を使ってください。<a class="reference internal" href="../library/stdtypes.html#bltin-types"><span class="std std-ref">組み込み型</span></a> や <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> を調べてください。</p></li>
<li><p>何かをするための基本要素が標準ライブラリにあるなら、自分で発明した代用品よりもそちらのほうが、(絶対にとは言えませんが) おそらく速いです。
それが組み込み型やある種の拡張型のように C で書かれたものならなおさらです。
たとえば、ソートするには、必ず <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> 組み込みメソッドか <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> 関数を使ってください (また、中程度に高度な例は、 <a class="reference internal" href="../howto/sorting.html#sortinghowto"><span class="std std-ref">Sorting Techniques</span></a> を参照してください)。</p></li>
<li><p>抽象化は、遠回りにしがちで、インタプリタの作業を増やすことになります。この遠回りさが、なされる作業の量より重大になると、プログラムが遅くなってしまいます。過度な抽象化、特に細かい関数やメソッドの形で現れるもの (これは読みにくさも落とします) は防ぐべきです。</p></li>
</ul>
<p>pure Python にできる限界に達したなら、更に進むためのツールがあります。例えば、<a class="reference external" href="https://cython.org">Cython</a> は、Python コードのわずかに変形した版を C 拡張にコンパイルし、多種のプラットフォームで使えます。Cython は、コンパイル (と任意の型アノテーション) を利用し、コードの解釈を大幅に速くします。C プログラミングに自信があるなら、自分で <a class="reference internal" href="../extending/index.html#extending-index"><span class="std std-ref">write a C extension module</span></a> こともできます。</p>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference external" href="https://wiki.python.org/moin/PythonSpeed/PerformanceTips">パフォーマンス tips</a> が載っている wiki のページ。</p>
</div>
</section>
<section id="what-is-the-most-efficient-way-to-concatenate-many-strings-together">
<span id="efficient-string-concatenation"></span><h3><a class="toc-backref" href="#id42" role="doc-backlink">多くの文字列を結合するのに最も効率的な方法は何ですか？</a><a class="headerlink" href="#what-is-the-most-efficient-way-to-concatenate-many-strings-together" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> および <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> オブジェクトはイミュータブルなので、多くの文字列の結合は結合ごとに新しいオブジェクトを作成し、効率が悪いです。
一般的に、全体の実行時間のコストは文字列の長さの二乗に比例します。</p>
<p>多くの <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> オブジェクトを累積するのにおすすめのイディオムは、すべてをリストに配置してから最後に <a class="reference internal" href="../library/stdtypes.html#str.join" title="str.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.join()</span></code></a> を呼び出すことです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">my_strings</span><span class="p">:</span>
    <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
</pre></div>
</div>
<p>(他の割と効率的なイディオムは、 <a class="reference internal" href="../library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> を使うことです)</p>
<p>多くの <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> オブジェクトを累積するのにおすすめのイディオムは、 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> オブジェクトをインプレース結合 (<code class="docutils literal notranslate"><span class="pre">+=</span></code> 演算子) で拡張することです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
<span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">my_bytes_objects</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">b</span>
</pre></div>
</div>
</section>
</section>
<section id="sequences-tuples-lists">
<h2><a class="toc-backref" href="#id43" role="doc-backlink">シーケンス(タプル/リスト)</a><a class="headerlink" href="#sequences-tuples-lists" title="Link to this heading">¶</a></h2>
<section id="how-do-i-convert-between-tuples-and-lists">
<h3><a class="toc-backref" href="#id44" role="doc-backlink">タプル、リスト間の変更はどのようにするのですか？</a><a class="headerlink" href="#how-do-i-convert-between-tuples-and-lists" title="Link to this heading">¶</a></h3>
<p>型コンストラクタ <code class="docutils literal notranslate"><span class="pre">tuple(seq)</span></code> はすべてのシーケンス (実際には、すべてのイテラブル) を同じ要素、同じ順序のタプルに変換します。</p>
<p>例えば、 <code class="docutils literal notranslate"><span class="pre">tuple([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></code> は <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></code> を与え、 <code class="docutils literal notranslate"><span class="pre">tuple('abc')</span></code> は <code class="docutils literal notranslate"><span class="pre">('a',</span> <span class="pre">'b',</span> <span class="pre">'c')</span></code> を与えます。引数がタプルなら、コピーを作らずに引数のオブジェクトそのものを返すので、あるオブジェクトが既にタプルになっているか確信が持てないのなら、 <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">tuple()</span></code></a> を呼ぶのが手軽です。</p>
<p>型コンストラクタ <code class="docutils literal notranslate"><span class="pre">list(seq)</span></code> はすべてのシーケンスあるいはイテラブルを同じ要素、同じ順序のリストに変換します。例えば、<code class="docutils literal notranslate"><span class="pre">list((1,</span> <span class="pre">2,</span> <span class="pre">3))</span></code> は <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> を与え、<code class="docutils literal notranslate"><span class="pre">list('abc')</span></code> は <code class="docutils literal notranslate"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></code> を与えます。引数がリストなら、<code class="docutils literal notranslate"><span class="pre">seq[:]</span></code> と同様にコピーを作ります。</p>
</section>
<section id="what-s-a-negative-index">
<h3><a class="toc-backref" href="#id45" role="doc-backlink">負の添え字は何ですか？</a><a class="headerlink" href="#what-s-a-negative-index" title="Link to this heading">¶</a></h3>
<p>Python のシーケンスは正の数と負の数でインデクスされます。正の数では、0 が最初のインデクス、1 が 2 番目のインデクス、以下も同様です。負のインデクスでは、-1 が最後のインデクス、-2 が最後から 2 番目のインデクス、以下も同様です。<code class="docutils literal notranslate"><span class="pre">seq[-n]</span></code> は <code class="docutils literal notranslate"><span class="pre">seq[len(seq)-n]</span></code> と同じだと考えてください。</p>
<p>負のインデクスを使うと便利なことがあります。例えば、<code class="docutils literal notranslate"><span class="pre">S[:-1]</span></code> は文字列の最後以外のすべての文字を表すので、文字列の末尾の改行を取り除くときに便利です。</p>
</section>
<section id="how-do-i-iterate-over-a-sequence-in-reverse-order">
<h3><a class="toc-backref" href="#id46" role="doc-backlink">シーケンスを逆順にイテレートするにはどうしたらいいですか？</a><a class="headerlink" href="#how-do-i-iterate-over-a-sequence-in-reverse-order" title="Link to this heading">¶</a></h3>
<p>組み込み関数 <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> を使ってください。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
    <span class="o">...</span>  <span class="c1"># do something with x ...</span>
</pre></div>
</div>
<p>これは元のシーケンスをいじるのではなく、逆順の新しいコピーを作ってイテレートさせます。</p>
</section>
<section id="how-do-you-remove-duplicates-from-a-list">
<h3><a class="toc-backref" href="#id47" role="doc-backlink">リストから重複を取り除くにはどうしますか？</a><a class="headerlink" href="#how-do-you-remove-duplicates-from-a-list" title="Link to this heading">¶</a></h3>
<p>Python Cookbook の長い議論に多くの方法があるので参照してください:</p>
<blockquote>
<div><p><a class="reference external" href="https://code.activestate.com/recipes/52560/">https://code.activestate.com/recipes/52560/</a></p>
</div></blockquote>
<p>リストを並び替えて構わないのなら、ソートした上でリストの最初から最後までを調べ、次のように重複を削除してください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">mylist</span><span class="p">:</span>
    <span class="n">mylist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">mylist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mylist</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">last</span> <span class="o">==</span> <span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">del</span> <span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">mylist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>リストのすべての要素が集合のキーとして使える (つまり、すべての要素が <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>) なら、おそらくこのほうが速いです</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">mylist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">mylist</span><span class="p">))</span>
</pre></div>
</div>
<p>リストを集合に変換するときに重複は取り除かれるので、それをリストに戻せばいいのです。</p>
</section>
<section id="how-do-you-remove-multiple-items-from-a-list">
<h3><a class="toc-backref" href="#id48" role="doc-backlink">リストから複数のアイテムを取り除く方法</a><a class="headerlink" href="#how-do-you-remove-multiple-items-from-a-list" title="Link to this heading">¶</a></h3>
<p>重複除去と同様に、削除条件を付けて明示的に逆回すのも一つの方法です。ですが、明示的/暗黙的な反復でスライス置換する方が速くて簡単です。こちらは３つのバリエーションです。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">mylist</span><span class="p">[:]</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="n">keep_function</span><span class="p">,</span> <span class="n">mylist</span><span class="p">)</span>
<span class="n">mylist</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mylist</span> <span class="k">if</span> <span class="n">keep_condition</span><span class="p">)</span>
<span class="n">mylist</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mylist</span> <span class="k">if</span> <span class="n">keep_condition</span><span class="p">]</span>
</pre></div>
</div>
<p>リスト内包表記がおそらく最も高速です。</p>
</section>
<section id="how-do-you-make-an-array-in-python">
<h3><a class="toc-backref" href="#id49" role="doc-backlink">Python で配列を作るにはどうしますか？</a><a class="headerlink" href="#how-do-you-make-an-array-in-python" title="Link to this heading">¶</a></h3>
<p>リストを使ってください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s2">&quot;this&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="s2">&quot;an&quot;</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>リストの時間計算量は C や Pascal の配列と同じです。大きな違いは、Python のリストは多くの異なる型のオブジェクトを含めることです。</p>
<p><code class="docutils literal notranslate"><span class="pre">array</span></code> モジュールにも固定された型を簡潔に表現する配列を作るためのメソッドがありますが、リストよりもインデクスが遅いです。また、<a class="reference external" href="https://numpy.org/">NumPy</a> やその他のサードパーティー拡張でも、様々な特徴をもつ配列的な構造体が定義されています。</p>
<p>Lisp 方式の連結リストを得るのに、タプルを使って <em>cons cells</em> をエミュレートできます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">lisp_list</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;like&quot;</span><span class="p">,</span>  <span class="p">(</span><span class="s2">&quot;this&quot;</span><span class="p">,</span>  <span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>ミュータブルな必要があるなら、タプルではなくリストを使いましょう。Lisp の <em>car</em> にあたるものが <code class="docutils literal notranslate"><span class="pre">lisp_list[0]</span></code> で、cdr にあたるものが <code class="docutils literal notranslate"><span class="pre">lisp_list[1]</span></code> です。本当に必要だと確信できるとき以外はこれはしないでください。たいてい、これは Python のリストを使うよりも非常に遅いですから。</p>
</section>
<section id="how-do-i-create-a-multidimensional-list">
<span id="faq-multidimensional-list"></span><h3><a class="toc-backref" href="#id50" role="doc-backlink">多次元のリストを作るにはどうしますか？</a><a class="headerlink" href="#how-do-i-create-a-multidimensional-list" title="Link to this heading">¶</a></h3>
<p>このようにして多次元の配列を作ろうとしてしまったことがあるでしょう:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
</pre></div>
</div>
<p>これを表示したときには問題なさそうに見えます:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">[[None, None], [None, None], [None, None]]</span>
</pre></div>
</div>
<p>しかし値を代入すると、その値が複数の場所に現れてしまいます:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">[[5, None], [5, None], [5, None]]</span>
</pre></div>
</div>
<p>これは、<code class="docutils literal notranslate"><span class="pre">*</span></code> を使ったリストの複製がコピーを作らず、存在するオブジェクトへの参照を作るだけだからです。この <code class="docutils literal notranslate"><span class="pre">*3</span></code> は長さ 2 の同じリストへの参照を含むリストを作ります。一つの列に対する変更はすべての列に現れますが、これが望んだ結果であることはまずないでしょう。</p>
<p>おすすめの方法は、最初に望んだ長さのリストを作り、それから新しく作ったリストでそれぞれの要素を埋めていくことです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
</pre></div>
</div>
<p>これは長さ 2 の異なるリスト 3 つを含むリストを生成します。リスト内包表記も使えます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="p">)]</span>
</pre></div>
</div>
<p>あるいは、行列データ型を提供している拡張を使用することもできます; <a class="reference external" href="https://numpy.org/">NumPy</a> が最もよく知られています。</p>
</section>
<section id="how-do-i-apply-a-method-or-function-to-a-sequence-of-objects">
<h3><a class="toc-backref" href="#id51" role="doc-backlink">オブジェクトのシーケンスにメソッドや関数を適用するにはどうしますか？</a><a class="headerlink" href="#how-do-i-apply-a-method-or-function-to-a-sequence-of-objects" title="Link to this heading">¶</a></h3>
<p>メソッドや関数を呼び出して結果を蓄積するのには、 <a class="reference internal" href="../glossary.html#term-list-comprehension"><span class="xref std std-term">list comprehension</span></a> （リスト内包表記） がエレガントな解決策です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">method</span><span class="p">()</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">mylist</span><span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">function</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">mylist</span><span class="p">]</span>
</pre></div>
</div>
<p>戻り値を保存せずにメソッドや関数を実行するだけなら、ただの <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> ループで十分です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">mylist</span><span class="p">:</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">method</span><span class="p">()</span>

<span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">mylist</span><span class="p">:</span>
    <span class="n">function</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works">
<span id="faq-augmented-assignment-tuple-error"></span><h3><a class="toc-backref" href="#id52" role="doc-backlink">なぜ加算はされるのに a_tuple[i] += ['item'] は例外を送出するのですか?</a><a class="headerlink" href="#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works" title="Link to this heading">¶</a></h3>
<p>これは、累算代入演算子は <em>代入</em> 演算子だ、という事実と、Python での可変オブジェクトと不変オブジェクトの違いが組み合わさって起きるのです。</p>
<p>この議論は一般的に、可変オブジェクトを指すタプルの要素に、累算代入演算子が適用されたときにも適用できますが、例として <code class="docutils literal notranslate"><span class="pre">list</span></code> と <code class="docutils literal notranslate"><span class="pre">+=</span></code> を使います。</p>
<p>次のように書いたとします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">   </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
<p>例外が送出された理由は明らかです: <code class="docutils literal notranslate"><span class="pre">1</span></code> が (<code class="docutils literal notranslate"><span class="pre">1</span></code>) を指すオブジェクト <code class="docutils literal notranslate"><span class="pre">a_tuple[0]</span></code> に加えられ、結果のオブジェクト <code class="docutils literal notranslate"><span class="pre">2</span></code> が生成されますが、計算結果 <code class="docutils literal notranslate"><span class="pre">2</span></code> をタプルの第 <code class="docutils literal notranslate"><span class="pre">0</span></code> 要素に代入しようとしたときに、エラーが発生します。なぜならば、タプルの要素が何を指すかは変えられないからです。</p>
<p>このような裏事情の元、累算代入文はだいたい次のようなことをしています:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
<p>タプルは不変なので、例外を生み出しているのは操作の代入部分なのです。</p>
<p>次のように書いたとします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span> <span class="o">=</span> <span class="p">([</span><span class="s1">&#39;foo&#39;</span><span class="p">],</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;item&#39;</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
<p>この例外にはちょっと驚きますが、もっと驚くべきことは、エラーがあったとしても追記はきちんと動いている、という事実です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[&#39;foo&#39;, &#39;item&#39;]</span>
</pre></div>
</div>
<p>なぜこれが起きるかを調べるためには、次の 2 点を知っている必要があります。(a) オブジェクトに <a class="reference internal" href="../reference/datamodel.html#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a> 特殊メソッドが実装されている場合、拡張代入 <code class="docutils literal notranslate"><span class="pre">+=</span></code> が実行されるときにそれが呼び出され、その返り値が代入文で使われます; (b) リストでは、<code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code> は <code class="xref py py-meth docutils literal notranslate"><span class="pre">extend()</span></code> の呼び出しと等価で、リストを返します。こんな理由で、リストでは <code class="docutils literal notranslate"><span class="pre">+=</span></code> は <code class="xref py py-meth docutils literal notranslate"><span class="pre">list.extend()</span></code> の &quot;略記&quot; だと言ったのでした:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span>
<span class="go">[1]</span>
</pre></div>
</div>
<p>これは次と等価です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">a_list</span><span class="o">.</span><span class="fm">__iadd__</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_list</span> <span class="o">=</span> <span class="n">result</span>
</pre></div>
</div>
<p>a_list が指していたオブジェクトは更新され、更新されたオブジェクトへのポインタは再度 <code class="docutils literal notranslate"><span class="pre">a_list</span></code> に代入されます。代入しているのは、<code class="docutils literal notranslate"><span class="pre">a_list</span></code> が更新前まで指していた同じオブジェクトへのポインタなので、代入は最終的には何もしていないのですが、代入処理自体は起きています。</p>
<p>従って、今のタプルの例では、次のと同じことが起きています:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="fm">__iadd__</span><span class="p">([</span><span class="s1">&#39;item&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;tuple&#39; object does not support item assignment</span>
</pre></div>
</div>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code> は成功し、リストは拡張 (extend) されますが、<code class="docutils literal notranslate"><span class="pre">result</span></code> が <code class="docutils literal notranslate"><span class="pre">a_tuple[0]</span></code> が既に指しているオブジェクトと同じオブジェクトを指していたとしても、タプルは不変なので、その最後の代入はやはりエラーとなります。</p>
</section>
<section id="i-want-to-do-a-complicated-sort-can-you-do-a-schwartzian-transform-in-python">
<h3><a class="toc-backref" href="#id53" role="doc-backlink">複雑なソートがしたいのですが、Python でシュワルツ変換はできますか？</a><a class="headerlink" href="#i-want-to-do-a-complicated-sort-can-you-do-a-schwartzian-transform-in-python" title="Link to this heading">¶</a></h3>
<p>Perl コミュニティの Randal Schwartz の作とされるこのテクニックは、リストの要素を、それぞれの要素をその「ソート値」に対応付けるメトリックによってソートします。Python では、 <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> メソッドに <code class="docutils literal notranslate"><span class="pre">key</span></code> 引数を使ってください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Isorted</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:]</span>
<span class="n">Isorted</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">15</span><span class="p">]))</span>
</pre></div>
</div>
</section>
<section id="how-can-i-sort-one-list-by-values-from-another-list">
<h3><a class="toc-backref" href="#id54" role="doc-backlink">リストを別のリストの値によってソートするにはどうしますか？</a><a class="headerlink" href="#how-can-i-sort-one-list-by-values-from-another-list" title="Link to this heading">¶</a></h3>
<p>二つのイテレータを混ぜあわせてタプルのイテレータにしてから、必要な要素を選んでください。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">list1</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;what&quot;</span><span class="p">,</span> <span class="s2">&quot;I&#39;m&quot;</span><span class="p">,</span> <span class="s2">&quot;sorting&quot;</span><span class="p">,</span> <span class="s2">&quot;by&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">list2</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;something&quot;</span><span class="p">,</span> <span class="s2">&quot;else&quot;</span><span class="p">,</span> <span class="s2">&quot;to&quot;</span><span class="p">,</span> <span class="s2">&quot;sort&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span>
<span class="go">[(&quot;I&#39;m&quot;, &#39;else&#39;), (&#39;by&#39;, &#39;sort&#39;), (&#39;sorting&#39;, &#39;to&#39;), (&#39;what&#39;, &#39;something&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>
<span class="go">[&#39;else&#39;, &#39;sort&#39;, &#39;to&#39;, &#39;something&#39;]</span>
</pre></div>
</div>
</section>
</section>
<section id="objects">
<h2><a class="toc-backref" href="#id55" role="doc-backlink">オブジェクト</a><a class="headerlink" href="#objects" title="Link to this heading">¶</a></h2>
<section id="what-is-a-class">
<h3><a class="toc-backref" href="#id56" role="doc-backlink">クラスとは何ですか？</a><a class="headerlink" href="#what-is-a-class" title="Link to this heading">¶</a></h3>
<p>クラスは、class 文の実行で生成される特殊なオブジェクトです。クラスオブジェクトはインスタンスオブジェクトを生成するためのテンプレートとして使われ、あるデータ型に特有のデータ (attribute/属性) とコード (メソッド) の両方を内蔵しています。</p>
<p>新しいクラスを一つ以上の他のクラス (新しいクラスの基底クラスと呼ばれます) に基づいて作ることもできます。この新しいクラスは、基底クラスから属性とメソッドを継承します。これにより、オブジェクトモデルを継承で連続的に洗練できます。メールボックスへの基本的なアクセサを提供する一般的な <code class="docutils literal notranslate"><span class="pre">Mailbox</span></code> クラスを作って、それからいろいろな特定のメールボックスの形式を扱う <code class="docutils literal notranslate"><span class="pre">MboxMailbox</span></code>、<code class="docutils literal notranslate"><span class="pre">MaildirMailbox</span></code>、<code class="docutils literal notranslate"><span class="pre">OutlookMailbox</span></code> のようなサブクラスを作れるのです。</p>
</section>
<section id="what-is-a-method">
<h3><a class="toc-backref" href="#id57" role="doc-backlink">メソッドとは何ですか？</a><a class="headerlink" href="#what-is-a-method" title="Link to this heading">¶</a></h3>
<p>メソッドは、オブジェクト <code class="docutils literal notranslate"><span class="pre">x</span></code> が持つ関数で、通常 <code class="docutils literal notranslate"><span class="pre">x.name(arguments...)</span></code> として呼び出されるものです。メソッドはクラス定義の中で関数として定義されます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arg</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attribute</span>
</pre></div>
</div>
</section>
<section id="what-is-self">
<h3><a class="toc-backref" href="#id58" role="doc-backlink">self とは何ですか？</a><a class="headerlink" href="#what-is-self" title="Link to this heading">¶</a></h3>
<p>self はメソッドの第一引数に慣習的につけられる名前にすぎません。<code class="docutils literal notranslate"><span class="pre">meth(self,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> として定義されたメソッドは、その定義がなされたクラスのインスタンス <code class="docutils literal notranslate"><span class="pre">x</span></code> に対して <code class="docutils literal notranslate"><span class="pre">x.meth(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> として呼び出されます。呼び出されたメソッドは、<code class="docutils literal notranslate"><span class="pre">meth(x,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> が呼ばれたものと考えます。</p>
<p><a class="reference internal" href="design.html#why-self"><span class="std std-ref">なぜメソッドの定義や呼び出しにおいて 'self' を明示しなければならないのですか？</span></a> も参照してください。</p>
</section>
<section id="how-do-i-check-if-an-object-is-an-instance-of-a-given-class-or-of-a-subclass-of-it">
<h3><a class="toc-backref" href="#id59" role="doc-backlink">あるオブジェクトが、与えられたクラスやそのサブクラスのインスタンスであるかを調べるにはどうしますか？</a><a class="headerlink" href="#how-do-i-check-if-an-object-is-an-instance-of-a-given-class-or-of-a-subclass-of-it" title="Link to this heading">¶</a></h3>
<p>ビルトイン関数 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">cls)</span></code></a> を使ってください。クラスのタプルを与えて <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">(class1,</span> <span class="pre">class2,</span> <span class="pre">...))</span></code> のようにすれば、あるオブジェクトが任意の数のクラスのオブジェクトであるかを調べられますし、<code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">str)</span></code> や <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">(int,</span> <span class="pre">float,</span> <span class="pre">complex))</span></code> のようにすれば、Python のビルトイン型のオブジェクトであるかも調べられます。</p>
<p>注意： <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> は <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a> (抽象基底クラス)からの仮想継承もチェックします。そのため、登録 (register) されたクラスが直接/間接的にそれを継承していなくても <code class="docutils literal notranslate"><span class="pre">True</span></code> を返します。「真のインスタンス」をテストする場合は、クラスの <a class="reference internal" href="../glossary.html#term-MRO"><span class="xref std std-term">MRO</span></a> を調べます:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span>

<span class="k">class</span> <span class="nc">P</span><span class="p">:</span>
     <span class="k">pass</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">P</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">Mapping</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>        <span class="c1"># direct</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>        <span class="c1"># indirect</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">)</span>  <span class="c1"># virtual</span>
<span class="go">True</span>

<span class="go"># Actual inheritance chain</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="vm">__mro__</span>
<span class="go">(&lt;class &#39;C&#39;&gt;, &lt;class &#39;P&#39;&gt;, &lt;class &#39;object&#39;&gt;)</span>

<span class="go"># Test for &quot;true inheritance&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mapping</span> <span class="ow">in</span> <span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="vm">__mro__</span>
<span class="go">False</span>
</pre></div>
</div>
<p>なお、大部分のプログラムでは、 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> をユーザー定義のクラスに何度も使うべきではありません。クラスを自分で開発するときに、適切なオブジェクト指向スタイルは、特定の振る舞いをカプセル化するクラスのメソッドを定義するものであって、オブジェクトのクラスを調べてそのクラスに応じて違うことをするものではありません。例えば、何かをする関数があったとして:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Mailbox</span><span class="p">):</span>
        <span class="o">...</span>  <span class="c1"># code to search a mailbox</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Document</span><span class="p">):</span>
        <span class="o">...</span>  <span class="c1"># code to search a document</span>
    <span class="k">elif</span> <span class="o">...</span>
</pre></div>
</div>
<p>よりよいアプローチは、<code class="docutils literal notranslate"><span class="pre">search()</span></code> メソッドをすべてのクラスに定義して、それをただ呼び出すことです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mailbox</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>  <span class="c1"># code to search a mailbox</span>

<span class="k">class</span> <span class="nc">Document</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>  <span class="c1"># code to search a document</span>

<span class="n">obj</span><span class="o">.</span><span class="n">search</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="what-is-delegation">
<h3><a class="toc-backref" href="#id60" role="doc-backlink">委譲とは何ですか？</a><a class="headerlink" href="#what-is-delegation" title="Link to this heading">¶</a></h3>
<p>委譲 (delegation) とは、オブジェクト指向のテクニック (デザインパターンとも呼ばれる) の一つです。オブジェクト <code class="docutils literal notranslate"><span class="pre">x</span></code> があって、そのメソッドのうちただ一つの振る舞いを変えたいとしましょう。新しいクラスを作成し、変えたいメソッドだけを新しく実装し、他のすべてのメソッドを <code class="docutils literal notranslate"><span class="pre">x</span></code> の対応するメソッドに委譲する新しいクラスを作れます。</p>
<p>Python プログラマは簡単に委譲を実装できます。例えば、以下のクラスは、ファイルのように振る舞いながらすべての文字を大文字に変換するクラスを実装します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UpperOut</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outfile</span> <span class="o">=</span> <span class="n">outfile</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_outfile</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>ここで <code class="docutils literal notranslate"><span class="pre">UpperOut</span></code> クラスは <code class="docutils literal notranslate"><span class="pre">write()</span></code> メソッドを定義しなおして、引数の文字列を大文字に変換してから基礎となる <code class="docutils literal notranslate"><span class="pre">self._outfile.write()</span></code> メソッドを呼び出すようにします。その他すべてのメソッドは基礎となる <code class="docutils literal notranslate"><span class="pre">self._outfile</span></code> オブジェクトに移譲されます。この委譲は <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> メソッドを通してなされます。属性の制御の詳細は <a class="reference internal" href="../reference/datamodel.html#attribute-access"><span class="std std-ref">言語リファレンス</span></a> を参照してください。</p>
<p>なお、一般的に委譲はトリッキーになりがちです。属性が設定される時には読み出される時と同様に、そのクラスに <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> メソッドを定義する必要があり、それには細心の注意が必要です。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code> の基本的な実装はおおよそ以下のようになります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>たいてい、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code> 実装は <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">self.__dict__</span></code></a> を変更して、無限再帰を起こすことなくローカルな状態を保存するようにしなければなりません。</p>
</section>
<section id="how-do-i-call-a-method-defined-in-a-base-class-from-a-derived-class-that-extends-it">
<h3><a class="toc-backref" href="#id61" role="doc-backlink">基底クラスで定義されたメソッドを、そのクラスを継承した派生クラスから呼び出すにはどうしますか？</a><a class="headerlink" href="#how-do-i-call-a-method-defined-in-a-base-class-from-a-derived-class-that-extends-it" title="Link to this heading">¶</a></h3>
<p>組み込みの <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 関数を使ってください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Derived</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>  <span class="c1"># calls Base.meth</span>
</pre></div>
</div>
<p>この例では、 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> は呼ばれたインスタンス (<code class="docutils literal notranslate"><span class="pre">self</span></code> の値) を自動判断し、 <code class="docutils literal notranslate"><span class="pre">type(self).__mro__</span></code> で <a class="reference internal" href="../glossary.html#term-method-resolution-order"><span class="xref std std-term">method resolution order</span></a> (MRO メソッド解決順) を検索し、そしてMRO内で <code class="docutils literal notranslate"><span class="pre">Derived</span></code> の次行を返します: <code class="docutils literal notranslate"><span class="pre">Base</span></code> 。</p>
</section>
<section id="how-can-i-organize-my-code-to-make-it-easier-to-change-the-base-class">
<h3><a class="toc-backref" href="#id62" role="doc-backlink">基底クラスの名前を変えやすいコードを書くにはどうしますか？</a><a class="headerlink" href="#how-can-i-organize-my-code-to-make-it-easier-to-change-the-base-class" title="Link to this heading">¶</a></h3>
<p>基底クラスをエイリアス (alias) に代入しておいてから、そのエイリアスを継承するといいかもしれません。そうすればエイリアスに代入する値を変えるだけで済みます。ちなみに、この手法は使用する基底クラスを動的に選びたいとき、例えば使えるリソースによって選びたいときなどにも便利です。例:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="o">...</span>

<span class="n">BaseAlias</span> <span class="o">=</span> <span class="n">Base</span>

<span class="k">class</span> <span class="nc">Derived</span><span class="p">(</span><span class="n">BaseAlias</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
</section>
<section id="how-do-i-create-static-class-data-and-static-class-methods">
<h3><a class="toc-backref" href="#id63" role="doc-backlink">静的なクラスデータや静的なクラスメソッドを作るにはどうしますか？</a><a class="headerlink" href="#how-do-i-create-static-class-data-and-static-class-methods" title="Link to this heading">¶</a></h3>
<p>(C++ や Java の意味で) 静的なデータも静的なメソッドも Python でサポートされています。</p>
<p>静的なデータを作るには、単純にクラス属性を定義してください。その属性に新しい値を代入するには、代入するクラス名を明示する必要があります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># number of times C.__init__ called</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">C</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">getcount</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">count</span>  <span class="c1"># or return self.count</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">c</span></code> そのものや <code class="docutils literal notranslate"><span class="pre">c.__class__</span></code> から <code class="docutils literal notranslate"><span class="pre">C</span></code> にいたるパス探索経路上のクラスによってオーバーライドされない限り、<code class="docutils literal notranslate"><span class="pre">c.count</span></code> も <code class="docutils literal notranslate"><span class="pre">isinstance(c,</span> <span class="pre">C)</span></code> であるすべての <code class="docutils literal notranslate"><span class="pre">c</span></code> に対する <code class="docutils literal notranslate"><span class="pre">C.count</span></code> を参照します。</p>
<p>注意: C のメソッド内では、<code class="docutils literal notranslate"><span class="pre">self.count</span> <span class="pre">=</span> <span class="pre">42</span></code> のような代入は <code class="docutils literal notranslate"><span class="pre">self</span></code> 自身の辞書に &quot;count&quot; という名前の新しくて関係ないインスタンスを作ります。クラスの静的なデータの再束縛には、メソッド内であるか否かにかかわらず、いつもクラスを指定しなければなりません:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">314</span>
</pre></div>
</div>
<p>静的メソッドが使えます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">static</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">):</span>
        <span class="c1"># No &#39;self&#39; parameter!</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>しかし、静的メソッドの効果を得るもっと簡単な方法は、単にモジュールレベル関数を使うことです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">getcount</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">count</span>
</pre></div>
</div>
<p>モジュールあたりに一つのクラスを定義するように (あるいはクラス組織を厳密に関連させるように) コードが構成されているなら、これで必要なカプセル化ができます。</p>
</section>
<section id="how-can-i-overload-constructors-or-methods-in-python">
<h3><a class="toc-backref" href="#id64" role="doc-backlink">Python でコンストラクタ(やメソッド)をオーバーロードするにはどうしたらいいですか？</a><a class="headerlink" href="#how-can-i-overload-constructors-or-methods-in-python" title="Link to this heading">¶</a></h3>
<p>この質問の答えはすべてのメソッドについて言えることですが、この質問はだいたい以下の構造の文脈から出てきます。</p>
<p>C++ では、このように書けます</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">class</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">C</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;No arguments</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">C</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Argument is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Python では、一つのコンストラクタでデフォルトの引数を使ってすべての場合に対応するように書かなければなりません。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No arguments&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Argument is&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>これで完全に等価とは言えませんが、実用上は十分に近いです。</p>
<p>長さが変えられる引数のリストを試すには、例えば</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>これと同じやり方がすべてのメソッド定義で使えます。</p>
</section>
<section id="i-try-to-use-spam-and-i-get-an-error-about-someclassname-spam">
<h3><a class="toc-backref" href="#id65" role="doc-backlink">__spam を使おうとしたら _SomeClassName__spam からエラーがでました。</a><a class="headerlink" href="#i-try-to-use-spam-and-i-get-an-error-about-someclassname-spam" title="Link to this heading">¶</a></h3>
<p>先頭にアンダースコアが二つ付いた変数名は、クラスのプライベートな変数を、 &quot;マングル化&quot; という単純かつ効率のいい方法で定義します。<code class="docutils literal notranslate"><span class="pre">__spam</span></code> のような形式 (先頭に二つ以上、末尾にもしあっても一つのアンダースコアがある) のすべての識別子は、<code class="docutils literal notranslate"><span class="pre">classname</span></code> が先頭のアンダースコアをすべて削除した現在のクラス名とすれば、<code class="docutils literal notranslate"><span class="pre">_classname__spam</span></code> のように文字上で置換えられます。</p>
<p>これはプライベートであることを保証するものではありません。これでも外部のユーザが &quot;_classname__spam&quot; 属性に直接アクセスできますし、プライベートな変数はオブジェクトの <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> から見えます。多くの Python プログラマはわざわざプライベートな変数名を使おうとなど考えません。</p>
</section>
<section id="my-class-defines-del-but-it-is-not-called-when-i-delete-the-object">
<h3><a class="toc-backref" href="#id66" role="doc-backlink">クラスに __del__ メソッドを定義しているのですが、オブジェクトを削除したときに呼ばれません。</a><a class="headerlink" href="#my-class-defines-del-but-it-is-not-called-when-i-delete-the-object" title="Link to this heading">¶</a></h3>
<p>いくつかの可能性があります。</p>
<p><a class="reference internal" href="../reference/simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> 文は必ずしも <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> を呼び出すとは限りません -- これは単純にオブジェクトの参照カウントを減らすもので、カウントがゼロになったときに <code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code> が呼び出されます。</p>
<p>データ構造が循環リンク (子のそれぞれが親の参照を持ち、親のそれぞれが子のリストを持つツリーなど) を含む場合、その参照カウントは決して 0 にはなりません。時々、Python はこのようなサイクルを検出するアルゴリズムを実行しますが、データ構造への参照がなくなってからこのガベージコレクタが実行されるまでいくらか時間が掛かるかもしれないので、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code> メソッドは不都合な予期できないタイミングで呼び出されるかもしれません。これは問題を再現しようとするときに不便です。さらに悪いことに、オブジェクトの <code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code> メソッドが実行される順序は任意です。 <a class="reference internal" href="../library/gc.html#gc.collect" title="gc.collect"><code class="xref py py-func docutils literal notranslate"><span class="pre">gc.collect()</span></code></a> を起動して収集を強制することができますが、オブジェクトが決して回収されないような本当に病的な場合も <em>あります</em> 。</p>
<p>循環参照コレクタがあるとはいえ、オブジェクトに <code class="docutils literal notranslate"><span class="pre">close()</span></code> メソッドを明示的に定義し、使い終わったらいつでも呼び出せるようにするのはいいことです。
<code class="docutils literal notranslate"><span class="pre">close()</span></code> メソッドを使うと、サブオブジェクトを参照している属性を取り除けます。
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code> を直接呼び出さないでください -- <code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code> は <code class="docutils literal notranslate"><span class="pre">close()</span></code> を呼び出すでしょうし、 <code class="docutils literal notranslate"><span class="pre">close()</span></code> なら同じオブジェクトに対して複数回呼ばれてもいいことが保証されているでしょう。</p>
<p>循環参照を避ける他の方法は、 <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> モジュールを使って、参照カウントを増やすことなくオブジェクトを示すことです。例えばツリー構造は、親と (必要なら！) 兄弟に弱参照を使うべきです。</p>
<p>最後に、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code> メソッドが例外を発生させた場合、警告のメッセージが <a class="reference internal" href="../library/sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> に書きこまれます。</p>
</section>
<section id="how-do-i-get-a-list-of-all-instances-of-a-given-class">
<h3><a class="toc-backref" href="#id67" role="doc-backlink">与えられたクラスのすべてのインスタンスのリストを得るにはどうしますか？</a><a class="headerlink" href="#how-do-i-get-a-list-of-all-instances-of-a-given-class" title="Link to this heading">¶</a></h3>
<p>Python はクラス (やビルトイン型) のすべてのインスタンスをたどりません。クラスのコンストラクタにそれぞれのインスタンスへの弱参照のリストを作らせることですべてのインスタンスをたどらせられます。</p>
</section>
<section id="why-does-the-result-of-id-appear-to-be-not-unique">
<h3><a class="toc-backref" href="#id68" role="doc-backlink">なぜ <code class="docutils literal notranslate"><span class="pre">id()</span></code> の結果は一意でないように見えるのですか?</a><a class="headerlink" href="#why-does-the-result-of-id-appear-to-be-not-unique" title="Link to this heading">¶</a></h3>
<p>組み込みの <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> は、オブジェクトが生存している間は一意なことが保証されている整数値を返します。 CPython では、それはオブジェクトのメモリアドレスなので、オブジェクトがメモリから削除された後に、次に新しく生成されたオブジェクトはメモリの同じ場所にメモリ領域を確保されていることが、しばしば起きます。この現象を次の例で示しましょう:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> 
<span class="go">13901272</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span> 
<span class="go">13901272</span>
</pre></div>
</div>
<p>2 つの同じ値を持つ id は <code class="docutils literal notranslate"><span class="pre">id()</span></code> の実行の前に作られてすぐさま削除された異なる整数オブジェクトによるものです。id を調べたいオブジェクトがまだ生きてることを保証したいなら、オブジェクトへの別の参照を作ってください:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> 
<span class="go">13901272</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> 
<span class="go">13891296</span>
</pre></div>
</div>
</section>
<section id="when-can-i-rely-on-identity-tests-with-the-is-operator">
<h3><a class="toc-backref" href="#id69" role="doc-backlink">いつ <em>is</em> 演算子での同一性テストが頼れますか？</a><a class="headerlink" href="#when-can-i-rely-on-identity-tests-with-the-is-operator" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">is</span></code> 演算子はオブジェクトの同一性をテストします。  テスト <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">b</span></code> は <code class="docutils literal notranslate"><span class="pre">id(a)</span> <span class="pre">==</span> <span class="pre">id(b)</span></code> と同等です。</p>
<p>同一性テストの最も重要な特性は、オブジェクトは常にそれ自身と同一であり、 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">a</span></code> は常に <code class="docutils literal notranslate"><span class="pre">True</span></code> を返すということです。  同一性テストは通常、等価性テストよりも高速です。  また、等価性テストとは異なり、同一性テストは真偽値 <code class="docutils literal notranslate"><span class="pre">True</span></code> または``False`` を返すことが保証されています。</p>
<p>ただし、同一性テストを等価性テストの代用とできるのは、オブジェクトの同一性が保証されている場合 <em>のみ</em> です。  一般的に、同一性が保証される状況は3つあります:</p>
<p>1） 代入は新しい名前を作りますが、オブジェクトIDは変えません。  <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">=</span> <span class="pre">old</span></code> 代入の後、 <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">is</span> <span class="pre">old</span></code> が保証されます。</p>
<p>2） オブジェクト参照を格納するコンテナにオブジェクトを入れても、オブジェクトIDは変わりません。  <code class="docutils literal notranslate"><span class="pre">s[0]</span> <span class="pre">=</span> <span class="pre">x</span></code> リスト代入の後、 <code class="docutils literal notranslate"><span class="pre">s[0]</span> <span class="pre">is</span> <span class="pre">x</span></code> が保証されます。</p>
<p>3） オブジェクトがシングルトンなら、それはそのオブジェクトのインスタンスは１つだけ存在できることを意味します。  <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">None</span></code> と <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">None</span></code> 代入の後、 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">b</span></code> が保証されます。<code class="docutils literal notranslate"><span class="pre">None</span></code> がシングルトンのためです。</p>
<p>多くの他の状況では、同一性テストは賢明でなく、等価性テストをお勧めします。  特に、シングルトンであることが保証されていない <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> や <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> などの定数をチェックするために同一性テストを使わないでください。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">500</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">500</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="ow">is</span> <span class="n">c</span>
<span class="go">False</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;Python&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="s1">&#39;Py&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="s1">&#39;thon&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="ow">is</span> <span class="n">c</span>
<span class="go">False</span>
</pre></div>
</div>
<p>同様に、ミュータブルなコンテナの新しいインスタンスは同一ではありません:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">False</span>
</pre></div>
</div>
<p>標準ライブラリのコードには、同一性テストを正しく使うための一般的なパターンがあります:</p>
<p>1） <span class="target" id="index-10"></span><a class="pep reference external" href="https://peps.python.org/pep-0008/"><strong>PEP 8</strong></a> で推奨されるように、同一性テストは <code class="docutils literal notranslate"><span class="pre">None</span></code> のチェックの良い方法です。  コードの中で平易な英語のように読めますし、 false と評価される真偽値を持ちうる他のオブジェクトとの混同を避けます。</p>
<p>2） <code class="docutils literal notranslate"><span class="pre">None</span></code> が有効な入力値である場合、省略された引数を検出にはコツがいります。  そのような状況では、他のオブジェクトと区別されることが保証されたシングルトンの番兵オブジェクトを作れます。  例えば、これは <a class="reference internal" href="../library/stdtypes.html#dict.pop" title="dict.pop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.pop()</span></code></a> のように振る舞うメソッドを実装する方法です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">_sentinel</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">_sentinel</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="n">_sentinel</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">default</span>
</pre></div>
</div>
<p>3） コンテナの実装では、等価性テストを同一性テストで補強しないといけない場合があります。  これは、 <code class="docutils literal notranslate"><span class="pre">float('NaN')</span></code> のような自分自身と等価でないオブジェクトによってコードが混乱するのを防ぐためです。</p>
<p>例えば、これは <code class="xref py py-meth docutils literal notranslate"><span class="pre">collections.abc.Sequence.__contains__()</span></code>: の実装です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="n">value</span> <span class="ow">or</span> <span class="n">v</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</section>
<section id="how-can-a-subclass-control-what-data-is-stored-in-an-immutable-instance">
<h3><a class="toc-backref" href="#id70" role="doc-backlink">どうすればサブクラスはイミュータブルなインスタンスに格納されたデータを制御できますか？</a><a class="headerlink" href="#how-can-a-subclass-control-what-data-is-stored-in-an-immutable-instance" title="Link to this heading">¶</a></h3>
<p>イミュータブル型をサブクラス化する場合、 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> ではなく <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> メソッドを継承します。  前者はインスタンスが生成された <em>後</em> に動くため、イミュータブルなインスタンスのデータを変えるには遅すぎます。</p>
<p>これらのイミュータブルクラスはすべて、親クラスと異なるシグネチャを持ちます:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span>

<span class="k">class</span> <span class="nc">FirstOfMonthDate</span><span class="p">(</span><span class="n">date</span><span class="p">):</span>
    <span class="s2">&quot;Always choose the first day of the month&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">NamedInt</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>
    <span class="s2">&quot;Allow text names for some numbers&quot;</span>
    <span class="n">xlat</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;zero&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;ten&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">}</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">xlat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">TitleStr</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="s2">&quot;Convert str to name suitable for a URL path&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span> <span class="ow">or</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>クラスはこのように使えます:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">FirstOfMonthDate</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
<span class="go">FirstOfMonthDate(2012, 2, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NamedInt</span><span class="p">(</span><span class="s1">&#39;ten&#39;</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NamedInt</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TitleStr</span><span class="p">(</span><span class="s1">&#39;Blog: Why Python Rocks&#39;</span><span class="p">)</span>
<span class="go">&#39;blog-why-python-rocks&#39;</span>
</pre></div>
</div>
</section>
<section id="how-do-i-cache-method-calls">
<span id="faq-cache-method-calls"></span><h3><a class="toc-backref" href="#id71" role="doc-backlink">メソッド呼び出しをキャッシュするには どうしたらいいですか？</a><a class="headerlink" href="#how-do-i-cache-method-calls" title="Link to this heading">¶</a></h3>
<p>メソッドキャッシュの主な道具は２つあり、 <a class="reference internal" href="../library/functools.html#functools.cached_property" title="functools.cached_property"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.cached_property()</span></code></a> と <a class="reference internal" href="../library/functools.html#functools.lru_cache" title="functools.lru_cache"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.lru_cache()</span></code></a> です。前者はインスタンスレベル、後者はクラスレベルで結果を保存します。</p>
<p><em>cached_property</em> アプローチは、引数を取らないメソッドでのみ働きます。これはインスタンスへの参照を作りません。キャッシュされたメソッドの結果は、インスタンスが生きている間だけ保持されます。</p>
<p>利点は、インスタンスが使われなくなった場合、キャッシュされたメソッドの結果がすぐに解放されることです。欠点は、インスタンスが溜まると、溜められたメソッドの結果も増えてしまうことです。それらは際限なく増える恐れがあります。</p>
<p><em>lru_cache</em> アプローチは、 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> な引数を持つメソッドで働きます。 weak references を渡すための特別な努力がない限り、インスタンスへの参照を作ります。</p>
<p>least recently used アルゴリズム（訳注：LRU 直近に使われたものを残す）の利点は、キャッシュが指定された <em>maxsize</em> で制限されることです。欠点は、キャッシュから期限切れで追い出されるかクリアされるまで、インスタンスが生き続けることです。</p>
<p>この例は各種テクニックを示します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Weather</span><span class="p">:</span>
    <span class="s2">&quot;Lookup weather information on a government website&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station_id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_station_id</span> <span class="o">=</span> <span class="n">station_id</span>
        <span class="c1"># The _station_id is private and immutable</span>

    <span class="k">def</span> <span class="nf">current_temperature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Latest hourly observation&quot;</span>
        <span class="c1"># Do not cache this because old results</span>
        <span class="c1"># can be out of date.</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">location</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return the longitude/latitude coordinates of the station&quot;</span>
        <span class="c1"># Result only depends on the station_id</span>

    <span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">historic_rainfall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;mm&#39;</span><span class="p">):</span>
        <span class="s2">&quot;Rainfall on a given date&quot;</span>
        <span class="c1"># Depends on the station_id, date, and units.</span>
</pre></div>
</div>
<p>上の例では、 <em>station_id</em> が常に変わらないことを前提としています。関連するインスタンスの属性が可変である場合、 <em>cached_property</em> アプローチは属性の変更を検出できないため、機能しなくなります。</p>
<p><em>station_id</em> が可変の場合に <em>lru_cache</em> アプローチを機能させるには、クラスで <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> と <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> メソッドを定義する必要があります。これにより、キャッシュは関連する属性の更新を検出できます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Weather</span><span class="p">:</span>
    <span class="s2">&quot;Example with a mutable station identifier&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station_id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">station_id</span> <span class="o">=</span> <span class="n">station_id</span>

    <span class="k">def</span> <span class="nf">change_station</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station_id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">station_id</span> <span class="o">=</span> <span class="n">station_id</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">station_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">station_id</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">station_id</span><span class="p">)</span>

    <span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">historic_rainfall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;cm&#39;</span><span class="p">):</span>
        <span class="s1">&#39;Rainfall on a given date&#39;</span>
        <span class="c1"># Depends on the station_id, date, and units.</span>
</pre></div>
</div>
</section>
</section>
<section id="modules">
<h2><a class="toc-backref" href="#id72" role="doc-backlink">モジュール</a><a class="headerlink" href="#modules" title="Link to this heading">¶</a></h2>
<section id="how-do-i-create-a-pyc-file">
<h3><a class="toc-backref" href="#id73" role="doc-backlink">.pyc ファイルを作るにはどうしますか？</a><a class="headerlink" href="#how-do-i-create-a-pyc-file" title="Link to this heading">¶</a></h3>
<p>モジュールが初めてインポートされたとき (もしくは、現在のコンパイルされたファイルが作られてから、ソースファイルが変更されたとき) 、コンパイルされたコードが入っている <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> ファイルが、 <code class="docutils literal notranslate"><span class="pre">.py</span></code> ファイルのあるディレクトリのサブディレクトリ <code class="docutils literal notranslate"><span class="pre">__pycache__</span></code> に作成されます。 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> ファイルのファイル名は、 <code class="docutils literal notranslate"><span class="pre">.py</span></code> ファイルの名前で始まり、 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> で終わり、中間部分はこのファイルを作った <code class="docutils literal notranslate"><span class="pre">python</span></code> バイナリに依存した文字列になります。 (詳細は <span class="target" id="index-11"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a> を参照してください。)</p>
<p><code class="docutils literal notranslate"><span class="pre">.pyc</span></code> が作られない理由の 1 つは、ソースファイルがあるディレクトリの権限の問題、つまり <code class="docutils literal notranslate"><span class="pre">__pycache__</span></code> サブディレクトリが作れない問題です。これは、例えば、ウェブサーバーでテストを行っているときのような、開発者のユーザと実行者のユーザが別な場合に、起こり得ます。</p>
<p><span class="target" id="index-12"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONDONTWRITEBYTECODE</span></code></a> 環境変数がセットされない限り、モジュールをインポートしていて、 Python に <code class="docutils literal notranslate"><span class="pre">__pycache__</span></code> サブディレクトリを作り、そこにコンパイルされたモジュールが置ける能力 (権限、ディスクの空きスペース、など) がある場合は、 .pyc ファイルは自動的に作られます。</p>
<p>最上位のスクリプトを Python で実行するのはインポートとはみなされず、<code class="docutils literal notranslate"><span class="pre">.pyc</span></code> は作成されません。例えば、最上位のモジュール <code class="docutils literal notranslate"><span class="pre">foo.py</span></code> が別のモジュール <code class="docutils literal notranslate"><span class="pre">xyz.py</span></code> をインポートしている場合、(シェルコマンドとして <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">foo.py</span></code> と打ち込んで) <code class="docutils literal notranslate"><span class="pre">foo</span></code> を実行すると、<code class="docutils literal notranslate"><span class="pre">xyz</span></code> はインポートされるので <code class="docutils literal notranslate"><span class="pre">xyz</span></code> の <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> は作成されますが、<code class="docutils literal notranslate"><span class="pre">foo.py</span></code> はインポートされたわけではないので <code class="docutils literal notranslate"><span class="pre">foo</span></code> の <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> は作られません。</p>
<p><code class="docutils literal notranslate"><span class="pre">foo</span></code> の <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> ファイルを作成する -- つまり、インポートされていないモジュールの <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> ファイルを作成する -- 必要がある場合、 <a class="reference internal" href="../library/py_compile.html#module-py_compile" title="py_compile: Generate byte-code files from Python source files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">py_compile</span></code></a> モジュールと <a class="reference internal" href="../library/compileall.html#module-compileall" title="compileall: Tools for byte-compiling all Python source files in a directory tree."><code class="xref py py-mod docutils literal notranslate"><span class="pre">compileall</span></code></a> モジュールを使えば可能です。</p>
<p><a class="reference internal" href="../library/py_compile.html#module-py_compile" title="py_compile: Generate byte-code files from Python source files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">py_compile</span></code></a> モジュールは手動で任意のモジュールをコンパイルできます。やり方の一つは、このモジュールの <code class="docutils literal notranslate"><span class="pre">compile()</span></code> 関数をインタラクティブに実行することです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_compile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">py_compile</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;foo.py&#39;</span><span class="p">)</span>                 
</pre></div>
</div>
<p>このように実行すると、<code class="docutils literal notranslate"><span class="pre">foo.py</span></code> と同じ場所の <code class="docutils literal notranslate"><span class="pre">__pycache__</span></code> サブディレクトリに <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> が書き出されます (出力ファイルの位置は、オプション引数 <code class="docutils literal notranslate"><span class="pre">cfile</span></code> で上書きすることもできます)。</p>
<p><a class="reference internal" href="../library/compileall.html#module-compileall" title="compileall: Tools for byte-compiling all Python source files in a directory tree."><code class="xref py py-mod docutils literal notranslate"><span class="pre">compileall</span></code></a> モジュールを使えば自動的に一つや複数のディレクトリのすべてのファイルをコンパイルできます。シェルプロンプトから <code class="docutils literal notranslate"><span class="pre">compileall.py</span></code> を起動して、コンパイルしたいファイルを含むディレクトリのパスを指定してください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">compileall</span> <span class="o">.</span>
</pre></div>
</div>
</section>
<section id="how-do-i-find-the-current-module-name">
<h3><a class="toc-backref" href="#id74" role="doc-backlink">現在のモジュール名を知るにはどうしますか？</a><a class="headerlink" href="#how-do-i-find-the-current-module-name" title="Link to this heading">¶</a></h3>
<p>モジュールは前もって定義されたグローバル変数 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> を検索することで自身の名前を決定できます。この値が <code class="docutils literal notranslate"><span class="pre">'__main__'</span></code> であるとき、そのプログラムはスクリプトとして実行されています。インポートされることによって使われる大抵のモジュールはコマンドラインインターフェースや自己テストも提供していて、<code class="docutils literal notranslate"><span class="pre">__name__</span></code> をチェックしてからそのコードだけを実行します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running test...&#39;</span><span class="p">)</span>
    <span class="o">...</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="how-can-i-have-modules-that-mutually-import-each-other">
<h3><a class="toc-backref" href="#id75" role="doc-backlink">相互にインポートしあうモジュールを作るにはどうしたらいいですか？</a><a class="headerlink" href="#how-can-i-have-modules-that-mutually-import-each-other" title="Link to this heading">¶</a></h3>
<p>以下のモジュールがあったとしましょう:</p>
<p><code class="file docutils literal notranslate"><span class="pre">foo.py</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bar</span> <span class="kn">import</span> <span class="n">bar_var</span>
<span class="n">foo_var</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p><code class="file docutils literal notranslate"><span class="pre">bar.py</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">foo</span> <span class="kn">import</span> <span class="n">foo_var</span>
<span class="n">bar_var</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>問題はインタプリタが以下の段階を実行することです:</p>
<ul class="simple">
<li><p>main が <code class="docutils literal notranslate"><span class="pre">foo</span></code> をインポートする</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">foo</span></code> の空のグローバルが生成される</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">foo</span></code> がコンパイルされ実行を始める</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">foo</span></code> が <code class="docutils literal notranslate"><span class="pre">bar</span></code> をインポートする</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bar</span></code> の空のグローバルが生成される</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bar</span></code> がコンパイルされ実行を始める</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bar</span></code> が <code class="docutils literal notranslate"><span class="pre">foo</span></code> をインポートする(すでに <code class="docutils literal notranslate"><span class="pre">foo</span></code> という名前のモジュールがあるので no-op となる)</p></li>
<li><p>インポートメカニズムは <code class="docutils literal notranslate"><span class="pre">foo</span></code> のグローバルから <code class="docutils literal notranslate"><span class="pre">foo_var</span></code> を読んで、 <code class="docutils literal notranslate"><span class="pre">bar.foo_var</span> <span class="pre">=</span> <span class="pre">foo.foo_var</span></code> に設定しようとします。</p></li>
</ul>
<p>この最後の段階は失敗します。Python が <code class="docutils literal notranslate"><span class="pre">foo</span></code> を解釈し終わっていなくて、<code class="docutils literal notranslate"><span class="pre">foo</span></code> のグローバルなシンボルの辞書はまだ空ですから。</p>
<p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">foo</span></code> を使って、グローバルコードの <code class="docutils literal notranslate"><span class="pre">foo.foo_var</span></code> にアクセスしようとしたときにも、これと同じことが起こります。</p>
<p>この問題には (少なくとも) 三つの解決策があります。</p>
<p>Guido van Rossum は <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">&lt;module&gt;</span> <span class="pre">import</span> <span class="pre">...</span></code> を全く使わないで、すべてのコードを関数の中に入れることを勧めています。グローバル変数とクラス変数の初期化は定数とビルトイン関数のみで行われるべきです。これでインポートされたすべてのモジュールは <code class="docutils literal notranslate"><span class="pre">&lt;module&gt;.&lt;name&gt;</span></code> として参照されることになります。</p>
<p>Jim Roskind はそれぞれのモジュールに対して以下の順に進めることを提案しています:</p>
<ul class="simple">
<li><p>エクスポート (インポートされた基底クラスを必要としないグローバル、関数、クラス)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">import</span></code> 文</p></li>
<li><p>アクティブなコード (インポートされた値によって初期化されるグローバルを含む)。</p></li>
</ul>
<p>インポートが奇妙な場所に現れることから Van Rossum はこの方法をそれほど好みませんが、これは有効です。</p>
<p>Matthias Urlichs は第一に再帰インポートが必要ないようにコードを構築しなおすことを推奨しています。</p>
<p>これらの解決策はそれぞれ両立させることもできます。</p>
</section>
<section id="import-x-y-z-returns-module-x-how-do-i-get-z">
<h3><a class="toc-backref" href="#id76" role="doc-backlink">__import__('x.y.z') は &lt;module 'x'&gt; を返しますが、z を得るためにはどうしますか？</a><a class="headerlink" href="#import-x-y-z-returns-module-x-how-do-i-get-z" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> に <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> という便利な関数があるので、代わりにそちらを使用することを検討してください。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;x.y.z&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="when-i-edit-an-imported-module-and-reimport-it-the-changes-don-t-show-up-why-does-this-happen">
<h3><a class="toc-backref" href="#id77" role="doc-backlink">インポートされたモジュールを編集してから再インポートしましたが、変化が現れません。なぜですか？</a><a class="headerlink" href="#when-i-edit-an-imported-module-and-reimport-it-the-changes-don-t-show-up-why-does-this-happen" title="Link to this heading">¶</a></h3>
<p>効率と一貫性上の理由から、Python はモジュールが最初にインポートされた時にのみモジュールファイルを読み込みます。そうしないと、たくさんのモジュールでできていて、それぞれが同じ基本モジュールをインポートしているようなプログラムでは、その基本モジュールの解析と再解析が繰り返されることになります。変更されさたモジュールの再読込を強制するには、こうしてください:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">modname</span>
<span class="n">importlib</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">modname</span><span class="p">)</span>
</pre></div>
</div>
<p>注意:この手法は 100%安全とは言えません。とりわけ</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">modname</span> <span class="kn">import</span> <span class="n">some_objects</span>
</pre></div>
</div>
<p>のような文を含むモジュールは、インポートされたオブジェクトの古いバージョンを使い続けます。そのモジュールにクラス定義が含まれていたら、存在するクラスインスタンスは新しいクラス定義を使うようにアップデート <em>されません</em>。これによって以下の矛盾した振舞いがなされえます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">importlib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cls</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">C</span><span class="p">()</span>                <span class="c1"># Create an instance of C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">importlib</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
<span class="go">&lt;module &#39;cls&#39; from &#39;cls.py&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">C</span><span class="p">)</span>       <span class="c1"># isinstance is false?!?</span>
<span class="go">False</span>
</pre></div>
</div>
<p>この問題の本質は、クラスオブジェクトの &quot;固有値&quot; を印字することで明らかになります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span>
<span class="go">&#39;0x7352a0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">C</span><span class="p">))</span>
<span class="go">&#39;0x4198d0&#39;</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="#">プログラミング FAQ</a><ul>
<li><a class="reference internal" href="#general-questions">一般的な質問</a></li>
<li><a class="reference internal" href="#core-language">コア言語</a></li>
<li><a class="reference internal" href="#numbers-and-strings">数と文字列</a></li>
<li><a class="reference internal" href="#performance">性能</a></li>
<li><a class="reference internal" href="#sequences-tuples-lists">シーケンス(タプル/リスト)</a></li>
<li><a class="reference internal" href="#objects">オブジェクト</a></li>
<li><a class="reference internal" href="#modules">モジュール</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="general.html"
                          title="前の章へ">一般 Python FAQ</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="design.html"
                          title="次の章へ">デザインと歴史 FAQ</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/faq/programming.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="サイドバーをたたむ">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="design.html" title="デザインと歴史 FAQ"
             >次へ</a> |</li>
        <li class="right" >
          <a href="general.html" title="一般 Python FAQ"
             >前へ</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python よくある質問</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">プログラミング FAQ</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" id="search-box" />
          <input type="submit" value="検索" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    Copyright
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="/license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最終更新: Jun 11, 2024 (04:44 UTC)
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>

    <script type="text/javascript" src="../_static/switchers.js"></script>
  </body>
</html>