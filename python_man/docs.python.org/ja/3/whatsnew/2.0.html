<!DOCTYPE html>

<html lang="ja" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="What's New in Python 2.0" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/2.0.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="著者, A.M. Kuchling and Moshe Zadka,. はじめに: 新 Python リリース、バージョン 2.0 は、2000 年 10 月 16 日にリリースされました。この記事では 2.0 のエキサイティングな新機能をカバーし、いくつかの有用な変更点をハイライトし、少しの、コードの書き換えを要する互換性のない変更点について指摘します。 Python の開発は、リリースと..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="著者, A.M. Kuchling and Moshe Zadka,. はじめに: 新 Python リリース、バージョン 2.0 は、2000 年 10 月 16 日にリリースされました。この記事では 2.0 のエキサイティングな新機能をカバーし、いくつかの有用な変更点をハイライトし、少しの、コードの書き換えを要する互換性のない変更点について指摘します。 Python の開発は、リリースと..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>What&#39;s New in Python 2.0 &#8212; Python 3.12.4 ドキュメント</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css%3Fv=80d5e7a1.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css%3Fv=bb723527.css" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css%3Fv=b20cc3f5.css" />
    
    <script src="../_static/documentation_options.js%3Fv=7e11ab17"></script>
    <script src="../_static/doctools.js%3Fv=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js%3Fv=dc90522c"></script>
    <script src="../_static/translations.js%3Fv=4dbe4bdc"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.12.4 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="変更履歴" href="changelog.html" />
    <link rel="prev" title="What&#39;s New in Python 2.1" href="2.1.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="../../../3/whatsnew/2.0.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" />
                <input type="submit" value="検索"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="2.0.html#">What's New in Python 2.0</a><ul>
<li><a class="reference internal" href="2.0.html#introduction">はじめに</a></li>
<li><a class="reference internal" href="2.0.html#what-about-python-1-6">Python 1.6 はいかがですか?</a></li>
<li><a class="reference internal" href="2.0.html#new-development-process">新しい開発プロセス</a></li>
<li><a class="reference internal" href="2.0.html#unicode">Unicode 文字列型</a></li>
<li><a class="reference internal" href="2.0.html#list-comprehensions">リストの内包表記</a></li>
<li><a class="reference internal" href="2.0.html#augmented-assignment">累算代入 (Augmented Assignment)</a></li>
<li><a class="reference internal" href="2.0.html#string-methods">文字列メソッド</a></li>
<li><a class="reference internal" href="2.0.html#garbage-collection-of-cycles">循環参照のガベージコレクション</a></li>
<li><a class="reference internal" href="2.0.html#other-core-changes">その他の言語コアの変更</a><ul>
<li><a class="reference internal" href="2.0.html#minor-language-changes">言語のマイナー変更</a></li>
<li><a class="reference internal" href="2.0.html#changes-to-built-in-functions">ビルトイン関数の変更</a></li>
</ul>
</li>
<li><a class="reference internal" href="2.0.html#porting-to-2-0">Python 2.0 への移植</a></li>
<li><a class="reference internal" href="2.0.html#extending-embedding-changes">拡張と埋め込みについての変更</a></li>
<li><a class="reference internal" href="2.0.html#distutils-making-modules-easy-to-install">Distutils: モジュールの簡単インストール</a></li>
<li><a class="reference internal" href="2.0.html#xml-modules">XML モジュール</a><ul>
<li><a class="reference internal" href="2.0.html#sax2-support">SAX2 サポート</a></li>
<li><a class="reference internal" href="2.0.html#dom-support">DOM サポート</a></li>
<li><a class="reference internal" href="2.0.html#relationship-to-pyxml">PyXML との関係</a></li>
</ul>
</li>
<li><a class="reference internal" href="2.0.html#module-changes">更新されたモジュール</a></li>
<li><a class="reference internal" href="2.0.html#new-modules">新しいモジュール</a></li>
<li><a class="reference internal" href="2.0.html#idle-improvements">IDLE の改善</a></li>
<li><a class="reference internal" href="2.0.html#deleted-and-deprecated-modules">削除されたモジュール、非推奨となったモジュール</a></li>
<li><a class="reference internal" href="2.0.html#acknowledgements">謝辞</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="2.1.html"
                          title="前の章へ">What's New in Python 2.1</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="changelog.html"
                          title="次の章へ">変更履歴</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.0.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="changelog.html" title="変更履歴"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="2.1.html" title="What&#39;s New in Python 2.1"
             accesskey="P">前へ</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">What's New in Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="2.0.html">What's New in Python 2.0</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" id="search-box" />
          <input type="submit" value="検索" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-0">
<h1>What's New in Python 2.0<a class="headerlink" href="2.0.html#what-s-new-in-python-2-0" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">著者<span class="colon">:</span></dt>
<dd class="field-odd"><p>A.M. Kuchling and Moshe Zadka</p>
</dd>
</dl>
<section id="introduction">
<h2>はじめに<a class="headerlink" href="2.0.html#introduction" title="Link to this heading">¶</a></h2>
<p>新 Python リリース、バージョン 2.0 は、2000 年 10 月 16 日にリリースされました。この記事では 2.0 のエキサイティングな新機能をカバーし、いくつかの有用な変更点をハイライトし、少しの、コードの書き換えを要する互換性のない変更点について指摘します。</p>
<p>Python の開発は、リリースとリリースの間で止まることはなく、バグフィックスと改善はとめどなく、日夜提出されます。多くのマイナーフィックス、少しの最適化、ドキュメンテーション文字列の追加、より良いエラーメッセージが 2.0 に仲間入りしました。これら全てを列挙するのは不可能ですが、それは確かに大事でしょう、全てのリストを見たければ、公に入手可能な CVS ログを調べてください。この前進は、今やバグ修正に日々を費やすことで報酬を受け取って PythonLabs のために働く 5 人の開発者、それと SourceForge に移行した結果改善されたコミュニケーションのおかげです。</p>
</section>
<section id="what-about-python-1-6">
<h2>Python 1.6 はいかがですか?<a class="headerlink" href="2.0.html#what-about-python-1-6" title="Link to this heading">¶</a></h2>
<p>Python 1.6 は「推定的義務」の Python リリースと考えることが出来ます。2000 年 5 月にコア開発チームが CNRI を離れたあと、CNRI は Python にかかる作業全てが CNRI で実施されることを含む 1.6 リリースが作成されることをリクエストしました。それゆえ Python 1.6 は、最も重要な新機能としての Unicode サポートを含む、2000 年 5 月の CVS ツリーの状態と同等です。開発はもちろん 5 月以降も継続されましたので、1.6 ツリーは Python 2.0 との前方互換を保障するために少しの修正を受け取りました。1.6 はですから、Python の進化の一部であり、側枝ではありません。</p>
<p>では、あなたは Python 1.6 に興味を示すべきでしょうか? おそらく答えはノーです。1.6final と 2.0beta1 のリリースは同じ日に行われ (2000 年 9 月 5 日)、Python 2.0 のファイナライズはその一ヶ月かそこらで行われるよう計画されました。もしあなたが保守すべきアプリケーションを持っているならば、1.6 への移行には少しばかりコードの破壊を伴うようです。つまりその修正を行い、一ヶ月の間に 2.0 への移行による別の破壊ラウンドがやってきます。直接 2.0 に移行したほうが良いでしょう。このドキュメントに記載する、ほとんどの面白い機能は 2.0 のみのものであり、なぜならほとんどの作業は、5 月から 9 月の間に行われたからなのです。</p>
</section>
<section id="new-development-process">
<h2>新しい開発プロセス<a class="headerlink" href="2.0.html#new-development-process" title="Link to this heading">¶</a></h2>
<p>Python 2.0 における最も重要な変化はコードに対するものではまったくなくて、Python がどのように開発されるのかについてでしょう: 2000 年 5 月に Python 開発者たちは、ソースコード格納、バグ報告の追跡、パッチ提出の待ち行列管理のための SourceForge によって利用出来るようになったツールの使用を始めました。Python 2.0 ではバグ報告やパッチの提出には、Python プロジェクトページで利用可能なバグトラッキングとパッチ管理ツールを使ってください。 <a class="reference external" href="https://sourceforge.net/projects/python/">https://sourceforge.net/projects/python/</a> にあります(訳注: 2015 年現在の状況は What's New in Python 2.6 参照)。</p>
<p>SourceForge で現在ホストされているサービスの中で最も重要なのは Python CVS ツリーで、Python のソースコードを含む、バージョンコントロールされたレポジトリです。以前までは、CVS ツリーへの書き込み許可を持つ人々が 7 人ほどいて、全てのパッチはその中の一人が精査とチェックをする必要がありました。明らかにこれはスケーラブルではありませんでした。CVS ツリーを SourceForge に移動することで、より多くの人々に書き込み許可を与えることが可能になりました; 2000 年 9 月時点で、27 人の人々が変更をチェックイン出来るようになっていました。これは 4 倍の増加です。これは大規模な変更、これまでであれば小さなコア開発グループによるフィルタを経由しなければならないために試みられなかったような、大規模な変更を可能にしています。例えばある日 Peter Schneider-Kamp は K&amp;R C 互換を落としてしまうことを思い立ち、Python の C ソースを ANSI C に変換しました。python-dev メーリングリストでの承認を得たのち、彼は立て続けにチェックインを開始しておよそ一週間ほどで終わらせ、ほかの開発者たちも手助けに参加し、そして作業は完了しました。書き込み許可が 5 人だけだったならば、おそらくそのタスクはこう見做されたでしょう:「素晴らしい。けれども時間と労力に見合わない」。そして決して実現することはなかったことでしょう。</p>
<p>SourceForge のサービスを使うことへのシフトは、開発の目覚しいスピードアップをもたらしました。パッチはいまや、提出され、コメントされ、提出者以外の別人によって改定されて戻ってきて、などなどが、パッチがチェックインの価値があると判断されるまで行われています。バグは唯一つの中央保管庫で追跡され、修正には特定の誰かを割り当てることが出来、そして私たちはオープンバグを進捗の指標として考えることが出来ます。これは代償なしでは達成しませんでした; 開発者には今や以前よりもたくさんの処理すべき電子メールがあり、より多くメーリングリストに追従しなければならず、そして新しい環境のための特別なツールを要しました。例えば、SourceForge はデフォルトでパッチ提出とバグ報告を電子メールで通知しますが、これは全く助けにならないもので、Ka-Ping Yee はもっと有用なメッセージを送信するための HTML スクリーンスクレイパを書きました。</p>
<p>簡単にコードを追加出来るようになったことは、当初少し苦痛を大きくしました。例えばコードが不十分なままだったり、開発グループからのはっきりとした承諾のないままチェックインされたりするといったことです。浮上してきた承認プロセスは、Apache グループが使っているようなものにいくらか似たものです。開発者たちは +1, +0, -0, -1 というふうにパッチに投票できます; +1 と -1 は承諾、却下を表し、+0 と -0 は、開発者は変更にほとんど興味がないけれどもやや肯定、否定の傾向であることを意味します。Apache モデルからの最も大きな違いは、投票行為は本質的に助言であって、優しい終身独裁者 Guido van Rossum 侯に大衆の民意を伝えるものであることです。彼は投票結果をそれでも無視出来ますし、コミュニティが異論を唱えようが変更を承認したり却下したり出来ます。</p>
<p>実際のパッチの作成は新機能の追加での最後のステップであり、通常、良いデザインを工面する前のタスクと容易に比較出来ます。一方で新機能についての議論はしばしばメーリングリストでの長大なスレッドを巻き起こし、議論に追いつくのが大変になり、そして誰も python-dev の投稿全てを読めません。それゆえに、Python 拡張提案 (Python Enhancement Proposals: PEPs)を書く、相対的に形式ばったプロセスが、始動しました。インターネットの RFC をモデルにしたものです。PEPs は新機能提案を記述した草案文書であり、コミュニティの合意として提案が承認されるか却下されるまで継続的に改定されます。 <span class="target" id="index-8"></span><a class="pep reference external" href="https://peps.python.org/pep-0001/"><strong>PEP 1</strong></a> の導入部、&quot;PEP の目的とガイドライン&quot; から引用します:</p>
<blockquote class="epigraph">
<div><p>PEP は Python Enhancement Proposal を意味します。PEP は、Python コミュニティに対して情報を提供する、あるいは Python の新機能について記述する設計文書です。PEP は、機能についての技術的な仕様とその機能の論拠(理論)を簡潔に伝えるべきです。</p>
<p>私たちは PEP が新機能提案にかかる、コミュニティによる問題提起の集積と Python になされる設計決断の文書化のための最上位の機構となることを意図しています。PEP の著者にはコミュニティ内の合意形成を行うこと、反対意見を文書化することの責務があります。</p>
</div></blockquote>
<p>PEP の編集に関するプロセス、様式、体裁についての詳細が  <span class="target" id="index-9"></span><a class="pep reference external" href="https://peps.python.org/pep-0001/"><strong>PEP 1</strong></a> の残りの部分に書かれています。PEPs は SourceForge 上の Python CVS ツリーで営まれますが Python 2.0 配布物の一部ではなく、 <a class="reference external" href="https://peps.python.org/">https://peps.python.org/</a> で HTML 形式で利用可能です。2000 年 9 月時点で  <span class="target" id="index-10"></span><a class="pep reference external" href="https://peps.python.org/pep-0201/"><strong>PEP 201</strong></a> の &quot;Lockstep Iteration&quot; から PEP 225 の &quot;Elementwise/Objectwise Operators&quot; までの 25 の PEP があります。</p>
</section>
<section id="unicode">
<h2>Unicode 文字列型<a class="headerlink" href="2.0.html#unicode" title="Link to this heading">¶</a></h2>
<p>Python 2.0 での最大の新機能は新しい基礎データ型、Unicode 文字列です。Unicode は文字を表現するのに ASCII で使用される 8 ビット数の代わりに 16 ビットを使います。これによって 65,536 の個別の文字がサポート出来ます。(---訳注: Unicode の扱いはまず Python 2.2 で UCS4 が使えるように拡張され(つまり 32 ビットに拡張)、Python 3 では Unicode が唯一の文字列型に変更されています。後者の変更点は非常に大きいですが、クックブックの「Python 2 から Python 3 への移植」に比較的よくまとめられています。---)</p>
<p>最終的な Unicode サポートに関するインターフェイスは、python-dev メーリングリストにおける数え切れない、時として嵐のような議論を経て、Fredrik Lundh によって実装された Unicode 文字列型に基づいて、ほとんどが Marc-André Lemburg によって実装されました。インターフェイスについての詳細な説明は <span class="target" id="index-11"></span><a class="pep reference external" href="https://peps.python.org/pep-0100/"><strong>PEP 100</strong></a> 「Python Unicode の統合」に記述されました。今ここでは、Unicode インターフェイスについて、一番重要な点を単純にカバーするだけにしましょう。</p>
<p>Python ソースコード内では Unicode 文字列は <code class="docutils literal notranslate"><span class="pre">u&quot;string&quot;</span></code> のように書きます。任意の Unicode 文字は新しく追加されたエスケープシーケンスで書きます。 <code class="samp docutils literal notranslate"><span class="pre">\u</span><em><span class="pre">HHHH</span></em></code> のように書き、 <em>HHHH</em> は 0000 から FFFF までの 4 桁の 16 進表記数です。以前からあるエスケープシーケンス <code class="samp docutils literal notranslate"><span class="pre">\x</span><em><span class="pre">HH</span></em></code> も使えますし、8 進表記も、 <code class="docutils literal notranslate"><span class="pre">\777</span></code> で表現される U+01FF までの文字に使えます。</p>
<p>Unicode 文字列は普通の文字列と全く似ていて、 <a class="reference internal" href="../glossary.html#term-immutable"><span class="xref std std-term">immutable</span></a> なシーケンス型です。添え字でアクセス出来、スライス出来ますが、インプレイスに変更することは出来ません。Unicode 文字列は <code class="docutils literal notranslate"><span class="pre">encode(</span> <span class="pre">[encoding]</span> <span class="pre">)</span></code> メソッドを持っていて、これは望みのエンコーディングでエンコードした 8 ビット文字列を返します。エンコーディングは文字列で名前付けられていて、例えば <code class="docutils literal notranslate"><span class="pre">'ascii'</span></code>, <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>, <code class="docutils literal notranslate"><span class="pre">'iso-8859-1'</span></code> のようなものです。コーデック API は、新しいエンコーディングを実装し、Python プログラム全体を通して利用可能となるよう登録するために定義されています。エンコーディングが指定されない場合はデフォルトのエンコーディングは普通 7 ビット ASCII ですが、Python インストレーションにおいて、 <code class="file docutils literal notranslate"><span class="pre">site.py</span></code> のカスタマイズ版内で <code class="docutils literal notranslate"><span class="pre">sys.setdefaultencoding(encoding)</span></code> を呼び出すことで変更出来ます。</p>
<p>8 ビット文字列と Unicode 文字列を結合すると常に、デフォルトの ASCII エンコーディングを使って Unicode に型変換されます。 <code class="docutils literal notranslate"><span class="pre">'a'</span> <span class="pre">+</span> <span class="pre">u'bc'</span></code> の結果は <code class="docutils literal notranslate"><span class="pre">u'abc'</span></code> になります。</p>
<p>新たなビルトイン関数が追加され、既存のビルトイン関数も Unicode サポートのために修正されました:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">unichr(ch)</span></code> は Unicode におけるコードが整数 <em>ch</em> になるような文字 1 文字からなる Unicode 文字列を返します。</p></li>
<li><p><em>u</em> が 1 文字の通常文字あるいは Unicode 文字として、 <code class="docutils literal notranslate"><span class="pre">ord(u)</span></code> はコードを整数で返します。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unicode(string</span> <span class="pre">[,</span> <span class="pre">encoding]</span> <span class="pre">[,</span> <span class="pre">errors]</span> <span class="pre">)</span></code> は、8 ビット文字列から Unicode 文字列を作ります。 <code class="docutils literal notranslate"><span class="pre">encoding</span></code> は使用するエンコーディング名の文字列です。 <code class="docutils literal notranslate"><span class="pre">errors</span></code> パラメータは、現在エンコーディングにおいて不正な文字の扱いを指示します; これに値として <code class="docutils literal notranslate"><span class="pre">'strict'</span></code> を渡すと全てのエンコーディングエラーに対し、例外を引き起こします。 <code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> を渡すとエラーは黙って無視されます。 <code class="docutils literal notranslate"><span class="pre">'replace'</span></code> を渡すと、全ての問題ケースで、公式な置き換え文字である U+FFFD に置き換えます。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exec</span></code> 文や　<code class="docutils literal notranslate"><span class="pre">eval()</span></code>, <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>, <code class="docutils literal notranslate"><span class="pre">setattr()</span></code> のような色々なビルトインも、普通の文字列同様に Unicode 文字列を受け付けるようになりました。(この修正をするプロセスをいくつかのビルトインで忘れている可能性もあります。文字列を受け取るものが Unicode を全く受け取らないビルトインを見つけたら、バグとして報告してください。)</p></li>
</ul>
<p>新規モジュール <a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a> は、Unicode 文字の特性へのインターフェイスを提供します。例えば <code class="docutils literal notranslate"><span class="pre">unicodedata.category(u'A')</span></code> は 2 文字の文字列 'Lu' を返しますが、これは、 'L' が letter を、 'u' が uppercase を表します。 <code class="docutils literal notranslate"><span class="pre">unicodedata.bidirectional(u'\u0660')</span></code> は 'AN' を返し、これは U+0660 が Arabic Number であることを表します。</p>
<p><a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> モジュールには、既存のエンコーディングをルックアップする関数、新しいエンコーディングを登録する関数が含まれます。新しいエンコーディングを実装したいと思うのでない限りは、一番使うことになるのは <code class="docutils literal notranslate"><span class="pre">codecs.lookup(encoding)</span></code> でしょう。これは 4 要素のタプルを返します: <code class="docutils literal notranslate"><span class="pre">(encode_func,</span> <span class="pre">decode_func,</span> <span class="pre">stream_reader,</span> <span class="pre">stream_writer)</span></code> 。</p>
<ul class="simple">
<li><p><em>encode_func</em> は、Unicode 文字列を受け取って 2 要素タプル <code class="docutils literal notranslate"><span class="pre">(string,</span> <span class="pre">length)</span></code> を返す関数です。 <em>string</em> は、与えられたエンコーディングで Unicode 文字列を変換した部分 (おそらく全体) を含む 8 ビット文字列で、 <em>length</em> は何文字の Unicode 文字列が変換されたかを伝えます。</p></li>
<li><p><em>decode_func</em> は <em>encode_func</em> の対となる関数で、8 ビット文字列を受け取って、2 要素のタプル <code class="docutils literal notranslate"><span class="pre">(ustring,</span> <span class="pre">length)</span></code> を返します。 <em>ustring</em> が結果の Unicode 文字列で、整数 <em>length</em> が、8 ビット文字列何文字が消費されたかを表します。</p></li>
<li><p><em>stream_reader</em> is a class that supports decoding input from a stream.
<em>stream_reader(file_obj)</em> returns an object that supports the <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code>, and <code class="xref py py-meth docutils literal notranslate"><span class="pre">readlines()</span></code> methods.  These methods will all
translate from the given encoding and return Unicode strings.</p></li>
<li><p><em>stream_writer</em>, similarly, is a class that supports encoding output to a
stream.  <em>stream_writer(file_obj)</em> returns an object that supports the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">writelines()</span></code> methods.  These methods expect Unicode
strings, translating them to the given encoding on output.</p></li>
</ul>
<p>例えば以下のコードは Unicode 文字列を UTF-8 でエンコーディングしてファイルに書きます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">codecs</span>

<span class="n">unistr</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u0660\u2000</span><span class="s1">ab ...&#39;</span>

<span class="p">(</span><span class="n">UTF8_encode</span><span class="p">,</span> <span class="n">UTF8_decode</span><span class="p">,</span>
 <span class="n">UTF8_streamreader</span><span class="p">,</span> <span class="n">UTF8_streamwriter</span><span class="p">)</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s1">&#39;UTF-8&#39;</span><span class="p">)</span>

<span class="n">output</span> <span class="o">=</span> <span class="n">UTF8_streamwriter</span><span class="p">(</span> <span class="nb">open</span><span class="p">(</span> <span class="s1">&#39;/tmp/output&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="p">)</span>
<span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span> <span class="n">unistr</span> <span class="p">)</span>
<span class="n">output</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>そして以下コードではファイルから UTF-8 で読めます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">input</span> <span class="o">=</span> <span class="n">UTF8_streamreader</span><span class="p">(</span> <span class="nb">open</span><span class="p">(</span> <span class="s1">&#39;/tmp/output&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="p">)</span>
<span class="nb">print</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
<span class="nb">input</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> モジュールでは Unicode 対応した正規表現が利用可能で、これは新しい根底となる SRE なる実装から成り、Secret Labs AB の Fredrik Lundh によって書かれました。</p>
<p>Python コンパイラに全ての文字列リテラルを Unicode 文字列として解釈させるための <code class="docutils literal notranslate"><span class="pre">-U</span></code> コマンドラインオプションが追加されました。これはあなたの Python コードのテストと将来の保障を意図しています。というのも、将来の Python バージョンでは 8 ビット文字列のサポートがなくなって、Unicode 文字列だけとなる予定だからです。 (---訳注: ここで言っている将来バージョンとは、結果的には Python 3 になりました。What's New での明記はないのですが <code class="docutils literal notranslate"><span class="pre">-U</span></code> オプションは Python 2.7 時点では存在していません。ですが同じことは 2.6 以降では <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">unicode_literals</span></code> で出来ます。 ---)</p>
</section>
<section id="list-comprehensions">
<h2>リストの内包表記<a class="headerlink" href="2.0.html#list-comprehensions" title="Link to this heading">¶</a></h2>
<p>リストというのは Python の主要なデータ型で、多くのプログラムがリストをいつかは操るものです。リストの操作での 2 つのよくある操作は、それらについてループし、あるいは特定の基準に合致したものを取り出すか個々の要素にある関数を適用するかする、といったものです。例えば文字列のリストが与えられた場合、特定の部分文字列を含む全ての文字列を引き抜いたり、あるいは各行から末尾の空白を取り除いたりしたいでしょう。</p>
<p>既にあった <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> 関数、 <a class="reference internal" href="../library/functions.html#filter" title="filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a> 関数がこの目的のためには使えますが、それらにはその引数の一つに関数が必要です。何か既存のビルトイン関数で直接渡せるものがあればよいのですが、これがない場合その必要とされる仕事をする小さな関数を作る必要があって、また、Python のスコープ規則によって、その小さな関数が何かほかの情報を必要とする場合に醜いものになります。前パラグラフでの最初の例を考えましょう。指定の部分文字列を含む文字列リストから全てを探す例です。このように書けるでしょう:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Given the list L, make a list of all strings</span>
<span class="c1"># containing the substring S.</span>
<span class="n">sublist</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">substring</span><span class="o">=</span><span class="n">S</span><span class="p">:</span>
                     <span class="n">string</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">substring</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                  <span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
<p>Python のスコープ規則のために、 <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 式で作っている匿名関数にデフォルト引数を使い、これに検索対象の部分文字列を渡しています。リスト内包表記はこれを明快にします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sublist</span> <span class="o">=</span> <span class="p">[</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">L</span> <span class="k">if</span> <span class="n">string</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">]</span>
</pre></div>
</div>
<p>リスト内包表記は以下の形式を持ちます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="n">expression</span> <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">sequence1</span>
             <span class="k">for</span> <span class="n">expr2</span> <span class="ow">in</span> <span class="n">sequence2</span> <span class="o">...</span>
             <span class="k">for</span> <span class="n">exprN</span> <span class="ow">in</span> <span class="n">sequenceN</span>
             <span class="k">if</span> <span class="n">condition</span> <span class="p">]</span>
</pre></div>
</div>
<p><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code>...<code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code> 節はイテレートするシーケンスを含みます。シーケンス群は同じ長さである必要はありません。それらは並列でイテレートされる <em>のではなく</em> 左から右の順で周ります。続くパラグラフでもっとわかりやすく説明します。生成されるリストの要素は一連の <em>expression</em> の値となります。最後の <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 節はオプショナルです。これがあれば <em>expression</em> は <em>condition</em> が真の場合にのみ評価・追加されます。</p>
<p>セマンティクスについてとてもわかりやすく説明しておきましょう。リスト内包は以下の Python コードと等価です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">expr1</span> <span class="ow">in</span> <span class="n">sequence1</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">expr2</span> <span class="ow">in</span> <span class="n">sequence2</span><span class="p">:</span>
    <span class="o">...</span>
        <span class="k">for</span> <span class="n">exprN</span> <span class="ow">in</span> <span class="n">sequenceN</span><span class="p">:</span>
             <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">):</span>
                  <span class="c1"># Append the value of</span>
                  <span class="c1"># the expression to the</span>
                  <span class="c1"># resulting list.</span>
</pre></div>
</div>
<p>つまり、複数の <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code>...<code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code> 節があって <code class="docutils literal notranslate"><span class="pre">if</span></code> がないときの最終出力は、長さが各シーケンス長の積に等しくなるということです。長さ 3 のリスト二つなら、出力リストの長さは 9 要素です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">seq1</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span>
<span class="n">seq2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>
<span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p>Python の文法に曖昧さを紛れ込ませないように、<em>expression</em> でタプルを作るなら括弧で囲わなくてはなりません。下にあるリスト内包表記で、最初のは構文エラーですが、二番目は有効です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Syntax error</span>
<span class="p">[</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>
<span class="c1"># Correct</span>
<span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>
</pre></div>
</div>
<p>リスト内包表記のアイディアは、もともとは関数型プログラミング言語 Haskell (<a class="reference external" href="https://www.haskell.org">https://www.haskell.org</a>) に由来しています。Greg Ewing が Python にこれを追加することを最も実際的に主張し、彼が最初のリスト内包のパッチを書きました。それは傍目には終わりのない議論が python-dev メーリングリストにて続き、Skip Montanaro によって最新に保たれました。</p>
</section>
<section id="augmented-assignment">
<h2>累算代入 (Augmented Assignment)<a class="headerlink" href="2.0.html#augmented-assignment" title="Link to this heading">¶</a></h2>
<p>累算代入はもう一つの長らく待ち望まれた機能であり、Python 2.0 に追加されました。累算代入演算子には  <code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code> などがあります。例えばステートメント <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">2</span></code> は変数 <code class="docutils literal notranslate"><span class="pre">a</span></code> に 2 を加算し、これはちょっとだけ長い記述 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">2</span></code> と同じです。</p>
<p>The full list of supported assignment operators is <code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>,
<code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">%=</span></code>, <code class="docutils literal notranslate"><span class="pre">**=</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>, <code class="docutils literal notranslate"><span class="pre">|=</span></code>, <code class="docutils literal notranslate"><span class="pre">^=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, and <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>.  Python
classes can override the augmented assignment operators by defining methods
named <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__isub__()</span></code>, etc.  For example, the following
<code class="xref py py-class docutils literal notranslate"><span class="pre">Number</span></code> class stores a number and supports using += to create a new
instance with an incremented value.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Number</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">increment</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Number</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">increment</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="n">Number</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">n</span> <span class="o">+=</span> <span class="mi">3</span>
<span class="nb">print</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span>
</pre></div>
</div>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code> special method is called with the value of the increment,
and should return a new instance with an appropriately modified value; this
return value is bound as the new value of the variable on the left-hand side.</p>
<p>累算代入演算子は最初に C 言語で導入されて、 <strong class="program">awk</strong>, C++, Java, Perl, PHP といった C から派生した言語のほとんどでサポートされています。累算代入のパッチは Thomas Wouters により実装されました。</p>
</section>
<section id="string-methods">
<h2>文字列メソッド<a class="headerlink" href="2.0.html#string-methods" title="Link to this heading">¶</a></h2>
<p>Until now string-manipulation functionality was in the <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> module,
which was usually a front-end for the <code class="xref py py-mod docutils literal notranslate"><span class="pre">strop</span></code> module written in C.  The
addition of Unicode posed a difficulty for the <code class="xref py py-mod docutils literal notranslate"><span class="pre">strop</span></code> module, because the
functions would all need to be rewritten in order to accept either 8-bit or
Unicode strings.  For functions such as <code class="xref py py-func docutils literal notranslate"><span class="pre">string.replace()</span></code>, which takes 3
string arguments, that means eight possible permutations, and correspondingly
complicated code.</p>
<p>代わりに、Python 2.0 は問題を文字列型に押し込み、文字列操作機能が 8 ビット文字列と Unicode 文字列の両方のメソッドを通じて利用可能としました。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;andrew&#39;</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
<span class="go">&#39;Andrew&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;hostname&#39;</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;os&#39;</span><span class="p">,</span> <span class="s1">&#39;linux&#39;</span><span class="p">)</span>
<span class="go">&#39;hlinuxtname&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;moshe&#39;</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;sh&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>変わらない一つのこと、華やかなエイプリルフールのジョークではありませんが、それは Python 文字列が <a class="reference internal" href="../glossary.html#term-immutable"><span class="xref std std-term">immutable</span></a> だということです。ですので文字列メソッドは新しい文字列を返し、それが操作する文字列を変更しません。</p>
<p>古い <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> モジュールはまだ後方互換性のために残されますが、それはほとんど新たな文字列メソッドへのフロントエンドとして振舞います。</p>
<p>Two methods which have no parallel in pre-2.0 versions, although they did exist
in JPython for quite some time, are <code class="xref py py-meth docutils literal notranslate"><span class="pre">startswith()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">endswith()</span></code>.
<code class="docutils literal notranslate"><span class="pre">s.startswith(t)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">s[:len(t)]</span> <span class="pre">==</span> <span class="pre">t</span></code>, while
<code class="docutils literal notranslate"><span class="pre">s.endswith(t)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">s[-len(t):]</span> <span class="pre">==</span> <span class="pre">t</span></code>.</p>
<p>One other method which deserves special mention is <code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code>.  The
<code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code> method of a string receives one parameter, a sequence of strings,
and is equivalent to the <code class="xref py py-func docutils literal notranslate"><span class="pre">string.join()</span></code> function from the old <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a>
module, with the arguments reversed. In other words, <code class="docutils literal notranslate"><span class="pre">s.join(seq)</span></code> is
equivalent to the old <code class="docutils literal notranslate"><span class="pre">string.join(seq,</span> <span class="pre">s)</span></code>.</p>
</section>
<section id="garbage-collection-of-cycles">
<h2>循環参照のガベージコレクション<a class="headerlink" href="2.0.html#garbage-collection-of-cycles" title="Link to this heading">¶</a></h2>
<p>Python の C 実装は、ガーベージコレクションの実装に参照カウントを使っています。全ての Python オブジェクトは自身を参照している数を維持していて、参照が作成されたり破壊されたりするカウントを調整しています。参照カウントがゼロになればそのオブジェクトにはもはや到達可能ではありません。あなたはそれにアクセスするためのオブジェクトへの参照を持つ必要がありますが、カウントがゼロならば参照はもはや存在しないということです。</p>
<p>参照カウントはある種望ましい特徴を持っています。それは理解しやすく、実装しやすく、結果としての実装の移植性は高く、かなり高速であり、そして、独自のメモリ処理方式を実装しているようなほかのライブラリと共にでも良く振舞います。参照カウントの主要な問題点は、それが時々、オブジェクトにはもう到達不能であることに気付かないので、結果としてメモリリークを引き起こすことです。これは参照の循環がある場合に発生します。</p>
<p>最も単純な循環について考えてみます。クラスインスタンスが自身への参照を持つ場合です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">instance</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="p">()</span>
<span class="n">instance</span><span class="o">.</span><span class="n">myself</span> <span class="o">=</span> <span class="n">instance</span>
</pre></div>
</div>
<p>上の例の 2 行のコードが実行された後では、 <code class="docutils literal notranslate"><span class="pre">instance</span></code> の参照カウントは 2 です。参照の一つ目は <code class="docutils literal notranslate"><span class="pre">'instance'</span></code> と名付けられた変数からのもので、もう一つの参照は、インスタンスの <code class="docutils literal notranslate"><span class="pre">myself</span></code> 属性から来るものです。</p>
<p>このあとに続くコードが <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">instance</span></code> だとしたら、何が起こるでしょうか? <code class="docutils literal notranslate"><span class="pre">instance</span></code> の参照カウントは 1 減るので参照カウントは 1 になります。 <code class="docutils literal notranslate"><span class="pre">myself</span></code> 属性内の参照はいまだ存在します。けれどもインスタンスはもう Python コードからは到達不能ですから、本来削除出来るはずです。お互いを参照しあうならばいくつものオブジェクトが循環に参加しえるので、結果それら全てのオブジェクトはリークしてしまいます。</p>
<p>Python 2.0 はこの問題を、循環検出アルゴリズムを周期的に実行することによりフィックスします。そのアルゴリズムは、到達不能な循環を探して関係するオブジェクトを削除します。新しく追加された <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> モジュールは、ガーベージコレクションを実行する関数、デバッグのための統計情報を取得する関数、コレクタのパラメータを調整する関数を提供します。</p>
<p>循環検出アルゴリズムの実行はいくらかの時間がかかるので、結果として多少の追加的なオーバヘッドがかかるでしょう。2.0 を使って循環のコレクションの経験を積んだのちに、 Python 2.1 では注意深い調整によりオーバヘッドを最小に出来ることが望まれています。今のところパフォーマンスの損失がいかほどなのかは明らかではありません。これはこれのベンチマークがトリッキーであり、プログラムがどれだけの頻度でオブジェクトを構築・破棄するのかに大きく依存するからです。循環の検出は Python コンパイル時に無効に出来ます。もしもあなたが小さな速度のペナルティでさえも許容出来ないであるとか、あるいは循環のコレクションがバギーであることを疑うのであれば、 <strong class="program">configure</strong> スクリプト実行時に <code class="xref std std-option docutils literal notranslate"><span class="pre">--without-cycle-gc</span></code> スイッチを与えることでそうすることが出来ます。 (---訳注: Python 2.3 でこの循環参照の GC は必須となり、 <code class="xref std std-option docutils literal notranslate"><span class="pre">--without-cycle-gc</span></code> 、 <code class="xref std std-option docutils literal notranslate"><span class="pre">--with-cycle-gc</span></code> での有無効化は撤廃されました。---)</p>
<p>何人かの人々がこの問題に体当たりで取り組み、解決に対する貢献をしました。循環検出アプローチの初期の実装は、Toby Kelsey により書かれました。現在のアルゴリズムは CNRI を訪れている間に Eric Tiedemann によって提案されて、Guido van Rossum と Neil Schemenauer が別々の 2 つの実装を書いて、あとで Neil によって統合されたものです。そこに至るまでにもほかの数多くの人々によって提案がなされました。python-dev メーリングリストの 2000 年 3 月のアーカイブに、これに関するほとんどの議論が含まれています。特にタイトルが &quot;Reference cycle collection for Python&quot; と &quot;Finalization again&quot; のスレッドです。</p>
</section>
<section id="other-core-changes">
<h2>その他の言語コアの変更<a class="headerlink" href="2.0.html#other-core-changes" title="Link to this heading">¶</a></h2>
<p>Python 文法とビルトイン関数について、色々マイナーな変更がなされました。影響が広範囲に及ぶものは一つもありませんが、手軽で便利なものです。</p>
<section id="minor-language-changes">
<h3>言語のマイナー変更<a class="headerlink" href="2.0.html#minor-language-changes" title="Link to this heading">¶</a></h3>
<p>A new syntax makes it more convenient to call a given function with a tuple of
arguments and/or a dictionary of keyword arguments. In Python 1.5 and earlier,
you'd use the <code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code> built-in function: <code class="docutils literal notranslate"><span class="pre">apply(f,</span> <span class="pre">args,</span> <span class="pre">kw)</span></code> calls the
function <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code> with the argument tuple <em>args</em> and the keyword arguments in
the dictionary <em>kw</em>.  <code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code>  is the same in 2.0, but thanks to a patch
from Greg Ewing, <code class="docutils literal notranslate"><span class="pre">f(*args,</span> <span class="pre">**kw)</span></code> is a shorter and clearer way to achieve the
same effect.  This syntax is symmetrical with the syntax for defining
functions:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="c1"># args is a tuple of positional args,</span>
    <span class="c1"># kw is a dictionary of keyword args</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">print</span></code> statement can now have its output directed to a file-like
object by following the <code class="docutils literal notranslate"><span class="pre">print</span></code> with  <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span> <span class="pre">file</span></code>, similar to the
redirection operator in Unix shells. Previously you'd either have to use the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> method of the file-like object, which lacks the convenience and
simplicity of <code class="docutils literal notranslate"><span class="pre">print</span></code>, or you could assign a new value to
<code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> and then restore the old value.  For sending output to standard
error, it's much easier to write this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="o">&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Warning: action field not supplied&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">module</span> <span class="pre">as</span> <span class="pre">name</span></code> または <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">name</span> <span class="pre">as</span> <span class="pre">othername</span></code> という構文を使って、インポートするモジュールの名前をリネーム出来るようになりました。パッチは Thomas Wouters が投稿しました。</p>
<p><code class="docutils literal notranslate"><span class="pre">%</span></code> 演算子を使う際に新しい書式化スタイルが利用可能です; '%r' はその引数の <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> を挿入します。これは対称性の検討からも考えられました。今の場合は既存の '%s' が引数の <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> を挿入することに呼応するものです。例えば <code class="docutils literal notranslate"><span class="pre">'%r</span> <span class="pre">%s'</span> <span class="pre">%</span> <span class="pre">('abc',</span> <span class="pre">'abc')</span></code> は文字列 <code class="docutils literal notranslate"><span class="pre">'abc'</span> <span class="pre">abc</span></code> を返します。</p>
<p>Previously there was no way to implement a class that overrode Python's built-in
<a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> operator and implemented a custom version.  <code class="docutils literal notranslate"><span class="pre">obj</span> <span class="pre">in</span> <span class="pre">seq</span></code> returns
true if <em>obj</em> is present in the sequence <em>seq</em>; Python computes this by simply
trying every index of the sequence until either <em>obj</em> is found or an
<a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> is encountered.  Moshe Zadka contributed a patch which adds a
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code> magic method for providing a custom implementation for
<code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code>. Additionally, new built-in objects written in C can define what
<code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code> means for them via a new slot in the sequence protocol.</p>
<p>以前のバージョンの Python では、オブジェクトの削除に再帰するアルゴリズムを使っていました。データ構造が深くネストしている場合、インタプリタが C のスタックを使い果たしてクラッシュしていました。Christian Tismer はこの問題をフィックスする削除ロジックに書き直しました。これに関係する注目すべきものとしては、再帰するオブジェクトの比較が無限再帰してクラッシュしていたのを、Jeremy Hylton が書き直してクラッシュしないようにして、有用な結果を生成するようにしたことです。例えば以下コード:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The comparison <code class="docutils literal notranslate"><span class="pre">a==b</span></code> returns true, because the two recursive data structures
are isomorphic. See the thread &quot;trashcan and PR#7&quot; in the April 2000 archives of
the python-dev mailing list for the discussion leading up to this
implementation, and some useful relevant links.    Note that comparisons can now
also raise exceptions. In earlier versions of Python, a comparison operation
such as <code class="docutils literal notranslate"><span class="pre">cmp(a,b)</span></code> would always produce an answer, even if a user-defined
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__cmp__()</span></code> method encountered an error, since the resulting exception would
simply be silently swallowed.</p>
<p>Work has been done on porting Python to 64-bit Windows on the Itanium processor,
mostly by Trent Mick of ActiveState.  (Confusingly, <code class="docutils literal notranslate"><span class="pre">sys.platform</span></code> is still
<code class="docutils literal notranslate"><span class="pre">'win32'</span></code> on Win64 because it seems that for ease of porting, MS Visual C++
treats code as 32 bit on Itanium.) PythonWin also supports Windows CE; see the
Python CE page at <a class="reference external" href="https://pythonce.sourceforge.net/">https://pythonce.sourceforge.net/</a> for more information.</p>
<p>Another new platform is Darwin/MacOS X; initial support for it is in Python 2.0.
Dynamic loading works, if you specify &quot;configure --with-dyld --with-suffix=.x&quot;.
Consult the README in the Python source distribution for more instructions.</p>
<p>変数に値が割り当てられる前にローカル変数を参照するコードにおいて、 <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 例外はよく混乱するものであり、この欠点を軽減する試みがなされました。例えば下に挙げるコードは <code class="docutils literal notranslate"><span class="pre">print</span></code> 文で 1.5.2 と 2.0 の両方で例外が発生しますが、1.5.2 は <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 例外が、2.0 では新規の例外 <a class="reference internal" href="../library/exceptions.html#UnboundLocalError" title="UnboundLocalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnboundLocalError</span></code></a> が投げられます。 <a class="reference internal" href="../library/exceptions.html#UnboundLocalError" title="UnboundLocalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnboundLocalError</span></code></a> は <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> のサブクラスですので <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> が投げられることを想定する既存のコードはそのまま動作するはずです。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="nb">print</span> <span class="s2">&quot;i=&quot;</span><span class="p">,</span><span class="n">i</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p>2 つの新規例外 <a class="reference internal" href="../library/exceptions.html#TabError" title="TabError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TabError</span></code></a> と <a class="reference internal" href="../library/exceptions.html#IndentationError" title="IndentationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndentationError</span></code></a> が導入されました。これらはともに <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> のサブクラスで、Python コードに不適切なインデントが見つかると送出されます。</p>
</section>
<section id="changes-to-built-in-functions">
<h3>ビルトイン関数の変更<a class="headerlink" href="2.0.html#changes-to-built-in-functions" title="Link to this heading">¶</a></h3>
<p>新しいビルトイン関数 <code class="docutils literal notranslate"><span class="pre">zip(seq1,</span> <span class="pre">seq2,</span> <span class="pre">...)</span></code> が追加されました。 <a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> はタプルのリストを返します。それぞれは、引数のシーケンスのそれぞれの i 番目要素たちを含むタプルです。 <a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> と <code class="docutils literal notranslate"><span class="pre">map(None,</span> <span class="pre">seq1,</span> <span class="pre">seq2)</span></code> の違いは、 <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> はシーケンスが同じ長さを持たない場合に <code class="docutils literal notranslate"><span class="pre">None</span></code> が埋められるのに対し、 <a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> は返すリストの長さを、引数のシーケンスの最も短い長さに切り詰めます。</p>
<p>The <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> and <code class="xref py py-func docutils literal notranslate"><span class="pre">long()</span></code> functions now accept an optional &quot;base&quot;
parameter when the first argument is a string. <code class="docutils literal notranslate"><span class="pre">int('123',</span> <span class="pre">10)</span></code> returns 123,
while <code class="docutils literal notranslate"><span class="pre">int('123',</span> <span class="pre">16)</span></code> returns 291.  <code class="docutils literal notranslate"><span class="pre">int(123,</span> <span class="pre">16)</span></code> raises a
<a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception with the message &quot;can't convert non-string with
explicit base&quot;.</p>
<p><a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> モジュールに、これまでより詳細なバージョン情報を持つ変数が追加されました。 <code class="docutils literal notranslate"><span class="pre">sys.version_info</span></code> はタプル <code class="docutils literal notranslate"><span class="pre">(major,</span> <span class="pre">minor,</span> <span class="pre">micro,</span> <span class="pre">level,</span> <span class="pre">serial)</span></code> です。例えば仮に 2.0.1beta1 というバージョンだったとすれば、 <code class="docutils literal notranslate"><span class="pre">sys.version_info</span></code> は <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">'beta',</span> <span class="pre">1)</span></code> となるでしょう。 <em>level</em> は <code class="docutils literal notranslate"><span class="pre">&quot;alpha&quot;</span></code> や <code class="docutils literal notranslate"><span class="pre">&quot;beta&quot;</span></code> といった文字列で、最終リリースでは <code class="docutils literal notranslate"><span class="pre">&quot;final&quot;</span></code> です。(---訳注: Python 2.7 で名前付きタプルになっています。また、その属性名では level ではなく releaselevel です。---)</p>
<p>Dictionaries have an odd new method, <code class="docutils literal notranslate"><span class="pre">setdefault(key,</span> <span class="pre">default)</span></code>, which
behaves similarly to the existing <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code> method.  However, if the key is
missing, <code class="xref py py-meth docutils literal notranslate"><span class="pre">setdefault()</span></code> both returns the value of <em>default</em> as <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code>
would do, and also inserts it into the dictionary as the value for <em>key</em>.  Thus,
the following lines of code:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nb">dict</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span> <span class="n">key</span> <span class="p">):</span> <span class="k">return</span> <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</pre></div>
</div>
<p>は、単一の <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">dict.setdefault(key,</span> <span class="pre">[])</span></code> ステートメントだけで書けます。</p>
<p>再帰の暴走を C のスタックが埋め尽くされてコアダンプしたり GPF (訳注: General Protection Fault) する前に捕捉するために、インタプリタは最大の再帰の深さをセットします。以前まではこの制限は Python コンパイル時点で決めてしまっていましたが、2.0 では最大の再帰の深さは <a class="reference internal" href="../library/sys.html#sys.getrecursionlimit" title="sys.getrecursionlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getrecursionlimit()</span></code></a> と <a class="reference internal" href="../library/sys.html#sys.setrecursionlimit" title="sys.setrecursionlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setrecursionlimit()</span></code></a> を使って読み取れ、修正出来ます。このデフォルトは 1000 です。また、当該プラットフォームでのおよその最大値は、新たに追加されたスクリプト <code class="file docutils literal notranslate"><span class="pre">Misc/find_recursionlimit.py</span></code> を実行することで知ることが出来ます。</p>
</section>
</section>
<section id="porting-to-2-0">
<h2>Python 2.0 への移植<a class="headerlink" href="2.0.html#porting-to-2-0" title="Link to this heading">¶</a></h2>
<p>新しい Python リリースは以前のリリースとの互換性を保つために苦心していますし、その記録はかなり良くなされてきました。ですがいくつかの変更に関しては、大抵は大きな誤りであると判明した初期デザインを修正するという理由で、後方互換性を破壊することを必ずしも回避せずに有用性が検討されています。このセクションでは Python 2.0 において、古い Python コードを破壊するかもしれない変更点について列挙します。</p>
<p>The change which will probably break the most code is tightening up the
arguments accepted by some methods.  Some methods would take multiple arguments
and treat them as a tuple, particularly various list methods such as
<code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code>. In earlier versions of Python, if <code class="docutils literal notranslate"><span class="pre">L</span></code> is
a list, <code class="docutils literal notranslate"><span class="pre">L.append(</span> <span class="pre">1,2</span> <span class="pre">)</span></code> appends the tuple <code class="docutils literal notranslate"><span class="pre">(1,2)</span></code> to the list.  In Python
2.0 this causes a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception to be raised, with the message:
'append requires exactly 1 argument; 2 given'.  The fix is to simply add an
extra set of parentheses to pass both values as a tuple:  <code class="docutils literal notranslate"><span class="pre">L.append(</span> <span class="pre">(1,2)</span> <span class="pre">)</span></code>.</p>
<p>The earlier versions of these methods were more forgiving because they used an
old function in Python's C interface to parse their arguments; 2.0 modernizes
them to use <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>, the current argument parsing function,
which provides more helpful error messages and treats multi-argument calls as
errors.  If you absolutely must use 2.0 but can't fix your code, you can edit
<code class="file docutils literal notranslate"><span class="pre">Objects/listobject.c</span></code> and define the preprocessor symbol
<code class="docutils literal notranslate"><span class="pre">NO_STRICT_LIST_APPEND</span></code> to preserve the old behaviour; this isn't recommended.</p>
<p><a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> モジュールのいくつかの関数についてはまだこの方法が許されています。例えば、 <code class="docutils literal notranslate"><span class="pre">socket.connect(</span> <span class="pre">('hostname',</span> <span class="pre">25)</span> <span class="pre">)</span></code> が正しい形式なのですが、 <code class="docutils literal notranslate"><span class="pre">socket.connect('hostname',</span> <span class="pre">25)</span></code> も動作します。<a class="reference internal" href="../library/socket.html#socket.socket.connect_ex" title="socket.socket.connect_ex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect_ex</span></code></a> と <a class="reference internal" href="../library/socket.html#socket.socket.bind" title="socket.socket.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.bind</span></code></a> も同じようにおおらかです。2.0alpha1 がそれら関数を厳しくしたのですが、ドキュメントが実際には複数引数を取る形式で誤って書かれたために、多くの人々がその厳しくなったチェックに違反してしまうコードを書いてしまいました。GvR はその変更を、市民たちの反応を受けて元に戻し、 <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> モジュールについてはドキュメントは修正されて、複数引数形式は非推奨としてマークするに留められました。将来バージョンの Python においてこれはもう一度厳しく <em>なります</em> 。 (---訳注: What's New からは読み取れませんが少なくとも 2.7 では単一引数でしか渡せません。つまり明示的にタプルにして渡す必要があります。---)</p>
<p>文字列リテラル内の <code class="docutils literal notranslate"><span class="pre">\x</span></code> エスケープは、正確に 2 桁の 16 進表記文字になりました。以前は 'x' に続く 16 進表記文字全てを消費して最後の 8 ビットを使っていたため、 <code class="docutils literal notranslate"><span class="pre">\x123456</span></code> は <code class="docutils literal notranslate"><span class="pre">\x56</span></code> と同じでした。</p>
<p>例外 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> と <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> がよりフレンドリなエラーメッセージを持つようになっています。それらのテキストは <code class="docutils literal notranslate"><span class="pre">'Spam'</span> <span class="pre">instance</span> <span class="pre">has</span> <span class="pre">no</span> <span class="pre">attribute</span> <span class="pre">'eggs'</span></code> や <code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">'eggs'</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">defined</span></code> のようなものになります。以前まではエラーメッセージは存在しない属性名 <code class="docutils literal notranslate"><span class="pre">eggs</span></code> だけでしたので、この事実に便乗して書かれたコードは 2.0 では壊れます。</p>
<p>Some work has been done to make integers and long integers a bit more
interchangeable.  In 1.5.2, large-file support was added for Solaris, to allow
reading files larger than 2 GiB; this made the <code class="xref py py-meth docutils literal notranslate"><span class="pre">tell()</span></code> method of file
objects return a long integer instead of a regular integer.  Some code would
subtract two file offsets and attempt to use the result to multiply a sequence
or slice a string, but this raised a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.  In 2.0, long integers
can be used to multiply or slice a sequence, and it'll behave as you'd
intuitively expect it to; <code class="docutils literal notranslate"><span class="pre">3L</span> <span class="pre">*</span> <span class="pre">'abc'</span></code> produces 'abcabcabc', and
<code class="docutils literal notranslate"><span class="pre">(0,1,2,3)[2L:4L]</span></code> produces (2,3). Long integers can also be used in various
contexts where previously only integers were accepted, such as in the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">seek()</span></code> method of file objects, and in the formats supported by the <code class="docutils literal notranslate"><span class="pre">%</span></code>
operator (<code class="docutils literal notranslate"><span class="pre">%d</span></code>, <code class="docutils literal notranslate"><span class="pre">%i</span></code>, <code class="docutils literal notranslate"><span class="pre">%x</span></code>, etc.).  For example, <code class="docutils literal notranslate"><span class="pre">&quot;%d&quot;</span> <span class="pre">%</span> <span class="pre">2L**64</span></code> will
produce the string <code class="docutils literal notranslate"><span class="pre">18446744073709551616</span></code>.</p>
<p>一番微妙な長整数についての変更は、長整数を <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> してももはや末尾の 'L' 文字が付かないことです。 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> では今でも付くのにも関わらずです。 'L' は長整数を普通の整数と全く同じように印字したい多くの人々を悩ませてきました。それを各々自分なりの手段で取り除く必要があったからです。これはもう 2.0 では問題でなくなりましたが、 'L' が付くことをあてにして <code class="docutils literal notranslate"><span class="pre">str(longval)[:-1]</span></code> とするコードが今度は数値の最後の桁を失ってしまいます。</p>
<p>Taking the <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> of a float now uses a different formatting precision
than <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a>.  <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> uses <code class="docutils literal notranslate"><span class="pre">%.17g</span></code> format string for C's
<code class="xref py py-func docutils literal notranslate"><span class="pre">sprintf()</span></code>, while <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> uses <code class="docutils literal notranslate"><span class="pre">%.12g</span></code> as before.  The effect is that
<a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> may occasionally show more decimal places than  <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a>, for
certain numbers.  For example, the number 8.1 can't be represented exactly in
binary, so <code class="docutils literal notranslate"><span class="pre">repr(8.1)</span></code> is <code class="docutils literal notranslate"><span class="pre">'8.0999999999999996'</span></code>, while str(8.1) is
<code class="docutils literal notranslate"><span class="pre">'8.1'</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">-X</span></code> command-line option, which turned all standard exceptions into
strings instead of classes, has been removed; the standard exceptions will now
always be classes.  The <code class="xref py py-mod docutils literal notranslate"><span class="pre">exceptions</span></code> module containing the standard
exceptions was translated from Python to a built-in C module, written by Barry
Warsaw and Fredrik Lundh.</p>
</section>
<section id="extending-embedding-changes">
<h2>拡張と埋め込みについての変更<a class="headerlink" href="2.0.html#extending-embedding-changes" title="Link to this heading">¶</a></h2>
<p>いくつかの変更点については覆いが被されていて、C 拡張モジュールや大きなアプリケーションでの Python インタプリタの埋め込みを書く人々からしか見えないものです。Python C API を扱う必要がないのであれば、このセクションは読み飛ばして差し支えありません。</p>
<p>Python C API のバージョン番号がインクリメントされたので、1.5.2 でコンパイルされた C 拡張は 2.0 で動作させるために再コンパイルしなければなりません。Windows では Python 1.5.x でビルドされたサードパーティ拡張を Python 2.0 でインポートすることは、Windows の DLL の仕組みのために、出来ません。その場合 Python は例外を投げ、インポートは失敗します。(---訳注: この文章、おかしなことを言っているので一応…。おそらく「Windows の一般市民は C コンパイラを持っていない」ことが著者の頭にあって、手が滑っているのだと思います。DLL の動作の仕組みが問題となるのは事実ですが、本質的には Windows 云々はあまり関係ないです。API が変わるか ABI が変わるならプラットフォームに関係なくリコンパイルは常に必要です。 ---)</p>
<p>Users of Jim Fulton's ExtensionClass module will be pleased to find out that
hooks have been added so that ExtensionClasses are now supported by
<a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> and <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>. This means you no longer have to
remember to write code such as <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">type(obj)</span> <span class="pre">==</span> <span class="pre">myExtensionClass</span></code>, but can use
the more natural <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">isinstance(obj,</span> <span class="pre">myExtensionClass)</span></code>.</p>
<p><code class="file docutils literal notranslate"><span class="pre">Python/importdl.c</span></code> ファイルが多くの異なるプラットフォームの動的ロードをサポートするのに大量の #ifdef だらけになっていたのを、Greg Stein が掃除して再編成しました。 <code class="file docutils literal notranslate"><span class="pre">importdl.c</span></code> は今ではとても小さくなり、プラットフォーム依存のコードは <code class="file docutils literal notranslate"><span class="pre">Python/dynload_*.c</span></code> ファイル群の束にそれぞれ移動しました。もう一つの掃除。include/ ディレクトリ内で色々な移植性のためのハックを施すためのたくさんの <code class="file docutils literal notranslate"><span class="pre">my*.h</span></code> ファイルたちが、単一の <code class="file docutils literal notranslate"><span class="pre">Include/pyport.h</span></code> にマージされました。</p>
<p>Vladimir Marangozov の手による、待ち望まれた malloc の再編成が完了しました。これは Python インタプリタが C 標準の <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> の代わりにカスタムアロケータを使うことを容易にするものです。ドキュメントについては <code class="file docutils literal notranslate"><span class="pre">Include/pymem.h</span></code> と <code class="file docutils literal notranslate"><span class="pre">Include/objimpl.h</span></code> のコメントを読んで下さい。インターフェイスが決着するまでの間の長い長い議論については python.org の 'patches' と 'python-dev' リストのウェブアーカイブをみてください。(---訳注: この件についての続きの話が  What's New in Python 2.3 に Pymalloc として少しわかりやすく記述されています。---)</p>
<p>MacOS の GUSI 開発環境の最近のバージョンは POSIX スレッドをサポートしています。ですので Python の POSIX スレッディングのサポートは今では Macintosh で動作します。ユーザ空間での GNU <code class="docutils literal notranslate"><span class="pre">pth</span></code> ライブラリを使ったスレッディングサポートも寄稿されました。</p>
<p>Windows でのスレッディングサポートも拡張されました。Windows は、競合があるケースでのみカーネルオブジェクトを使うスレッドロックをサポートしています。競合がない普通のケースではそれらはより単純な関数を使い、これは段違いに高速です。NT での Python 1.5.2 版でスレッド化すると、非スレッド版の 2 倍遅くなりますが、2.0 に変えるとその差はたった 10% です。これらの改善は Yakov Markovitch の貢献によるものです。</p>
<p>Python 2.0 のソースが ANSI C プロトタイプだけを使うようになったので、Python のコンパイルには ANSI C コンパイラが必須になりました。K&amp;R C しかサポートしないコンパイラではもうコンパイル出来ません。</p>
<p>Previously the Python virtual machine used 16-bit numbers in its bytecode,
limiting the size of source files.  In particular, this affected the maximum
size of literal lists and dictionaries in Python source; occasionally people who
are generating Python code would run into this limit.  A patch by Charles G.
Waldman raises the limit from <code class="docutils literal notranslate"><span class="pre">2**16</span></code> to <code class="docutils literal notranslate"><span class="pre">2**32</span></code>.</p>
<p>Three new convenience functions intended for adding constants to a module's
dictionary at module initialization time were added: <a class="reference internal" href="../c-api/module.html#c.PyModule_AddObject" title="PyModule_AddObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_AddObject()</span></code></a>,
<a class="reference internal" href="../c-api/module.html#c.PyModule_AddIntConstant" title="PyModule_AddIntConstant"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_AddIntConstant()</span></code></a>, and <a class="reference internal" href="../c-api/module.html#c.PyModule_AddStringConstant" title="PyModule_AddStringConstant"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_AddStringConstant()</span></code></a>.  Each
of these functions takes a module object, a null-terminated C string containing
the name to be added, and a third argument for the value to be assigned to the
name.  This third argument is, respectively, a Python object, a C long, or a C
string.</p>
<p>Unix スタイルのシグナルハンドラへのラッパーAPIが追加されました。 <a class="reference internal" href="../c-api/sys.html#c.PyOS_getsig" title="PyOS_getsig"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_getsig()</span></code></a> でシグナルハンドラを取得し、 <a class="reference internal" href="../c-api/sys.html#c.PyOS_setsig" title="PyOS_setsig"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_setsig()</span></code></a> で新しいハンドラをセットします。</p>
</section>
<section id="distutils-making-modules-easy-to-install">
<h2>Distutils: モジュールの簡単インストール<a class="headerlink" href="2.0.html#distutils-making-modules-easy-to-install" title="Link to this heading">¶</a></h2>
<p>Python 2.0 以前は、モジュールのインストールは退屈な作業でした -- Python がどこにインストールされているかや拡張モジュールのコンパイルに必要なオプションを自動的に知る方法はありませんでした。ソフトウェアの作者は Makefile と設定ファイル群の編集という大変な労力を要する儀式を通過しなければならないのに、それは実際には Unix だけのためであって Windows と MacOS のサポートを置き去りにするものでした。Python ユーザは全く異なったインストール命令に直面していました。それは拡張パッケージごとに異なり、Python インストールをある種つまらない作業としていました。</p>
<p>The SIG for distribution utilities, shepherded by Greg Ward, has created the
Distutils, a system to make package installation much easier.  They form the
<code class="docutils literal notranslate"><span class="pre">distutils</span></code> package, a new part of Python's standard library. In the best
case, installing a Python module from source will require the same steps: first
you simply mean unpack the tarball or zip archive, and the run &quot;<code class="docutils literal notranslate"><span class="pre">python</span>
<span class="pre">setup.py</span> <span class="pre">install</span></code>&quot;.  The platform will be automatically detected, the compiler
will be recognized, C extension modules will be compiled, and the distribution
installed into the proper directory.  Optional command-line arguments provide
more control over the installation process, the distutils package offers many
places to override defaults -- separating the build from the install, building
or installing in non-default directories, and more.</p>
<p>Distutils を使うには <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> スクリプトを書く必要があります。単純なケースでは、ソフトウェアが .py ファイルだけを含む場合、最小限の <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> は数行足らずで書けます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="n">setup</span> <span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;1.0&quot;</span><span class="p">,</span>
       <span class="n">py_modules</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;module1&quot;</span><span class="p">,</span> <span class="s2">&quot;module2&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p><code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> ファイルは、ソフトウェアが少しのパッケージで構成される場合はこれより大きく複雑になることはありません:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="n">setup</span> <span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;1.0&quot;</span><span class="p">,</span>
       <span class="n">packages</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;package&quot;</span><span class="p">,</span> <span class="s2">&quot;package.subpackage&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>C 拡張が最も複雑なケースになりえます。以下は PyXML パッケージからもってきた例です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Extension</span>

<span class="n">expat_extension</span> <span class="o">=</span> <span class="n">Extension</span><span class="p">(</span><span class="s1">&#39;xml.parsers.pyexpat&#39;</span><span class="p">,</span>
     <span class="n">define_macros</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;XML_NS&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)],</span>
     <span class="n">include_dirs</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;extensions/expat/xmltok&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;extensions/expat/xmlparse&#39;</span> <span class="p">],</span>
     <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;extensions/pyexpat.c&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;extensions/expat/xmltok/xmltok.c&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;extensions/expat/xmltok/xmlrole.c&#39;</span><span class="p">,</span> <span class="p">]</span>
       <span class="p">)</span>
<span class="n">setup</span> <span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;PyXML&quot;</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;0.5.4&quot;</span><span class="p">,</span>
       <span class="n">ext_modules</span> <span class="o">=</span><span class="p">[</span> <span class="n">expat_extension</span> <span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Distutils ではソース配布物、バイナリ配布物の作成の面倒もみてくれます。 &quot;sdist&quot; コマンドは &quot;<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">sdist</span></code>&quot; を実行することで起動し、これは <code class="file docutils literal notranslate"><span class="pre">foo-1.0.tar.gz</span></code> のようなソース配布物を作ります。新しいコマンドを作るのは難しくありません。コマンド &quot;bdist_rpm&quot; と &quot;bdist_wininst&quot; が既に寄稿されていて、各々 RPM 配布物の作成、Windows インストーラの作成を行います。Debian パッケージや Solaris の <code class="file docutils literal notranslate"><span class="pre">.pkg</span></code> のようなほかの配布フォーマットを作成するコマンドについての開発ステージは様々です。</p>
<p>これら全ては、 Python ドキュメントの基本的なセットとして追加されたマニュアル <em>Python モジュールの配布</em> にドキュメントされています。</p>
</section>
<section id="xml-modules">
<h2>XML モジュール<a class="headerlink" href="2.0.html#xml-modules" title="Link to this heading">¶</a></h2>
<p>Python 1.5.2 included a simple XML parser in the form of the <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmllib</span></code>
module, contributed by Sjoerd Mullender.  Since 1.5.2's release, two different
interfaces for processing XML have become common: SAX2 (version 2 of the Simple
API for XML) provides an event-driven interface with some similarities to
<code class="xref py py-mod docutils literal notranslate"><span class="pre">xmllib</span></code>, and the DOM (Document Object Model) provides a tree-based
interface, transforming an XML document into a tree of nodes that can be
traversed and modified.  Python 2.0 includes a SAX2 interface and a stripped-down
DOM interface as part of the <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> package. Here we will give a brief
overview of these new interfaces; consult the Python documentation or the source
code for complete details. The Python XML SIG is also working on improved
documentation.</p>
<section id="sax2-support">
<h3>SAX2 サポート<a class="headerlink" href="2.0.html#sax2-support" title="Link to this heading">¶</a></h3>
<p>SAX defines an event-driven interface for parsing XML.  To use SAX, you must
write a SAX handler class.  Handler classes inherit from various classes
provided by SAX, and override various methods that will then be called by the
XML parser.  For example, the <a class="reference internal" href="../library/xml.sax.handler.html#xml.sax.handler.ContentHandler.startElement" title="xml.sax.handler.ContentHandler.startElement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startElement()</span></code></a> and <a class="reference internal" href="../library/xml.sax.handler.html#xml.sax.handler.ContentHandler.endElement" title="xml.sax.handler.ContentHandler.endElement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">endElement()</span></code></a>
methods are called for every starting and end tag encountered by the parser, the
<a class="reference internal" href="../library/xml.sax.handler.html#xml.sax.handler.ContentHandler.characters" title="xml.sax.handler.ContentHandler.characters"><code class="xref py py-meth docutils literal notranslate"><span class="pre">characters()</span></code></a> method is called for every chunk of character data, and so
forth.</p>
<p>イベントドリブンのアプローチはドキュメント全体をいっときにメモリに持たなくて良い点で有利であり、ドキュメントが本当に巨大であるものを処理する際にはこれは重要です。ですが SAX ハンドラクラスを記述することは、ドキュメント構造を変更しようとする場合にはある種入り組んだものとなって、とても複雑になりえます。</p>
<p>以下の小さな実例プログラムでは、全ての開始・終了タグでメッセージを印字するハンドラを定義して、ファイル <code class="file docutils literal notranslate"><span class="pre">hamlet.xml</span></code> をそのハンドラを使ってパースしています:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xml</span> <span class="kn">import</span> <span class="n">sax</span>

<span class="k">class</span> <span class="nc">SimpleHandler</span><span class="p">(</span><span class="n">sax</span><span class="o">.</span><span class="n">ContentHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">startElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;Start of element:&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">endElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;End of element:&#39;</span><span class="p">,</span> <span class="n">name</span>

<span class="c1"># Create a parser object</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">sax</span><span class="o">.</span><span class="n">make_parser</span><span class="p">()</span>

<span class="c1"># Tell it what handler to use</span>
<span class="n">handler</span> <span class="o">=</span> <span class="n">SimpleHandler</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">setContentHandler</span><span class="p">(</span> <span class="n">handler</span> <span class="p">)</span>

<span class="c1"># Parse a file!</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span> <span class="s1">&#39;hamlet.xml&#39;</span> <span class="p">)</span>
</pre></div>
</div>
<p>For more information, consult the Python documentation, or the XML HOWTO at
<a class="reference external" href="https://pyxml.sourceforge.net/topics/howto/xml-howto.html">https://pyxml.sourceforge.net/topics/howto/xml-howto.html</a>.</p>
</section>
<section id="dom-support">
<h3>DOM サポート<a class="headerlink" href="2.0.html#dom-support" title="Link to this heading">¶</a></h3>
<p>The Document Object Model is a tree-based representation for an XML document.  A
top-level <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code> instance is the root of the tree, and has a single
child which is the top-level <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> instance. This <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code>
has children nodes representing character data and any sub-elements, which may
have further children of their own, and so forth.  Using the DOM you can
traverse the resulting tree any way you like, access element and attribute
values, insert and delete nodes, and convert the tree back into XML.</p>
<p>DOM は XML ドキュメントを修正するのに有用です。というのも DOM ツリーは作成出来、新規ノードを追加したりサブツリーを再編成したりすることで修正出来、出力として新たな XML ドキュメントを生成出来るからです。DOM ツリーを手動で構築して XML に変換することも出来ます。これにより単純に <code class="docutils literal notranslate"><span class="pre">&lt;tag1&gt;</span></code>...<code class="docutils literal notranslate"><span class="pre">&lt;/tag1&gt;</span></code> をファイルに書くよりも柔軟性の高い方法で XML 出力を生成出来ます。</p>
<p>The DOM implementation included with Python lives in the <a class="reference internal" href="../library/xml.dom.minidom.html#module-xml.dom.minidom" title="xml.dom.minidom: Minimal Document Object Model (DOM) implementation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.dom.minidom</span></code></a>
module.  It's a lightweight implementation of the Level 1 DOM with support for
XML namespaces.  The  <code class="xref py py-func docutils literal notranslate"><span class="pre">parse()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">parseString()</span></code> convenience
functions are provided for generating a DOM tree:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xml.dom</span> <span class="kn">import</span> <span class="n">minidom</span>
<span class="n">doc</span> <span class="o">=</span> <span class="n">minidom</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;hamlet.xml&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">doc</span></code> is a <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code> instance.  <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code>, like all the other
DOM classes such as <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">Text</span></code>, is a subclass of the
<code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code> base class.  All the nodes in a DOM tree therefore support certain
common methods, such as <code class="xref py py-meth docutils literal notranslate"><span class="pre">toxml()</span></code> which returns a string containing the XML
representation of the node and its children.  Each class also has special
methods of its own; for example, <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code>
instances have a method to find all child elements with a given tag name.
Continuing from the previous 2-line example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">perslist</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">getElementsByTagName</span><span class="p">(</span> <span class="s1">&#39;PERSONA&#39;</span> <span class="p">)</span>
<span class="nb">print</span> <span class="n">perslist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">toxml</span><span class="p">()</span>
<span class="nb">print</span> <span class="n">perslist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">toxml</span><span class="p">()</span>
</pre></div>
</div>
<p><em>Hamlet</em> XML ファイルに対して上の例は以下のような出力をします:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">PERSONA</span><span class="o">&gt;</span><span class="n">CLAUDIUS</span><span class="p">,</span> <span class="n">king</span> <span class="n">of</span> <span class="n">Denmark</span><span class="o">.</span> <span class="o">&lt;/</span><span class="n">PERSONA</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">PERSONA</span><span class="o">&gt;</span><span class="n">HAMLET</span><span class="p">,</span> <span class="n">son</span> <span class="n">to</span> <span class="n">the</span> <span class="n">late</span><span class="p">,</span> <span class="ow">and</span> <span class="n">nephew</span> <span class="n">to</span> <span class="n">the</span> <span class="n">present</span> <span class="n">king</span><span class="o">.&lt;/</span><span class="n">PERSONA</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>ドキュメントのルートエレメントは <code class="docutils literal notranslate"><span class="pre">doc.documentElement</span></code> として取得出来、その子は簡単に、ノードを削除したり追加したりすることで修正出来ます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">documentElement</span>

<span class="c1"># Remove the first child</span>
<span class="n">root</span><span class="o">.</span><span class="n">removeChild</span><span class="p">(</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>

<span class="c1"># Move the new first child to the end</span>
<span class="n">root</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>

<span class="c1"># Insert the new first child (originally,</span>
<span class="c1"># the third child) before the 20th child.</span>
<span class="n">root</span><span class="o">.</span><span class="n">insertBefore</span><span class="p">(</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Again, I will refer you to the Python documentation for a complete listing of
the different <code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code> classes and their various methods.</p>
</section>
<section id="relationship-to-pyxml">
<h3>PyXML との関係<a class="headerlink" href="2.0.html#relationship-to-pyxml" title="Link to this heading">¶</a></h3>
<p>The XML Special Interest Group has been working on XML-related Python code for a
while.  Its code distribution, called PyXML, is available from the SIG's web
pages at <a class="reference external" href="https://www.python.org/community/sigs/current/xml-sig">https://www.python.org/community/sigs/current/xml-sig</a>. The PyXML distribution also used
the package name <code class="docutils literal notranslate"><span class="pre">xml</span></code>.  If you've written programs that used PyXML, you're
probably wondering about its compatibility with the 2.0 <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> package.</p>
<p>結論として、Python 2.0 の <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> パッケージは PyXML と互換性がありません。ですが、直近バージョンの PyXML をインストールすることで互換性を持たせることができます。 多くのアプリケーションは Python 2.0 に含まれる XML サポートで十分ですが、より複雑なアプリケーションは完全なPyXML パッケージをインストールする必要があります。 インストールされた PyXML バージョン 0.6.0 以上は、Python に同梱されている <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> パッケージを置き換え、標準パッケージの厳密なスーパーセットとなり、多くの追加機能が追加されます。 PyXML の追加機能には次のようなものがあります。</p>
<ul class="simple">
<li><p>4DOM, a full DOM implementation from FourThought, Inc.</p></li>
<li><p>The xmlproc validating parser, written by Lars Marius Garshol.</p></li>
<li><p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">sgmlop</span></code> parser accelerator module, written by Fredrik Lundh.</p></li>
</ul>
</section>
</section>
<section id="module-changes">
<h2>更新されたモジュール<a class="headerlink" href="2.0.html#module-changes" title="Link to this heading">¶</a></h2>
<p>Lots of improvements and bugfixes were made to Python's extensive standard
library; some of the affected modules include <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a>,
<a class="reference internal" href="../library/configparser.html#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ConfigParser</span></code></a>, <a class="reference internal" href="../library/cgi.html#module-cgi" title="cgi: Helpers for running Python scripts via the Common Gateway Interface. (非推奨)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cgi</span></code></a>, <a class="reference internal" href="../library/calendar.html#module-calendar" title="calendar: Functions for working with calendars, including some emulation of the Unix cal program."><code class="xref py py-mod docutils literal notranslate"><span class="pre">calendar</span></code></a>, <a class="reference internal" href="../library/posix.html#module-posix" title="posix: The most common POSIX system calls (normally used via module os). (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">posix</span></code></a>, <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a>,
<code class="xref py py-mod docutils literal notranslate"><span class="pre">xmllib</span></code>, <a class="reference internal" href="../library/aifc.html#module-aifc" title="aifc: Read and write audio files in AIFF or AIFC format. (非推奨)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">aifc</span></code></a>, <a class="reference internal" href="../library/chunk.html#module-chunk" title="chunk: Module to read IFF chunks. (非推奨)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">chunk</span></code></a> <a class="reference internal" href="../library/wave.html#module-wave" title="wave: Provide an interface to the WAV sound format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">wave</span></code></a>, <a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a>, <a class="reference internal" href="../library/shelve.html#module-shelve" title="shelve: Python object persistence."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shelve</span></code></a>,
and <a class="reference internal" href="../library/nntplib.html#module-nntplib" title="nntplib: NNTP protocol client (requires sockets). (非推奨)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nntplib</span></code></a>.  Consult the CVS logs for the exact patch-by-patch details.</p>
<p>Brian Gallew contributed OpenSSL support for the <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> module.  OpenSSL
is an implementation of the Secure Socket Layer, which encrypts the data being
sent over a socket.  When compiling Python, you can edit <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code>
to include SSL support, which adds an additional function to the <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a>
module: <code class="docutils literal notranslate"><span class="pre">socket.ssl(socket,</span> <span class="pre">keyfile,</span> <span class="pre">certfile)</span></code>, which takes a socket
object and returns an SSL socket.  The <a class="reference internal" href="../library/http.html#module-http" title="http: HTTP status codes and messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code></a> and <a class="reference internal" href="../library/urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> modules
were also changed to support <code class="docutils literal notranslate"><span class="pre">https://</span></code> URLs, though no one has implemented
FTP or SMTP over SSL.</p>
<p>The <a class="reference internal" href="../library/http.html#module-http" title="http: HTTP status codes and messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code></a> module has been rewritten by Greg Stein to support HTTP/1.1.</p>
<p>Backward compatibility with the 1.5 version of <code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code> is provided,
though using HTTP/1.1 features such as pipelining will require rewriting code to
use a different set of interfaces.</p>
<p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> module now supports Tcl/Tk version 8.1, 8.2, or 8.3, and
support for the older 7.x versions has been dropped.  The Tkinter module now
supports displaying Unicode strings in Tk widgets. Also, Fredrik Lundh
contributed an optimization which makes operations like <code class="docutils literal notranslate"><span class="pre">create_line</span></code> and
<code class="docutils literal notranslate"><span class="pre">create_polygon</span></code> much faster, especially when using lots of coordinates.</p>
<p><a class="reference internal" href="../library/curses.html#module-curses" title="curses: An interface to the curses library, providing portable terminal handling. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">curses</span></code></a> モジュールが、Oliver Andrich による拡張版をもとに大規模に拡張され、ncurses と SYSV curses からの多くの追加機能、例えば色付きの表示、別の文字集合サポート、パッド、マウスサポートなどをサポートするようになりました。このことは、モジュールが BSD curses だけしか持っていない OS とは互換性が無いことを意味しますが、現在メンテナンスされている OS でそういう類のものは無さそうです。</p>
<p>2.0 の Unicode サポートについて前述したように、 <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> モジュールで提供される正規表現の根底となる実装が変更されました。SRE は新しい正規表現エンジンで、Fredrik Lundh によって書かれ、部分的に Hewlett Packard 社により寄贈されました。これは 8 ビット文字列と Unicode 文字列両方に合致するようサポートされています。</p>
</section>
<section id="new-modules">
<h2>新しいモジュール<a class="headerlink" href="2.0.html#new-modules" title="Link to this heading">¶</a></h2>
<p>数多くのモジュールが新しく追加されました。ここではそれらを短い説明とともに列挙するだけにします。特定のモジュールの詳細は 2.0 のドキュメントを調べてください。</p>
<ul class="simple">
<li><p><a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a>: Python インタプリタが終了する前に呼び出す関数を登録します。これまで <code class="docutils literal notranslate"><span class="pre">sys.exitfunc</span></code> に直接セットしてきたコードは  <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> モジュールを代わりに用いるように修正してください。 <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> をインポートし、 <a class="reference internal" href="../library/atexit.html#atexit.register" title="atexit.register"><code class="xref py py-func docutils literal notranslate"><span class="pre">atexit.register()</span></code></a> で終了時に呼び出す関数を登録します。(Contributed by Skip Montanaro.)</p></li>
<li><p><a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings</span></code>, <a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a>:  Added as part of the new
Unicode support.</p></li>
<li><p><a class="reference internal" href="../library/filecmp.html#module-filecmp" title="filecmp: Compare files efficiently."><code class="xref py py-mod docutils literal notranslate"><span class="pre">filecmp</span></code></a>: Supersedes the old <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmp</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmpcache</span></code> and
<code class="xref py py-mod docutils literal notranslate"><span class="pre">dircmp</span></code> modules, which have now become deprecated. (Contributed by Gordon
MacMillan and Moshe Zadka.)</p></li>
<li><p><a class="reference internal" href="../library/gettext.html#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code></a>: このモジュールは Python プログラムに、GNU gettext メッセージカタログライブラリへのインターフェイスを提供することで国際化 (I18N=internationalization) と地域化 (L10N=localization) サポートをもたらします。 (Integrated by Barry Warsaw, from separate contributions by Martin von Löwis, Peter Funk, and James Henstridge.)</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">linuxaudiodev</span></code>: Support for the <code class="file docutils literal notranslate"><span class="pre">/dev/audio</span></code> device on Linux, a
twin to the existing <code class="xref py py-mod docutils literal notranslate"><span class="pre">sunaudiodev</span></code> module. (Contributed by Peter Bosch,
with fixes by Jeremy Hylton.)</p></li>
<li><p><a class="reference internal" href="../library/mmap.html#module-mmap" title="mmap: Interface to memory-mapped files for Unix and Windows."><code class="xref py py-mod docutils literal notranslate"><span class="pre">mmap</span></code></a>: Windows、Unix 両方でのメモリマップドファイルへのインターフェイスです。ファイル内容をメモリに直接マッピング出来、それは <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">mutable</span></a> な文字列であるかのように振る舞い、これにより読み書き出来ます。それらは例えば <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> モジュールのような普通は文字列を期待するような関数にさえも渡せます。(Contributed by Sam Rushing, with some extensions by A.M. Kuchling.)</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyexpat</span></code>: An interface to the Expat XML parser. (Contributed by Paul
Prescod.)</p></li>
<li><p><a class="reference internal" href="../library/urllib.robotparser.html#module-urllib.robotparser" title="urllib.robotparser: Load a robots.txt file and answer questions about fetchability of other URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">robotparser</span></code></a>: Parse a <code class="file docutils literal notranslate"><span class="pre">robots.txt</span></code> file, which is used for writing
web spiders that politely avoid certain areas of a web site.  The parser accepts
the contents of a <code class="file docutils literal notranslate"><span class="pre">robots.txt</span></code> file, builds a set of rules from it, and
can then answer questions about the fetchability of a given URL.  (Contributed
by Skip Montanaro.)</p></li>
<li><p><a class="reference internal" href="../library/tabnanny.html#module-tabnanny" title="tabnanny: Tool for detecting white space related problems in Python source files in a directory tree."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tabnanny</span></code></a>: Python ソースコードが曖昧なインデントになっていないかをチェックするモジュール/スクリプトです。 (Contributed by Tim Peters.)</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">UserString</span></code>: A base class useful for deriving objects that behave like
strings.</p></li>
<li><p><a class="reference internal" href="../library/webbrowser.html#module-webbrowser" title="webbrowser: Easy-to-use controller for web browsers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">webbrowser</span></code></a>: 指定した URL で、プラットフォームに依存しない方法でウェブブラウザを起動するモジュールです。個々のプラットフォームにおいて様々なブラウザが特定の順序で試されます。ユーザはどのブラウザを起動するかを環境変数 <em>BROWSER</em> をセットすることで変更出来ます。(元々は Eric S. Raymond による <a class="reference internal" href="../library/urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> への、同じ機能追加をするパッチに触発されましたが、最終的なモジュールは Fred Drake が元々 <code class="file docutils literal notranslate"><span class="pre">Tools/idle/BrowserControl.py</span></code> として実装したものに由来し、Fred が標準ライブラリに適合させました。)</p></li>
<li><p><a class="reference internal" href="../library/winreg.html#module-winreg" title="winreg: Routines and objects for manipulating the Windows registry. (Windows)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code></a>: An interface to the Windows registry.  <code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code> is an
adaptation of functions that have been part of PythonWin since 1995, but has now
been added to the core  distribution, and enhanced to support Unicode.
<code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code> was written by Bill Tutt and Mark Hammond.</p></li>
<li><p><a class="reference internal" href="../library/zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a>: ZIP 形式アーカイブの読み書きのためのモジュールです。DOS/Windows での <strong class="program">PKZIP</strong> や Unix での <strong class="program">zip</strong> により生成されるアーカイブで、 <strong class="program">gzip</strong> 形式とは混同しないで下さい (こちらは <a class="reference internal" href="../library/gzip.html#module-gzip" title="gzip: Interfaces for gzip compression and decompression using file objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gzip</span></code></a> モジュールによってサポートされています)。(Contributed by James C. Ahlstrom.)</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">imputil</span></code>: A module that provides a simpler way for writing customized
import hooks, in comparison to the existing <code class="xref py py-mod docutils literal notranslate"><span class="pre">ihooks</span></code> module.  (Implemented
by Greg Stein, with much discussion on python-dev along the way.)</p></li>
</ul>
</section>
<section id="idle-improvements">
<h2>IDLE の改善<a class="headerlink" href="2.0.html#idle-improvements" title="Link to this heading">¶</a></h2>
<p>IDLE は公式の Python のクロスプラットフォームな IDE で、 Tkinter を使って書かれています。Python 2.0 では IDLE 0.6 を含めました。これは多くの新機能追加と改善がなされています。以下はその一部です:</p>
<ul class="simple">
<li><p>UI の、特にシンタックスハイライトと自動インデントの領域において、改善と最適化がなされました。</p></li>
<li><p>クラスブラウザで、例えばモジュール内のトップレベル関数のような、より多くの情報をみることが出来るようになりました。</p></li>
<li><p>タブ幅をユーザ制御出来るようになりました。既存の Python ファイルを操作する際には、IDLE は自動的にインデントの慣習を検知してそれに合わせます。</p></li>
<li><p>色々なプラットフォームでブラウザの呼び出しがサポートされています。これを使って、ブラウザで Python ドキュメントを開きます。</p></li>
<li><p>IDLE がコマンドラインを持つようになりました。これは普通の Python インタプリタに大きく似せてあります。</p></li>
<li><p>色々な場所でコンテキストヘルプが出るようになっています。</p></li>
<li><p>IDLE は今ではパッケージとしてインストール出来ます。</p></li>
<li><p>エディタウィンドウ内では、下部に行/桁を表示するようになっています。</p></li>
<li><p>新たな 3 つのキーストロークコマンド: モジュールのチェック (<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Alt</kbd>-<kbd class="kbd docutils literal notranslate">F5</kbd></kbd>)、モジュールのインポート (<kbd class="kbd docutils literal notranslate">F5</kbd>)、スクリプト実行 (<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>-<kbd class="kbd docutils literal notranslate">F5</kbd></kbd>).</p></li>
</ul>
</section>
<section id="deleted-and-deprecated-modules">
<h2>削除されたモジュール、非推奨となったモジュール<a class="headerlink" href="2.0.html#deleted-and-deprecated-modules" title="Link to this heading">¶</a></h2>
<p>A few modules have been dropped because they're obsolete, or because there are
now better ways to do the same thing.  The <code class="xref py py-mod docutils literal notranslate"><span class="pre">stdwin</span></code> module is gone; it was
for a platform-independent windowing toolkit that's no longer developed.</p>
<p>A number of modules have been moved to the <code class="file docutils literal notranslate"><span class="pre">lib-old</span></code> subdirectory:
<code class="xref py py-mod docutils literal notranslate"><span class="pre">cmp</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmpcache</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">dircmp</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">dump</span></code>,  <code class="xref py py-mod docutils literal notranslate"><span class="pre">find</span></code>,
<code class="xref py py-mod docutils literal notranslate"><span class="pre">grep</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">packmail</span></code>,  <code class="xref py py-mod docutils literal notranslate"><span class="pre">poly</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">util</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">whatsound</span></code>,
<code class="xref py py-mod docutils literal notranslate"><span class="pre">zmod</span></code>.  If you have code which relies on a module  that's been moved to
<code class="file docutils literal notranslate"><span class="pre">lib-old</span></code>, you can simply add that directory to <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>   to get them
back, but you're encouraged to update any code that uses these modules.</p>
</section>
<section id="acknowledgements">
<h2>謝辞<a class="headerlink" href="2.0.html#acknowledgements" title="Link to this heading">¶</a></h2>
<p>著者は提案の申し出や修正、様々なこの記事の草稿の助けをしてくれた以下の人々に感謝します:  David Bolen, Mark Hammond, Gregg Hauser, Jeremy Hylton, Fredrik Lundh, Detlef Lannert, Aahz Maruch, Skip Montanaro, Vladimir Marangozov, Tobias Polzin, Guido van Rossum, Neil Schemenauer, and Russ Schmidt.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="2.0.html#">What's New in Python 2.0</a><ul>
<li><a class="reference internal" href="2.0.html#introduction">はじめに</a></li>
<li><a class="reference internal" href="2.0.html#what-about-python-1-6">Python 1.6 はいかがですか?</a></li>
<li><a class="reference internal" href="2.0.html#new-development-process">新しい開発プロセス</a></li>
<li><a class="reference internal" href="2.0.html#unicode">Unicode 文字列型</a></li>
<li><a class="reference internal" href="2.0.html#list-comprehensions">リストの内包表記</a></li>
<li><a class="reference internal" href="2.0.html#augmented-assignment">累算代入 (Augmented Assignment)</a></li>
<li><a class="reference internal" href="2.0.html#string-methods">文字列メソッド</a></li>
<li><a class="reference internal" href="2.0.html#garbage-collection-of-cycles">循環参照のガベージコレクション</a></li>
<li><a class="reference internal" href="2.0.html#other-core-changes">その他の言語コアの変更</a><ul>
<li><a class="reference internal" href="2.0.html#minor-language-changes">言語のマイナー変更</a></li>
<li><a class="reference internal" href="2.0.html#changes-to-built-in-functions">ビルトイン関数の変更</a></li>
</ul>
</li>
<li><a class="reference internal" href="2.0.html#porting-to-2-0">Python 2.0 への移植</a></li>
<li><a class="reference internal" href="2.0.html#extending-embedding-changes">拡張と埋め込みについての変更</a></li>
<li><a class="reference internal" href="2.0.html#distutils-making-modules-easy-to-install">Distutils: モジュールの簡単インストール</a></li>
<li><a class="reference internal" href="2.0.html#xml-modules">XML モジュール</a><ul>
<li><a class="reference internal" href="2.0.html#sax2-support">SAX2 サポート</a></li>
<li><a class="reference internal" href="2.0.html#dom-support">DOM サポート</a></li>
<li><a class="reference internal" href="2.0.html#relationship-to-pyxml">PyXML との関係</a></li>
</ul>
</li>
<li><a class="reference internal" href="2.0.html#module-changes">更新されたモジュール</a></li>
<li><a class="reference internal" href="2.0.html#new-modules">新しいモジュール</a></li>
<li><a class="reference internal" href="2.0.html#idle-improvements">IDLE の改善</a></li>
<li><a class="reference internal" href="2.0.html#deleted-and-deprecated-modules">削除されたモジュール、非推奨となったモジュール</a></li>
<li><a class="reference internal" href="2.0.html#acknowledgements">謝辞</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="2.1.html"
                          title="前の章へ">What's New in Python 2.1</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="changelog.html"
                          title="次の章へ">変更履歴</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.0.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="サイドバーをたたむ">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="changelog.html" title="変更履歴"
             >次へ</a> |</li>
        <li class="right" >
          <a href="2.1.html" title="What&#39;s New in Python 2.1"
             >前へ</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >What's New in Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="2.0.html">What's New in Python 2.0</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" id="search-box" />
          <input type="submit" value="検索" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    Copyright
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="../../../license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最終更新: Jun 11, 2024 (04:44 UTC)
    
      <a href="../../../bugs.html">Found a bug</a>?
    
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>

    <script type="text/javascript" src="../_static/switchers.js"></script>
  </body>
</html>