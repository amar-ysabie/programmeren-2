<!DOCTYPE html>

<html lang="fr" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Glossaire" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/glossary.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content=">>>, L'invite de commande utilisée par défaut dans l'interpréteur interactif. On la voit souvent dans des exemples de code qui peuvent être exécutés interactivement dans l'interpréteur.,,..., Peut ..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content=">>>, L'invite de commande utilisée par défaut dans l'interpréteur interactif. On la voit souvent dans des exemples de code qui peuvent être exécutés interactivement dans l'interpréteur.,,..., Peut ..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>Glossaire &#8212; Documentation Python 3.12.4</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
    <link rel="stylesheet" type="text/css" href="_static/pydoctheme.css?v=bb723527" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="_static/pygments_dark.css?v=b20cc3f5" />
    
    <script src="_static/documentation_options.js?v=6f87fcbb"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=bf059b8c"></script>
    
    <script src="_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Recherchez dans Documentation Python 3.12.4"
          href="_static/opensearch.xml"/>
    <link rel="author" title="À propos de ces documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Recherche" href="search.html" />
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="next" title="À propos de ces documents" href="about.html" />
    <link rel="prev" title="FAQ &#34;Pourquoi Python est installé sur mon ordinateur ?&#34;" href="faq/installed.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="https://docs.python.org/3/glossary.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="_static/py.svg" />
            <script type="text/javascript" src="_static/copybutton.js"></script>
            <script type="text/javascript" src="_static/menu.js"></script>
            <script type="text/javascript" src="_static/search-focus.js"></script>
            <script type="text/javascript" src="_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" />
                <input type="submit" value="Go"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="faq/installed.html"
                          title="Chapitre précédent">FAQ &quot;Pourquoi Python est installé sur mon ordinateur ?&quot;</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="about.html"
                          title="Chapitre suivant">À propos de ces documents</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/glossary.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="about.html" title="À propos de ces documents"
             accesskey="N">suivant</a> |</li>
        <li class="right" >
          <a href="faq/installed.html" title="FAQ &#34;Pourquoi Python est installé sur mon ordinateur ?&#34;"
             accesskey="P">précédent</a> |</li>

          <li><img src="_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.12.4 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">Glossaire</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="glossary">
<span id="id1"></span><h1>Glossaire<a class="headerlink" href="#glossary" title="Lien vers cette rubrique">¶</a></h1>
<dl class="glossary">
<dt id="term-0"><code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code><a class="headerlink" href="#term-0" title="Lien vers ce terme">¶</a></dt><dd><p>L'invite de commande utilisée par défaut dans l'interpréteur interactif. On la voit souvent dans des exemples de code qui peuvent être exécutés interactivement dans l'interpréteur.</p>
</dd>
<dt id="term-..."><code class="docutils literal notranslate"><span class="pre">...</span></code><a class="headerlink" href="#term-..." title="Lien vers ce terme">¶</a></dt><dd><p>Peut faire référence à :</p>
<ul class="simple">
<li><p>L'invite de commande utilisée par défaut dans l'interpréteur interactif lorsqu'on entre un bloc de code indenté, dans des délimiteurs fonctionnant par paires (parenthèses, crochets, accolades, triple guillemets), ou après un avoir spécifié un décorateur.</p></li>
<li><p>La constante <a class="reference internal" href="library/constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal notranslate"><span class="pre">Ellipsis</span></code></a>.</p></li>
</ul>
</dd>
<dt id="term-2to3">2to3<a class="headerlink" href="#term-2to3" title="Lien vers ce terme">¶</a></dt><dd><p>Outil qui essaie de convertir du code pour Python 2.x en code pour Python 3.x en gérant la plupart des incompatibilités qui peuvent être détectées en analysant la source et parcourant son arbre syntaxique.</p>
<p><em>2to3</em> est disponible dans la bibliothèque standard sous le nom de <a class="reference internal" href="library/2to3.html#module-lib2to3" title="lib2to3: The 2to3 library"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lib2to3</span></code></a> ; un point d’entrée indépendant est fourni via <code class="file docutils literal notranslate"><span class="pre">Tools/scripts/2to3</span></code>. Cf. <a class="reference internal" href="library/2to3.html#to3-reference"><span class="std std-ref">2to3 --- Automated Python 2 to 3 code translation</span></a>.</p>
</dd>
<dt id="term-abstract-base-class">classe mère abstraite<a class="headerlink" href="#term-abstract-base-class" title="Lien vers ce terme">¶</a></dt><dd><p>Les classes mères abstraites (ABC, suivant l'abréviation anglaise <em>Abstract Base Class</em>) complètent le <a class="reference internal" href="#term-duck-typing"><span class="xref std std-term">duck-typing</span></a> en fournissant un moyen de définir des interfaces pour les cas où d'autres techniques comme <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> seraient inélégantes ou subtilement fausses (par exemple avec les <a class="reference internal" href="reference/datamodel.html#special-lookup"><span class="std std-ref">méthodes magiques</span></a>). Les ABC introduisent des sous-classes virtuelles qui n'héritent pas d'une classe mais qui sont quand même reconnues par <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> ou <a class="reference internal" href="library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> (voir la documentation du module <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a>). Python contient de nombreuses ABC pour les structures de données (dans le module <a class="reference internal" href="library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a>), les nombres (dans le module <a class="reference internal" href="library/numbers.html#module-numbers" title="numbers: Numeric abstract base classes (Complex, Real, Integral, etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">numbers</span></code></a>), les flux (dans le module <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a>) et les chercheurs-chargeurs du système d'importation (dans le module <a class="reference internal" href="library/importlib.html#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a>). Vous pouvez créer vos propres ABC avec le module <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a>.</p>
</dd>
<dt id="term-annotation">annotation<a class="headerlink" href="#term-annotation" title="Lien vers ce terme">¶</a></dt><dd><p>Étiquette associée à une variable, un attribut de classe, un paramètre de fonction ou une valeur de retour. Elle est utilisée par convention comme <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">type hint</span></a>.</p>
<p>Les annotations de variables locales ne sont pas accessibles au moment de l'exécution, mais les annotations de variables globales, d'attributs de classe et de fonctions sont stockées dans l'attribut spécial <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> des modules, classes et fonctions, respectivement.</p>
<p>Voir <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">annotation de variable</span></a>, <a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">annotation de fonction</span></a>, les <span class="target" id="index-70"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> et <span class="target" id="index-71"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>, qui décrivent cette fonctionnalité. Voir aussi <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Bonnes pratiques concernant les annotations</span></a> sur les bonnes pratiques concernant les annotations.</p>
</dd>
<dt id="term-argument">argument<a class="headerlink" href="#term-argument" title="Lien vers ce terme">¶</a></dt><dd><p>Valeur, donnée à une <a class="reference internal" href="#term-function"><span class="xref std std-term">fonction</span></a> ou à une <a class="reference internal" href="#term-method"><span class="xref std std-term">méthode</span></a> lors de son appel. Il existe deux types d'arguments :</p>
<ul>
<li><p><em class="dfn">argument nommé</em> : un argument précédé d'un identifiant (comme <code class="docutils literal notranslate"><span class="pre">name=</span></code>) ou un dictionnaire précédé de <code class="docutils literal notranslate"><span class="pre">**</span></code>, lors d'un appel de fonction. Par exemple, <code class="docutils literal notranslate"><span class="pre">3</span></code> et <code class="docutils literal notranslate"><span class="pre">5</span></code> sont tous les deux des arguments nommés dans l'appel à <a class="reference internal" href="library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> ici :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="n">real</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;real&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;imag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">argument positionnel</em> : un argument qui n'est pas nommé. Les arguments positionnels apparaissent au début de la liste des arguments, ou donnés sous forme d'un <a class="reference internal" href="#term-iterable"><span class="xref std std-term">itérable</span></a> précédé par <code class="docutils literal notranslate"><span class="pre">*</span></code>. Par exemple, <code class="docutils literal notranslate"><span class="pre">3</span></code> et <code class="docutils literal notranslate"><span class="pre">5</span></code> sont tous les deux des arguments positionnels dans les appels suivants :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
<p>Les arguments se retrouvent dans le corps de la fonction appelée parmi les variables locales. Voir la section <a class="reference internal" href="reference/expressions.html#calls"><span class="std std-ref">Appels</span></a> à propos des règles dictant cette affectation. Syntaxiquement, toute expression est acceptée comme argument, et c'est la valeur résultante de l'expression qui sera affectée à la variable locale.</p>
<p>Voir aussi <a class="reference internal" href="#term-parameter"><span class="xref std std-term">paramètre</span></a> dans le glossaire, la question <a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">Différence entre argument et paramètre</span></a> de la FAQ et la <span class="target" id="index-72"></span><a class="pep reference external" href="https://peps.python.org/pep-0362/"><strong>PEP 362</strong></a>.</p>
</dd>
<dt id="term-asynchronous-context-manager">gestionnaire de contexte asynchrone<a class="headerlink" href="#term-asynchronous-context-manager" title="Lien vers ce terme">¶</a></dt><dd><p>(<em>asynchronous context manager</em> en anglais) Objet contrôlant l'environnement à l'intérieur d'une instruction <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> en définissant les méthodes <a class="reference internal" href="reference/datamodel.html#object.__aenter__" title="object.__aenter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aenter__()</span></code></a> et <a class="reference internal" href="reference/datamodel.html#object.__aexit__" title="object.__aexit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code></a>. A été Introduit par la <span class="target" id="index-73"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-asynchronous-generator">générateur asynchrone<a class="headerlink" href="#term-asynchronous-generator" title="Lien vers ce terme">¶</a></dt><dd><p>Fonction qui renvoie un <a class="reference internal" href="#term-asynchronous-generator-iterator"><span class="xref std std-term">itérateur de générateur asynchrone</span></a>. Cela ressemble à une coroutine définie par <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>, sauf qu'elle contient une ou des expressions <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> produisant ainsi uns série de valeurs utilisables dans une boucle <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>.</p>
<p>Générateur asynchrone fait généralement référence à une fonction, mais peut faire référence à un <em>itérateur de générateur asynchrone</em> dans certains contextes. Dans les cas où le sens voulu n'est pas clair, utiliser l'ensemble des termes lève l’ambiguïté.</p>
<p>Un générateur asynchrone peut contenir des expressions <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> ainsi que des instructions <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>, et <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a>.</p>
</dd>
<dt id="term-asynchronous-generator-iterator">itérateur de générateur asynchrone<a class="headerlink" href="#term-asynchronous-generator-iterator" title="Lien vers ce terme">¶</a></dt><dd><p>Objet créé par un <a class="reference internal" href="#term-asynchronous-generator"><span class="xref std std-term">générateur asynchrone</span></a>.</p>
<p>C'est un <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> qui, lorsqu'il est appelé via la méthode <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> renvoie un objet <em>awaitable</em> qui exécute le corps de la fonction du générateur asynchrone jusqu'au prochain <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>.</p>
<p>Chaque <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> suspend temporairement l'exécution, en gardant en mémoire l'emplacement et l'état de l'exécution (ce qui inclut les variables locales et les <em>try</em> en cours). Lorsque l'exécution de l'itérateur de générateur asynchrone reprend avec un nouvel <em>awaitable</em> renvoyé par <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a>, elle repart de là où elle s'était arrêtée. Voir les <span class="target" id="index-74"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> et <span class="target" id="index-75"></span><a class="pep reference external" href="https://peps.python.org/pep-0525/"><strong>PEP 525</strong></a>.</p>
</dd>
<dt id="term-asynchronous-iterable">itérable asynchrone<a class="headerlink" href="#term-asynchronous-iterable" title="Lien vers ce terme">¶</a></dt><dd><p>Objet qui peut être utilisé dans une instruction <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>. Sa méthode <a class="reference internal" href="reference/datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> doit renvoyer un <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a>. A été introduit par la <span class="target" id="index-76"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-asynchronous-iterator">itérateur asynchrone<a class="headerlink" href="#term-asynchronous-iterator" title="Lien vers ce terme">¶</a></dt><dd><p>Objet qui implémente les méthodes <a class="reference internal" href="reference/datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> et <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a>. <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> doit renvoyer un objet <a class="reference internal" href="#term-awaitable"><span class="xref std std-term">awaitable</span></a>. Tant que la méthode <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> produit des objets <em>awaitable</em>, le <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> appelant les consomme. L'itérateur asynchrone lève une exception <a class="reference internal" href="library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> pour signifier la fin de l'itération. A été introduit par la <span class="target" id="index-77"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-attribute">attribut<a class="headerlink" href="#term-attribute" title="Lien vers ce terme">¶</a></dt><dd><p>Valeur associée à un objet et habituellement désignée par son nom <em>via</em> une notation utilisant des points. Par exemple, si un objet <em>o</em> possède un attribut <em>a</em>, cet attribut est référencé par <em>o.a</em>.</p>
<p>Il est possible de donner à un objet un attribut dont le nom n'est pas un identifiant tel que défini pour les <a class="reference internal" href="reference/lexical_analysis.html#identifiers"><span class="std std-ref">Identifiants et mots-clés</span></a>, par exemple en utilisant <a class="reference internal" href="library/functions.html#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a>, si l'objet le permet. Un tel attribut ne sera pas accessible à l'aide d'une expression pointée et on devra y accéder avec <a class="reference internal" href="library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a>.</p>
</dd>
<dt id="term-awaitable">attendable (<em>awaitable</em>)<a class="headerlink" href="#term-awaitable" title="Lien vers ce terme">¶</a></dt><dd><p>Objet pouvant être utilisé dans une expression <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>. Ce peut être une <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">coroutine</span></a> ou un objet avec une méthode <a class="reference internal" href="reference/datamodel.html#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>. Voir aussi la <span class="target" id="index-78"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-BDFL">BDFL<a class="headerlink" href="#term-BDFL" title="Lien vers ce terme">¶</a></dt><dd><p>Dictateur bienveillant à vie (<em>Benevolent Dictator For Life</em> en anglais). Pseudonyme de <a class="reference external" href="https://gvanrossum.github.io/">Guido van Rossum</a>, le créateur de Python.</p>
</dd>
<dt id="term-binary-file">fichier binaire<a class="headerlink" href="#term-binary-file" title="Lien vers ce terme">¶</a></dt><dd><p>A <a class="reference internal" href="#term-file-object"><span class="xref std std-term">file object</span></a> able to read and write
<a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a>.
Examples of binary files are files opened in binary mode (<code class="docutils literal notranslate"><span class="pre">'rb'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'wb'</span></code> or <code class="docutils literal notranslate"><span class="pre">'rb+'</span></code>), <a class="reference internal" href="library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin.buffer</span></code></a>,
<a class="reference internal" href="library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout.buffer</span></code></a>, and instances of
<a class="reference internal" href="library/io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> and <a class="reference internal" href="library/gzip.html#gzip.GzipFile" title="gzip.GzipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">gzip.GzipFile</span></code></a>.</p>
<p>Consultez <a class="reference internal" href="#term-text-file"><span class="xref std std-term">fichier texte</span></a>, un objet fichier capable de lire et d'écrire des objets <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
</dd>
<dt id="term-borrowed-reference">référence empruntée<a class="headerlink" href="#term-borrowed-reference" title="Lien vers ce terme">¶</a></dt><dd><p>In Python's C API, a borrowed reference is a reference to an object,
where the code using the object does not own the reference.
It becomes a dangling
pointer if the object is destroyed. For example, a garbage collection can
remove the last <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">strong reference</span></a> to the object and so destroy it.</p>
<p>Il est recommandé d'appeler <a class="reference internal" href="c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_INCREF()</span></code></a> sur la <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">référence empruntée</span></a>, ce qui la transforme <em>in situ</em> en une <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">référence forte</span></a>. Vous pouvez faire une exception si vous êtes certain que l'objet ne peut pas être supprimé avant la dernière utilisation de la référence empruntée. Voir aussi la fonction <a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a>, qui crée une nouvelle <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">référence forte</span></a>.</p>
</dd>
<dt id="term-bytes-like-object">objet octet-compatible<a class="headerlink" href="#term-bytes-like-object" title="Lien vers ce terme">¶</a></dt><dd><p>Un objet gérant le <a class="reference internal" href="c-api/buffer.html#bufferobjects"><span class="std std-ref">protocole tampon</span></a> et pouvant exporter un tampon (<em>buffer</em> en anglais) C-<a class="reference internal" href="#term-contiguous"><span class="xref std std-term">contigu</span></a>. Cela inclut les objets <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> et <a class="reference internal" href="library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a>, ainsi que beaucoup d'objets <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>. Les objets octets-compatibles peuvent être utilisés pour diverses opérations sur des données binaires, comme la compression, la sauvegarde dans un fichier binaire ou l'envoi sur le réseau.</p>
<p>Certaines opérations nécessitent de travailler sur des données binaires variables. La documentation parle de ceux-ci comme des <em>read-write bytes-like objects</em>. Par exemple, <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> ou une <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> d'un <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> en font partie. D'autres opérations nécessitent de travailler sur des données binaires stockées dans des objets immuables (« <em>objets octets-compatibles en lecture seule</em> »), par exemple des <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> ou des <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> d'un objet <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd>
<dt id="term-bytecode">code intermédiaire (<em>bytecode</em>)<a class="headerlink" href="#term-bytecode" title="Lien vers ce terme">¶</a></dt><dd><p>Le code source, en Python, est compilé en un code intermédiaire (<em>bytecode</em> en anglais), la représentation interne à CPython d'un programme Python. Le code intermédiaire est mis en cache dans un fichier <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> de manière à ce qu'une seconde exécution soit plus rapide (la compilation en code intermédiaire a déjà été faite). On dit que ce <em>langage intermédiaire</em> est exécuté sur une <a class="reference internal" href="#term-virtual-machine"><span class="xref std std-term">virtual machine</span></a> qui exécute des instructions machine pour chaque instruction du code intermédiaire. Notez que le code intermédiaire n'a pas vocation à fonctionner sur différentes machines virtuelles Python ou à être stable entre différentes versions de Python.</p>
<p>La documentation du <a class="reference internal" href="library/dis.html#bytecodes"><span class="std std-ref">module dis</span></a> fournit une liste des instructions du code intermédiaire.</p>
</dd>
<dt id="term-callable">appelable (<em>callable</em>)<a class="headerlink" href="#term-callable" title="Lien vers ce terme">¶</a></dt><dd><p>Un appelable est un objet qui peut être appelé, éventuellement avec un ensemble d'arguments (voir  <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>), avec la syntaxe suivante :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">callable</span><span class="p">(</span><span class="n">argument1</span><span class="p">,</span> <span class="n">argument2</span><span class="p">,</span> <span class="n">argumentN</span><span class="p">)</span>
</pre></div>
</div>
<p>Une <a class="reference internal" href="#term-function"><span class="xref std std-term">fonction</span></a>, et par extension une <a class="reference internal" href="#term-method"><span class="xref std std-term">méthode</span></a>, est un appelable. Une instance d'une classe qui implémente la méthode <a class="reference internal" href="reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> est également un appelable.</p>
</dd>
<dt id="term-callback">fonction de rappel (<em>callback</em>)<a class="headerlink" href="#term-callback" title="Lien vers ce terme">¶</a></dt><dd><p>Une fonction (classique, par opposition à une coroutine) passée en argument pour être exécutée plus tard.</p>
</dd>
<dt id="term-class">classe<a class="headerlink" href="#term-class" title="Lien vers ce terme">¶</a></dt><dd><p>Modèle pour créer des objets définis par l'utilisateur. Une définition de classe (<em>class</em>) contient normalement des définitions de méthodes qui agissent sur les instances de la classe.</p>
</dd>
<dt id="term-class-variable">variable de classe<a class="headerlink" href="#term-class-variable" title="Lien vers ce terme">¶</a></dt><dd><p>Une variable définie dans une classe et destinée à être modifiée uniquement au niveau de la classe (c'est-à-dire, pas dans une instance de la classe).</p>
</dd>
<dt id="term-complex-number">nombre complexe<a class="headerlink" href="#term-complex-number" title="Lien vers ce terme">¶</a></dt><dd><p>Extension des nombres réels familiers, dans laquelle tous les nombres sont exprimés sous la forme d'une somme d'une partie réelle et d'une partie imaginaire. Les nombres imaginaires sont les nombres réels multipliés par l'unité imaginaire (la racine carrée de <code class="docutils literal notranslate"><span class="pre">-1</span></code>, souvent écrite <code class="docutils literal notranslate"><span class="pre">i</span></code> en mathématiques ou <code class="docutils literal notranslate"><span class="pre">j</span></code> par les ingénieurs). Python comprend nativement les nombres complexes, écrits avec cette dernière notation : la partie imaginaire est écrite avec un suffixe <code class="docutils literal notranslate"><span class="pre">j</span></code>, exemple, <code class="docutils literal notranslate"><span class="pre">3+1j</span></code>. Pour utiliser les équivalents complexes de <a class="reference internal" href="library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a>, utilisez <a class="reference internal" href="library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a>. Les nombres complexes sont un concept assez avancé en mathématiques. Si vous ne connaissez pas ce concept, vous pouvez tranquillement les ignorer.</p>
</dd>
<dt id="term-context-manager">gestionnaire de contexte<a class="headerlink" href="#term-context-manager" title="Lien vers ce terme">¶</a></dt><dd><p>An object which controls the environment seen in a <a class="reference internal" href="reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>
statement by defining <a class="reference internal" href="reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> and <a class="reference internal" href="reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> methods.
See <span class="target" id="index-9"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a>.</p>
</dd>
<dt id="term-context-variable">variable de contexte<a class="headerlink" href="#term-context-variable" title="Lien vers ce terme">¶</a></dt><dd><p>Une variable qui peut avoir des valeurs différentes en fonction de son contexte. Cela est similaire au stockage par fil d’exécution (<em>Thread Local Storage</em> en anglais) dans lequel chaque fil d’exécution peut avoir une valeur différente pour une variable. Toutefois, avec les variables de contexte, il peut y avoir plusieurs contextes dans un fil d’exécution et l’utilisation principale pour les variables de contexte est de garder une trace des variables dans les tâches asynchrones concourantes. Voir <a class="reference internal" href="library/contextvars.html#module-contextvars" title="contextvars: Context Variables"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a>.</p>
</dd>
<dt id="term-contiguous">contigu<a class="headerlink" href="#term-contiguous" title="Lien vers ce terme">¶</a></dt><dd><p id="index-10">Un tampon (<em>buffer</em> en anglais) est considéré comme contigu s’il est soit <em>C-contigu</em> soit <em>Fortran-contigu</em>. Les tampons de dimension zéro sont C-contigus et Fortran-contigus. Pour un tableau à une dimension, ses éléments doivent être placés en mémoire l’un à côté de l’autre, dans l’ordre croissant de leur indice, en commençant à zéro. Pour qu’un tableau multidimensionnel soit C-contigu, le dernier indice doit être celui qui varie le plus rapidement lors du parcours de ses éléments dans l’ordre de leur adresse mémoire. À l'inverse, dans les tableaux Fortran-contigu, c’est le premier indice qui doit varier le plus rapidement.</p>
</dd>
<dt id="term-coroutine">coroutine<a class="headerlink" href="#term-coroutine" title="Lien vers ce terme">¶</a></dt><dd><p>Les coroutines sont une forme généralisée des fonctions. On entre dans une fonction en un point et on en sort en un autre point. On peut entrer, sortir et reprendre l'exécution d'une coroutine en plusieurs points. Elles peuvent être implémentées en utilisant l'instruction <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>. Voir aussi la <span class="target" id="index-79"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-coroutine-function">fonction coroutine<a class="headerlink" href="#term-coroutine-function" title="Lien vers ce terme">¶</a></dt><dd><p>Fonction qui renvoie un objet <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">coroutine</span></a>. Une fonction coroutine peut être définie par l'instruction <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> et peut contenir les mots clés <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>, <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> ainsi que <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a>. A été introduit par la <span class="target" id="index-80"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-CPython">CPython<a class="headerlink" href="#term-CPython" title="Lien vers ce terme">¶</a></dt><dd><p>L'implémentation canonique du langage de programmation Python, tel que distribué sur <a class="reference external" href="https://www.python.org">python.org</a>. Le terme &quot;CPython&quot; est utilisé dans certains contextes lorsqu'il est nécessaire de distinguer cette implémentation des autres comme <em>Jython</em> ou <em>IronPython</em>.</p>
</dd>
<dt id="term-decorator">décorateur<a class="headerlink" href="#term-decorator" title="Lien vers ce terme">¶</a></dt><dd><p>Fonction dont la valeur de retour est une autre fonction. Un décorateur est habituellement utilisé pour transformer une fonction via la syntaxe <code class="docutils literal notranslate"><span class="pre">&#64;wrapper</span></code>, dont les exemples typiques sont : <a class="reference internal" href="library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> et <a class="reference internal" href="library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>.</p>
<p>La syntaxe des décorateurs est simplement du sucre syntaxique, les définitions des deux fonctions suivantes sont sémantiquement équivalentes :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Quoique moins fréquemment utilisé, le même concept existe pour les classes. Consultez la documentation <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">définitions de fonctions</span></a> et <a class="reference internal" href="reference/compound_stmts.html#class"><span class="std std-ref">définitions de classes</span></a> pour en savoir plus sur les décorateurs.</p>
</dd>
<dt id="term-descriptor">descripteur<a class="headerlink" href="#term-descriptor" title="Lien vers ce terme">¶</a></dt><dd><p>Any object which defines the methods <a class="reference internal" href="reference/datamodel.html#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>,
<a class="reference internal" href="reference/datamodel.html#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a>, or <a class="reference internal" href="reference/datamodel.html#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>.
When a class attribute is a descriptor, its special
binding behavior is triggered upon attribute lookup.  Normally, using
<em>a.b</em> to get, set or delete an attribute looks up the object named <em>b</em> in
the class dictionary for <em>a</em>, but if <em>b</em> is a descriptor, the respective
descriptor method gets called.  Understanding descriptors is a key to a
deep understanding of Python because they are the basis for many features
including functions, methods, properties, class methods, static methods,
and reference to super classes.</p>
<p>Pour plus d'informations sur les méthodes des descripteurs, consultez <a class="reference internal" href="reference/datamodel.html#descriptors"><span class="std std-ref">Implémentation de descripteurs</span></a> ou le <a class="reference internal" href="howto/descriptor.html#descriptorhowto"><span class="std std-ref">guide pour l'utilisation des descripteurs</span></a>.</p>
</dd>
<dt id="term-dictionary">dictionnaire<a class="headerlink" href="#term-dictionary" title="Lien vers ce terme">¶</a></dt><dd><p>An associative array, where arbitrary keys are mapped to values.  The
keys can be any object with <a class="reference internal" href="reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> and
<a class="reference internal" href="reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> methods.
Called a hash in Perl.</p>
</dd>
<dt id="term-dictionary-comprehension">dictionnaire en compréhension (ou dictionnaire en intension)<a class="headerlink" href="#term-dictionary-comprehension" title="Lien vers ce terme">¶</a></dt><dd><p>Écriture concise pour traiter tout ou partie des éléments d'un itérable et renvoyer un dictionnaire contenant les résultats. <code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{n:</span> <span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span> <span class="pre">for</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">range(10)}</span></code> génère un dictionnaire contenant des clés <code class="docutils literal notranslate"><span class="pre">n</span></code> liées à leurs valeurs <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span></code>. Voir <a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">compréhensions</span></a>.</p>
</dd>
<dt id="term-dictionary-view">vue de dictionnaire<a class="headerlink" href="#term-dictionary-view" title="Lien vers ce terme">¶</a></dt><dd><p>Objets retournés par les méthodes <a class="reference internal" href="library/stdtypes.html#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.keys()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#dict.values" title="dict.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.values()</span></code></a> et <a class="reference internal" href="library/stdtypes.html#dict.items" title="dict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.items()</span></code></a>. Ils fournissent des vues dynamiques des entrées du dictionnaire, ce qui signifie que lorsque le dictionnaire change, la vue change. Pour transformer une vue en vraie liste, utilisez <code class="docutils literal notranslate"><span class="pre">list(dictview)</span></code>. Voir <a class="reference internal" href="library/stdtypes.html#dict-views"><span class="std std-ref">Les vues de dictionnaires</span></a>.</p>
</dd>
<dt id="term-docstring">chaîne de documentation (<em>docstring</em>)<a class="headerlink" href="#term-docstring" title="Lien vers ce terme">¶</a></dt><dd><p>A string literal which appears as the first expression in a class,
function or module.  While ignored when the suite is executed, it is
recognized by the compiler and put into the <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> attribute
of the enclosing class, function or module.  Since it is available via
introspection, it is the canonical place for documentation of the
object.</p>
</dd>
<dt id="term-duck-typing">typage canard (<em>duck-typing</em>)<a class="headerlink" href="#term-duck-typing" title="Lien vers ce terme">¶</a></dt><dd><p>Style de programmation qui ne prend pas en compte le type d'un objet pour déterminer s'il respecte une interface, mais qui appelle simplement la méthode ou l'attribut (<em>Si ça a un bec et que ça cancane, ça doit être un canard</em>, <em>duck</em> signifie canard en anglais). En se concentrant sur les interfaces plutôt que les types, du code bien construit améliore sa flexibilité en autorisant des substitutions polymorphiques. Le <em>duck-typing</em> évite de vérifier les types via <a class="reference internal" href="library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> ou <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>, Notez cependant que le <em>duck-typing</em> peut travailler de pair avec les <a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">classes mère abstraites</span></a>. À la place, le <em>duck-typing</em> utilise plutôt <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> ou la programmation <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a>.</p>
</dd>
<dt id="term-EAFP">EAFP<a class="headerlink" href="#term-EAFP" title="Lien vers ce terme">¶</a></dt><dd><p>Il est plus simple de demander pardon que demander la permission (<em>Easier to Ask for Forgiveness than Permission</em> en anglais). Ce style de développement Python fait l'hypothèse que le code est valide et traite les exceptions si cette hypothèse s'avère fausse. Ce style, propre et efficace, est caractérisé par la présence de beaucoup de mots clés <a class="reference internal" href="reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> et <a class="reference internal" href="reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a>. Cette technique de programmation contraste avec le style <a class="reference internal" href="#term-LBYL"><span class="xref std std-term">LBYL</span></a> utilisé couramment dans les langages tels que C.</p>
</dd>
<dt id="term-expression">expression<a class="headerlink" href="#term-expression" title="Lien vers ce terme">¶</a></dt><dd><p>Suite logique de termes et chiffres conformes à la syntaxe Python dont l'évaluation fournit une valeur. En d'autres termes, une expression est une suite d'éléments tels que des noms, opérateurs, littéraux, accès d'attributs, méthodes ou fonctions qui aboutissent à une valeur. Contrairement à beaucoup d'autres langages, les différentes constructions du langage ne sont pas toutes des expressions. On trouve également des <a class="reference internal" href="#term-statement"><span class="xref std std-term">instructions</span></a> qui ne peuvent pas être utilisées comme expressions, tel que <a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a>. Les affectations sont également des instructions et non des expressions.</p>
</dd>
<dt id="term-extension-module">module d'extension<a class="headerlink" href="#term-extension-module" title="Lien vers ce terme">¶</a></dt><dd><p>Module écrit en C ou C++, utilisant l'API C de Python pour interagir avec Python et le code de l'utilisateur.</p>
</dd>
<dt id="term-f-string">f-string<a class="headerlink" href="#term-f-string" title="Lien vers ce terme">¶</a></dt><dd><p>Chaîne littérale préfixée de <code class="docutils literal notranslate"><span class="pre">'f'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'F'</span></code>. Les &quot;f-strings&quot; sont un raccourci pour <a class="reference internal" href="reference/lexical_analysis.html#f-strings"><span class="std std-ref">formatted string literals</span></a>. Voir la <span class="target" id="index-81"></span><a class="pep reference external" href="https://peps.python.org/pep-0498/"><strong>PEP 498</strong></a>.</p>
</dd>
<dt id="term-file-object">objet fichier<a class="headerlink" href="#term-file-object" title="Lien vers ce terme">¶</a></dt><dd><p>An object exposing a file-oriented API (with methods such as
<code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code>) to an underlying resource.  Depending
on the way it was created, a file object can mediate access to a real
on-disk file or to another type of storage or communication device
(for example standard input/output, in-memory buffers, sockets, pipes,
etc.).  File objects are also called <em class="dfn">file-like objects</em> or
<em class="dfn">streams</em>.</p>
<p>Il existe en réalité trois catégories de fichiers objets : les <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">fichiers binaires</span></a> bruts, les <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">fichiers binaires</span></a> avec tampon (<em>buffer</em>) et les <a class="reference internal" href="#term-text-file"><span class="xref std std-term">fichiers textes</span></a>. Leurs interfaces sont définies dans le module <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a>. Le moyen le plus simple et direct de créer un objet fichier est d'utiliser la fonction <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.</p>
</dd>
<dt id="term-file-like-object">objet fichier-compatible<a class="headerlink" href="#term-file-like-object" title="Lien vers ce terme">¶</a></dt><dd><p>Synonyme de <a class="reference internal" href="#term-file-object"><span class="xref std std-term">objet fichier</span></a>.</p>
</dd>
<dt id="term-filesystem-encoding-and-error-handler">encodage du système de fichiers et gestionnaire d'erreurs associé<a class="headerlink" href="#term-filesystem-encoding-and-error-handler" title="Lien vers ce terme">¶</a></dt><dd><p>Encodage et gestionnaire d'erreurs utilisés par Python pour décoder les octets fournis par le système d'exploitation et encoder les chaînes de caractères Unicode afin de les passer au système.</p>
<p>L'encodage du système de fichiers doit impérativement pouvoir décoder tous les octets jusqu'à 128. Si ce n'est pas le cas, certaines fonctions de l'API lèvent <a class="reference internal" href="library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>.</p>
<p>Cet encodage et son gestionnaire d'erreur peuvent être obtenus à l'aide des fonctions <a class="reference internal" href="library/sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencoding()</span></code></a> et <a class="reference internal" href="library/sys.html#sys.getfilesystemencodeerrors" title="sys.getfilesystemencodeerrors"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencodeerrors()</span></code></a>.</p>
<p>L'<a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">encodage du système de fichiers et gestionnaire d'erreurs associé</span></a> sont configurés au démarrage de Python par la fonction <a class="reference internal" href="c-api/init_config.html#c.PyConfig_Read" title="PyConfig_Read"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Read()</span></code></a> : regardez <a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_encoding" title="PyConfig.filesystem_encoding"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_encoding</span></code></a> et <a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_errors" title="PyConfig.filesystem_errors"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_errors</span></code></a> dans les membres de <a class="reference internal" href="c-api/init_config.html#c.PyConfig" title="PyConfig"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyConfig</span></code></a>.</p>
<p>Voir aussi <a class="reference internal" href="#term-locale-encoding"><span class="xref std std-term">encodage régional</span></a>.</p>
</dd>
<dt id="term-finder">chercheur<a class="headerlink" href="#term-finder" title="Lien vers ce terme">¶</a></dt><dd><p>Objet qui essaie de trouver un <a class="reference internal" href="#term-loader"><span class="xref std std-term">chargeur</span></a> pour le module en cours d'importation.</p>
<p>There are two types of finder: <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">meta path finders</span></a> for use with <a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>, and <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">path
entry finders</span></a> for use with <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>.</p>
<p>See <a class="reference internal" href="reference/import.html#importsystem"><span class="std std-ref">Le système d'importation</span></a> and <a class="reference internal" href="library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> for much more detail.</p>
</dd>
<dt id="term-floor-division">division entière<a class="headerlink" href="#term-floor-division" title="Lien vers ce terme">¶</a></dt><dd><p>Division mathématique arrondissant à l'entier inférieur. L'opérateur de la division entière est <code class="docutils literal notranslate"><span class="pre">//</span></code>. Par exemple l'expression <code class="docutils literal notranslate"><span class="pre">11</span> <span class="pre">//</span> <span class="pre">4</span></code> vaut <code class="docutils literal notranslate"><span class="pre">2</span></code>, contrairement à <code class="docutils literal notranslate"><span class="pre">11</span> <span class="pre">/</span> <span class="pre">4</span></code> qui vaut <code class="docutils literal notranslate"><span class="pre">2.75</span></code>. Notez que <code class="docutils literal notranslate"><span class="pre">(-11)</span> <span class="pre">//</span> <span class="pre">4</span></code> vaut <code class="docutils literal notranslate"><span class="pre">-3</span></code> car l'arrondi se fait à l'entier inférieur. Voir la <span class="target" id="index-82"></span><a class="pep reference external" href="https://peps.python.org/pep-0328/"><strong>PEP 328</strong></a>.</p>
</dd>
<dt id="term-function">fonction<a class="headerlink" href="#term-function" title="Lien vers ce terme">¶</a></dt><dd><p>Suite d'instructions qui renvoie une valeur à son appelant. On peut lui passer des <a class="reference internal" href="#term-argument"><span class="xref std std-term">arguments</span></a> qui pourront être utilisés dans le corps de la fonction. Voir aussi <a class="reference internal" href="#term-parameter"><span class="xref std std-term">paramètre</span></a>, <a class="reference internal" href="#term-method"><span class="xref std std-term">méthode</span></a> et <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Définition de fonctions</span></a>.</p>
</dd>
<dt id="term-function-annotation">annotation de fonction<a class="headerlink" href="#term-function-annotation" title="Lien vers ce terme">¶</a></dt><dd><p><a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a> d'un paramètre de fonction ou valeur de retour.</p>
<p>Les annotations de fonctions sont généralement utilisées pour des <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">indications de types</span></a> : par exemple, cette fonction devrait prendre deux arguments <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> et devrait également avoir une valeur de retour de type <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum_two_numbers</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
   <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>L'annotation syntaxique de la fonction est expliquée dans la section <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Définition de fonctions</span></a>.</p>
<p>Voir <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">annotation de variable</span></a> et la <span class="target" id="index-83"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, qui décrivent cette fonctionnalité. Voir aussi <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Bonnes pratiques concernant les annotations</span></a> sur les bonnes pratiques concernant les annotations.</p>
</dd>
<dt id="term-__future__">__future__<a class="headerlink" href="#term-__future__" title="Lien vers ce terme">¶</a></dt><dd><p>Une <a class="reference internal" href="reference/simple_stmts.html#future"><span class="std std-ref">importation depuis le futur</span></a> s'écrit <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">&lt;fonctionnalité&gt;</span></code>. Lorsqu'une importation du futur est active dans un module, Python compile ce module avec une certaine modification de la syntaxe ou du comportement qui est vouée à devenir standard dans une version ultérieure. Le module <a class="reference internal" href="library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a> documente les possibilités pour <em>fonctionnalité</em>. L'importation a aussi l'effet normal d'importer une variable du module. Cette variable contient des informations utiles sur la fonctionnalité en question, notamment la version de Python dans laquelle elle a été ajoutée, et celle dans laquelle elle deviendra standard :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">__future__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__future__</span><span class="o">.</span><span class="n">division</span>
<span class="go">_Feature((2, 2, 0, &#39;alpha&#39;, 2), (3, 0, 0, &#39;alpha&#39;, 0), 8192)</span>
</pre></div>
</div>
</dd>
<dt id="term-garbage-collection">ramasse-miettes<a class="headerlink" href="#term-garbage-collection" title="Lien vers ce terme">¶</a></dt><dd><p>(<em>garbage collection</em> en anglais) Mécanisme permettant de libérer de la mémoire lorsqu'elle n'est plus utilisée. Python utilise un ramasse-miettes par comptage de référence et un ramasse-miettes cyclique capable de détecter et casser les références circulaires. Le ramasse-miettes peut être contrôlé en utilisant le module <a class="reference internal" href="library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a>.</p>
</dd>
<dt id="term-generator">générateur<a class="headerlink" href="#term-generator" title="Lien vers ce terme">¶</a></dt><dd><p>Fonction qui renvoie un <a class="reference internal" href="#term-generator-iterator"><span class="xref std std-term">itérateur de générateur</span></a>. Cela ressemble à une fonction normale, en dehors du fait qu'elle contient une ou des expressions <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> produisant une série de valeurs utilisable dans une boucle <em>for</em> ou récupérées une à une via la fonction <a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>.</p>
<p>Fait généralement référence à une fonction génératrice mais peut faire référence à un <em>itérateur de générateur</em> dans certains contextes. Dans les cas où le sens voulu n'est pas clair, utiliser les termes complets lève l’ambiguïté.</p>
</dd>
<dt id="term-generator-iterator">itérateur de générateur<a class="headerlink" href="#term-generator-iterator" title="Lien vers ce terme">¶</a></dt><dd><p>Objet créé par une fonction <a class="reference internal" href="#term-generator"><span class="xref std std-term">générateur</span></a>.</p>
<p>Chaque <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> suspend temporairement l'exécution, en se rappelant l'endroit et l'état de l'exécution (y compris les variables locales et les <em>try</em> en cours). Lorsque l'itérateur de générateur reprend, il repart là où il en était (contrairement à une fonction qui prendrait un nouveau départ à chaque invocation).</p>
</dd>
<dt id="term-generator-expression">expression génératrice<a class="headerlink" href="#term-generator-expression" title="Lien vers ce terme">¶</a></dt><dd><p>Expression qui donne un itérateur. Elle ressemble à une expression normale, suivie d'une clause <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> définissant une variable de boucle, un intervalle et une clause <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> optionnelle. Toute cette expression génère des valeurs pour la fonction qui l'entoure :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>         <span class="c1"># sum of squares 0, 1, 4, ... 81</span>
<span class="go">285</span>
</pre></div>
</div>
</dd>
<dt id="term-generic-function">fonction générique<a class="headerlink" href="#term-generic-function" title="Lien vers ce terme">¶</a></dt><dd><p>Fonction composée de plusieurs fonctions implémentant les mêmes opérations pour différents types. L'implémentation à utiliser est déterminée lors de l'appel par l'algorithme de répartition.</p>
<p>Voir aussi <a class="reference internal" href="#term-single-dispatch"><span class="xref std std-term">single dispatch</span></a>, le décorateur <a class="reference internal" href="library/functools.html#functools.singledispatch" title="functools.singledispatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.singledispatch()</span></code></a> et la <span class="target" id="index-84"></span><a class="pep reference external" href="https://peps.python.org/pep-0443/"><strong>PEP 443</strong></a>.</p>
</dd>
<dt id="term-generic-type">type générique<a class="headerlink" href="#term-generic-type" title="Lien vers ce terme">¶</a></dt><dd><p>Un <a class="reference internal" href="#term-type"><span class="xref std std-term">type</span></a> qui peut être paramétré ; généralement un <a class="reference internal" href="reference/datamodel.html#sequence-types"><span class="std std-ref">conteneur</span></a> comme <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> ou <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>. Utilisé pour les <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">indications de type</span></a> et les <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotations</span></a>.</p>
<p>Pour plus de détails, voir <a class="reference internal" href="library/stdtypes.html#types-genericalias"><span class="std std-ref">types alias génériques</span></a> et le module <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a>.  On trouvera l'historique de cette fonctionnalité dans les <span class="target" id="index-85"></span><a class="pep reference external" href="https://peps.python.org/pep-0483/"><strong>PEP 483</strong></a>, <span class="target" id="index-86"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> et <span class="target" id="index-87"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a>.</p>
</dd>
<dt id="term-GIL">GIL<a class="headerlink" href="#term-GIL" title="Lien vers ce terme">¶</a></dt><dd><p>Voir <a class="reference internal" href="#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a>.</p>
</dd>
<dt id="term-global-interpreter-lock">verrou global de l'interpréteur<a class="headerlink" href="#term-global-interpreter-lock" title="Lien vers ce terme">¶</a></dt><dd><p>(<em>global interpreter lock</em> en anglais) Mécanisme utilisé par l'interpréteur <a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a> pour s'assurer qu'un seul fil d'exécution (<em>thread</em> en anglais) n'exécute le <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">bytecode</span></a> à la fois. Cela simplifie l'implémentation de CPython en rendant le modèle objet (incluant des parties critiques comme la classe native <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>) implicitement protégé contre les accès concourants. Verrouiller l'interpréteur entier rend plus facile l'implémentation de multiples fils d'exécution (<em>multi-thread</em> en anglais), au détriment malheureusement de beaucoup du parallélisme possible sur les machines ayant plusieurs processeurs.</p>
<p>Cependant, certains modules d'extension, standards ou non, sont conçus de manière à libérer le GIL lorsqu'ils effectuent des tâches lourdes tel que la compression ou le hachage. De la même manière, le GIL est toujours libéré lors des entrées-sorties.</p>
<p>Les tentatives précédentes d'implémenter un interpréteur Python avec une granularité de verrouillage plus fine ont toutes échouées, à cause de leurs mauvaises performances dans le cas d'un processeur unique. Il est admis que corriger ce problème de performance induit mènerait à une implémentation beaucoup plus compliquée et donc plus coûteuse à maintenir.</p>
</dd>
<dt id="term-hash-based-pyc"><em>pyc</em> utilisant le hachage<a class="headerlink" href="#term-hash-based-pyc" title="Lien vers ce terme">¶</a></dt><dd><p>Un fichier de cache de code intermédiaire (<em>bytecode</em> en anglais) qui utilise le hachage plutôt que l'heure de dernière modification du fichier source correspondant pour déterminer sa validité. Voir <a class="reference internal" href="reference/import.html#pyc-invalidation"><span class="std std-ref">Invalidation de bytecode mis en cache</span></a>.</p>
</dd>
<dt id="term-hashable">hachable<a class="headerlink" href="#term-hashable" title="Lien vers ce terme">¶</a></dt><dd><p>An object is <em>hashable</em> if it has a hash value which never changes during
its lifetime (it needs a <a class="reference internal" href="reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> method), and can be
compared to other objects (it needs an <a class="reference internal" href="reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> method).
Hashable objects which
compare equal must have the same hash value.</p>
<p>La hachabilité permet à un objet d'être utilisé comme clé de dictionnaire ou en tant que membre d'un ensemble (type <em>set</em>), car ces structures de données utilisent ce <em>hash</em>.</p>
<p>La plupart des types immuables natifs de Python sont hachables, mais les conteneurs mutables (comme les listes ou les dictionnaires) ne le sont pas ; les conteneurs immuables (comme les n-uplets ou les ensembles figés) ne sont hachables que si leurs éléments sont hachables. Les instances de classes définies par les utilisateurs sont hachables par défaut. Elles sont toutes considérées différentes (sauf avec elles-mêmes) et leur valeur de hachage est calculée à partir de leur <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a>.</p>
</dd>
<dt id="term-IDLE">IDLE<a class="headerlink" href="#term-IDLE" title="Lien vers ce terme">¶</a></dt><dd><p>Environnement d'apprentissage et de développement intégré pour Python. <a class="reference internal" href="library/idle.html#idle"><span class="std std-ref">IDLE</span></a> est un éditeur basique et un interpréteur livré avec la distribution standard de Python.</p>
</dd>
<dt id="term-immutable">immuable<a class="headerlink" href="#term-immutable" title="Lien vers ce terme">¶</a></dt><dd><p>Objet dont la valeur ne change pas. Les nombres, les chaînes et les <em>n</em>-uplets sont immuables. Ils ne peuvent être modifiés. Un nouvel objet doit être créé si une valeur différente doit être stockée. Ils jouent un rôle important quand une valeur de <em>hash</em> constante est requise, typiquement en clé de dictionnaire.</p>
</dd>
<dt id="term-import-path">chemin des importations<a class="headerlink" href="#term-import-path" title="Lien vers ce terme">¶</a></dt><dd><p>Liste de <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">entrées</span></a> dans lesquelles le <a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">chercheur basé sur les chemins</span></a> cherche les modules à importer. Typiquement, lors d'une importation, cette liste vient de <a class="reference internal" href="library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> ; pour les sous-paquets, elle peut aussi venir de l'attribut <code class="docutils literal notranslate"><span class="pre">__path__</span></code> du paquet parent.</p>
</dd>
<dt id="term-importing">importation<a class="headerlink" href="#term-importing" title="Lien vers ce terme">¶</a></dt><dd><p>Processus rendant le code Python d'un module disponible dans un autre.</p>
</dd>
<dt id="term-importer">importateur<a class="headerlink" href="#term-importer" title="Lien vers ce terme">¶</a></dt><dd><p>Objet qui trouve et charge un module, en même temps un <a class="reference internal" href="#term-finder"><span class="xref std std-term">chercheur</span></a> et un <a class="reference internal" href="#term-loader"><span class="xref std std-term">chargeur</span></a>.</p>
</dd>
<dt id="term-interactive">interactif<a class="headerlink" href="#term-interactive" title="Lien vers ce terme">¶</a></dt><dd><p>Python a un interpréteur interactif, ce qui signifie que vous pouvez écrire des expressions et des instructions à l'invite de l'interpréteur. L'interpréteur Python va les exécuter immédiatement et vous en présenter le résultat. Démarrez juste <code class="docutils literal notranslate"><span class="pre">python</span></code> (probablement depuis le menu principal de votre ordinateur). C'est un moyen puissant pour tester de nouvelles idées ou étudier de nouveaux modules (souvenez-vous de <code class="docutils literal notranslate"><span class="pre">help(x)</span></code>).</p>
</dd>
<dt id="term-interpreted">interprété<a class="headerlink" href="#term-interpreted" title="Lien vers ce terme">¶</a></dt><dd><p>Python est un langage interprété, en opposition aux langages compilés, bien que la frontière soit floue en raison de la présence d'un compilateur en code intermédiaire. Cela signifie que les fichiers sources peuvent être exécutés directement, sans avoir à compiler un fichier exécutable intermédiaire. Les langages interprétés ont généralement un cycle de développement / débogage plus court que les langages compilés. Cependant, ils s'exécutent généralement plus lentement. Voir aussi <a class="reference internal" href="#term-interactive"><span class="xref std std-term">interactif</span></a>.</p>
</dd>
<dt id="term-interpreter-shutdown">arrêt de l'interpréteur<a class="headerlink" href="#term-interpreter-shutdown" title="Lien vers ce terme">¶</a></dt><dd><p>Lorsqu'on lui demande de s'arrêter, l'interpréteur Python entre dans une phase spéciale où il libère graduellement les ressources allouées, comme les modules ou quelques structures de données internes. Il fait aussi quelques appels au <a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">ramasse-miettes</span></a>. Cela peut déclencher l'exécution de code dans des destructeurs ou des fonctions de rappels de <em>weakrefs</em>. Le code exécuté lors de l'arrêt peut rencontrer des exceptions puisque les ressources auxquelles il fait appel sont susceptibles de ne plus fonctionner, (typiquement les modules des bibliothèques ou le mécanisme de <em>warning</em>).</p>
<p>La principale raison d'arrêt de l'interpréteur est que le module <code class="docutils literal notranslate"><span class="pre">__main__</span></code> ou le script en cours d'exécution a terminé de s'exécuter.</p>
</dd>
<dt id="term-iterable">itérable<a class="headerlink" href="#term-iterable" title="Lien vers ce terme">¶</a></dt><dd><p>An object capable of returning its members one at a time. Examples of
iterables include all sequence types (such as <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>,
and <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>) and some non-sequence types like <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>,
<a class="reference internal" href="#term-file-object"><span class="xref std std-term">file objects</span></a>, and objects of any classes you define
with an <a class="reference internal" href="library/stdtypes.html#iterator.__iter__" title="iterator.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method or with a
<a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method
that implements <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a> semantics.</p>
<p>Iterables can be
used in a <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> loop and in many other places where a sequence is
needed (<a class="reference internal" href="library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a>, <a class="reference internal" href="library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a>, ...).  When an iterable object is passed
as an argument to the built-in function <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a>, it returns an
iterator for the object.  This iterator is good for one pass over the set
of values.  When using iterables, it is usually not necessary to call
<a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> or deal with iterator objects yourself.  The <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>
statement does that automatically for you, creating a temporary unnamed
variable to hold the iterator for the duration of the loop.  See also
<a class="reference internal" href="#term-iterator"><span class="xref std std-term">iterator</span></a>, <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>, and <a class="reference internal" href="#term-generator"><span class="xref std std-term">generator</span></a>.</p>
</dd>
<dt id="term-iterator">itérateur<a class="headerlink" href="#term-iterator" title="Lien vers ce terme">¶</a></dt><dd><p>An object representing a stream of data.  Repeated calls to the iterator's
<a class="reference internal" href="library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> method (or passing it to the built-in function
<a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>) return successive items in the stream.  When no more data
are available a <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception is raised instead.  At this
point, the iterator object is exhausted and any further calls to its
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code> method just raise <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> again.  Iterators
are required to have an <a class="reference internal" href="library/stdtypes.html#iterator.__iter__" title="iterator.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method that returns the iterator
object itself so every iterator is also iterable and may be used in most
places where other iterables are accepted.  One notable exception is code
which attempts multiple iteration passes.  A container object (such as a
<a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>) produces a fresh new iterator each time you pass it to the
<a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> function or use it in a <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> loop.  Attempting this
with an iterator will just return the same exhausted iterator object used
in the previous iteration pass, making it appear like an empty container.</p>
<p>Vous trouverez davantage d'informations dans <a class="reference internal" href="library/stdtypes.html#typeiter"><span class="std std-ref">Les types itérateurs</span></a>.</p>
<div class="impl-detail compound">
<p><strong>Particularité de l'implémentation CPython :</strong> CPython does not consistently apply the requirement that an iterator
define <a class="reference internal" href="library/stdtypes.html#iterator.__iter__" title="iterator.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>.</p>
</div>
</dd>
<dt id="term-key-function">fonction clé<a class="headerlink" href="#term-key-function" title="Lien vers ce terme">¶</a></dt><dd><p>Une fonction clé est un objet appelable qui renvoie une valeur à fins de tri ou de classement. Par exemple, la fonction <a class="reference internal" href="library/locale.html#locale.strxfrm" title="locale.strxfrm"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.strxfrm()</span></code></a> est utilisée pour générer une clé de classement prenant en compte les conventions de classement spécifiques aux paramètres régionaux courants.</p>
<p>Plusieurs outils dans Python acceptent des fonctions clés pour déterminer comment les éléments sont classés ou groupés. On peut citer les fonctions <a class="reference internal" href="library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.merge" title="heapq.merge"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.merge()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nsmallest" title="heapq.nsmallest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nsmallest()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nlargest" title="heapq.nlargest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nlargest()</span></code></a> et <a class="reference internal" href="library/itertools.html#itertools.groupby" title="itertools.groupby"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.groupby()</span></code></a>.</p>
<p>Il existe plusieurs moyens de créer une fonction clé. Par exemple, la méthode <a class="reference internal" href="library/stdtypes.html#str.lower" title="str.lower"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.lower()</span></code></a> peut servir de fonction clé pour effectuer des recherches insensibles à la casse. Aussi, il est possible de créer des fonctions clés avec des expressions <a class="reference internal" href="reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a>, comme <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">r:</span> <span class="pre">(r[0],</span> <span class="pre">r[2])</span></code>. Par ailleurs <a class="reference internal" href="library/operator.html#operator.attrgetter" title="operator.attrgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">attrgetter()</span></code></a>, <a class="reference internal" href="library/operator.html#operator.itemgetter" title="operator.itemgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">itemgetter()</span></code></a> et <a class="reference internal" href="library/operator.html#operator.methodcaller" title="operator.methodcaller"><code class="xref py py-func docutils literal notranslate"><span class="pre">methodcaller()</span></code></a> permettent de créer des fonctions clés. Voir <a class="reference internal" href="howto/sorting.html#sortinghowto"><span class="std std-ref">le guide pour le tri</span></a> pour des exemples de création et d'utilisation de fonctions clefs.</p>
</dd>
<dt id="term-keyword-argument">argument nommé<a class="headerlink" href="#term-keyword-argument" title="Lien vers ce terme">¶</a></dt><dd><p>Voir <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>.</p>
</dd>
<dt id="term-lambda">lambda<a class="headerlink" href="#term-lambda" title="Lien vers ce terme">¶</a></dt><dd><p>Fonction anonyme sous la forme d'une <a class="reference internal" href="#term-expression"><span class="xref std std-term">expression</span></a> et ne contenant qu'une seule expression, exécutée lorsque la fonction est appelée. La syntaxe pour créer des fonctions lambda est : <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">[parameters]:</span> <span class="pre">expression</span></code></p>
</dd>
<dt id="term-LBYL">LBYL<a class="headerlink" href="#term-LBYL" title="Lien vers ce terme">¶</a></dt><dd><p>Regarde avant de sauter, (<em>Look before you leap</em> en anglais). Ce style de programmation consiste à vérifier des conditions avant d'effectuer des appels ou des accès. Ce style contraste avec le style <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a> et se caractérise par la présence de beaucoup d'instructions <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>.</p>
<p>Dans un environnement avec plusieurs fils d'exécution (<em>multi-threaded</em> en anglais), le style <em>LBYL</em> peut engendrer un séquencement critique (<em>race condition</em> en anglais) entre le &quot;regarde&quot; et le &quot;sauter&quot;. Par exemple, le code <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">mapping:</span> <span class="pre">return</span> <span class="pre">mapping[key]</span></code> peut échouer si un autre fil d'exécution supprime la clé <em>key</em> du <em>mapping</em> après le test mais avant l'accès. Ce problème peut être résolu avec des verrous (<em>locks</em>) ou avec l'approche EAFP.</p>
</dd>
<dt id="term-list">liste<a class="headerlink" href="#term-list" title="Lien vers ce terme">¶</a></dt><dd><p>A built-in Python <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>.  Despite its name it is more akin
to an array in other languages than to a linked list since access to
elements is <em>O</em>(1).</p>
</dd>
<dt id="term-list-comprehension">liste en compréhension (ou liste en intension)<a class="headerlink" href="#term-list-comprehension" title="Lien vers ce terme">¶</a></dt><dd><p>Écriture concise pour manipuler tout ou partie des éléments d'une séquence et renvoyer une liste contenant les résultats. <code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">['{:#04x}'.format(x)</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(256)</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0]</span></code> génère la liste composée des nombres pairs de 0 à 255 écrits sous formes de chaînes de caractères et en hexadécimal (<code class="docutils literal notranslate"><span class="pre">0x…</span></code>). La clause <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> est optionnelle. Si elle est omise, tous les éléments du <code class="docutils literal notranslate"><span class="pre">range(256)</span></code> seront utilisés.</p>
</dd>
<dt id="term-loader">chargeur<a class="headerlink" href="#term-loader" title="Lien vers ce terme">¶</a></dt><dd><p>Objet qui charge un module. Il doit définir une méthode nommée <code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code>. Un chargeur est typiquement donné par un <a class="reference internal" href="#term-finder"><span class="xref std std-term">chercheur</span></a>. Voir la <span class="target" id="index-88"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> pour plus de détails et <code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.ABC.Loader</span></code> pour sa <a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">classe mère abstraite</span></a>.</p>
</dd>
<dt id="term-locale-encoding">encodage régional<a class="headerlink" href="#term-locale-encoding" title="Lien vers ce terme">¶</a></dt><dd><p>Sous Unix, il est défini par la variable régionale LC_CTYPE. Il peut être modifié par <a class="reference internal" href="library/locale.html#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.setlocale(locale.LC_CTYPE,</span> <span class="pre">new_locale)</span></code></a>.</p>
<p>Sous Windows, c'est un encodage ANSI (par ex. : <code class="docutils literal notranslate"><span class="pre">&quot;cp1252&quot;</span></code>).</p>
<p>Sous Android et VxWorks, Python utilise <code class="docutils literal notranslate"><span class="pre">&quot;utf-8&quot;</span></code> comme encodage régional.</p>
<p><a class="reference internal" href="library/locale.html#locale.getencoding" title="locale.getencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getencoding()</span></code></a> can be used to get the locale encoding.</p>
<p>Voir aussi l'<a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">encodage du systèmes de fichiers et gestionnaire d'erreurs associé</span></a>.</p>
</dd>
<dt id="term-magic-method">méthode magique<a class="headerlink" href="#term-magic-method" title="Lien vers ce terme">¶</a></dt><dd><p id="index-23">Un synonyme informel de <a class="reference internal" href="#term-special-method"><span class="xref std std-term">special method</span></a>.</p>
</dd>
<dt id="term-mapping">tableau de correspondances (<em>mapping</em> en anglais)<a class="headerlink" href="#term-mapping" title="Lien vers ce terme">¶</a></dt><dd><p>Conteneur permettant de rechercher des éléments à partir de clés et implémentant les méthodes spécifiées dans les classes mères abstraites des <a class="reference internal" href="library/collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">tableaux</span> <span class="pre">de</span> <span class="pre">correspondances</span></code></a> (immuables) ou <a class="reference internal" href="library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">tableaux</span> <span class="pre">de</span> <span class="pre">correspondances</span> <span class="pre">mutables</span></code></a> (voir les <a class="reference internal" href="library/collections.abc.html#collections-abstract-base-classes"><span class="std std-ref">classes mères abstraites</span></a>). Les classes suivantes sont des exemples de tableaux de correspondances : <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> et <a class="reference internal" href="library/collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a>.</p>
</dd>
<dt id="term-meta-path-finder">chercheur dans les méta-chemins<a class="headerlink" href="#term-meta-path-finder" title="Lien vers ce terme">¶</a></dt><dd><p>Un <a class="reference internal" href="#term-finder"><span class="xref std std-term">chercheur</span></a> renvoyé par une recherche dans <a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>. Les chercheurs dans les méta-chemins ressemblent, mais sont différents des <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">chercheurs d'entrée dans path</span></a>.</p>
<p>Voir <a class="reference internal" href="library/importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> pour les méthodes que les chercheurs dans les méta-chemins doivent implémenter.</p>
</dd>
<dt id="term-metaclass">métaclasse<a class="headerlink" href="#term-metaclass" title="Lien vers ce terme">¶</a></dt><dd><p>Classe d'une classe. Les définitions de classe créent un nom pour la classe, un dictionnaire de classe et une liste de classes parentes. La métaclasse a pour rôle de réunir ces trois paramètres pour construire la classe. La plupart des langages orientés objet fournissent une implémentation par défaut. La particularité de Python est la possibilité de créer des métaclasses personnalisées. La plupart des utilisateurs n'auront jamais besoin de cet outil, mais lorsque le besoin survient, les métaclasses offrent des solutions élégantes et puissantes. Elles sont utilisées pour journaliser les accès à des propriétés, rendre sûrs les environnements <em>multi-threads</em>, suivre la création d'objets, implémenter des singletons et bien d'autres tâches.</p>
<p>Plus d'informations sont disponibles dans : <a class="reference internal" href="reference/datamodel.html#metaclasses"><span class="std std-ref">Métaclasses</span></a>.</p>
</dd>
<dt id="term-method">méthode<a class="headerlink" href="#term-method" title="Lien vers ce terme">¶</a></dt><dd><p>Fonction définie à l'intérieur d'une classe. Lorsqu'elle est appelée comme un attribut d'une instance de cette classe, la méthode reçoit l'instance en premier <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a> (qui, par convention, est habituellement nommé <code class="docutils literal notranslate"><span class="pre">self</span></code>). Voir <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a> et <a class="reference internal" href="#term-nested-scope"><span class="xref std std-term">nested scope</span></a>.</p>
</dd>
<dt id="term-method-resolution-order">ordre de résolution des méthodes<a class="headerlink" href="#term-method-resolution-order" title="Lien vers ce terme">¶</a></dt><dd><p>Method Resolution Order is the order in which base classes are searched
for a member during lookup. See <a class="reference internal" href="howto/mro.html#python-2-3-mro"><span class="std std-ref">The Python 2.3 Method Resolution Order</span></a> for details of the
algorithm used by the Python interpreter since the 2.3 release.</p>
</dd>
<dt id="term-module">module<a class="headerlink" href="#term-module" title="Lien vers ce terme">¶</a></dt><dd><p>Objet utilisé pour organiser une portion unitaire de code en Python. Les modules ont un espace de nommage et peuvent contenir n'importe quels objets Python. Charger des modules est appelé <a class="reference internal" href="#term-importing"><span class="xref std std-term">importer</span></a>.</p>
<p>Voir aussi <a class="reference internal" href="#term-package"><span class="xref std std-term">paquet</span></a>.</p>
</dd>
<dt id="term-module-spec">spécificateur de module<a class="headerlink" href="#term-module-spec" title="Lien vers ce terme">¶</a></dt><dd><p>Espace de nommage contenant les informations, relatives à l'importation, utilisées pour charger un module. C'est une instance de la classe <a class="reference internal" href="library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ModuleSpec</span></code></a>.</p>
</dd>
<dt id="term-MRO">MRO<a class="headerlink" href="#term-MRO" title="Lien vers ce terme">¶</a></dt><dd><p>Voir <a class="reference internal" href="#term-method-resolution-order"><span class="xref std std-term">ordre de résolution des méthodes</span></a>.</p>
</dd>
<dt id="term-mutable">mutable<a class="headerlink" href="#term-mutable" title="Lien vers ce terme">¶</a></dt><dd><p>Un objet mutable peut changer de valeur tout en gardant le même <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a>. Voir aussi <a class="reference internal" href="#term-immutable"><span class="xref std std-term">immuable</span></a>.</p>
</dd>
<dt id="term-named-tuple"><em>n</em>-uplet nommé<a class="headerlink" href="#term-named-tuple" title="Lien vers ce terme">¶</a></dt><dd><p>Le terme &quot;n-uplet nommé&quot; s'applique à tous les types ou classes qui héritent de la classe <code class="docutils literal notranslate"><span class="pre">tuple</span></code> et dont les éléments indexables sont aussi accessibles en utilisant des attributs nommés. Les types et classes peuvent avoir aussi d'autres caractéristiques.</p>
<p>Plusieurs types natifs sont appelés n-uplets, y compris les valeurs retournées par <a class="reference internal" href="library/time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a> et <a class="reference internal" href="library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a>. Un autre exemple est <a class="reference internal" href="library/sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.float_info</span></code></a> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>                   <span class="c1"># indexed access</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max_exp</span>              <span class="c1"># named field access</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>   <span class="c1"># kind of tuple</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some named tuples are built-in types (such as the above examples).
Alternatively, a named tuple can be created from a regular class
definition that inherits from <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> and that defines named
fields.  Such a class can be written by hand, or it can be created by
inheriting <a class="reference internal" href="library/typing.html#typing.NamedTuple" title="typing.NamedTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.NamedTuple</span></code></a>, or with the factory function
<a class="reference internal" href="library/collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a>.  The latter techniques also add some
extra methods that may not be found in hand-written or built-in named
tuples.</p>
</dd>
<dt id="term-namespace">espace de nommage<a class="headerlink" href="#term-namespace" title="Lien vers ce terme">¶</a></dt><dd><p>L'endroit où une variable est stockée. Les espaces de nommage sont implémentés avec des dictionnaires. Il existe des espaces de nommage globaux, natifs ou imbriqués dans les objets (dans les méthodes). Les espaces de nommage favorisent la modularité car ils permettent d'éviter les conflits de noms. Par exemple, les fonctions <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">builtins.open</span></code></a> et <a class="reference internal" href="library/os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a> sont différenciées par leurs espaces de nom. Les espaces de nommage aident aussi à la lisibilité et la maintenabilité en rendant clair quel module implémente une fonction. Par exemple, écrire <a class="reference internal" href="library/random.html#random.seed" title="random.seed"><code class="xref py py-func docutils literal notranslate"><span class="pre">random.seed()</span></code></a> ou <a class="reference internal" href="library/itertools.html#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.islice()</span></code></a> affiche clairement que ces fonctions sont implémentées respectivement dans les modules <a class="reference internal" href="library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> et <a class="reference internal" href="library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a>.</p>
</dd>
<dt id="term-namespace-package">paquet-espace de nommage<a class="headerlink" href="#term-namespace-package" title="Lien vers ce terme">¶</a></dt><dd><p>Un <a class="reference internal" href="#term-package"><span class="xref std std-term">paquet</span></a> tel que défini dans la <span class="target" id="index-89"></span><a class="pep reference external" href="https://peps.python.org/pep-0421/"><strong>PEP 421</strong></a> qui ne sert qu'à contenir des sous-paquets. Les paquets-espace de nommage peuvent n'avoir aucune représentation physique et, plus spécifiquement, ne sont pas comme un <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">paquet classique</span></a> puisqu'ils n'ont pas de fichier <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>.</p>
<p>Voir aussi <a class="reference internal" href="#term-module"><span class="xref std std-term">module</span></a>.</p>
</dd>
<dt id="term-nested-scope">portée imbriquée<a class="headerlink" href="#term-nested-scope" title="Lien vers ce terme">¶</a></dt><dd><p>Possibilité de faire référence à une variable déclarée dans une définition englobante. Typiquement, une fonction définie à l'intérieur d'une autre fonction a accès aux variables de cette dernière. Souvenez-vous cependant que cela ne fonctionne que pour accéder à des variables, pas pour les assigner. Les variables locales sont lues et assignées dans l'espace de nommage le plus proche. Tout comme les variables globales qui sont stockés dans l'espace de nommage global, le mot clef <a class="reference internal" href="reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> permet d'écrire dans l'espace de nommage dans lequel est déclarée la variable.</p>
</dd>
<dt id="term-new-style-class">nouvelle classe<a class="headerlink" href="#term-new-style-class" title="Lien vers ce terme">¶</a></dt><dd><p>Old name for the flavor of classes now used for all class objects.  In
earlier Python versions, only new-style classes could use Python's newer,
versatile features like <a class="reference internal" href="reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>, descriptors,
properties, <a class="reference internal" href="reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a>, class methods, and static
methods.</p>
</dd>
<dt id="term-object">objet<a class="headerlink" href="#term-object" title="Lien vers ce terme">¶</a></dt><dd><p>N'importe quelle donnée comportant des états (sous forme d'attributs ou d'une valeur) et un comportement (des méthodes). C'est aussi (<code class="docutils literal notranslate"><span class="pre">object</span></code>) l'ancêtre commun à absolument toutes les <a class="reference internal" href="#term-new-style-class"><span class="xref std std-term">nouvelles classes</span></a>.</p>
</dd>
<dt id="term-package">paquet<a class="headerlink" href="#term-package" title="Lien vers ce terme">¶</a></dt><dd><p><a class="reference internal" href="#term-module"><span class="xref std std-term">module</span></a> Python qui peut contenir des sous-modules ou des sous-paquets. Techniquement, un paquet est un module qui possède un attribut <code class="docutils literal notranslate"><span class="pre">__path__</span></code>.</p>
<p>Voir aussi <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">paquet classique</span></a> et <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">namespace package</span></a>.</p>
</dd>
<dt id="term-parameter">paramètre<a class="headerlink" href="#term-parameter" title="Lien vers ce terme">¶</a></dt><dd><p>Entité nommée dans la définition d'une <a class="reference internal" href="#term-function"><span class="xref std std-term">fonction</span></a> (ou méthode), décrivant un <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a> (ou dans certains cas des arguments) que la fonction accepte. Il existe cinq sortes de paramètres :</p>
<ul>
<li><p><em class="dfn">positional-or-keyword</em> : l'argument peut être passé soit par sa <a class="reference internal" href="#term-argument"><span class="xref std std-term">position</span></a>, soit en tant que <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument nommé</span></a>. C'est le type de paramètre par défaut. Par exemple, <em>foo</em> et <em>bar</em> dans l'exemple suivant :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="positional-only-parameter">
<li><p><em class="dfn">positional-only</em> : définit un argument qui ne peut être fourni que par position. Les paramètres <em>positional-only</em> peuvent être définis en insérant un caractère &quot;/&quot; dans la liste de paramètres de la définition de fonction après eux. Par exemple : <em>posonly1</em> et <em>posonly2</em> dans le code suivant :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">posonly1</span><span class="p">,</span> <span class="n">posonly2</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">positional_or_keyword</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="keyword-only-parameter">
<li><p><em class="dfn">keyword-only</em> : l'argument ne peut être fourni que nommé. Les paramètres <em>keyword-only</em> peuvent être définis en utilisant un seul paramètre <em>var-positional</em>, ou en ajoutant une étoile (<code class="docutils literal notranslate"><span class="pre">*</span></code>) seule dans la liste des paramètres avant eux. Par exemple, <em>kw_only1</em> et <em>kw_only2</em> dans le code suivant :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kw_only1</span><span class="p">,</span> <span class="n">kw_only2</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">var-positional</em> : une séquence d'arguments positionnels peut être fournie (en plus de tous les arguments positionnels déjà acceptés par d'autres paramètres). Un tel paramètre peut être défini en préfixant son nom par une <code class="docutils literal notranslate"><span class="pre">*</span></code>. Par exemple <em>args</em> ci-après :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">var-keyword</em> : une quantité arbitraire d'arguments peut être passée, chacun étant nommé (en plus de tous les arguments nommés déjà acceptés par d'autres paramètres). Un tel paramètre est défini en préfixant le nom du paramètre par <code class="docutils literal notranslate"><span class="pre">**</span></code>. Par exemple, <em>kwargs</em> ci-dessus.</p></li>
</ul>
<p>Les paramètres peuvent spécifier des arguments obligatoires ou optionnels, ainsi que des valeurs par défaut pour les arguments optionnels.</p>
<p>Voir aussi <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a> dans le glossaire, la question sur <a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">la différence entre les arguments et les paramètres</span></a> dans la FAQ, la classe <a class="reference internal" href="library/inspect.html#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">inspect.Parameter</span></code></a>, la section <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Définition de fonctions</span></a> et la <span class="target" id="index-90"></span><a class="pep reference external" href="https://peps.python.org/pep-0362/"><strong>PEP 362</strong></a>.</p>
</dd>
<dt id="term-path-entry">entrée de chemin<a class="headerlink" href="#term-path-entry" title="Lien vers ce terme">¶</a></dt><dd><p>Emplacement dans le <a class="reference internal" href="#term-import-path"><span class="xref std std-term">chemin des importations</span></a> (<em>import path</em> en anglais, d'où le <em>path</em>) que le <a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">chercheur basé sur les chemins</span></a> consulte pour trouver des modules à importer.</p>
</dd>
<dt id="term-path-entry-finder">chercheur de chemins<a class="headerlink" href="#term-path-entry-finder" title="Lien vers ce terme">¶</a></dt><dd><p><a class="reference internal" href="#term-finder"><span class="xref std std-term">chercheur</span></a> renvoyé par un appelable sur un <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> (c'est-à-dire un <a class="reference internal" href="#term-path-entry-hook"><span class="xref std std-term">point d'entrée pour la recherche dans path</span></a>) qui sait où trouver des modules lorsqu'on lui donne une <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">entrée de path</span></a>.</p>
<p>Voir <a class="reference internal" href="library/importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> pour les méthodes qu'un chercheur d'entrée dans <em>path</em> doit implémenter.</p>
</dd>
<dt id="term-path-entry-hook">point d'entrée pour la recherche dans <em>path</em><a class="headerlink" href="#term-path-entry-hook" title="Lien vers ce terme">¶</a></dt><dd><p>A callable on the <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> list which returns a <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">path
entry finder</span></a> if it knows how to find modules on a specific <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">path
entry</span></a>.</p>
</dd>
<dt id="term-path-based-finder">chercheur basé sur les chemins<a class="headerlink" href="#term-path-based-finder" title="Lien vers ce terme">¶</a></dt><dd><p>L'un des <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">chercheurs dans les méta-chemins</span></a> par défaut qui cherche des modules dans un <a class="reference internal" href="#term-import-path"><span class="xref std std-term">chemin des importations</span></a>.</p>
</dd>
<dt id="term-path-like-object">objet simili-chemin<a class="headerlink" href="#term-path-like-object" title="Lien vers ce terme">¶</a></dt><dd><p>Objet représentant un chemin du système de fichiers. Un objet simili-chemin est un objet <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou un objet <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> représentant un chemin ou un objet implémentant le protocole <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a>. Un objet qui accepte le protocole <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> peut être converti en un chemin <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> du système de fichiers en appelant la fonction <a class="reference internal" href="library/os.html#os.fspath" title="os.fspath"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fspath()</span></code></a>. <a class="reference internal" href="library/os.html#os.fsdecode" title="os.fsdecode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsdecode()</span></code></a> et <a class="reference internal" href="library/os.html#os.fsencode" title="os.fsencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsencode()</span></code></a> peuvent être utilisées, respectivement, pour garantir un résultat de type <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ou <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> à la place. A été Introduit par la <span class="target" id="index-91"></span><a class="pep reference external" href="https://peps.python.org/pep-0519/"><strong>PEP 519</strong></a>.</p>
</dd>
<dt id="term-PEP">PEP<a class="headerlink" href="#term-PEP" title="Lien vers ce terme">¶</a></dt><dd><p><em>Python Enhancement Proposal</em> (Proposition d'amélioration de Python). Une PEP est un document de conception fournissant des informations à la communauté Python ou décrivant une nouvelle fonctionnalité pour Python, ses processus ou son environnement. Les PEP doivent fournir une spécification technique concise et une justification des fonctionnalités proposées.</p>
<p>Les PEP sont censées être les principaux mécanismes pour proposer de nouvelles fonctionnalités majeures, pour recueillir les commentaires de la communauté sur une question et pour documenter les décisions de conception qui sont intégrées en Python. L’auteur du PEP est responsable de l’établissement d’un consensus au sein de la communauté et de documenter les opinions contradictoires.</p>
<p>Voir la <span class="target" id="index-92"></span><a class="pep reference external" href="https://peps.python.org/pep-0001/"><strong>PEP 1</strong></a>.</p>
</dd>
<dt id="term-portion">portion<a class="headerlink" href="#term-portion" title="Lien vers ce terme">¶</a></dt><dd><p>Jeu de fichiers dans un seul dossier (pouvant être stocké sous forme de fichier zip) qui contribue à l'espace de nommage d'un paquet, tel que défini dans la <span class="target" id="index-93"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a>.</p>
</dd>
<dt id="term-positional-argument">argument positionnel<a class="headerlink" href="#term-positional-argument" title="Lien vers ce terme">¶</a></dt><dd><p>Voir <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>.</p>
</dd>
<dt id="term-provisional-API">API provisoire<a class="headerlink" href="#term-provisional-API" title="Lien vers ce terme">¶</a></dt><dd><p>Une API provisoire est une API qui n'offre aucune garantie de rétrocompatibilité (la bibliothèque standard exige la rétrocompatibilité). Bien que des changements majeurs d'une telle interface ne soient pas attendus, tant qu'elle est étiquetée provisoire, des changements cassant la rétrocompatibilité (y compris sa suppression complète) peuvent survenir si les développeurs principaux le jugent nécessaire. Ces modifications ne surviendront que si de sérieux problèmes sont découverts et qu'ils n'avaient pas été identifiés avant l'ajout de l'API.</p>
<p>Même pour les API provisoires, les changements cassant la rétrocompatibilité sont considérés comme des &quot;solutions de dernier recours&quot;. Tout ce qui est possible sera fait pour tenter de résoudre les problèmes en conservant la rétrocompatibilité.</p>
<p>Ce processus permet à la bibliothèque standard de continuer à évoluer avec le temps, sans se bloquer longtemps sur des erreurs d'architecture. Voir la <span class="target" id="index-94"></span><a class="pep reference external" href="https://peps.python.org/pep-0411/"><strong>PEP 411</strong></a> pour plus de détails.</p>
</dd>
<dt id="term-provisional-package">paquet provisoire<a class="headerlink" href="#term-provisional-package" title="Lien vers ce terme">¶</a></dt><dd><p>Voir <a class="reference internal" href="#term-provisional-API"><span class="xref std std-term">provisional API</span></a>.</p>
</dd>
<dt id="term-Python-3000">Python 3000<a class="headerlink" href="#term-Python-3000" title="Lien vers ce terme">¶</a></dt><dd><p>Surnom donné à la série des Python 3.x (très vieux surnom donné à l'époque où Python 3 représentait un futur lointain). Aussi abrégé <em>Py3k</em>.</p>
</dd>
<dt id="term-Pythonic"><em>Pythonique</em><a class="headerlink" href="#term-Pythonic" title="Lien vers ce terme">¶</a></dt><dd><p>Idée, ou bout de code, qui colle aux idiomes de Python plutôt qu'aux concepts communs rencontrés dans d'autres langages. Par exemple, il est idiomatique en Python de parcourir les éléments d'un itérable en utilisant <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>. Beaucoup d'autres langages n'ont pas cette possibilité, donc les gens qui ne sont pas habitués à Python utilisent parfois un compteur numérique à la place :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">food</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">food</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>Plutôt qu'utiliser la méthode, plus propre et élégante, donc <em>Pythonique</em> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">piece</span> <span class="ow">in</span> <span class="n">food</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt id="term-qualified-name">nom qualifié<a class="headerlink" href="#term-qualified-name" title="Lien vers ce terme">¶</a></dt><dd><p>Nom, comprenant des points, montrant le &quot;chemin&quot; de l'espace de nommage global d'un module vers une classe, fonction ou méthode définie dans ce module, tel que défini dans la <span class="target" id="index-95"></span><a class="pep reference external" href="https://peps.python.org/pep-3155/"><strong>PEP 3155</strong></a>. Pour les fonctions et classes de premier niveau, le nom qualifié est le même que le nom de l'objet :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>            <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">meth</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D.meth&#39;</span>
</pre></div>
</div>
<p>Lorsqu'il est utilisé pour nommer des modules, le <em>nom qualifié complet</em> (<em>fully qualified name - FQN</em> en anglais) signifie le chemin complet (séparé par des points) vers le module, incluant tous les paquets parents. Par exemple : <code class="docutils literal notranslate"><span class="pre">email.mime.text</span></code> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">email.mime.text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span><span class="o">.</span><span class="n">mime</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;email.mime.text&#39;</span>
</pre></div>
</div>
</dd>
<dt id="term-reference-count">nombre de références<a class="headerlink" href="#term-reference-count" title="Lien vers ce terme">¶</a></dt><dd><p>The number of references to an object.  When the reference count of an
object drops to zero, it is deallocated.  Some objects are
&quot;immortal&quot; and have reference counts that are never modified, and
therefore the objects are never deallocated.  Reference counting is
generally not visible to Python code, but it is a key element of the
<a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a> implementation.  Programmers can call the
<a class="reference internal" href="library/sys.html#sys.getrefcount" title="sys.getrefcount"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getrefcount()</span></code></a> function to return the
reference count for a particular object.</p>
</dd>
<dt id="term-regular-package">paquet classique<a class="headerlink" href="#term-regular-package" title="Lien vers ce terme">¶</a></dt><dd><p><a class="reference internal" href="#term-package"><span class="xref std std-term">paquet</span></a> traditionnel, tel qu'un dossier contenant un fichier <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>.</p>
<p>Voir aussi <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">paquet-espace de nommage</span></a>.</p>
</dd>
<dt id="term-__slots__">__slots__<a class="headerlink" href="#term-__slots__" title="Lien vers ce terme">¶</a></dt><dd><p>Déclaration dans une classe qui économise de la mémoire en pré-allouant de l'espace pour les attributs des instances et qui élimine le dictionnaire (des attributs) des instances. Bien que populaire, cette technique est difficile à maîtriser et devrait être réservée à de rares cas où un grand nombre d'instances dans une application devient un sujet critique pour la mémoire.</p>
</dd>
<dt id="term-sequence">séquence<a class="headerlink" href="#term-sequence" title="Lien vers ce terme">¶</a></dt><dd><p>An <a class="reference internal" href="#term-iterable"><span class="xref std std-term">iterable</span></a> which supports efficient element access using integer
indices via the <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> special method and defines a
<a class="reference internal" href="reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> method that returns the length of the sequence.
Some built-in sequence types are <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>,
<a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, and <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Note that <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> also
supports <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code>, but is considered a
mapping rather than a sequence because the lookups use arbitrary
<a class="reference internal" href="#term-immutable"><span class="xref std std-term">immutable</span></a> keys rather than integers.</p>
<p>The <a class="reference internal" href="library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> abstract base class
defines a much richer interface that goes beyond just
<a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> and <a class="reference internal" href="reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a>, adding
<code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>, <a class="reference internal" href="reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a>, and
<a class="reference internal" href="reference/datamodel.html#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a>. Types that implement this expanded
interface can be registered explicitly using
<a class="reference internal" href="library/abc.html#abc.ABCMeta.register" title="abc.ABCMeta.register"><code class="xref py py-func docutils literal notranslate"><span class="pre">register()</span></code></a>. For more documentation on sequence
methods generally, see
<a class="reference internal" href="library/stdtypes.html#typesseq-common"><span class="std std-ref">Common Sequence Operations</span></a>.</p>
</dd>
<dt id="term-set-comprehension">ensemble en compréhension (ou ensemble en intension)<a class="headerlink" href="#term-set-comprehension" title="Lien vers ce terme">¶</a></dt><dd><p>Une façon compacte de traiter tout ou partie des éléments d'un itérable et de renvoyer un <em>set</em> avec les résultats. <code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{c</span> <span class="pre">for</span> <span class="pre">c</span> <span class="pre">in</span> <span class="pre">'abracadabra'</span> <span class="pre">if</span> <span class="pre">c</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">'abc'}</span></code> génère l'ensemble contenant les lettres « r » et « d » <code class="docutils literal notranslate"><span class="pre">{'r',</span> <span class="pre">'d'}</span></code>. Voir <a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">Agencements des listes, ensembles et dictionnaires</span></a>.</p>
</dd>
<dt id="term-single-dispatch">distribution simple<a class="headerlink" href="#term-single-dispatch" title="Lien vers ce terme">¶</a></dt><dd><p>Forme de distribution, comme les <a class="reference internal" href="#term-generic-function"><span class="xref std std-term">fonction génériques</span></a>, où l'implémentation est choisie en fonction du type d'un seul argument.</p>
</dd>
<dt id="term-slice">tranche<a class="headerlink" href="#term-slice" title="Lien vers ce terme">¶</a></dt><dd><p>(<em>slice</em> en anglais), un objet contenant habituellement une portion de <a class="reference internal" href="#term-sequence"><span class="xref std std-term">séquence</span></a>. Une tranche est créée en utilisant la notation <code class="docutils literal notranslate"><span class="pre">[]</span></code> avec des <code class="docutils literal notranslate"><span class="pre">:</span></code> entre les nombres lorsque plusieurs sont fournis, comme dans <code class="docutils literal notranslate"><span class="pre">variable_name[1:3:5]</span></code>. Cette notation utilise des objets <a class="reference internal" href="library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> en interne.</p>
</dd>
<dt id="term-special-method">méthode spéciale<a class="headerlink" href="#term-special-method" title="Lien vers ce terme">¶</a></dt><dd><p id="index-31">(<em>special method</em> en anglais) Méthode appelée implicitement par Python pour exécuter une opération sur un type, comme une addition. De telles méthodes ont des noms commençant et terminant par des doubles tirets bas. Les méthodes spéciales sont documentées dans <a class="reference internal" href="reference/datamodel.html#specialnames"><span class="std std-ref">Méthodes spéciales</span></a>.</p>
</dd>
<dt id="term-statement">instruction<a class="headerlink" href="#term-statement" title="Lien vers ce terme">¶</a></dt><dd><p>Une instruction (<em>statement</em> en anglais) est un composant d'un &quot;bloc&quot; de code. Une instruction est soit une <a class="reference internal" href="#term-expression"><span class="xref std std-term">expression</span></a>, soit une ou plusieurs constructions basées sur un mot-clé, comme <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>, <a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> ou <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>.</p>
</dd>
<dt id="term-static-type-checker">static type checker<a class="headerlink" href="#term-static-type-checker" title="Lien vers ce terme">¶</a></dt><dd><p>An external tool that reads Python code and analyzes it, looking for
issues such as incorrect types. See also <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">type hints</span></a>
and the <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> module.</p>
</dd>
<dt id="term-strong-reference">référence forte<a class="headerlink" href="#term-strong-reference" title="Lien vers ce terme">¶</a></dt><dd><p>In Python's C API, a strong reference is a reference to an object
which is owned by the code holding the reference.  The strong
reference is taken by calling <a class="reference internal" href="c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_INCREF()</span></code></a> when the
reference is created and released with <a class="reference internal" href="c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a>
when the reference is deleted.</p>
<p>Une référence forte est créée à l'aide de la fonction <a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a>. Il faut normalement appeler <a class="reference internal" href="c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a> dessus avant de sortir de sa portée lexicale, sans quoi il y a une fuite de référence.</p>
<p>Voir aussi <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">référence empruntée</span></a>.</p>
</dd>
<dt id="term-text-encoding">encodages de texte<a class="headerlink" href="#term-text-encoding" title="Lien vers ce terme">¶</a></dt><dd><p>Une chaîne de caractères en Python est une suite de points de code Unicode (dans l'intervalle <code class="docutils literal notranslate"><span class="pre">U+0000</span></code>--<code class="docutils literal notranslate"><span class="pre">U+10FFFF</span></code>). Pour stocker ou transmettre une chaîne, il est nécessaire de la sérialiser en suite d'octets.</p>
<p>Sérialiser une chaîne de caractères en une suite d'octets s'appelle « encoder » et recréer la chaîne à partir de la suite d'octets s'appelle « décoder ».</p>
<p>Il existe de multiples <a class="reference internal" href="library/codecs.html#standard-encodings"><span class="std std-ref">codecs</span></a> pour la sérialisation de texte, que l'on regroupe sous l'expression « encodages de texte ».</p>
</dd>
<dt id="term-text-file">fichier texte<a class="headerlink" href="#term-text-file" title="Lien vers ce terme">¶</a></dt><dd><p><a class="reference internal" href="#term-file-object"><span class="xref std std-term">Objet fichier</span></a> capable de lire et d'écrire des objets <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>. Souvent, un fichier texte (<em>text file</em> en anglais) accède en fait à un flux de donnée en octets et gère l'<a class="reference internal" href="#term-text-encoding"><span class="xref std std-term">encodage de texte</span></a> automatiquement. Des exemples de fichiers textes sont les fichiers ouverts en mode texte (<code class="docutils literal notranslate"><span class="pre">'r'</span></code> ou <code class="docutils literal notranslate"><span class="pre">'w'</span></code>), <a class="reference internal" href="library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a>, <a class="reference internal" href="library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a> et les instances de <a class="reference internal" href="library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a>.</p>
<p>Voir aussi <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">fichier binaire</span></a> pour un objet fichier capable de lire et d'écrire des <a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">objets octets-compatibles</span></a>.</p>
</dd>
<dt id="term-triple-quoted-string">chaîne entre triple guillemets<a class="headerlink" href="#term-triple-quoted-string" title="Lien vers ce terme">¶</a></dt><dd><p>Chaîne qui est délimitée par trois guillemets simples (<code class="docutils literal notranslate"><span class="pre">'</span></code>) ou trois guillemets doubles (<code class="docutils literal notranslate"><span class="pre">&quot;</span></code>). Bien qu'elle ne fournisse aucune fonctionnalité qui ne soit pas disponible avec une chaîne entre guillemets, elle est utile pour de nombreuses raisons. Elle vous autorise à insérer des guillemets simples et doubles dans une chaîne sans avoir à les protéger et elle peut s'étendre sur plusieurs lignes sans avoir à terminer chaque ligne par un <code class="docutils literal notranslate"><span class="pre">\</span></code>. Elle est ainsi particulièrement utile pour les chaînes de documentation (<em>docstrings</em>).</p>
</dd>
<dt id="term-type">type<a class="headerlink" href="#term-type" title="Lien vers ce terme">¶</a></dt><dd><p>Le type d'un objet Python détermine quel genre d'objet c'est. Tous les objets ont un type. Le type d'un objet peut être obtenu via son attribut <a class="reference internal" href="library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> ou via <code class="docutils literal notranslate"><span class="pre">type(obj)</span></code>.</p>
</dd>
<dt id="term-type-alias">alias de type<a class="headerlink" href="#term-type-alias" title="Lien vers ce terme">¶</a></dt><dd><p>Synonyme d'un type, créé en affectant le type à un identifiant.</p>
<p>Les alias de types sont utiles pour simplifier les <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">indications de types</span></a>. Par exemple :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">remove_gray_shades</span><span class="p">(</span>
        <span class="n">colors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>pourrait être rendu plus lisible comme ceci :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Color</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">remove_gray_shades</span><span class="p">(</span><span class="n">colors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Color</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Color</span><span class="p">]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Voir <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> et la <span class="target" id="index-96"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, qui décrivent cette fonctionnalité.</p>
</dd>
<dt id="term-type-hint">indication de type<a class="headerlink" href="#term-type-hint" title="Lien vers ce terme">¶</a></dt><dd><p>L'<a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a> qui spécifie le type attendu pour une variable, un attribut de classe, un paramètre de fonction ou une valeur de retour.</p>
<p>Type hints are optional and are not enforced by Python but
they are useful to <a class="reference internal" href="#term-static-type-checker"><span class="xref std std-term">static type checkers</span></a>.
They can also aid IDEs with code completion and refactoring.</p>
<p>Les indications de type de variables globales, d'attributs de classe et de fonctions, mais pas de variables locales, peuvent être consultées en utilisant <a class="reference internal" href="library/typing.html#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.get_type_hints()</span></code></a>.</p>
<p>Voir <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> et la <span class="target" id="index-97"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, qui décrivent cette fonctionnalité.</p>
</dd>
<dt id="term-universal-newlines">retours à la ligne universels<a class="headerlink" href="#term-universal-newlines" title="Lien vers ce terme">¶</a></dt><dd><p>Une manière d'interpréter des flux de texte dans lesquels sont reconnues toutes les fins de ligne suivantes : la convention Unix <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>, la convention Windows <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code> et l'ancienne convention Macintosh <code class="docutils literal notranslate"><span class="pre">'\r'</span></code>. Voir la <span class="target" id="index-98"></span><a class="pep reference external" href="https://peps.python.org/pep-0278/"><strong>PEP 278</strong></a> et la <span class="target" id="index-99"></span><a class="pep reference external" href="https://peps.python.org/pep-3116/"><strong>PEP 3116</strong></a>, ainsi que la fonction <a class="reference internal" href="library/stdtypes.html#bytes.splitlines" title="bytes.splitlines"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.splitlines()</span></code></a> pour d'autres usages.</p>
</dd>
<dt id="term-variable-annotation">annotation de variable<a class="headerlink" href="#term-variable-annotation" title="Lien vers ce terme">¶</a></dt><dd><p><a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a> d'une variable ou d'un attribut de classe.</p>
<p>Lorsque vous annotez une variable ou un attribut de classe, l'affectation est facultative :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">field</span><span class="p">:</span> <span class="s1">&#39;annotation&#39;</span>
</pre></div>
</div>
<p>Les annotations de variables sont généralement utilisées pour des <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">indications de types</span></a> : par exemple, cette variable devrait prendre des valeurs de type <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> :</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>La syntaxe d'annotation de variable est expliquée dans la section <a class="reference internal" href="reference/simple_stmts.html#annassign"><span class="std std-ref">Les assignations annotées</span></a>.</p>
<p>Reportez-vous à <a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">annotation de fonction</span></a>, à la <span class="target" id="index-100"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> et à la <span class="target" id="index-101"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a> qui décrivent cette fonctionnalité. Voir aussi <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Bonnes pratiques concernant les annotations</span></a> sur les bonnes pratiques concernant les annotations.</p>
</dd>
<dt id="term-virtual-environment">environnement virtuel<a class="headerlink" href="#term-virtual-environment" title="Lien vers ce terme">¶</a></dt><dd><p>Environnement d'exécution isolé (en mode coopératif) qui permet aux utilisateurs de Python et aux applications d'installer et de mettre à jour des paquets sans interférer avec d'autres applications Python fonctionnant sur le même système.</p>
<p>Voir aussi <a class="reference internal" href="library/venv.html#module-venv" title="venv: Creation of virtual environments."><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code></a>.</p>
</dd>
<dt id="term-virtual-machine">machine virtuelle<a class="headerlink" href="#term-virtual-machine" title="Lien vers ce terme">¶</a></dt><dd><p>Ordinateur défini entièrement par du logiciel. La machine virtuelle (<em>virtual machine</em>) de Python exécute le <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">code intermédiaire</span></a> produit par le compilateur de <em>bytecode</em>.</p>
</dd>
<dt id="term-Zen-of-Python">Le zen de Python<a class="headerlink" href="#term-Zen-of-Python" title="Lien vers ce terme">¶</a></dt><dd><p>Liste de principes et de préceptes utiles pour comprendre et utiliser le langage. Cette liste peut être obtenue en tapant &quot;<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">this</span></code>&quot; dans une invite Python interactive.</p>
</dd>
</dl>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="faq/installed.html"
                          title="Chapitre précédent">FAQ &quot;Pourquoi Python est installé sur mon ordinateur ?&quot;</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="about.html"
                          title="Chapitre suivant">À propos de ces documents</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">Signalement de bogue</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/glossary.rst"
            rel="nofollow">Voir la source
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Réduire la barre latérale">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Index des modules Python"
             >modules</a> |</li>
        <li class="right" >
          <a href="about.html" title="À propos de ces documents"
             >suivant</a> |</li>
        <li class="right" >
          <a href="faq/installed.html" title="FAQ &#34;Pourquoi Python est installé sur mon ordinateur ?&#34;"
             >précédent</a> |</li>

          <li><img src="_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.12.4 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">Glossaire</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="Recherche rapide" aria-label="Recherche rapide" type="search" name="q" id="search-box" />
          <input type="submit" value="Go" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="copyright.html">
    
    Copyright
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="/license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      Mis à jour le Jun 09, 2024 (22:21 UTC).
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br />

    Créé en utilisant <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>

    <script type="text/javascript" src="_static/switchers.js"></script>
  </body>
</html>