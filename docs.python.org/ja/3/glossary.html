<!DOCTYPE html>

<html lang="ja" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="用語集" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/glossary.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content=">>>, The default Python prompt of the interactive shell. Often seen for code examples which can be executed interactively in the interpreter.,,..., 次のものが考えられます:- The default Python prompt of the in..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content=">>>, The default Python prompt of the interactive shell. Often seen for code examples which can be executed interactively in the interpreter.,,..., 次のものが考えられます:- The default Python prompt of the in..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>用語集 &#8212; Python 3.12.4 ドキュメント</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
    <link rel="stylesheet" type="text/css" href="_static/pydoctheme.css?v=bb723527" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="_static/pygments_dark.css?v=b20cc3f5" />
    
    <script src="_static/documentation_options.js?v=7e11ab17"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=4dbe4bdc"></script>
    
    <script src="_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.12.4 ドキュメント 内を検索"
          href="_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="about.html" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="next" title="このドキュメントについて" href="about.html" />
    <link rel="prev" title="&#34;なぜ Python が私のコンピュータにインストールされているのですか？&#34; FAQ" href="faq/installed.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="https://docs.python.org/3/glossary.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="_static/py.svg" />
            <script type="text/javascript" src="_static/copybutton.js"></script>
            <script type="text/javascript" src="_static/menu.js"></script>
            <script type="text/javascript" src="_static/search-focus.js"></script>
            <script type="text/javascript" src="_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" />
                <input type="submit" value="検索"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="faq/installed.html"
                          title="前の章へ">&quot;なぜ Python が私のコンピュータにインストールされているのですか？&quot; FAQ</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="about.html"
                          title="次の章へ">このドキュメントについて</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/glossary.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="about.html" title="このドキュメントについて"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="faq/installed.html" title="&#34;なぜ Python が私のコンピュータにインストールされているのですか？&#34; FAQ"
             accesskey="P">前へ</a> |</li>

          <li><img src="_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.12.4 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">用語集</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" id="search-box" />
          <input type="submit" value="検索" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="glossary">
<span id="id1"></span><h1>用語集<a class="headerlink" href="#glossary" title="Link to this heading">¶</a></h1>
<dl class="glossary">
<dt id="term-0"><code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code><a class="headerlink" href="#term-0" title="Link to this term">¶</a></dt><dd><p>The default Python prompt of the interactive shell.  Often seen for code
examples which can be executed interactively in the interpreter.</p>
</dd>
<dt id="term-..."><code class="docutils literal notranslate"><span class="pre">...</span></code><a class="headerlink" href="#term-..." title="Link to this term">¶</a></dt><dd><p>次のものが考えられます:</p>
<ul class="simple">
<li><p>The default Python prompt of the interactive shell when entering the
code for an indented code block, when within a pair of matching left and
right delimiters (parentheses, square brackets, curly braces or triple
quotes), or after specifying a decorator.</p></li>
<li><p>組み込みの定数 <a class="reference internal" href="library/constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal notranslate"><span class="pre">Ellipsis</span></code></a> 。</p></li>
</ul>
</dd>
<dt id="term-2to3">2to3<a class="headerlink" href="#term-2to3" title="Link to this term">¶</a></dt><dd><p>A tool that tries to convert Python 2.x code to Python 3.x code by
handling most of the incompatibilities which can be detected by parsing the
source and traversing the parse tree.</p>
<p>2to3 is available in the standard library as <a class="reference internal" href="library/2to3.html#module-lib2to3" title="lib2to3: The 2to3 library"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lib2to3</span></code></a>; a standalone
entry point is provided as <code class="file docutils literal notranslate"><span class="pre">Tools/scripts/2to3</span></code>.  See
<a class="reference internal" href="library/2to3.html#to3-reference"><span class="std std-ref">2to3 --- Python 2 から 3 への自動コード変換</span></a>.</p>
</dd>
<dt id="term-abstract-base-class">abstract base class<a class="headerlink" href="#term-abstract-base-class" title="Link to this term">¶</a></dt><dd><p>(抽象基底クラス) 抽象基底クラスは <a class="reference internal" href="#term-duck-typing"><span class="xref std std-term">duck-typing</span></a> を補完するもので、 <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> などの別のテクニックでは不恰好であったり微妙に誤る (例えば <a class="reference internal" href="reference/datamodel.html#special-lookup"><span class="std std-ref">magic methods</span></a> の場合) 場合にインターフェースを定義する方法を提供します。ABC は仮想 (virtual) サブクラスを導入します。これは親クラスから継承しませんが、それでも <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> や <a class="reference internal" href="library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> に認識されます; <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> モジュールのドキュメントを参照してください。Python には、多くの組み込み ABC が同梱されています。その対象は、(<a class="reference internal" href="library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> モジュールで) データ構造、(<a class="reference internal" href="library/numbers.html#module-numbers" title="numbers: Numeric abstract base classes (Complex, Real, Integral, etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">numbers</span></code></a> モジュールで) 数、(<a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> モジュールで) ストリーム、(<a class="reference internal" href="library/importlib.html#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> モジュールで) インポートファインダ及びローダーです。 <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> モジュールを利用して独自の ABC を作成できます。</p>
</dd>
<dt id="term-annotation">annotation<a class="headerlink" href="#term-annotation" title="Link to this term">¶</a></dt><dd><p>(アノテーション) 変数、クラス属性、関数のパラメータや返り値に関係するラベルです。
慣例により <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">type hint</span></a> として使われています。</p>
<p>ローカル変数のアノテーションは実行時にはアクセスできませんが、グローバル変数、クラス属性、関数のアノテーションはそれぞれモジュール、クラス、関数の <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> 特殊属性に保持されています。</p>
<p>機能の説明がある <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">variable annotation</span></a>, <a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">function annotation</span></a>, <span class="target" id="index-67"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, <span class="target" id="index-68"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a> を参照してください。また、アノテーションを利用するベストプラクティスとして <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Annotations Best Practices</span></a> も参照してください。</p>
</dd>
<dt id="term-argument">引数 (argument)<a class="headerlink" href="#term-argument" title="Link to this term">¶</a></dt><dd><p>(実引数) 関数を呼び出す際に、 <a class="reference internal" href="#term-function"><span class="xref std std-term">関数</span></a> (または <a class="reference internal" href="#term-method"><span class="xref std std-term">メソッド</span></a>) に渡す値です。実引数には２種類あります:</p>
<ul>
<li><p><em class="dfn">キーワード引数</em>: 関数呼び出しの際に引数の前に識別子がついたもの (例: <code class="docutils literal notranslate"><span class="pre">name=</span></code>) や、 <code class="docutils literal notranslate"><span class="pre">**</span></code> に続けた辞書の中の値として渡された引数。例えば、次の <a class="reference internal" href="library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> の呼び出しでは、 <code class="docutils literal notranslate"><span class="pre">3</span></code> と <code class="docutils literal notranslate"><span class="pre">5</span></code> がキーワード引数です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="n">real</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;real&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;imag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">位置引数</em>: キーワード引数以外の引数。位置引数は引数リストの先頭に書くことができ、また <code class="docutils literal notranslate"><span class="pre">*</span></code> に続けた <a class="reference internal" href="#term-iterable"><span class="xref std std-term">iterable</span></a> の要素として渡すことができます。例えば、次の例では <code class="docutils literal notranslate"><span class="pre">3</span></code> と <code class="docutils literal notranslate"><span class="pre">5</span></code> は両方共位置引数です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
<p>実引数は関数の実体において名前付きのローカル変数に割り当てられます。割り当てを行う規則については <a class="reference internal" href="reference/expressions.html#calls"><span class="std std-ref">呼び出し (call)</span></a> を参照してください。シンタックスにおいて実引数を表すためにあらゆる式を使うことが出来ます。評価された値はローカル変数に割り当てられます。</p>
<p><a class="reference internal" href="#term-parameter"><span class="xref std std-term">仮引数</span></a> 、FAQ の <a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">実引数と仮引数の違いは何ですか?</span></a> 、<span class="target" id="index-69"></span><a class="pep reference external" href="https://peps.python.org/pep-0362/"><strong>PEP 362</strong></a> を参照してください。</p>
</dd>
<dt id="term-asynchronous-context-manager">asynchronous context manager<a class="headerlink" href="#term-asynchronous-context-manager" title="Link to this term">¶</a></dt><dd><p>(非同期コンテキストマネージャ)
<a class="reference internal" href="reference/datamodel.html#object.__aenter__" title="object.__aenter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aenter__()</span></code></a> と <a class="reference internal" href="reference/datamodel.html#object.__aexit__" title="object.__aexit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code></a> メソッドを定義することで <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 文内の環境を管理するオブジェクトです。  <span class="target" id="index-70"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> で導入されました。</p>
</dd>
<dt id="term-asynchronous-generator">asynchronous generator<a class="headerlink" href="#term-asynchronous-generator" title="Link to this term">¶</a></dt><dd><p>(非同期ジェネレータ)
<a class="reference internal" href="#term-asynchronous-generator-iterator"><span class="xref std std-term">asynchronous generator iterator</span></a> を返す関数です。
<a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> で定義されたコルーチン関数に似ていますが、 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 式を持つ点で異なります。
<a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 式は <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> ループで使用できる値の並びを生成するのに使用されます。</p>
<p>通常は非同期ジェネレータ関数を指しますが、文脈によっては <em>非同期ジェネレータイテレータ</em> を指す場合があります。
意図された意味が明らかでない場合、 明瞭化のために完全な単語を使用します。</p>
<p>非同期ジェネレータ関数には、 <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 文や <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 文だけでなく <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 式もあることがあります。</p>
</dd>
<dt id="term-asynchronous-generator-iterator">asynchronous generator iterator<a class="headerlink" href="#term-asynchronous-generator-iterator" title="Link to this term">¶</a></dt><dd><p>(非同期ジェネレータイテレータ)
<a class="reference internal" href="#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a> 関数で生成されるオブジェクトです。</p>
<p>これは <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> で、 <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> メソッドを使って呼ばれると awaitable オブジェクトを返します。  この awaitable オブジェクトは、次の <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 式まで非同期ジェネレータ関数の本体を実行します。</p>
<p>各 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> では一時的に処理を中断し、その場の実行状態 (ローカル変数や保留中の try 文を含む) を記憶します。  <em>非同期ジェネレータイテレータ</em> が <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> で返された他の awaitable で実際に再開する時には、その中断箇所が選ばれます。  <span class="target" id="index-71"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> および <span class="target" id="index-72"></span><a class="pep reference external" href="https://peps.python.org/pep-0525/"><strong>PEP 525</strong></a> を参照してください。</p>
</dd>
<dt id="term-asynchronous-iterable">asynchronous iterable<a class="headerlink" href="#term-asynchronous-iterable" title="Link to this term">¶</a></dt><dd><p>(非同期イテラブル)
<a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 文の中で使用できるオブジェクトです。  自身の <a class="reference internal" href="reference/datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> メソッドから <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> を返さなければなりません。  <span class="target" id="index-73"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> で導入されました。</p>
</dd>
<dt id="term-asynchronous-iterator">asynchronous iterator<a class="headerlink" href="#term-asynchronous-iterator" title="Link to this term">¶</a></dt><dd><p>(非同期イテレータ)
<a class="reference internal" href="reference/datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> と <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> メソッドを実装したオブジェクトです。  <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> は <a class="reference internal" href="#term-awaitable"><span class="xref std std-term">awaitable</span></a> オブジェクトを返さなければなりません。  <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> は <a class="reference internal" href="library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 例外を送出するまで、非同期イテレータの <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> メソッドが返す awaitable を解決します。  <span class="target" id="index-74"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> で導入されました。</p>
</dd>
<dt id="term-attribute">属性<a class="headerlink" href="#term-attribute" title="Link to this term">¶</a></dt><dd><p>(属性) オブジェクトに関連付けられ、ドット表記式によって名前で通常参照される値です。例えば、オブジェクト <em>o</em> が属性 <em>a</em> を持っているとき、その属性は <em>o.a</em> で参照されます。</p>
<p>オブジェクトには、 <a class="reference internal" href="reference/lexical_analysis.html#identifiers"><span class="std std-ref">識別子 (identifier) およびキーワード (keyword)</span></a> で定義される識別子ではない名前の属性を与えることができます。たとえば <a class="reference internal" href="library/functions.html#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a> を使い、オブジェクトがそれを許可している場合に行えます。このような属性はドット表記式ではアクセスできず、代わりに <a class="reference internal" href="library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> を使って取る必要があります。</p>
</dd>
<dt id="term-awaitable">awaitable<a class="headerlink" href="#term-awaitable" title="Link to this term">¶</a></dt><dd><p>(待機可能)
<a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 式で使用することが出来るオブジェクトです。  <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">coroutine</span></a> か、 <a class="reference internal" href="reference/datamodel.html#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> メソッドがあるオブジェクトです。 <span class="target" id="index-75"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> を参照してください。</p>
</dd>
<dt id="term-BDFL">BDFL<a class="headerlink" href="#term-BDFL" title="Link to this term">¶</a></dt><dd><p>慈悲深き終身独裁者 (Benevolent Dictator For Life) の略です。Python の作者、<a class="reference external" href="https://gvanrossum.github.io/">Guido van Rossum</a> のことです。</p>
</dd>
<dt id="term-binary-file">binary file<a class="headerlink" href="#term-binary-file" title="Link to this term">¶</a></dt><dd><p>(バイナリファイル)
<a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">bytes-like オブジェクト</span></a> の読み込みおよび書き込みができる <a class="reference internal" href="#term-file-object"><span class="xref std std-term">ファイルオブジェクト</span></a> です。
バイナリファイルの例は、バイナリモード (<code class="docutils literal notranslate"><span class="pre">'rb'</span></code>, <code class="docutils literal notranslate"><span class="pre">'wb'</span></code> or <code class="docutils literal notranslate"><span class="pre">'rb+'</span></code>) で開かれたファイル、<a class="reference internal" href="library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin.buffer</span></code></a>、<a class="reference internal" href="library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout.buffer</span></code></a>、 <a class="reference internal" href="library/io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> や <a class="reference internal" href="library/gzip.html#gzip.GzipFile" title="gzip.GzipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">gzip.GzipFile</span></code></a>. のインスタンスです。</p>
<p><a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> オブジェクトの読み書きができるファイルオブジェクトについては、 <a class="reference internal" href="#term-text-file"><span class="xref std std-term">text file</span></a> も参照してください。</p>
</dd>
<dt id="term-borrowed-reference">borrowed reference<a class="headerlink" href="#term-borrowed-reference" title="Link to this term">¶</a></dt><dd><p>In Python's C API, a borrowed reference is a reference to an object,
where the code using the object does not own the reference.
It becomes a dangling
pointer if the object is destroyed. For example, a garbage collection can
remove the last <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">strong reference</span></a> to the object and so destroy it.</p>
<p>Calling <a class="reference internal" href="c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_INCREF()</span></code></a> on the <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">borrowed reference</span></a> is
recommended to convert it to a <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">strong reference</span></a> in-place, except
when the object cannot be destroyed before the last usage of the borrowed
reference. The <a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a> function can be used to create a new
<a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">strong reference</span></a>.</p>
</dd>
<dt id="term-bytes-like-object">bytes-like object<a class="headerlink" href="#term-bytes-like-object" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="c-api/buffer.html#bufferobjects"><span class="std std-ref">バッファプロトコル (buffer Protocol)</span></a> をサポートしていて、 C 言語の意味で <a class="reference internal" href="#term-contiguous"><span class="xref std std-term">連続した</span></a> バッファーを提供可能なオブジェクト。
<a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>, <a class="reference internal" href="library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a> や、多くの一般的な <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> オブジェクトがこれに当たります。
bytes-like オブジェクトは、データ圧縮、バイナリファイルへの保存、ソケットを経由した送信など、バイナリデータを要求するいろいろな操作に利用することができます。</p>
<p>幾つかの操作ではバイナリデータを変更する必要があります。
その操作のドキュメントではよく &quot;読み書き可能な bytes-like オブジェクト&quot; に言及しています。
変更可能なバッファーオブジェクトには、 <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> と <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> の <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> などが含まれます。
また、他の幾つかの操作では不変なオブジェクト内のバイナリデータ (&quot;読み出し専用の bytes-like オブジェクト&quot;) を必要します。それには <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> と <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> の <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> オブジェクトが含まれます。</p>
</dd>
<dt id="term-bytecode">bytecode<a class="headerlink" href="#term-bytecode" title="Link to this term">¶</a></dt><dd><p>(バイトコード) Python のソースコードは、 Python プログラムの CPython インタプリタの内部表現であるバイトコードへとコンパイルされます。
バイトコードは <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> ファイルにキャッシュされ、同じファイルが二度目に実行されるときはより高速になります (ソースコードからバイトコードへの再度のコンパイルは回避されます)。
この &quot;中間言語 (intermediate language)&quot; は、各々のバイトコードに対応する機械語を実行する <a class="reference internal" href="#term-virtual-machine"><span class="xref std std-term">仮想マシン</span></a> で動作するといえます。
重要な注意として、バイトコードは異なる Python 仮想マシン間で動作することや、Python リリース間で安定であることは期待されていません。</p>
<p>バイトコードの命令一覧は <a class="reference internal" href="library/dis.html#bytecodes"><span class="std std-ref">dis モジュール</span></a> にあります。</p>
</dd>
<dt id="term-callable">callable<a class="headerlink" href="#term-callable" title="Link to this term">¶</a></dt><dd><p>A callable is an object that can be called, possibly with a set
of arguments (see <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>), with the following syntax:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">callable</span><span class="p">(</span><span class="n">argument1</span><span class="p">,</span> <span class="n">argument2</span><span class="p">,</span> <span class="n">argumentN</span><span class="p">)</span>
</pre></div>
</div>
<p>A <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a>, and by extension a <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a>, is a callable.
An instance of a class that implements the <a class="reference internal" href="reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a>
method is also a callable.</p>
</dd>
<dt id="term-callback">callback<a class="headerlink" href="#term-callback" title="Link to this term">¶</a></dt><dd><p>(コールバック) 将来のある時点で実行されるために引数として渡される関数</p>
</dd>
<dt id="term-class">クラス<a class="headerlink" href="#term-class" title="Link to this term">¶</a></dt><dd><p>(クラス) ユーザー定義オブジェクトを作成するためのテンプレートです。クラス定義は普通、そのクラスのインスタンス上の操作をするメソッドの定義を含みます。</p>
</dd>
<dt id="term-class-variable">class variable<a class="headerlink" href="#term-class-variable" title="Link to this term">¶</a></dt><dd><p>(クラス変数) クラス上に定義され、クラスレベルで (つまり、クラスのインスタンス上ではなしに) 変更されることを目的としている変数です。</p>
</dd>
<dt id="term-complex-number">complex number<a class="headerlink" href="#term-complex-number" title="Link to this term">¶</a></dt><dd><p>(複素数) よく知られている実数系を拡張したもので、すべての数は実部と虚部の和として表されます。虚数は虚数単位 (<code class="docutils literal notranslate"><span class="pre">-1</span></code> の平方根) に実数を掛けたもので、一般に数学では <code class="docutils literal notranslate"><span class="pre">i</span></code> と書かれ、工学では <code class="docutils literal notranslate"><span class="pre">j</span></code> と書かれます。Python は複素数に組み込みで対応し、後者の表記を取っています。虚部は末尾に <code class="docutils literal notranslate"><span class="pre">j</span></code> をつけて書きます。例えば <code class="docutils literal notranslate"><span class="pre">3+1j</span></code> です。 <a class="reference internal" href="library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> モジュールの複素数版を利用するには、 <a class="reference internal" href="library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a> を使います。複素数の使用はかなり高度な数学の機能です。必要性を感じなければ、ほぼ間違いなく無視してしまってよいでしょう。</p>
</dd>
<dt id="term-context-manager">context manager<a class="headerlink" href="#term-context-manager" title="Link to this term">¶</a></dt><dd><p>An object which controls the environment seen in a <a class="reference internal" href="reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>
statement by defining <a class="reference internal" href="reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> and <a class="reference internal" href="reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> methods.
See <span class="target" id="index-9"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a>.</p>
</dd>
<dt id="term-context-variable">context variable<a class="headerlink" href="#term-context-variable" title="Link to this term">¶</a></dt><dd><p>(コンテキスト変数) コンテキストに依存して異なる値を持つ変数。
これは、ある変数の値が各々の実行スレッドで異なり得るスレッドローカルストレージに似ています。
しかしコンテキスト変数では、 1 つの実行スレッドにいくつかのコンテキストがあり得、コンテキスト変数の主な用途は並列な非同期タスクの変数の追跡です。
<a class="reference internal" href="library/contextvars.html#module-contextvars" title="contextvars: Context Variables"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a> を参照してください。</p>
</dd>
<dt id="term-contiguous">contiguous<a class="headerlink" href="#term-contiguous" title="Link to this term">¶</a></dt><dd><p id="index-10">(隣接、連続) バッファが厳密に <em>C-連続</em> または <em>Fortran 連続</em> である場合に、そのバッファは連続しているとみなせます。
ゼロ次元バッファは C 連続であり Fortran 連続です。
一次元の配列では、その要素は必ずメモリ上で隣接するように配置され、添字がゼロから始まり増えていく順序で並びます。
多次元の C-連続な配列では、メモリアドレス順に要素を巡る際には最後の添え字が最初に変わるのに対し、 Fortran 連続な配列では最初の添え字が最初に動きます。</p>
</dd>
<dt id="term-coroutine">コルーチン<a class="headerlink" href="#term-coroutine" title="Link to this term">¶</a></dt><dd><p>(コルーチン) コルーチンはサブルーチンのより一般的な形式です。
サブルーチンには決められた地点から入り、別の決められた地点から出ます。
コルーチンには多くの様々な地点から入る、出る、再開することができます。
コルーチンは <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 文で実装できます。
<span class="target" id="index-76"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> を参照してください。</p>
</dd>
<dt id="term-coroutine-function">coroutine function<a class="headerlink" href="#term-coroutine-function" title="Link to this term">¶</a></dt><dd><p>(コルーチン関数)
<a class="reference internal" href="#term-coroutine"><span class="xref std std-term">coroutine</span></a> オブジェクトを返す関数です。
コルーチン関数は <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 文で実装され、<a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>、<a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>、 および <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> キーワードを持つことが出来ます。
これらは <span class="target" id="index-77"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> で導入されました。</p>
</dd>
<dt id="term-CPython">CPython<a class="headerlink" href="#term-CPython" title="Link to this term">¶</a></dt><dd><p><a class="reference external" href="https://www.python.org">python.org</a> で配布されている、Python プログラミング言語の標準的な実装です。&quot;CPython&quot; という単語は、この実装を Jython や IronPython といった他の実装と区別する必要が有る場合に利用されます。</p>
</dd>
<dt id="term-decorator">decorator<a class="headerlink" href="#term-decorator" title="Link to this term">¶</a></dt><dd><p>(デコレータ) 別の関数を返す関数で、通常、 <code class="docutils literal notranslate"><span class="pre">&#64;wrapper</span></code> 構文で関数変換として適用されます。デコレータの一般的な利用例は、 <a class="reference internal" href="library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> と <a class="reference internal" href="library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> です。</p>
<p>デコレータの文法はシンタックスシュガーです。次の2つの関数定義は意味的に同じものです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>同じ概念がクラスにも存在しますが、あまり使われません。デコレータについて詳しくは、 <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> および <a class="reference internal" href="reference/compound_stmts.html#class"><span class="std std-ref">クラス定義</span></a> のドキュメントを参照してください。</p>
</dd>
<dt id="term-descriptor">descriptor<a class="headerlink" href="#term-descriptor" title="Link to this term">¶</a></dt><dd><p>Any object which defines the methods <a class="reference internal" href="reference/datamodel.html#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>,
<a class="reference internal" href="reference/datamodel.html#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a>, or <a class="reference internal" href="reference/datamodel.html#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>.
When a class attribute is a descriptor, its special
binding behavior is triggered upon attribute lookup.  Normally, using
<em>a.b</em> to get, set or delete an attribute looks up the object named <em>b</em> in
the class dictionary for <em>a</em>, but if <em>b</em> is a descriptor, the respective
descriptor method gets called.  Understanding descriptors is a key to a
deep understanding of Python because they are the basis for many features
including functions, methods, properties, class methods, static methods,
and reference to super classes.</p>
<p>デスクリプタのメソッドに関しての詳細は、 <a class="reference internal" href="reference/datamodel.html#descriptors"><span class="std std-ref">デスクリプタ (descriptor) の実装</span></a> や <a class="reference internal" href="howto/descriptor.html#descriptorhowto"><span class="std std-ref">Descriptor How To Guide</span></a> を参照してください。</p>
</dd>
<dt id="term-dictionary">dictionary<a class="headerlink" href="#term-dictionary" title="Link to this term">¶</a></dt><dd><p>An associative array, where arbitrary keys are mapped to values.  The
keys can be any object with <a class="reference internal" href="reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> and
<a class="reference internal" href="reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> methods.
Called a hash in Perl.</p>
</dd>
<dt id="term-dictionary-comprehension">dictionary comprehension<a class="headerlink" href="#term-dictionary-comprehension" title="Link to this term">¶</a></dt><dd><p>(辞書内包表記) iterable 内の全てあるいは一部の要素を処理して、その結果からなる辞書を返すコンパクトな書き方です。 <code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{n:</span> <span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span> <span class="pre">for</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">range(10)}</span></code> とすると、キー <code class="docutils literal notranslate"><span class="pre">n</span></code> を値 <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span></code> に対応付ける辞書を生成します。 <a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">リスト、集合、辞書の表示</span></a> を参照してください。</p>
</dd>
<dt id="term-dictionary-view">dictionary view<a class="headerlink" href="#term-dictionary-view" title="Link to this term">¶</a></dt><dd><p>(辞書ビュー)
<a class="reference internal" href="library/stdtypes.html#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.keys()</span></code></a>、<a class="reference internal" href="library/stdtypes.html#dict.values" title="dict.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.values()</span></code></a>、<a class="reference internal" href="library/stdtypes.html#dict.items" title="dict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.items()</span></code></a> が返すオブジェクトです。
辞書の項目の動的なビューを提供します。
すなわち、辞書が変更されるとビューはそれを反映します。
辞書ビューを強制的に完全なリストにするには <code class="docutils literal notranslate"><span class="pre">list(dictview)</span></code> を使用してください。
<a class="reference internal" href="library/stdtypes.html#dict-views"><span class="std std-ref">辞書ビューオブジェクト</span></a> を参照してください。</p>
</dd>
<dt id="term-docstring">docstring<a class="headerlink" href="#term-docstring" title="Link to this term">¶</a></dt><dd><p>A string literal which appears as the first expression in a class,
function or module.  While ignored when the suite is executed, it is
recognized by the compiler and put into the <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> attribute
of the enclosing class, function or module.  Since it is available via
introspection, it is the canonical place for documentation of the
object.</p>
</dd>
<dt id="term-duck-typing">duck-typing<a class="headerlink" href="#term-duck-typing" title="Link to this term">¶</a></dt><dd><p>あるオブジェクトが正しいインターフェースを持っているかを決定するのにオブジェクトの型を見ないプログラミングスタイルです。代わりに、単純にオブジェクトのメソッドや属性が呼ばれたり使われたりします。（「アヒルのように見えて、アヒルのように鳴けば、それはアヒルである。」）インターフェースを型より重視することで、上手くデザインされたコードは、ポリモーフィックな代替を許して柔軟性を向上させます。ダックタイピングは <a class="reference internal" href="library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> や <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> による判定を避けます。 (ただし、ダックタイピングを <a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">抽象基底クラス</span></a> で補完することもできます。) その代わり、典型的に <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> 判定や <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a> プログラミングを利用します。</p>
</dd>
<dt id="term-EAFP">EAFP<a class="headerlink" href="#term-EAFP" title="Link to this term">¶</a></dt><dd><p>「認可をとるより許しを請う方が容易  (easier to ask for forgiveness than permission、マーフィーの法則)」の略です。この Python で広く使われているコーディングスタイルでは、通常は有効なキーや属性が存在するものと仮定し、その仮定が誤っていた場合に例外を捕捉します。この簡潔で手早く書けるコーディングスタイルには、 <a class="reference internal" href="reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 文および <a class="reference internal" href="reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 文がたくさんあるのが特徴です。このテクニックは、C のような言語でよく使われている <a class="reference internal" href="#term-LBYL"><span class="xref std std-term">LBYL</span></a> スタイルと対照的なものです。</p>
</dd>
<dt id="term-expression">expression<a class="headerlink" href="#term-expression" title="Link to this term">¶</a></dt><dd><p>(式) 何かの値と評価される、一まとまりの構文 (a piece of syntax) です。言い換えると、式とはリテラル、名前、属性アクセス、演算子や関数呼び出しなど、値を返す式の要素の積み重ねです。他の多くの言語と違い、Python では言語の全ての構成要素が式というわけではありません。 <a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> のように、式としては使えない <a class="reference internal" href="#term-statement"><span class="xref std std-term">文</span></a> もあります。代入も式ではなく文です。</p>
</dd>
<dt id="term-extension-module">extension module<a class="headerlink" href="#term-extension-module" title="Link to this term">¶</a></dt><dd><p>(拡張モジュール) C や C++ で書かれたモジュールで、Python の C API を利用して Python コアやユーザーコードとやりとりします。</p>
</dd>
<dt id="term-f-string">f-string<a class="headerlink" href="#term-f-string" title="Link to this term">¶</a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">'f'</span></code> や <code class="docutils literal notranslate"><span class="pre">'F'</span></code> が先頭に付いた文字列リテラルは &quot;f-string&quot; と呼ばれ、これは <a class="reference internal" href="reference/lexical_analysis.html#f-strings"><span class="std std-ref">フォーマット済み文字列リテラル</span></a> の短縮形の名称です。
<span class="target" id="index-78"></span><a class="pep reference external" href="https://peps.python.org/pep-0498/"><strong>PEP 498</strong></a> も参照してください。</p>
</dd>
<dt id="term-file-object">file object<a class="headerlink" href="#term-file-object" title="Link to this term">¶</a></dt><dd><p>An object exposing a file-oriented API (with methods such as
<code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code>) to an underlying resource.  Depending
on the way it was created, a file object can mediate access to a real
on-disk file or to another type of storage or communication device
(for example standard input/output, in-memory buffers, sockets, pipes,
etc.).  File objects are also called <em class="dfn">file-like objects</em> or
<em class="dfn">streams</em>.</p>
<p>ファイルオブジェクトには実際には 3 種類あります: 生の <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">バイナリーファイル</span></a>、バッファされた <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">バイナリーファイル</span></a>、そして <a class="reference internal" href="#term-text-file"><span class="xref std std-term">テキストファイル</span></a> です。インターフェイスは <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> モジュールで定義されています。ファイルオブジェクトを作る標準的な方法は <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 関数を使うことです。</p>
</dd>
<dt id="term-file-like-object">file-like object<a class="headerlink" href="#term-file-like-object" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-file-object"><span class="xref std std-term">file object</span></a> と同義です。</p>
</dd>
<dt id="term-filesystem-encoding-and-error-handler">filesystem encoding and error handler<a class="headerlink" href="#term-filesystem-encoding-and-error-handler" title="Link to this term">¶</a></dt><dd><p>Encoding and error handler used by Python to decode bytes from the
operating system and encode Unicode to the operating system.</p>
<p>ファイルシステムのエンコーディングでは、すべてが 128 バイト以下に正常にデコードされることが保証されなくてはなりません。ファイルシステムのエンコーディングでこれが保証されなかった場合は、API 関数が <a class="reference internal" href="library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a> を送出することがあります。</p>
<p>The <a class="reference internal" href="library/sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencoding()</span></code></a> and
<a class="reference internal" href="library/sys.html#sys.getfilesystemencodeerrors" title="sys.getfilesystemencodeerrors"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencodeerrors()</span></code></a> functions can be used to get the
filesystem encoding and error handler.</p>
<p>The <a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a> are configured at
Python startup by the <a class="reference internal" href="c-api/init_config.html#c.PyConfig_Read" title="PyConfig_Read"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Read()</span></code></a> function: see
<a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_encoding" title="PyConfig.filesystem_encoding"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_encoding</span></code></a> and
<a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_errors" title="PyConfig.filesystem_errors"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_errors</span></code></a> members of <a class="reference internal" href="c-api/init_config.html#c.PyConfig" title="PyConfig"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyConfig</span></code></a>.</p>
<p>See also the <a class="reference internal" href="#term-locale-encoding"><span class="xref std std-term">locale encoding</span></a>.</p>
</dd>
<dt id="term-finder">finder<a class="headerlink" href="#term-finder" title="Link to this term">¶</a></dt><dd><p>(ファインダ)
インポートされているモジュールの <a class="reference internal" href="#term-loader"><span class="xref std std-term">loader</span></a> の発見を試行するオブジェクトです。</p>
<p>There are two types of finder: <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">meta path finders</span></a> for use with <a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>, and <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">path
entry finders</span></a> for use with <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>.</p>
<p>See <a class="reference internal" href="reference/import.html#importsystem"><span class="std std-ref">インポートシステム</span></a> and <a class="reference internal" href="library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> for much more detail.</p>
</dd>
<dt id="term-floor-division">floor division<a class="headerlink" href="#term-floor-division" title="Link to this term">¶</a></dt><dd><p>(切り捨て除算) 一番近い整数に切り捨てる数学的除算。
切り捨て除算演算子は <code class="docutils literal notranslate"><span class="pre">//</span></code> です。
例えば、 <code class="docutils literal notranslate"><span class="pre">11</span> <span class="pre">//</span> <span class="pre">4</span></code> は <code class="docutils literal notranslate"><span class="pre">2</span></code> になり、それとは対称に浮動小数点数の真の除算では <code class="docutils literal notranslate"><span class="pre">2.75</span></code> が 返ってきます。
<code class="docutils literal notranslate"><span class="pre">(-11)</span> <span class="pre">//</span> <span class="pre">4</span></code> は <code class="docutils literal notranslate"><span class="pre">-2.75</span></code> を <em>小さい方に</em> 丸める (訳注: 負の無限大への丸めを行う) ので <code class="docutils literal notranslate"><span class="pre">-3</span></code> になることに注意してください。
<span class="target" id="index-79"></span><a class="pep reference external" href="https://peps.python.org/pep-0238/"><strong>PEP 238</strong></a> を参照してください。</p>
</dd>
<dt id="term-function">関数<a class="headerlink" href="#term-function" title="Link to this term">¶</a></dt><dd><p>(関数) 呼び出し側に値を返す一連の文のことです。関数には0以上の <a class="reference internal" href="#term-argument"><span class="xref std std-term">実引数</span></a> を渡すことが出来ます。実体の実行時に引数を使用することが出来ます。 <a class="reference internal" href="#term-parameter"><span class="xref std std-term">仮引数</span></a>、<a class="reference internal" href="#term-method"><span class="xref std std-term">メソッド</span></a>、<a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> を参照してください。</p>
</dd>
<dt id="term-function-annotation">function annotation<a class="headerlink" href="#term-function-annotation" title="Link to this term">¶</a></dt><dd><p>(関数アノテーション) 関数のパラメータや返り値の <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a> です。</p>
<p>関数アノテーションは、通常は <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">型ヒント</span></a> のために使われます: 例えば、この関数は 2 つの <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 型の引数を取ると期待され、また <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 型の返り値を持つと期待されています。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum_two_numbers</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
   <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>関数アノテーションの文法は <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> の節で解説されています。</p>
<p>機能の説明がある <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">variable annotation</span></a>, <span class="target" id="index-80"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>,を参照してください。また、アノテーションを利用するベストプラクティスとして <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Annotations Best Practices</span></a> も参照してください。</p>
</dd>
<dt id="term-__future__">__future__<a class="headerlink" href="#term-__future__" title="Link to this term">¶</a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">&lt;feature&gt;</span></code> という <a class="reference internal" href="reference/simple_stmts.html#future"><span class="std std-ref">future 文</span></a> は、コンパイラーに将来の Python リリースで標準となる構文や意味を使用して現在のモジュールをコンパイルするよう指示します。 <a class="reference internal" href="library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a> モジュールでは、 <em>feature</em> のとりうる値をドキュメント化しています。このモジュールをインポートし、その変数を評価することで、新機能が最初に言語に追加されたのはいつかや、いつデフォルトになるか (またはなったか) を見ることができます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">__future__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__future__</span><span class="o">.</span><span class="n">division</span>
<span class="go">_Feature((2, 2, 0, &#39;alpha&#39;, 2), (3, 0, 0, &#39;alpha&#39;, 0), 8192)</span>
</pre></div>
</div>
</dd>
<dt id="term-garbage-collection">garbage collection<a class="headerlink" href="#term-garbage-collection" title="Link to this term">¶</a></dt><dd><p>(ガベージコレクション) これ以降使われることのないメモリを解放する処理です。
Pythonは、参照カウントと、循環参照を検出し破壊する循環ガベージコレクタを使ってガベージコレクションを行います。
ガベージコレクタは <a class="reference internal" href="library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> モジュールを使って操作できます。</p>
</dd>
<dt id="term-generator">ジェネレータ<a class="headerlink" href="#term-generator" title="Link to this term">¶</a></dt><dd><p>(ジェネレータ)
<a class="reference internal" href="#term-generator-iterator"><span class="xref std std-term">generator iterator</span></a> を返す関数です。
通常の関数に似ていますが、 <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 式を持つ点で異なります。
<a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 式は、 for ループで使用できたり、<a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 関数で値を 1 つずつ取り出したりできる、値の並びを生成するのに使用されます。</p>
<p>通常はジェネレータ関数を指しますが、文脈によっては <em>ジェネレータイテレータ</em> を指す場合があります。
意図された意味が明らかでない場合、 明瞭化のために完全な単語を使用します。</p>
</dd>
<dt id="term-generator-iterator">generator iterator<a class="headerlink" href="#term-generator-iterator" title="Link to this term">¶</a></dt><dd><p>(ジェネレータイテレータ)
<a class="reference internal" href="#term-generator"><span class="xref std std-term">generator</span></a> 関数で生成されるオブジェクトです。</p>
<p><a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> のたびに局所実行状態 (局所変数や未処理の try 文などを含む) を記憶して、処理は一時的に中断されます。
<em>ジェネレータイテレータ</em> が再開されると、中断した位置を取得します (通常の関数が実行のたびに新しい状態から開始するのと対照的です)。</p>
</dd>
<dt id="term-generator-expression">generator expression<a class="headerlink" href="#term-generator-expression" title="Link to this term">¶</a></dt><dd><p>An expression that returns an iterator.  It looks like a normal expression
followed by a <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> clause defining a loop variable, range,
and an optional <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> clause.  The combined expression
generates values for an enclosing function:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>         <span class="c1"># sum of squares 0, 1, 4, ... 81</span>
<span class="go">285</span>
</pre></div>
</div>
</dd>
<dt id="term-generic-function">generic function<a class="headerlink" href="#term-generic-function" title="Link to this term">¶</a></dt><dd><p>(ジェネリック関数) 異なる型に対し同じ操作をする関数群から構成される関数です。呼び出し時にどの実装を用いるかはディスパッチアルゴリズムにより決定されます。</p>
<p><a class="reference internal" href="#term-single-dispatch"><span class="xref std std-term">single dispatch</span></a>、<a class="reference internal" href="library/functools.html#functools.singledispatch" title="functools.singledispatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.singledispatch()</span></code></a> デコレータ、<span class="target" id="index-81"></span><a class="pep reference external" href="https://peps.python.org/pep-0443/"><strong>PEP 443</strong></a> を参照してください。</p>
</dd>
<dt id="term-generic-type">generic type<a class="headerlink" href="#term-generic-type" title="Link to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-type"><span class="xref std std-term">type</span></a> that can be parameterized; typically a
<a class="reference internal" href="reference/datamodel.html#sequence-types"><span class="std std-ref">container class</span></a> such as <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> or
<a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>. Used for <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">type hints</span></a> and
<a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotations</span></a>.</p>
<p>For more details, see <a class="reference internal" href="library/stdtypes.html#types-genericalias"><span class="std std-ref">generic alias types</span></a>,
<span class="target" id="index-19"></span><a class="pep reference external" href="https://peps.python.org/pep-0483/"><strong>PEP 483</strong></a>, <span class="target" id="index-20"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, <span class="target" id="index-21"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a>, and the <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> module.</p>
</dd>
<dt id="term-GIL">GIL<a class="headerlink" href="#term-GIL" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a> を参照してください。</p>
</dd>
<dt id="term-global-interpreter-lock">global interpreter lock<a class="headerlink" href="#term-global-interpreter-lock" title="Link to this term">¶</a></dt><dd><p>(グローバルインタプリタロック) <a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a> インタプリタが利用している、一度に Python の <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">バイトコード</span></a> を実行するスレッドは一つだけであることを保証する仕組みです。これにより (<a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> などの重要な組み込み型を含む) オブジェクトモデルが同時アクセスに対して暗黙的に安全になるので、 CPython の実装がシンプルになります。インタプリタ全体をロックすることで、マルチプロセッサマシンが生じる並列化のコストと引き換えに、インタプリタを簡単にマルチスレッド化できるようになります。</p>
<p>ただし、標準あるいは外部のいくつかの拡張モジュールは、圧縮やハッシュ計算などの計算の重い処理をするときに GIL を解除するように設計されています。また、I/O 処理をする場合 GIL は常に解除されます。</p>
<p>Past efforts to create a &quot;free-threaded&quot; interpreter (one which locks
shared data at a much finer granularity) have not been successful
because performance suffered in the common single-processor case. It
is believed that overcoming this performance issue would make the
implementation much more complicated and therefore costlier to maintain.</p>
</dd>
<dt id="term-hash-based-pyc">hash-based pyc<a class="headerlink" href="#term-hash-based-pyc" title="Link to this term">¶</a></dt><dd><p>(ハッシュベース pyc ファイル) 正当性を判別するために、対応するソースファイルの最終更新時刻ではなくハッシュ値を使用するバイトコードのキャッシュファイルです。<a class="reference internal" href="reference/import.html#pyc-invalidation"><span class="std std-ref">キャッシュされたバイトコードの無効化</span></a> を参照してください。</p>
</dd>
<dt id="term-hashable">hashable<a class="headerlink" href="#term-hashable" title="Link to this term">¶</a></dt><dd><p>An object is <em>hashable</em> if it has a hash value which never changes during
its lifetime (it needs a <a class="reference internal" href="reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> method), and can be
compared to other objects (it needs an <a class="reference internal" href="reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> method).
Hashable objects which
compare equal must have the same hash value.</p>
<p>ハッシュ可能なオブジェクトは辞書のキーや集合のメンバーとして使えます。辞書や集合のデータ構造は内部でハッシュ値を使っているからです。</p>
<p>Python のイミュータブルな組み込みオブジェクトは、ほとんどがハッシュ可能です。(リストや辞書のような) ミュータブルなコンテナはハッシュ不可能です。(タプルや frozenset のような) イミュータブルなコンテナは、要素がハッシュ可能であるときのみハッシュ可能です。
ユーザー定義のクラスのインスタンスであるようなオブジェクトはデフォルトでハッシュ可能です。
それらは全て (自身を除いて) 比較結果は非等価であり、ハッシュ値は <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> より得られます。</p>
</dd>
<dt id="term-IDLE">IDLE<a class="headerlink" href="#term-IDLE" title="Link to this term">¶</a></dt><dd><p>Python の統合開発環境 (Integrated DeveLopment Environment)及び学習環境 (Learning Environment) です。<a class="reference internal" href="library/idle.html#idle"><span class="std std-ref">IDLE</span></a> は Python の標準的な配布に同梱されている基本的な機能のエディタとインタプリタ環境です。</p>
</dd>
<dt id="term-immutable">immutable<a class="headerlink" href="#term-immutable" title="Link to this term">¶</a></dt><dd><p>(イミュータブル) 固定の値を持ったオブジェクトです。イミュータブルなオブジェクトには、数値、文字列、およびタプルなどがあります。これらのオブジェクトは値を変えられません。別の値を記憶させる際には、新たなオブジェクトを作成しなければなりません。イミュータブルなオブジェクトは、固定のハッシュ値が必要となる状況で重要な役割を果たします。辞書のキーがその例です。</p>
</dd>
<dt id="term-import-path">import path<a class="headerlink" href="#term-import-path" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">path based finder</span></a> が import するモジュールを検索する場所 (または <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">path entry</span></a>) のリスト。 import 中、このリストは通常 <a class="reference internal" href="library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> から来ますが、サブパッケージの場合は親パッケージの <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 属性からも来ます。</p>
</dd>
<dt id="term-importing">importing<a class="headerlink" href="#term-importing" title="Link to this term">¶</a></dt><dd><p>あるモジュールの Python コードが別のモジュールの Python コードで使えるようにする処理です。</p>
</dd>
<dt id="term-importer">importer<a class="headerlink" href="#term-importer" title="Link to this term">¶</a></dt><dd><p>モジュールを探してロードするオブジェクト。 <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a> と <a class="reference internal" href="#term-loader"><span class="xref std std-term">loader</span></a> のどちらでもあるオブジェクト。</p>
</dd>
<dt id="term-interactive">interactive<a class="headerlink" href="#term-interactive" title="Link to this term">¶</a></dt><dd><p>Python has an interactive interpreter which means you can enter
statements and expressions at the interpreter prompt, immediately
execute them and see their results.  Just launch <code class="docutils literal notranslate"><span class="pre">python</span></code> with no
arguments (possibly by selecting it from your computer's main
menu). It is a very powerful way to test out new ideas or inspect
modules and packages (remember <code class="docutils literal notranslate"><span class="pre">help(x)</span></code>).</p>
</dd>
<dt id="term-interpreted">interpreted<a class="headerlink" href="#term-interpreted" title="Link to this term">¶</a></dt><dd><p>Python はインタプリタ形式の言語であり、コンパイラ言語の対極に位置します。 (バイトコードコンパイラがあるために、この区別は曖昧ですが。) ここでのインタプリタ言語とは、ソースコードのファイルを、まず実行可能形式にしてから実行させるといった操作なしに、直接実行できることを意味します。インタプリタ形式の言語は通常、コンパイラ形式の言語よりも開発／デバッグのサイクルは短いものの、プログラムの実行は一般に遅いです。 <a class="reference internal" href="#term-interactive"><span class="xref std std-term">対話的</span></a> も参照してください。</p>
</dd>
<dt id="term-interpreter-shutdown">interpreter shutdown<a class="headerlink" href="#term-interpreter-shutdown" title="Link to this term">¶</a></dt><dd><p>Python インタープリターはシャットダウンを要請された時に、モジュールやすべてのクリティカルな内部構造をなどの、すべての確保したリソースを段階的に開放する、特別なフェーズに入ります。
このフェーズは <a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">ガベージコレクタ</span></a> を複数回呼び出します。
これによりユーザー定義のデストラクターや weakref コールバックが呼び出されることがあります。
シャットダウンフェーズ中に実行されるコードは、それが依存するリソースがすでに機能しない(よくある例はライブラリーモジュールや warning 機構です) ために様々な例外に直面します。</p>
<p>インタープリタがシャットダウンする主な理由は <code class="docutils literal notranslate"><span class="pre">__main__</span></code> モジュールや実行されていたスクリプトの実行が終了したことです。</p>
</dd>
<dt id="term-iterable">iterable<a class="headerlink" href="#term-iterable" title="Link to this term">¶</a></dt><dd><p>An object capable of returning its members one at a time. Examples of
iterables include all sequence types (such as <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>,
and <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>) and some non-sequence types like <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>,
<a class="reference internal" href="#term-file-object"><span class="xref std std-term">file objects</span></a>, and objects of any classes you define
with an <a class="reference internal" href="library/stdtypes.html#iterator.__iter__" title="iterator.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method or with a
<a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method
that implements <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a> semantics.</p>
<p>Iterables can be
used in a <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> loop and in many other places where a sequence is
needed (<a class="reference internal" href="library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a>, <a class="reference internal" href="library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a>, ...).  When an iterable object is passed
as an argument to the built-in function <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a>, it returns an
iterator for the object.  This iterator is good for one pass over the set
of values.  When using iterables, it is usually not necessary to call
<a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> or deal with iterator objects yourself.  The <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>
statement does that automatically for you, creating a temporary unnamed
variable to hold the iterator for the duration of the loop.  See also
<a class="reference internal" href="#term-iterator"><span class="xref std std-term">iterator</span></a>, <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>, and <a class="reference internal" href="#term-generator"><span class="xref std std-term">generator</span></a>.</p>
</dd>
<dt id="term-iterator">iterator<a class="headerlink" href="#term-iterator" title="Link to this term">¶</a></dt><dd><p>データの流れを表現するオブジェクトです。イテレータの <a class="reference internal" href="library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> メソッドを繰り返し呼び出す (または組み込み関数 <a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> に渡す) と、流れの中の要素を一つずつ返します。データがなくなると、代わりに <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 例外を送出します。その時点で、イテレータオブジェクトは尽きており、それ以降は <code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code> を何度呼んでも <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> を送出します。イテレータは、そのイテレータオブジェクト自体を返す <a class="reference internal" href="library/stdtypes.html#iterator.__iter__" title="iterator.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> メソッドを実装しなければならないので、イテレータは他の iterable を受理するほとんどの場所で利用できます。はっきりとした例外は複数の反復を行うようなコードです。 (<a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> のような) コンテナオブジェクトは、自身を <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 関数にオブジェクトに渡したり <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> ループ内で使うたびに、新たな未使用のイテレータを生成します。これをイテレータで行おうとすると、前回のイテレーションで使用済みの同じイテレータオブジェクトを単純に返すため、空のコンテナのようになってしまします。</p>
<p>詳細な情報は <a class="reference internal" href="library/stdtypes.html#typeiter"><span class="std std-ref">イテレータ型</span></a> にあります。</p>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> CPython does not consistently apply the requirement that an iterator
define <a class="reference internal" href="library/stdtypes.html#iterator.__iter__" title="iterator.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>.</p>
</div>
</dd>
<dt id="term-key-function">key function<a class="headerlink" href="#term-key-function" title="Link to this term">¶</a></dt><dd><p>(キー関数) キー関数、あるいは照合関数とは、ソートや順序比較のための値を返す呼び出し可能オブジェクト(callable)です。例えば、 <a class="reference internal" href="library/locale.html#locale.strxfrm" title="locale.strxfrm"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.strxfrm()</span></code></a> をキー関数に使えば、ロケール依存のソートの慣習にのっとったソートキーを返します。</p>
<p>Python の多くのツールはキー関数を受け取り要素の並び順やグループ化を管理します。
<a class="reference internal" href="library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.merge" title="heapq.merge"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.merge()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nsmallest" title="heapq.nsmallest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nsmallest()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nlargest" title="heapq.nlargest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nlargest()</span></code></a>, <a class="reference internal" href="library/itertools.html#itertools.groupby" title="itertools.groupby"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.groupby()</span></code></a> 等があります。</p>
<p>キー関数を作る方法はいくつかあります。
例えば <a class="reference internal" href="library/stdtypes.html#str.lower" title="str.lower"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.lower()</span></code></a> メソッドを大文字小文字を区別しないソートを行うキー関数として使うことが出来ます。
あるいは、<code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">r:</span> <span class="pre">(r[0],</span> <span class="pre">r[2])</span></code> のような <a class="reference internal" href="reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 式からキー関数を作ることができます。
また、<a class="reference internal" href="library/operator.html#operator.attrgetter" title="operator.attrgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.attrgetter()</span></code></a>, <a class="reference internal" href="library/operator.html#operator.itemgetter" title="operator.itemgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.itemgetter()</span></code></a>, <a class="reference internal" href="library/operator.html#operator.methodcaller" title="operator.methodcaller"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.methodcaller()</span></code></a> の  3 つのキー関数コンストラクタがあります。
キー関数の作り方と使い方の例は <a class="reference internal" href="howto/sorting.html#sortinghowto"><span class="std std-ref">Sorting HOW TO</span></a> を参照してください。</p>
</dd>
<dt id="term-keyword-argument">keyword argument<a class="headerlink" href="#term-keyword-argument" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-argument"><span class="xref std std-term">実引数</span></a> を参照してください。</p>
</dd>
<dt id="term-lambda">lambda<a class="headerlink" href="#term-lambda" title="Link to this term">¶</a></dt><dd><p>(ラムダ) 無名のインライン関数で、関数が呼び出されたときに評価される 1 つの <a class="reference internal" href="#term-expression"><span class="xref std std-term">式</span></a> を含みます。ラムダ関数を作る構文は <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">[parameters]:</span> <span class="pre">expression</span></code> です。</p>
</dd>
<dt id="term-LBYL">LBYL<a class="headerlink" href="#term-LBYL" title="Link to this term">¶</a></dt><dd><p>「ころばぬ先の杖 (look before you leap)」 の略です。このコーディングスタイルでは、呼び出しや検索を行う前に、明示的に前提条件 (pre-condition) 判定を行います。 <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a> アプローチと対照的で、 <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 文がたくさん使われるのが特徴的です。</p>
<p>マルチスレッド化された環境では、LBYL アプローチは &quot;見る&quot; 過程と &quot;飛ぶ&quot; 過程の競合状態を引き起こすリスクがあります。例えば、<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">mapping:</span> <span class="pre">return</span> <span class="pre">mapping[key]</span></code> というコードは、判定の後、別のスレッドが探索の前に <em>mapping</em> から <em>key</em> を取り除くと失敗します。この問題は、ロックするか EAFP アプローチを使うことで解決できます。</p>
</dd>
<dt id="term-list">list<a class="headerlink" href="#term-list" title="Link to this term">¶</a></dt><dd><p>A built-in Python <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>.  Despite its name it is more akin
to an array in other languages than to a linked list since access to
elements is <em>O</em>(1).</p>
</dd>
<dt id="term-list-comprehension">list comprehension<a class="headerlink" href="#term-list-comprehension" title="Link to this term">¶</a></dt><dd><p>(リスト内包表記) シーケンス中の全てあるいは一部の要素を処理して、その結果からなるリストを返す、コンパクトな方法です。 <code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">['{:#04x}'.format(x)</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(256)</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0]</span></code> とすると、 0 から 255 までの偶数を 16進数表記 (0x..) した文字列からなるリストを生成します。 <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 節はオプションです。 <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 節がない場合、 <code class="docutils literal notranslate"><span class="pre">range(256)</span></code> の全ての要素が処理されます。</p>
</dd>
<dt id="term-loader">loader<a class="headerlink" href="#term-loader" title="Link to this term">¶</a></dt><dd><p>モジュールをロードするオブジェクト。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code> という名前のメソッドを定義していなければなりません。ローダーは一般的に <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a> から返されます。詳細は <span class="target" id="index-82"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> を、 <a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a> については <a class="reference internal" href="library/importlib.html#importlib.abc.Loader" title="importlib.abc.Loader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.Loader</span></code></a> を参照してください。</p>
</dd>
<dt id="term-locale-encoding">ロケールエンコーディング<a class="headerlink" href="#term-locale-encoding" title="Link to this term">¶</a></dt><dd><p>On Unix, it is the encoding of the LC_CTYPE locale. It can be set with
<a class="reference internal" href="library/locale.html#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.setlocale(locale.LC_CTYPE,</span> <span class="pre">new_locale)</span></code></a>.</p>
<p>On Windows, it is the ANSI code page (ex: <code class="docutils literal notranslate"><span class="pre">&quot;cp1252&quot;</span></code>).</p>
<p>On Android and VxWorks, Python uses <code class="docutils literal notranslate"><span class="pre">&quot;utf-8&quot;</span></code> as the locale encoding.</p>
<p><a class="reference internal" href="library/locale.html#locale.getencoding" title="locale.getencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getencoding()</span></code></a> can be used to get the locale encoding.</p>
<p>See also the <a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a>.</p>
</dd>
<dt id="term-magic-method">magic method<a class="headerlink" href="#term-magic-method" title="Link to this term">¶</a></dt><dd><p id="index-23"><a class="reference internal" href="#term-special-method"><span class="xref std std-term">special method</span></a> のくだけた同義語です。</p>
</dd>
<dt id="term-mapping">mapping<a class="headerlink" href="#term-mapping" title="Link to this term">¶</a></dt><dd><p>(マッピング) 任意のキー探索をサポートしていて、 <a class="reference internal" href="library/collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> か <a class="reference internal" href="library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a> の <a class="reference internal" href="library/collections.abc.html#collections-abstract-base-classes"><span class="std std-ref">抽象基底クラス</span></a> で指定されたメソッドを実装しているコンテナオブジェクトです。例えば、 <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a> などです。</p>
</dd>
<dt id="term-meta-path-finder">meta path finder<a class="headerlink" href="#term-meta-path-finder" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> を検索して得られた <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a>.
meta path finder は <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> と関係はありますが、別物です。</p>
<p>meta path finder が実装するメソッドについては <a class="reference internal" href="library/importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> を参照してください。</p>
</dd>
<dt id="term-metaclass">metaclass<a class="headerlink" href="#term-metaclass" title="Link to this term">¶</a></dt><dd><p>(メタクラス) クラスのクラスです。クラス定義は、クラス名、クラスの辞書と、基底クラスのリストを作ります。メタクラスは、それら 3 つを引数として受け取り、クラスを作る責任を負います。ほとんどのオブジェクト指向言語は(訳注:メタクラスの)デフォルトの実装を提供しています。Python が特別なのはカスタムのメタクラスを作成できる点です。ほとんどのユーザーに取って、メタクラスは全く必要のないものです。しかし、一部の場面では、メタクラスは強力でエレガントな方法を提供します。たとえば属性アクセスのログを取ったり、スレッドセーフ性を追加したり、オブジェクトの生成を追跡したり、シングルトンを実装するなど、多くの場面で利用されます。</p>
<p>詳細は <a class="reference internal" href="reference/datamodel.html#metaclasses"><span class="std std-ref">メタクラス</span></a> を参照してください。</p>
</dd>
<dt id="term-method">メソッド<a class="headerlink" href="#term-method" title="Link to this term">¶</a></dt><dd><p>(メソッド) クラス本体の中で定義された関数。そのクラスのインスタンスの属性として呼び出された場合、メソッドはインスタンスオブジェクトを第一 <a class="reference internal" href="#term-argument"><span class="xref std std-term">引数</span></a> として受け取ります (この第一引数は通常 <code class="docutils literal notranslate"><span class="pre">self</span></code> と呼ばれます)。 <a class="reference internal" href="#term-function"><span class="xref std std-term">関数</span></a> と <a class="reference internal" href="#term-nested-scope"><span class="xref std std-term">ネストされたスコープ</span></a> も参照してください。</p>
</dd>
<dt id="term-method-resolution-order">method resolution order<a class="headerlink" href="#term-method-resolution-order" title="Link to this term">¶</a></dt><dd><p>Method Resolution Order is the order in which base classes are searched
for a member during lookup. See <a class="reference internal" href="howto/mro.html#python-2-3-mro"><span class="std std-ref">The Python 2.3 Method Resolution Order</span></a> for details of the
algorithm used by the Python interpreter since the 2.3 release.</p>
</dd>
<dt id="term-module">module<a class="headerlink" href="#term-module" title="Link to this term">¶</a></dt><dd><p>(モジュール) Python コードの組織単位としてはたらくオブジェクトです。モジュールは任意の Python オブジェクトを含む名前空間を持ちます。モジュールは <a class="reference internal" href="#term-importing"><span class="xref std std-term">importing</span></a> の処理によって Python に読み込まれます。</p>
<p><a class="reference internal" href="#term-package"><span class="xref std std-term">パッケージ</span></a> を参照してください。</p>
</dd>
<dt id="term-module-spec">module spec<a class="headerlink" href="#term-module-spec" title="Link to this term">¶</a></dt><dd><p>モジュールをロードするのに使われるインポート関連の情報を含む名前空間です。
<a class="reference internal" href="library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ModuleSpec</span></code></a> のインスタンスです。</p>
</dd>
<dt id="term-MRO">MRO<a class="headerlink" href="#term-MRO" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-method-resolution-order"><span class="xref std std-term">method resolution order</span></a> を参照してください。</p>
</dd>
<dt id="term-mutable">mutable<a class="headerlink" href="#term-mutable" title="Link to this term">¶</a></dt><dd><p>(ミュータブル) ミュータブルなオブジェクトは、 <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> を変えることなく値を変更できます。 <a class="reference internal" href="#term-immutable"><span class="xref std std-term">イミュータブル</span></a>) も参照してください。</p>
</dd>
<dt id="term-named-tuple">named tuple<a class="headerlink" href="#term-named-tuple" title="Link to this term">¶</a></dt><dd><p>&quot;名前付きタプル&quot; という用語は、タプルを継承していて、インデックスが付く要素に対し属性を使ってのアクセスもできる任意の型やクラスに応用されています。
その型やクラスは他の機能も持っていることもあります。</p>
<p><a class="reference internal" href="library/time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a> や <a class="reference internal" href="library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a> の返り値を含むいくつかの組み込み型は名前付きタプルです。
他の例は <a class="reference internal" href="library/sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.float_info</span></code></a> です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>                   <span class="c1"># indexed access</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max_exp</span>              <span class="c1"># named field access</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>   <span class="c1"># kind of tuple</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some named tuples are built-in types (such as the above examples).
Alternatively, a named tuple can be created from a regular class
definition that inherits from <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> and that defines named
fields.  Such a class can be written by hand, or it can be created by
inheriting <a class="reference internal" href="library/typing.html#typing.NamedTuple" title="typing.NamedTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.NamedTuple</span></code></a>, or with the factory function
<a class="reference internal" href="library/collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a>.  The latter techniques also add some
extra methods that may not be found in hand-written or built-in named
tuples.</p>
</dd>
<dt id="term-namespace">namespace<a class="headerlink" href="#term-namespace" title="Link to this term">¶</a></dt><dd><p>(名前空間) 変数が格納される場所です。名前空間は辞書として実装されます。名前空間にはオブジェクトの (メソッドの) 入れ子になったものだけでなく、局所的なもの、大域的なもの、そして組み込みのものがあります。名前空間は名前の衝突を防ぐことによってモジュール性をサポートする。例えば関数 <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">builtins.open</span></code></a> と <a class="reference internal" href="library/os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a> は名前空間で区別されています。また、どのモジュールが関数を実装しているか明示することによって名前空間は可読性と保守性を支援します。例えば、<a class="reference internal" href="library/random.html#random.seed" title="random.seed"><code class="xref py py-func docutils literal notranslate"><span class="pre">random.seed()</span></code></a> や <a class="reference internal" href="library/itertools.html#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.islice()</span></code></a> と書くと、それぞれモジュール <a class="reference internal" href="library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> や <a class="reference internal" href="library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a> で実装されていることが明らかです。</p>
</dd>
<dt id="term-namespace-package">namespace package<a class="headerlink" href="#term-namespace-package" title="Link to this term">¶</a></dt><dd><p>(名前空間パッケージ) サブパッケージのコンテナとしてのみ提供される <span class="target" id="index-83"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> で定義された <a class="reference internal" href="#term-package"><span class="xref std std-term">package</span></a>  です。名前空間パッケージは物理的な表現を持たないことができ、 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> ファイルを持たないため、 <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">regular package</span></a> とは異なります。</p>
<p><a class="reference internal" href="#term-module"><span class="xref std std-term">module</span></a> を参照してください。</p>
</dd>
<dt id="term-nested-scope">nested scope<a class="headerlink" href="#term-nested-scope" title="Link to this term">¶</a></dt><dd><p>(ネストされたスコープ) 外側で定義されている変数を参照する機能です。例えば、ある関数が別の関数の中で定義されている場合、内側の関数は外側の関数中の変数を参照できます。ネストされたスコープはデフォルトでは変数の参照だけができ、変数の代入はできないので注意してください。ローカル変数は、最も内側のスコープで変数を読み書きします。同様に、グローバル変数を使うとグローバル名前空間の値を読み書きします。 <a class="reference internal" href="reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> で外側の変数に書き込めます。</p>
</dd>
<dt id="term-new-style-class">new-style class<a class="headerlink" href="#term-new-style-class" title="Link to this term">¶</a></dt><dd><p>Old name for the flavor of classes now used for all class objects.  In
earlier Python versions, only new-style classes could use Python's newer,
versatile features like <a class="reference internal" href="reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>, descriptors,
properties, <a class="reference internal" href="reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a>, class methods, and static
methods.</p>
</dd>
<dt id="term-object">object<a class="headerlink" href="#term-object" title="Link to this term">¶</a></dt><dd><p>(オブジェクト) 状態 (属性や値) と定義された振る舞い (メソッド) をもつ全てのデータ。もしくは、全ての <a class="reference internal" href="#term-new-style-class"><span class="xref std std-term">新スタイルクラス</span></a> の究極の基底クラスのこと。</p>
</dd>
<dt id="term-package">package<a class="headerlink" href="#term-package" title="Link to this term">¶</a></dt><dd><p>(パッケージ) サブモジュールや再帰的にサブパッケージを含むことの出来る <a class="reference internal" href="#term-module"><span class="xref std std-term">module</span></a> のことです。専門的には、パッケージは <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 属性を持つ Python オブジェクトです。</p>
<p><a class="reference internal" href="#term-regular-package"><span class="xref std std-term">regular package</span></a> と <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">namespace package</span></a> を参照してください。</p>
</dd>
<dt id="term-parameter">parameter<a class="headerlink" href="#term-parameter" title="Link to this term">¶</a></dt><dd><p>(仮引数) 名前付の実体で <a class="reference internal" href="#term-function"><span class="xref std std-term">関数</span></a> (や <a class="reference internal" href="#term-method"><span class="xref std std-term">メソッド</span></a> ) の定義において関数が受ける <a class="reference internal" href="#term-argument"><span class="xref std std-term">実引数</span></a> を指定します。仮引数には5種類あります:</p>
<ul>
<li><p><em class="dfn">位置またはキーワード</em>: <a class="reference internal" href="#term-argument"><span class="xref std std-term">位置</span></a> であるいは <a class="reference internal" href="#term-argument"><span class="xref std std-term">キーワード引数</span></a> として渡すことができる引数を指定します。
これはたとえば以下の <em>foo</em> や <em>bar</em> のように、デフォルトの仮引数の種類です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="positional-only-parameter">
<li><p>位置専用: 位置によってのみ与えられる引数を指定します。位置専用の引数は 関数定義の引数のリストの中でそれらの後ろに <code class="docutils literal notranslate"><span class="pre">/</span></code> を含めることで定義できます。例えば下記の   <em>posonly1</em> と <em>posonly2</em> は位置専用引数になります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">posonly1</span><span class="p">,</span> <span class="n">posonly2</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">positional_or_keyword</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="keyword-only-parameter">
<li><p><em class="dfn">キーワード専用</em>: キーワードによってのみ与えられる引数を指定します。キーワード専用の引数を定義できる場所は、例えば以下の <em>kw_only1</em> や <em>kw_only2</em> のように、関数定義の仮引数リストに含めた可変長位置引数または裸の <code class="docutils literal notranslate"><span class="pre">*</span></code> の後です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kw_only1</span><span class="p">,</span> <span class="n">kw_only2</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">可変長位置</em>: (他の仮引数で既に受けられた任意の位置引数に加えて) 任意の個数の位置引数が与えられることを指定します。このような仮引数は、以下の <em>args</em> のように仮引数名の前に <code class="docutils literal notranslate"><span class="pre">*</span></code> をつけることで定義できます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">可変長キーワード</em>: (他の仮引数で既に受けられた任意のキーワード引数に加えて) 任意の個数のキーワード引数が与えられることを指定します。このような仮引数は、上の例の <em>kwargs</em> のように仮引数名の前に <code class="docutils literal notranslate"><span class="pre">**</span></code> をつけることで定義できます。</p></li>
</ul>
<p>仮引数はオプションと必須の引数のどちらも指定でき、オプションの引数にはデフォルト値も指定できます。</p>
<p><a class="reference internal" href="#term-parameter"><span class="xref std std-term">仮引数</span></a> 、FAQ の <a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">実引数と仮引数の違いは何ですか?</span></a> 、<a class="reference internal" href="library/inspect.html#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">inspect.Parameter</span></code></a>  クラス、 <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> セクション、<span class="target" id="index-84"></span><a class="pep reference external" href="https://peps.python.org/pep-0362/"><strong>PEP 362</strong></a> を参照してください。</p>
</dd>
<dt id="term-path-entry">path entry<a class="headerlink" href="#term-path-entry" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">path based finder</span></a> が import するモジュールを探す <a class="reference internal" href="#term-import-path"><span class="xref std std-term">import path</span></a> 上の1つの場所です。</p>
</dd>
<dt id="term-path-entry-finder">path entry finder<a class="headerlink" href="#term-path-entry-finder" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> にある callable (つまり <a class="reference internal" href="#term-path-entry-hook"><span class="xref std std-term">path entry hook</span></a>) が返した <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a> です。与えられた <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">path entry</span></a> にあるモジュールを見つける方法を知っています。</p>
<p>パスエントリーファインダが実装するメソッドについては <a class="reference internal" href="library/importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> を参照してください。</p>
</dd>
<dt id="term-path-entry-hook">path entry hook<a class="headerlink" href="#term-path-entry-hook" title="Link to this term">¶</a></dt><dd><p>A callable on the <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> list which returns a <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">path
entry finder</span></a> if it knows how to find modules on a specific <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">path
entry</span></a>.</p>
</dd>
<dt id="term-path-based-finder">path based finder<a class="headerlink" href="#term-path-based-finder" title="Link to this term">¶</a></dt><dd><p>デフォルトの <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a> の1つは、モジュールの <a class="reference internal" href="#term-import-path"><span class="xref std std-term">import path</span></a> を検索します。</p>
</dd>
<dt id="term-path-like-object">path-like object<a class="headerlink" href="#term-path-like-object" title="Link to this term">¶</a></dt><dd><p>(path-like オブジェクト) ファイルシステムパスを表します。
path-like オブジェクトは、パスを表す <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> オブジェクトや <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> オブジェクト、または <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> プロトコルを実装したオブジェクトのどれかです。
<a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> プロトコルをサポートしているオブジェクトは <a class="reference internal" href="library/os.html#os.fspath" title="os.fspath"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fspath()</span></code></a> を呼び出すことで <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> または <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> のファイルシステムパスに変換できます。 <a class="reference internal" href="library/os.html#os.fsdecode" title="os.fsdecode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsdecode()</span></code></a> と <a class="reference internal" href="library/os.html#os.fsencode" title="os.fsencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsencode()</span></code></a> はそれぞれ <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> あるいは <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> になるのを保証するのに使えます。
<span class="target" id="index-85"></span><a class="pep reference external" href="https://peps.python.org/pep-0519/"><strong>PEP 519</strong></a> で導入されました。</p>
</dd>
<dt id="term-PEP">PEP<a class="headerlink" href="#term-PEP" title="Link to this term">¶</a></dt><dd><p>Python Enhancement Proposal。PEP は、Python コミュニティに対して情報を提供する、あるいは Python の新機能やその過程や環境について記述する設計文書です。
PEP は、機能についての簡潔な技術的仕様と提案する機能の論拠 (理論) を伝えるべきです。</p>
<p>PEP は、新機能の提案にかかる、コミュニティによる問題提起の集積と Python になされる設計決断の文書化のための最上位の機構となることを意図しています。PEP の著者にはコミュニティ内の合意形成を行うこと、反対意見を文書化することの責務があります。</p>
<p><span class="target" id="index-86"></span><a class="pep reference external" href="https://peps.python.org/pep-0001/"><strong>PEP 1</strong></a> を参照してください。</p>
</dd>
<dt id="term-portion">portion<a class="headerlink" href="#term-portion" title="Link to this term">¶</a></dt><dd><p><span class="target" id="index-87"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> で定義されている、namespace package に属する、複数のファイルが (zipファイルに格納されている場合もある) 1つのディレクトリに格納されたもの。</p>
</dd>
<dt id="term-positional-argument">位置引数 (positional argument)<a class="headerlink" href="#term-positional-argument" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-argument"><span class="xref std std-term">実引数</span></a> を参照してください。</p>
</dd>
<dt id="term-provisional-API">provisional API<a class="headerlink" href="#term-provisional-API" title="Link to this term">¶</a></dt><dd><p>(暫定 API) 標準ライブラリの後方互換性保証から計画的に除外されたものです。そのようなインターフェースへの大きな変更は、暫定であるとされている間は期待されていませんが、コア開発者によって必要とみなされれば、後方非互換な変更 (インターフェースの削除まで含まれる) が行われえます。このような変更はむやみに行われるものではありません -- これは API を組み込む前には見落とされていた重大な欠陥が露呈したときにのみ行われます。</p>
<p>暫定 API についても、後方互換性のない変更は「最終手段」とみなされています。問題点が判明した場合でも後方互換な解決策を探すべきです。</p>
<p>このプロセスにより、標準ライブラリは問題となるデザインエラーに長い間閉じ込められることなく、時代を超えて進化を続けられます。詳細は <span class="target" id="index-88"></span><a class="pep reference external" href="https://peps.python.org/pep-0411/"><strong>PEP 411</strong></a> を参照してください。</p>
</dd>
<dt id="term-provisional-package">provisional package<a class="headerlink" href="#term-provisional-package" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-provisional-API"><span class="xref std std-term">provisional API</span></a> を参照してください。</p>
</dd>
<dt id="term-Python-3000">Python 3000<a class="headerlink" href="#term-Python-3000" title="Link to this term">¶</a></dt><dd><p>Python 3.x リリースラインのニックネームです。(Python 3 が遠い将来の話だった頃に作られた言葉です。) &quot;Py3k&quot; と略されることもあります。</p>
</dd>
<dt id="term-Pythonic">Pythonic<a class="headerlink" href="#term-Pythonic" title="Link to this term">¶</a></dt><dd><p>他の言語で一般的な考え方で書かれたコードではなく、Python の特に一般的なイディオムに従った考え方やコード片。例えば、Python の一般的なイディオムでは <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 文を使ってイテラブルのすべての要素に渡ってループします。他の多くの言語にはこの仕組みはないので、Python に慣れていない人は代わりに数値のカウンターを使うかもしれません:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">food</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">food</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>これに対し、きれいな Pythonic な方法は:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">piece</span> <span class="ow">in</span> <span class="n">food</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt id="term-qualified-name">qualified name<a class="headerlink" href="#term-qualified-name" title="Link to this term">¶</a></dt><dd><p>(修飾名) モジュールのグローバルスコープから、そのモジュールで定義されたクラス、関数、メソッドへの、 &quot;パス&quot; を表すドット名表記です。 <span class="target" id="index-89"></span><a class="pep reference external" href="https://peps.python.org/pep-3155/"><strong>PEP 3155</strong></a> で定義されています。トップレベルの関数やクラスでは、修飾名はオブジェクトの名前と同じです:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>            <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">meth</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D.meth&#39;</span>
</pre></div>
</div>
<p>モジュールへの参照で使われると、<em>完全修飾名 (fully qualified name)</em> はすべての親パッケージを含む全体のドット名表記、例えば <code class="docutils literal notranslate"><span class="pre">email.mime.text</span></code> を意味します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">email.mime.text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span><span class="o">.</span><span class="n">mime</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;email.mime.text&#39;</span>
</pre></div>
</div>
</dd>
<dt id="term-reference-count">reference count<a class="headerlink" href="#term-reference-count" title="Link to this term">¶</a></dt><dd><p>The number of references to an object.  When the reference count of an
object drops to zero, it is deallocated.  Some objects are
&quot;immortal&quot; and have reference counts that are never modified, and
therefore the objects are never deallocated.  Reference counting is
generally not visible to Python code, but it is a key element of the
<a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a> implementation.  Programmers can call the
<a class="reference internal" href="library/sys.html#sys.getrefcount" title="sys.getrefcount"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getrefcount()</span></code></a> function to return the
reference count for a particular object.</p>
</dd>
<dt id="term-regular-package">regular package<a class="headerlink" href="#term-regular-package" title="Link to this term">¶</a></dt><dd><p>伝統的な、 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> ファイルを含むディレクトリとしての <a class="reference internal" href="#term-package"><span class="xref std std-term">package</span></a>。</p>
<p><a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">namespace package</span></a> を参照してください。</p>
</dd>
<dt id="term-__slots__">__slots__<a class="headerlink" href="#term-__slots__" title="Link to this term">¶</a></dt><dd><p>クラス内での宣言で、インスタンス属性の領域をあらかじめ定義しておき、インスタンス辞書を排除することで、メモリを節約します。これはよく使われるテクニックですが、正しく扱うには少しトリッキーなので、稀なケース、例えばメモリが死活問題となるアプリケーションでインスタンスが大量に存在する、といったときを除き、使わないのがベストです。</p>
</dd>
<dt id="term-sequence">sequence<a class="headerlink" href="#term-sequence" title="Link to this term">¶</a></dt><dd><p>An <a class="reference internal" href="#term-iterable"><span class="xref std std-term">iterable</span></a> which supports efficient element access using integer
indices via the <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> special method and defines a
<a class="reference internal" href="reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> method that returns the length of the sequence.
Some built-in sequence types are <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>,
<a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, and <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Note that <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> also
supports <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code>, but is considered a
mapping rather than a sequence because the lookups use arbitrary
<a class="reference internal" href="#term-immutable"><span class="xref std std-term">immutable</span></a> keys rather than integers.</p>
<p>The <a class="reference internal" href="library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> abstract base class
defines a much richer interface that goes beyond just
<a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> and <a class="reference internal" href="reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a>, adding
<code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>, <a class="reference internal" href="reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a>, and
<a class="reference internal" href="reference/datamodel.html#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a>. Types that implement this expanded
interface can be registered explicitly using
<a class="reference internal" href="library/abc.html#abc.ABCMeta.register" title="abc.ABCMeta.register"><code class="xref py py-func docutils literal notranslate"><span class="pre">register()</span></code></a>. For more documentation on sequence
methods generally, see
<a class="reference internal" href="library/stdtypes.html#typesseq-common"><span class="std std-ref">Common Sequence Operations</span></a>.</p>
</dd>
<dt id="term-set-comprehension">set comprehension<a class="headerlink" href="#term-set-comprehension" title="Link to this term">¶</a></dt><dd><p>(集合内包表記) iterable 内の全てあるいは一部の要素を処理して、その結果からなる集合を返すコンパクトな書き方です。 <code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{c</span> <span class="pre">for</span> <span class="pre">c</span> <span class="pre">in</span> <span class="pre">'abracadabra'</span> <span class="pre">if</span> <span class="pre">c</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">'abc'}</span></code> とすると、<code class="docutils literal notranslate"><span class="pre">{'r',</span> <span class="pre">'d'}</span></code> という文字列の辞書を生成します。 <a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">リスト、集合、辞書の表示</span></a> を参照してください。</p>
</dd>
<dt id="term-single-dispatch">single dispatch<a class="headerlink" href="#term-single-dispatch" title="Link to this term">¶</a></dt><dd><p><a class="reference internal" href="#term-generic-function"><span class="xref std std-term">generic function</span></a> の一種で実装は一つの引数の型により選択されます。</p>
</dd>
<dt id="term-slice">slice<a class="headerlink" href="#term-slice" title="Link to this term">¶</a></dt><dd><p>(スライス) 一般に <a class="reference internal" href="#term-sequence"><span class="xref std std-term">シーケンス</span></a> の一部を含むオブジェクト。スライスは、添字表記 <code class="docutils literal notranslate"><span class="pre">[]</span></code> で与えられた複数の数の間にコロンを書くことで作られます。例えば、 <code class="docutils literal notranslate"><span class="pre">variable_name[1:3:5]</span></code> です。角括弧 (添字) 記号は <a class="reference internal" href="library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> オブジェクトを内部で利用しています。</p>
</dd>
<dt id="term-special-method">special method<a class="headerlink" href="#term-special-method" title="Link to this term">¶</a></dt><dd><p id="index-31">(特殊メソッド) ある型に特定の操作、例えば加算をするために Python から暗黙に呼び出されるメソッド。この種類のメソッドは、メソッド名の最初と最後にアンダースコア 2 つがついています。特殊メソッドについては <a class="reference internal" href="reference/datamodel.html#specialnames"><span class="std std-ref">特殊メソッド名</span></a> で解説されています。</p>
</dd>
<dt id="term-statement">statement<a class="headerlink" href="#term-statement" title="Link to this term">¶</a></dt><dd><p>(文) 文はスイート (コードの&quot;ブロック&quot;) に不可欠な要素です。文は <a class="reference internal" href="#term-expression"><span class="xref std std-term">式</span></a> かキーワードから構成されるもののどちらかです。後者には <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>、<a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a>、<a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> があります。</p>
</dd>
<dt id="term-static-type-checker">static type checker<a class="headerlink" href="#term-static-type-checker" title="Link to this term">¶</a></dt><dd><p>An external tool that reads Python code and analyzes it, looking for
issues such as incorrect types. See also <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">type hints</span></a>
and the <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> module.</p>
</dd>
<dt id="term-strong-reference">strong reference<a class="headerlink" href="#term-strong-reference" title="Link to this term">¶</a></dt><dd><p>In Python's C API, a strong reference is a reference to an object
which is owned by the code holding the reference.  The strong
reference is taken by calling <a class="reference internal" href="c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_INCREF()</span></code></a> when the
reference is created and released with <a class="reference internal" href="c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a>
when the reference is deleted.</p>
<p>The <a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a> function can be used to create a strong reference
to an object. Usually, the <a class="reference internal" href="c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a> function must be called on
the strong reference before exiting the scope of the strong reference, to
avoid leaking one reference.</p>
<p>See also <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">borrowed reference</span></a>.</p>
</dd>
<dt id="term-text-encoding">text encoding<a class="headerlink" href="#term-text-encoding" title="Link to this term">¶</a></dt><dd><p>A string in Python is a sequence of Unicode code points (in range
<code class="docutils literal notranslate"><span class="pre">U+0000</span></code>--<code class="docutils literal notranslate"><span class="pre">U+10FFFF</span></code>). To store or transfer a string, it needs to be
serialized as a sequence of bytes.</p>
<p>Serializing a string into a sequence of bytes is known as &quot;encoding&quot;, and
recreating the string from the sequence of bytes is known as &quot;decoding&quot;.</p>
<p>There are a variety of different text serialization
<a class="reference internal" href="library/codecs.html#standard-encodings"><span class="std std-ref">codecs</span></a>, which are collectively referred to as
&quot;text encodings&quot;.</p>
</dd>
<dt id="term-text-file">text file<a class="headerlink" href="#term-text-file" title="Link to this term">¶</a></dt><dd><p>(テキストファイル) <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> オブジェクトを読み書きできる <a class="reference internal" href="#term-file-object"><span class="xref std std-term">file object</span></a> です。
しばしば、テキストファイルは実際にバイト指向のデータストリームにアクセスし、 <a class="reference internal" href="#term-text-encoding"><span class="xref std std-term">テキストエンコーディング</span></a> を自動的に行います。
テキストファイルの例は、 <a class="reference internal" href="library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a>, <a class="reference internal" href="library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>, <a class="reference internal" href="library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> インスタンスなどをテキストモード (<code class="docutils literal notranslate"><span class="pre">'r'</span></code> or <code class="docutils literal notranslate"><span class="pre">'w'</span></code>) で開いたファイルです。</p>
<p><a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">bytes-like オブジェクト</span></a> を読み書きできるファイルオブジェクトについては、 <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">バイナリファイル</span></a> も参照してください。</p>
</dd>
<dt id="term-triple-quoted-string">triple-quoted string<a class="headerlink" href="#term-triple-quoted-string" title="Link to this term">¶</a></dt><dd><p>(三重クォート文字列) 3つの連続したクォート記号(&quot;)かアポストロフィー(')で囲まれた文字列。通常の(一重)クォート文字列に比べて表現できる文字列に違いはありませんが、幾つかの理由で有用です。1つか2つの連続したクォート記号をエスケープ無しに書くことができますし、行継続文字(\)を使わなくても複数行にまたがることができるので、ドキュメンテーション文字列を書く時に特に便利です。</p>
</dd>
<dt id="term-type">type<a class="headerlink" href="#term-type" title="Link to this term">¶</a></dt><dd><p>(型) Python オブジェクトの型はオブジェクトがどのようなものかを決めます。あらゆるオブジェクトは型を持っています。オブジェクトの型は <a class="reference internal" href="library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> 属性でアクセスしたり、<code class="docutils literal notranslate"><span class="pre">type(obj)</span></code> で取得したり出来ます。</p>
</dd>
<dt id="term-type-alias">type alias<a class="headerlink" href="#term-type-alias" title="Link to this term">¶</a></dt><dd><p>(型エイリアス) 型の別名で、型を識別子に代入して作成します。</p>
<p>型エイリアスは <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">型ヒント</span></a> を単純化するのに有用です。例えば:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">remove_gray_shades</span><span class="p">(</span>
        <span class="n">colors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>これは次のようにより読みやすくできます:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Color</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">remove_gray_shades</span><span class="p">(</span><span class="n">colors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Color</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Color</span><span class="p">]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>機能の説明がある <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> と <span class="target" id="index-90"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> を参照してください。</p>
</dd>
<dt id="term-type-hint">type hint<a class="headerlink" href="#term-type-hint" title="Link to this term">¶</a></dt><dd><p>(型ヒント) 変数、クラス属性、関数のパラメータや返り値の期待される型を指定する <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a> です。</p>
<p>Type hints are optional and are not enforced by Python but
they are useful to <a class="reference internal" href="#term-static-type-checker"><span class="xref std std-term">static type checkers</span></a>.
They can also aid IDEs with code completion and refactoring.</p>
<p>グローバル変数、クラス属性、関数で、ローカル変数でないものの型ヒントは <a class="reference internal" href="library/typing.html#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.get_type_hints()</span></code></a> で取得できます。</p>
<p>機能の説明がある <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> と <span class="target" id="index-91"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> を参照してください。</p>
</dd>
<dt id="term-universal-newlines">universal newlines<a class="headerlink" href="#term-universal-newlines" title="Link to this term">¶</a></dt><dd><p>テキストストリームの解釈法の一つで、以下のすべてを行末と認識します: Unix の行末規定 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>、Windows の規定 <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code>、古い Macintosh の規定 <code class="docutils literal notranslate"><span class="pre">'\r'</span></code>。利用法について詳しくは、 <span class="target" id="index-92"></span><a class="pep reference external" href="https://peps.python.org/pep-0278/"><strong>PEP 278</strong></a> と <span class="target" id="index-93"></span><a class="pep reference external" href="https://peps.python.org/pep-3116/"><strong>PEP 3116</strong></a> 、さらに <a class="reference internal" href="library/stdtypes.html#bytes.splitlines" title="bytes.splitlines"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.splitlines()</span></code></a> も参照してください。</p>
</dd>
<dt id="term-variable-annotation">variable annotation<a class="headerlink" href="#term-variable-annotation" title="Link to this term">¶</a></dt><dd><p>(変数アノテーション) 変数あるいはクラス属性の <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a> 。</p>
<p>変数あるいはクラス属性に注釈を付けたときは、代入部分は任意です:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">field</span><span class="p">:</span> <span class="s1">&#39;annotation&#39;</span>
</pre></div>
</div>
<p>変数アノテーションは通常は <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">型ヒント</span></a> のために使われます: 例えば、この変数は <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> の値を取ることを期待されています:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>変数アノテーションの構文については <a class="reference internal" href="reference/simple_stmts.html#annassign"><span class="std std-ref">注釈付き代入文 (annotated assignment statements)</span></a> 節で解説しています。</p>
<p>機能の説明がある <a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">function annotation</span></a>,  <span class="target" id="index-94"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> , <span class="target" id="index-95"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a> を参照してください。また、アノテーションを利用するベストプラクティスとして <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Annotations Best Practices</span></a> も参照してください。</p>
</dd>
<dt id="term-virtual-environment">virtual environment<a class="headerlink" href="#term-virtual-environment" title="Link to this term">¶</a></dt><dd><p>(仮想環境) 協調的に切り離された実行環境です。これにより Python ユーザとアプリケーションは同じシステム上で動いている他の Python アプリケーションの挙動に干渉することなく Python パッケージのインストールと更新を行うことができます。</p>
<p><a class="reference internal" href="library/venv.html#module-venv" title="venv: Creation of virtual environments."><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code></a> を参照してください。</p>
</dd>
<dt id="term-virtual-machine">virtual machine<a class="headerlink" href="#term-virtual-machine" title="Link to this term">¶</a></dt><dd><p>(仮想マシン) 完全にソフトウェアにより定義されたコンピュータ。 Python の仮想マシンは、バイトコードコンパイラが出力した <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">バイトコード</span></a> を実行します。</p>
</dd>
<dt id="term-Zen-of-Python">Zen of Python<a class="headerlink" href="#term-Zen-of-Python" title="Link to this term">¶</a></dt><dd><p>(Pythonの悟り) Python を理解し利用する上での導きとなる、Python の設計原則と哲学をリストにしたものです。対話プロンプトで &quot;<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">this</span></code>&quot; とするとこのリストを読めます。</p>
</dd>
</dl>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="faq/installed.html"
                          title="前の章へ">&quot;なぜ Python が私のコンピュータにインストールされているのですか？&quot; FAQ</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="about.html"
                          title="次の章へ">このドキュメントについて</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/glossary.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="サイドバーをたたむ">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="about.html" title="このドキュメントについて"
             >次へ</a> |</li>
        <li class="right" >
          <a href="faq/installed.html" title="&#34;なぜ Python が私のコンピュータにインストールされているのですか？&#34; FAQ"
             >前へ</a> |</li>

          <li><img src="_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.12.4 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">用語集</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" id="search-box" />
          <input type="submit" value="検索" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="copyright.html">
    
    Copyright
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="/license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最終更新: Jun 11, 2024 (04:44 UTC)
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>

    <script type="text/javascript" src="_static/switchers.js"></script>
  </body>
</html>