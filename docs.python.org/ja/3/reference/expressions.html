<!DOCTYPE html>

<html lang="ja" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="6. 式 (expression)" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/reference/expressions.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="この章では、Python の式における個々の要素の意味について解説します。 表記法に関する注意: この章と以降の章での拡張BNF (extended BNF) 表記は、字句解析規則ではなく、構文規則を記述するために用いられています。ある構文規則 (のある表現方法) が、以下の形式 で記述されていて、この構文特有の意味付け (semantics) が記述されていない場合、 name の形式をと..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="この章では、Python の式における個々の要素の意味について解説します。 表記法に関する注意: この章と以降の章での拡張BNF (extended BNF) 表記は、字句解析規則ではなく、構文規則を記述するために用いられています。ある構文規則 (のある表現方法) が、以下の形式 で記述されていて、この構文特有の意味付け (semantics) が記述されていない場合、 name の形式をと..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>6. 式 (expression) &#8212; Python 3.12.4 ドキュメント</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=bb723527" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=b20cc3f5" />
    
    <script src="../_static/documentation_options.js?v=7e11ab17"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=4dbe4bdc"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.12.4 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="7. 単純文 (simple statement)" href="simple_stmts.html" />
    <link rel="prev" title="5. インポートシステム" href="import.html" />
    
      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
    
    <link rel="canonical" href="https://docs.python.org/3/reference/expressions.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
<meta name="readthedocs-addons-api-version" content="1">
<script type="text/javascript">
 function onSwitch(event) {
     const option = event.target.selectedIndex;
     const item = event.target.options[option];
     window.location.href = item.dataset.url;
 }

 document.addEventListener("readthedocs-addons-data-ready", function(event) {
   const config = event.detail.data()

   // Add some mocked hardcoded versions pointing to the official
   // documentation while migrating to Read the Docs.
   // These are only for testing purposes.
   // TODO: remove them when managing all the versions on Read the Docs,
   // since all the "active, built and not hidden" versions will be shown automatically.
   let versions = config.versions.active.concat([
       {
           slug: "dev (3.13)",
           urls: {
               documentation: "https://docs.python.org/3.13/",
           }
       },
       {
           slug: "3.12",
           urls: {
               documentation: "https://docs.python.org/3.12/",
           }
       },
       {
           slug: "3.11",
           urls: {
               documentation: "https://docs.python.org/3.11/",
           }
       },
   ]);

   const versionSelect = `
   <select id="version_select">
   ${ versions.map(
       (version) => `
       <option
           value="${ version.slug }"
           ${ config.versions.current.slug === version.slug ? 'selected="selected"' : '' }
           data-url="${ version.urls.documentation }">
           ${ version.slug }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Prepend the current language to the options on the selector
   let languages = config.projects.translations.concat(config.projects.current);
   languages = languages.sort((a, b) => a.language.name.localeCompare(b.language.name));

   const languageSelect = `
   <select id="language_select">
   ${ languages.map(
       (translation) => `
       <option
           value="${ translation.slug }"
           ${ config.projects.current.slug === translation.slug ? 'selected="selected"' : '' }
           data-url="${ translation.urls.documentation }">
           ${ translation.language.name }
       </option>`
   ).join("\n") }
   </select>
   `;

   // Query all the placeholders because there are different ones for Desktop/Mobile
   const versionPlaceholders = document.querySelectorAll(".version_switcher_placeholder");
   for (placeholder of versionPlaceholders) {
       placeholder.innerHTML = versionSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }

   const languagePlaceholders = document.querySelectorAll(".language_switcher_placeholder");
   for (placeholder of languagePlaceholders) {
       placeholder.innerHTML = languageSelect;
       let selectElement = placeholder.querySelector("select");
       selectElement.addEventListener("change", onSwitch);
   }
 });
</script>

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" />
                <input type="submit" value="検索"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="#">6. 式 (expression)</a><ul>
<li><a class="reference internal" href="#arithmetic-conversions">6.1. 算術変換 (arithmetic conversion)</a></li>
<li><a class="reference internal" href="#atoms">6.2. アトム、原子的要素 (atom)</a><ul>
<li><a class="reference internal" href="#atom-identifiers">6.2.1. 識別子 (identifier、または名前 (name))</a></li>
<li><a class="reference internal" href="#literals">6.2.2. リテラル</a></li>
<li><a class="reference internal" href="#parenthesized-forms">6.2.3. 丸括弧形式 (parenthesized form)</a></li>
<li><a class="reference internal" href="#displays-for-lists-sets-and-dictionaries">6.2.4. リスト、集合、辞書の表示</a></li>
<li><a class="reference internal" href="#list-displays">6.2.5. リスト表示</a></li>
<li><a class="reference internal" href="#set-displays">6.2.6. 集合表示</a></li>
<li><a class="reference internal" href="#dictionary-displays">6.2.7. 辞書表示</a></li>
<li><a class="reference internal" href="#generator-expressions">6.2.8. ジェネレータ式</a></li>
<li><a class="reference internal" href="#yield-expressions">6.2.9. Yield 式</a><ul>
<li><a class="reference internal" href="#generator-iterator-methods">6.2.9.1. ジェネレータ-イテレータメソッド</a></li>
<li><a class="reference internal" href="#examples">6.2.9.2. 使用例</a></li>
<li><a class="reference internal" href="#asynchronous-generator-functions">6.2.9.3. 非同期ジェネレータ関数 (asynchronous generator function)</a></li>
<li><a class="reference internal" href="#asynchronous-generator-iterator-methods">6.2.9.4. 非同期ジェネレータイテレータメソッド</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#primaries">6.3. プライマリ</a><ul>
<li><a class="reference internal" href="#attribute-references">6.3.1. 属性参照</a></li>
<li><a class="reference internal" href="#subscriptions">6.3.2. 添字表記 (subscription)</a></li>
<li><a class="reference internal" href="#slicings">6.3.3. スライス表記 (slicing)</a></li>
<li><a class="reference internal" href="#calls">6.3.4. 呼び出し (call)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#await-expression">6.4. Await 式</a></li>
<li><a class="reference internal" href="#the-power-operator">6.5. べき乗演算 (power operator)</a></li>
<li><a class="reference internal" href="#unary-arithmetic-and-bitwise-operations">6.6. 単項算術演算とビット単位演算 (unary arithmetic and bitwise operation)</a></li>
<li><a class="reference internal" href="#binary-arithmetic-operations">6.7. 二項算術演算 (binary arithmetic operation)</a></li>
<li><a class="reference internal" href="#shifting-operations">6.8. シフト演算 (shifting operation)</a></li>
<li><a class="reference internal" href="#binary-bitwise-operations">6.9. ビット単位演算の二項演算 (binary bitwise operation)</a></li>
<li><a class="reference internal" href="#comparisons">6.10. 比較</a><ul>
<li><a class="reference internal" href="#value-comparisons">6.10.1. 値の比較</a></li>
<li><a class="reference internal" href="#membership-test-operations">6.10.2. 所属検査演算</a></li>
<li><a class="reference internal" href="#is-not">6.10.3. 同一性の比較</a></li>
</ul>
</li>
<li><a class="reference internal" href="#boolean-operations">6.11. ブール演算 (boolean operation)</a></li>
<li><a class="reference internal" href="#assignment-expressions">6.12. 代入式</a></li>
<li><a class="reference internal" href="#conditional-expressions">6.13. 条件式 (Conditional Expressions)</a></li>
<li><a class="reference internal" href="#lambda">6.14. ラムダ (lambda)</a></li>
<li><a class="reference internal" href="#expression-lists">6.15. 式のリスト</a></li>
<li><a class="reference internal" href="#evaluation-order">6.16. 評価順序</a></li>
<li><a class="reference internal" href="#operator-precedence">6.17. 演算子の優先順位</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="import.html"
                          title="前の章へ"><span class="section-number">5. </span>インポートシステム</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="simple_stmts.html"
                          title="次の章へ"><span class="section-number">7. </span>単純文 (simple statement)</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/expressions.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. 単純文 (simple statement)"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. インポートシステム"
             accesskey="P">前へ</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 言語リファレンス</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">6. </span>式 (expression)</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" id="search-box" />
          <input type="submit" value="検索" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="expressions">
<span id="id1"></span><h1><span class="section-number">6. </span>式 (expression)<a class="headerlink" href="#expressions" title="Link to this heading">¶</a></h1>
<p id="index-0">この章では、Python の式における個々の要素の意味について解説します。</p>
<p><strong>表記法に関する注意:</strong> この章と以降の章での拡張BNF (extended BNF) 表記は、字句解析規則ではなく、構文規則を記述するために用いられています。ある構文規則 (のある表現方法) が、以下の形式</p>
<pre>
<strong id="grammar-token-python-grammar-name">name</strong> ::=  othername
</pre>
<p>で記述されていて、この構文特有の意味付け (semantics) が記述されていない場合、 <code class="docutils literal notranslate"><span class="pre">name</span></code> の形式をとる構文の意味付けは <code class="docutils literal notranslate"><span class="pre">othername</span></code> の意味付けと同じになります。</p>
<section id="arithmetic-conversions">
<span id="conversions"></span><h2><span class="section-number">6.1. </span>算術変換 (arithmetic conversion)<a class="headerlink" href="#arithmetic-conversions" title="Link to this heading">¶</a></h2>
<p id="index-1">以下の算術演算子の記述で、「数値引数は共通の型に変換されます」と書かれているとき、組み込み型に対する演算子の実装は以下の通りに動作します:</p>
<ul class="simple">
<li><p>片方の引数が複素数型であれば、他方は複素数型に変換されます;</p></li>
<li><p>それ以外の場合で、片方の引数が浮動小数点数であれば、他方は浮動小数点型に変換されます;</p></li>
<li><p>それ以外場合は、両方の引数は整数でなければならず、変換の必要はありません。</p></li>
</ul>
<p>特定の演算子 ('%' 演算子の左引数としての文字列) には、さらに別の規則が適用されます。拡張は、それ自身の型変換のふるまいを定義していなければなりません。</p>
</section>
<section id="atoms">
<span id="id2"></span><h2><span class="section-number">6.2. </span>アトム、原子的要素 (atom)<a class="headerlink" href="#atoms" title="Link to this heading">¶</a></h2>
<p id="index-2">atom は、式の一番基本的な要素です。もっとも単純な atom は、識別子またはリテラルです。丸括弧、角括弧、または波括弧で囲われた形式 (form) もまた、構文上アトムに分類されます。atom の構文は以下のようになります:</p>
<pre>
<strong id="grammar-token-python-grammar-atom">atom     </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-literal"><code class="xref docutils literal notranslate"><span class="pre">literal</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-enclosure"><code class="xref docutils literal notranslate"><span class="pre">enclosure</span></code></a>
<strong id="grammar-token-python-grammar-enclosure">enclosure</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-parenth_form"><code class="xref docutils literal notranslate"><span class="pre">parenth_form</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-list_display"><code class="xref docutils literal notranslate"><span class="pre">list_display</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-dict_display"><code class="xref docutils literal notranslate"><span class="pre">dict_display</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-set_display"><code class="xref docutils literal notranslate"><span class="pre">set_display</span></code></a>
               | <a class="reference internal" href="#grammar-token-python-grammar-generator_expression"><code class="xref docutils literal notranslate"><span class="pre">generator_expression</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-yield_atom"><code class="xref docutils literal notranslate"><span class="pre">yield_atom</span></code></a>
</pre>
<section id="atom-identifiers">
<span id="identifiers-names"></span><h3><span class="section-number">6.2.1. </span>識別子 (identifier、または名前 (name))<a class="headerlink" href="#atom-identifiers" title="Link to this heading">¶</a></h3>
<p id="index-3">アトムの形になっている識別子 (identifier) は名前 (name) です。字句定義については <a class="reference internal" href="lexical_analysis.html#identifiers"><span class="std std-ref">識別子 (identifier) およびキーワード (keyword)</span></a> 節を、名前付けや束縛については <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">名前づけと束縛 (naming and binding)</span></a> 節を参照してください。</p>
<p id="index-4">名前があるオブジェクトに束縛されている場合、名前 atom を評価するとそのオブジェクトになります。名前が束縛されていない場合、 atom を評価しようとすると <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 例外を送出します。</p>
<p id="index-5"><span id="private-name-mangling"></span><strong>プライベートな名前のマングリング:</strong> クラス定義内に書かれた識別子で、2つ以上のアンダースコアから始まり、末尾が2つ以上のアンダースコアで終わっていないものは、そのクラスの <em class="dfn">プライベートな名前</em> とみなされます。プライベートな名前は、コードが生成される前により長い形式に変換されます。この変換によって、クラス名の先頭にアンダースコアがあれば除去し、先頭にアンダースコアを1つ付加し、名前の前に挿入されます。例えば、クラス名 <code class="docutils literal notranslate"><span class="pre">Ham</span></code> の中の識別子 <code class="docutils literal notranslate"><span class="pre">__spam</span></code> は、<code class="docutils literal notranslate"><span class="pre">_Ham__spam</span></code> に変換されます。変換は識別子が使用されている構文のコンテキストからは独立しています。変換された名前が非常に長い (255文字を超える) 場合、実装によっては名前の切り詰めが行われるかもしれません。クラス名がアンダースコアのみから成る場合は変換は行われません。</p>
</section>
<section id="literals">
<span id="atom-literals"></span><h3><span class="section-number">6.2.2. </span>リテラル<a class="headerlink" href="#literals" title="Link to this heading">¶</a></h3>
<p id="index-6">Python では、文字列やバイト列リテラルと、様々な数値リテラルをサポートしています:</p>
<pre>
<strong id="grammar-token-python-grammar-literal">literal</strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-stringliteral"><code class="xref docutils literal notranslate"><span class="pre">stringliteral</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-bytesliteral"><code class="xref docutils literal notranslate"><span class="pre">bytesliteral</span></code></a>
             | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-integer"><code class="xref docutils literal notranslate"><span class="pre">integer</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-floatnumber"><code class="xref docutils literal notranslate"><span class="pre">floatnumber</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-imagnumber"><code class="xref docutils literal notranslate"><span class="pre">imagnumber</span></code></a>
</pre>
<p>リテラルの評価は、与えられた型 (文字列、バイト列、整数、浮動小数点数、複素数) の与えられた値を持つオブジェクトを与えます。浮動小数点や虚数 (複素数) リテラルの場合、値は近似値になる場合があります。詳しくは <a class="reference internal" href="lexical_analysis.html#literals"><span class="std std-ref">リテラル</span></a> を参照してください。</p>
<p id="index-7">リテラルは全て変更不能なデータ型に対応します。このため、オブジェクトのアイデンティティはオブジェクトの値ほど重要ではありません。同じ値を持つ複数のリテラルを評価した場合、(それらのリテラルがプログラムの同じ場所由来のものであっても、そうでなくても) 同じオブジェクトを指しているか、まったく同じ値を持つ別のオブジェクトになります。</p>
</section>
<section id="parenthesized-forms">
<span id="parenthesized"></span><h3><span class="section-number">6.2.3. </span>丸括弧形式 (parenthesized form)<a class="headerlink" href="#parenthesized-forms" title="Link to this heading">¶</a></h3>
<p id="index-8">丸括弧形式とは、式リストの一形態で、丸括弧で囲ったものです:</p>
<pre>
<strong id="grammar-token-python-grammar-parenth_form">parenth_form</strong> ::=  &quot;(&quot; [<a class="reference internal" href="#grammar-token-python-grammar-starred_expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a>] &quot;)&quot;
</pre>
<p>丸括弧で囲われた式のリストは、個々の式が表現するものになります: リスト内に少なくとも一つのカンマが入っていた場合、タプルになります; そうでない場合、式のリストを構成している単一の式自体の値になります。</p>
<p id="index-9">中身が空の丸括弧のペアは、空のタプルオブジェクトを表します。
タプルは変更不能なので、リテラルと同じ規則が適用されます (すなわち、空のタプルが二箇所で使われると、それらは同じオブジェクトになることもあるし、ならないこともあります)。</p>
<p id="index-10">タプルは丸括弧で作成されるのではなく、カンマによって作成されることに注意してください。例外は空のタプルで、この場合には丸括弧が <em>必要です</em> --- 丸括弧のつかない &quot;何も記述しない式 (nothing)&quot; を使えるようにしてしまうと、文法があいまいなものになってしまい、よくあるタイプミスが検出されなくなってしまいます。</p>
</section>
<section id="displays-for-lists-sets-and-dictionaries">
<span id="comprehensions"></span><h3><span class="section-number">6.2.4. </span>リスト、集合、辞書の表示<a class="headerlink" href="#displays-for-lists-sets-and-dictionaries" title="Link to this heading">¶</a></h3>
<p id="index-11">リスト、集合、辞書を構築するために、 Python は &quot;表示 (display)&quot; と呼ばれる特別な構文を提供していて、次の二種類ずつがあります:</p>
<ul class="simple">
<li><p>コンテナの内容を明示的に列挙する</p></li>
<li><p><em class="dfn">内包表記 (comprehension)</em> と呼ばれる、ループ処理とフィルター処理の組み合わせを用いた計算結果</p></li>
</ul>
<p id="index-12">内包表記の共通の構文要素は次の通りです:</p>
<pre>
<strong id="grammar-token-python-grammar-comprehension">comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-assignment_expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> <a class="reference internal" href="#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a>
<strong id="grammar-token-python-grammar-comp_for">comp_for     </strong> ::=  [&quot;async&quot;] &quot;for&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-python-grammar-target_list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a> &quot;in&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [<a class="reference internal" href="#grammar-token-python-grammar-comp_iter"><code class="xref docutils literal notranslate"><span class="pre">comp_iter</span></code></a>]
<strong id="grammar-token-python-grammar-comp_iter">comp_iter    </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-comp_if"><code class="xref docutils literal notranslate"><span class="pre">comp_if</span></code></a>
<strong id="grammar-token-python-grammar-comp_if">comp_if      </strong> ::=  &quot;if&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [<a class="reference internal" href="#grammar-token-python-grammar-comp_iter"><code class="xref docutils literal notranslate"><span class="pre">comp_iter</span></code></a>]
</pre>
<p>内包表記はまず単一の式、続いて少なくとも 1 個の <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節、さらに続いて 0 個以上の <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節あるいは <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> 節からなります。
この場合、各々の <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節や <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> 節を、左から右へ深くなっていくネストしたブロックとみなし、ネストの最内のブロックに到達するごとに内包表記の先頭にある式を評価した結果が、最終的にできあがるコンテナの各要素になります。</p>
<p>ただし、最も左にある <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節のイテラブル式を除いて、内包表記は暗黙的にネストされた個別のスコープで実行されます。
この仕組みのおかげで、対象のリスト内で代入された名前が外側のスコープに &quot;漏れる&quot; ことはありません。</p>
<p>最も左にある <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節のイテラブル式は、それを直接囲んでいるスコープでそのまま評価され、暗黙的な入れ子のスコープに引数として渡されます。
後に続く <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節と、最も左にある <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節のフィルター条件はイテラブル式を直接囲んでいるスコープでは評価できません。というのは、それらは最も左のイテラブルから得られる値に依存しているかもしれないからです。
例えば次の通りです: <code class="docutils literal notranslate"><span class="pre">[x*y</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">range(x,</span> <span class="pre">x+10)]</span></code> 。</p>
<p>内包表記が常に適切な型のコンテナになるのを保証するために、 <code class="docutils literal notranslate"><span class="pre">yield</span></code> 式や <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 式は暗黙的な入れ子のスコープでは禁止されています。</p>
<p id="index-13">Python 3.6 から、 <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 関数では <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 節が <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> の反復処理をするのに使われることがありました。
<code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> 関数に含まれる内包表記が、先頭の式に続く <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節あるいは <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 節で構成されていることや、追加の <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節あるいは <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 節を含んでいること、そのうえ <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 式を使っていることがあるかもしれません。
内包表記が <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 節あるいは <code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code> 式やその他の非同期内包表記を含んでいる場合、それは <em class="dfn">非同期内包表記</em> と呼ばれます。
非同期内包表記は、それが現れるコルーチン関数の実行を中断させるかもしれません。
<span class="target" id="index-110"></span><a class="pep reference external" href="https://peps.python.org/pep-0530/"><strong>PEP 530</strong></a> も参照してください。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6: </span>非同期内包表記が導入されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.8 で変更: </span><code class="docutils literal notranslate"><span class="pre">yield</span></code> および <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> は暗黙的な入れ子のスコープでは禁止となりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.11 で変更: </span>Asynchronous comprehensions are now allowed inside comprehensions in
asynchronous functions. Outer comprehensions implicitly become
asynchronous.</p>
</div>
</section>
<section id="list-displays">
<span id="lists"></span><h3><span class="section-number">6.2.5. </span>リスト表示<a class="headerlink" href="#list-displays" title="Link to this heading">¶</a></h3>
<p id="index-15">リスト表示は、角括弧で囲われた式の系列です。系列は空の系列であってもかまいません:</p>
<pre>
<strong id="grammar-token-python-grammar-list_display">list_display</strong> ::=  &quot;[&quot; [<a class="reference internal" href="#grammar-token-python-grammar-starred_list"><code class="xref docutils literal notranslate"><span class="pre">starred_list</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>] &quot;]&quot;
</pre>
<p>リスト表示は、新しいリストオブジェクトを与えます。リストの内容は、式のリストまたはリスト内包表記 (list comprehension) で指定されます。
カンマで区切られた式のリストが与えられたときは、それらの各要素は左から右へと順に評価され、その順にリスト内に配置されます。
内包表記が与えられたときは、内包表記の結果の要素でリストが構成されます。</p>
</section>
<section id="set-displays">
<span id="set"></span><h3><span class="section-number">6.2.6. </span>集合表示<a class="headerlink" href="#set-displays" title="Link to this heading">¶</a></h3>
<p id="index-16">集合表示は波括弧で表され、キーと値を分けるコロンがないことで辞書表現と区別されます:</p>
<pre>
<strong id="grammar-token-python-grammar-set_display">set_display</strong> ::=  &quot;{&quot; (<a class="reference internal" href="#grammar-token-python-grammar-starred_list"><code class="xref docutils literal notranslate"><span class="pre">starred_list</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>) &quot;}&quot;
</pre>
<p>集合表示は、新しいミュータブルな集合オブジェクトを与えます。集合の内容は、式の並びまたは内包表記によって指定されます。
カンマ区切りの式のリストが与えられたときは、その要素は左から右へ順に評価され、集合オブジェクトに加えられます。
内包表記が与えられたときは、内包表記の結果の要素で集合が構成されます。</p>
<p>空集合は <code class="docutils literal notranslate"><span class="pre">{}</span></code> で構成できません。このリテラルは空の辞書を構成します。</p>
</section>
<section id="dictionary-displays">
<span id="dict"></span><h3><span class="section-number">6.2.7. </span>辞書表示<a class="headerlink" href="#dictionary-displays" title="Link to this heading">¶</a></h3>
<p id="index-17">A dictionary display is a possibly empty series of dict items (key/value pairs)
enclosed in curly braces:</p>
<pre>
<strong id="grammar-token-python-grammar-dict_display">dict_display      </strong> ::=  &quot;{&quot; [<a class="reference internal" href="#grammar-token-python-grammar-dict_item_list"><code class="xref docutils literal notranslate"><span class="pre">dict_item_list</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-dict_comprehension"><code class="xref docutils literal notranslate"><span class="pre">dict_comprehension</span></code></a>] &quot;}&quot;
<strong id="grammar-token-python-grammar-dict_item_list">dict_item_list    </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-dict_item"><code class="xref docutils literal notranslate"><span class="pre">dict_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-dict_item"><code class="xref docutils literal notranslate"><span class="pre">dict_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-dict_item">dict_item         </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | &quot;**&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>
<strong id="grammar-token-python-grammar-dict_comprehension">dict_comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a>
</pre>
<p>辞書表示は、新たな辞書オブジェクトを表します。</p>
<p>If a comma-separated sequence of dict items is given, they are evaluated
from left to right to define the entries of the dictionary: each key object is
used as a key into the dictionary to store the corresponding value.  This means
that you can specify the same key multiple times in the dict item list, and the
final dictionary's value for that key will be the last one given.</p>
<p id="index-18">A double asterisk <code class="docutils literal notranslate"><span class="pre">**</span></code> denotes <em class="dfn">dictionary unpacking</em>.
Its operand must be a <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>.  Each mapping item is added
to the new dictionary.  Later values replace values already set by
earlier dict items and earlier dictionary unpackings.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5: </span>辞書表示のアンパックは最初に <span class="target" id="index-111"></span><a class="pep reference external" href="https://peps.python.org/pep-0448/"><strong>PEP 448</strong></a> で提案されました。</p>
</div>
<p>辞書内包表記は、リストや集合の内包表記とは対照的に、通常の &quot;for&quot; や &quot;if&quot; 節の前に、コロンで分けられた 2 つの式が必要です。内包表記が起動すると、結果のキーと値の要素が、作られた順に新しい辞書に挿入されます。</p>
<p id="index-20">Restrictions on the types of the key values are listed earlier in section
<a class="reference internal" href="datamodel.html#types"><span class="std std-ref">標準型の階層</span></a>.  (To summarize, the key type should be <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>, which excludes
all mutable objects.)  Clashes between duplicate keys are not detected; the last
value (textually rightmost in the display) stored for a given key value
prevails.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.8 で変更: </span>Python 3.8 より前のバージョンでは、辞書内包表記において、キーと値の評価順序は明示されていませんでした。CPython では、値がキーより先に評価されていました。バージョン 3.8 からは <span class="target" id="index-112"></span><a class="pep reference external" href="https://peps.python.org/pep-0572/"><strong>PEP 572</strong></a> で提案されているように、キーが値より先に評価されます。</p>
</div>
</section>
<section id="generator-expressions">
<span id="genexpr"></span><h3><span class="section-number">6.2.8. </span>ジェネレータ式<a class="headerlink" href="#generator-expressions" title="Link to this heading">¶</a></h3>
<p id="index-22">ジェネレータ式 (generator expression) とは、丸括弧を使ったコンパクトなジェネレータ表記法です:</p>
<pre>
<strong id="grammar-token-python-grammar-generator_expression">generator_expression</strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a> &quot;)&quot;
</pre>
<p>ジェネレータ式は新たなジェネレータオブジェクトを与えます。この構文は内包表記とほぼ同じですが、角括弧や波括弧ではなく、丸括弧で囲まれます。</p>
<p>ジェネレータ式の中で使われている変数は、 (通常のジェネレータと同じように) そのジェネレータオブジェクトに対して <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> メソッドが呼ばれるときまで評価が遅延されます。
ただし、最も左にある <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節のイテラブル式は直ちに評価されます。そのためそこで生じたエラーは、最初の値が得られた時点ではなく、ジェネレータ式が定義された時点で発せられます。
後に続く <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節と、最も左にある <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> 節のフィルター条件はイテラブル式を直接囲んでいるスコープでは評価できません。というのは、それらは最も左のイテラブルから得られる値に依存しているかもしれないからです。
例えば次の通りです: <code class="docutils literal notranslate"><span class="pre">(x*y</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">range(x,</span> <span class="pre">x+10))</span></code> 。</p>
<p>関数の唯一の引数として渡す場合には、丸括弧を省略できます。詳しくは <a class="reference internal" href="#calls"><span class="std std-ref">呼び出し (call)</span></a> 節を参照してください。</p>
<p>ジェネレータ式自身の期待される動作を妨げないために、 <code class="docutils literal notranslate"><span class="pre">yield</span></code> 式や <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 式は暗黙的に定義されたジェネレータでは禁止されています。</p>
<p>ジェネレータ式が <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> 節あるいは <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 式を含んでいる場合、それは <em class="dfn">非同期ジェネレータ式</em> と呼ばれます。
非同期ジェネレータ式は、非同期イテレータである新しい非同期ジェネレータオブジェクトを返します (<a class="reference internal" href="datamodel.html#async-iterators"><span class="std std-ref">非同期イテレータ (Asynchronous Iterator)</span></a> を参照してください)。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6: </span>非同期ジェネレータ式が導入されました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.7 で変更: </span>Python 3.7 より前では、非同期ジェネレータ式は <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> コルーチンでしか使えませんでした。
3.7 からは、任意の関数で非同期ジェネレータ式が使えるようになりました。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.8 で変更: </span><code class="docutils literal notranslate"><span class="pre">yield</span></code> および <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> は暗黙的な入れ子のスコープでは禁止となりました。</p>
</div>
</section>
<section id="yield-expressions">
<span id="yieldexpr"></span><h3><span class="section-number">6.2.9. </span>Yield 式<a class="headerlink" href="#yield-expressions" title="Link to this heading">¶</a></h3>
<pre id="index-23">
<strong id="grammar-token-python-grammar-yield_atom">yield_atom      </strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-python-grammar-yield_expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a> &quot;)&quot;
<strong id="grammar-token-python-grammar-yield_from">yield_from      </strong> ::=  &quot;yield&quot; &quot;from&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-yield_expression">yield_expression</strong> ::=  &quot;yield&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-yield_from"><code class="xref docutils literal notranslate"><span class="pre">yield_from</span></code></a>
</pre>
<p>yield 式は <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">ジェネレータ</span></a> 関数や <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">非同期ジェネレータ</span></a> 関数を定義するときに使われます。従って、関数定義の本体でのみ使えます。
関数の本体で yield 式 を使用するとその関数はジェネレータ関数になり、 <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 関数の本体で使用するとそのコルーチン関数は非同期ジェネレータ関数になります。
例えば次のようになります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>  <span class="c1"># defines a generator function</span>
    <span class="k">yield</span> <span class="mi">123</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">agen</span><span class="p">():</span> <span class="c1"># defines an asynchronous generator function</span>
    <span class="k">yield</span> <span class="mi">123</span>
</pre></div>
</div>
<p>含まれているスコープの副作用のため、 <code class="docutils literal notranslate"><span class="pre">yield</span></code> 式は暗黙的に定義されたスコープの一部として内包表記やジェネレータ式を実装するのに使うことは許可されていません。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.8 で変更: </span>yield 式は、暗黙的な入れ子のスコープで内包表記やジェネレータ式を実装するための使用が禁止になりました。</p>
</div>
<p>ジェネレータ関数についてはすぐ下で説明されています。非同期ジェネレータ関数は、 <a class="reference internal" href="#asynchronous-generator-functions"><span class="std std-ref">非同期ジェネレータ関数 (asynchronous generator function)</span></a> 節に分けて説明されています。</p>
<p>ジェネレータ関数が呼び出された時、ジェネレータとしてのイテレータを返します。ジェネレータはその後ジェネレータ関数の実行を制御します。ジェネレータのメソッドが呼び出されると実行が開始されます。開始されると、最初の yield 式まで処理して一時停止し、呼び出し元へ <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> の値を、または <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> が省略されていれば <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。ここで言う一時停止とは、ローカル変数の束縛、命令ポインタや内部の評価スタック、そして例外処理のを含むすべてのローカル状態が保持されることを意味します。再度、ジェネレータのメソッドが呼び出されて実行を再開した時、ジェネレータは yield 式がただの外部呼び出しであったかのように処理を継続します。再開後の yield 式の値は実行を再開するメソッドに依存します。<a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> を使用した場合 (一般に <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 文や組み込み関数 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> など) の結果は <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> となり、<a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> を使用した場合はそのメソッドに渡された値が結果になります。</p>
<p id="index-24">これまで説明した内容から、ジェネレータ関数はコルーチンにとてもよく似ています。ジェネレータ関数は何度も生成し、1つ以上のエントリポイントを持ち、その実行は一時停止されます。ジェネレータ関数は yield した後で実行の継続を制御できないことが唯一の違いです。その制御は常にジェネレータの呼び出し元へ移されます。</p>
<p>yield 式は <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 構造内で使用できます。ジェネレータの (参照カウントがゼロに達するか、ガベージコレクションによる) 完了前に再開されない場合、ジェネレータ-イテレータの <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> メソッドが呼ばれ、<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 節が実行されます。</p>
<p id="index-25"><code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> を使用した場合、与えられた式はイテラブルでなければなりません。そのイテラブルをイテレートすることで生成された値は現在のジェネレータのメソッドの呼び出し元へ直接渡されます。<a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> で渡されたあらゆる値と <a class="reference internal" href="#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> で渡されたあらゆる例外は根底のイテレータに適切なメソッドがあれば渡されます。適切なメソッドがない場合、<a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> は <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> か <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> を、<a class="reference internal" href="#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> は渡された例外を即座に送出します。</p>
<p>根底のイテレータの完了時、引き起こされた <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> インスタンスの <a class="reference internal" href="../library/exceptions.html#StopIteration.value" title="StopIteration.value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> 属性はその yield 式の値となります。
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> を起こす際に明示的にセットされるか、サブイテレータがジェネレータであれば (サブイテレータからかえる値で) 自動的にセットされるかのどちらかです。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.3 で変更: </span>サブイテレータに制御フローを委譲するために <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> が追加されました。</p>
</div>
<p>yield 式が代入文の単独の右辺式であるとき、括弧は省略できます。</p>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<dl class="simple">
<dt><span class="target" id="index-113"></span><a class="pep reference external" href="https://peps.python.org/pep-0255/"><strong>PEP 255</strong></a> - 単純なジェネレータ</dt><dd><p>Python へのジェネレータと <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 文の導入提案。</p>
</dd>
<dt><span class="target" id="index-114"></span><a class="pep reference external" href="https://peps.python.org/pep-0342/"><strong>PEP 342</strong></a> - 拡張されたジェネレータを用いたコルーチン</dt><dd><p>シンプルなコルーチンとして利用できるように、ジェネレータの構文と API を拡張する提案。</p>
</dd>
<dt><span class="target" id="index-115"></span><a class="pep reference external" href="https://peps.python.org/pep-0380/"><strong>PEP 380</strong></a> - サブジェネレータへの委譲構文</dt><dd><p>サブジェネレータの委譲を簡単にするための、 <a class="reference internal" href="#grammar-token-python-grammar-yield_from"><code class="xref std std-token docutils literal notranslate"><span class="pre">yield_from</span></code></a> 構文の導入提案。</p>
</dd>
<dt><span class="target" id="index-116"></span><a class="pep reference external" href="https://peps.python.org/pep-0525/"><strong>PEP 525</strong></a> - 非同期ジェネレータ</dt><dd><p>コルーチン関数へのジェネレータの実装能力の追加による <span class="target" id="index-117"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> の拡張提案。</p>
</dd>
</dl>
</div>
<section id="generator-iterator-methods">
<span id="generator-methods"></span><span id="index-31"></span><h4><span class="section-number">6.2.9.1. </span>ジェネレータ-イテレータメソッド<a class="headerlink" href="#generator-iterator-methods" title="Link to this heading">¶</a></h4>
<p>この説ではジェネレータイテレータのメソッドについて説明します。これらはジェネレータ関数の実行制御に使用できます。</p>
<p>以下のジェネレータメソッドの呼び出しは、ジェネレータが既に実行中の場合 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 例外を送出する点に注意してください。</p>
<dl class="py method" id="index-32">
<dt class="sig sig-object py" id="generator.__next__">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">__next__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.__next__" title="Link to this definition">¶</a></dt>
<dd><p>ジェネレータ関数の実行を開始するか、最後に yield 式が実行されたところから再開します。ジェネレータ関数が <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> メソッドによって再開された時、その時点の <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 式の値は常に <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> と評価されます。その後次の <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 式まで実行し、ジェネレータは一時停止し、<a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> の値を <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> メソッドの呼び出し元に返します。ジェネレータが次の値を yield せずに終了した場合、<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 例外が送出されます。</p>
<p>このメソッドは通常、例えば <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> ループや組み込みの <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> 関数によって暗黙に呼び出されます。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="generator.send">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#generator.send" title="Link to this definition">¶</a></dt>
<dd><p>ジェネレータ関数の内部へ値を &quot;送り&quot;、実行を再開します。引数の <em>value</em> はその時点の yield 式の結果になります。 <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> メソッドは次にジェネレータが生成した値を返し、ジェネレータが次の値を生成することなく終了すると <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> を送出します。 <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> が呼び出されてジェネレータが開始するときは、値を受け取る yield 式が存在しないので、 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> を引数として呼び出さなければなりません。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="generator.throw">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#generator.throw" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>ジェネレータが中断した位置で例外を発生させて、そのジェネレータ関数が生成する次の値を返します。ジェネレータが値を生成することなく終了すると <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> が発生します。ジェネレータ関数が渡された例外を捕捉しない、もしくは違う例外を発生させるなら、その例外は呼び出し元へ伝搬されます。</p>
<p>In typical use, this is called with a single exception instance similar to the
way the <a class="reference internal" href="simple_stmts.html#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> keyword is used.</p>
<p>For backwards compatibility, however, the second signature is
supported, following a convention from older versions of Python.
The <em>type</em> argument should be an exception class, and <em>value</em>
should be an exception instance. If the <em>value</em> is not provided, the
<em>type</em> constructor is called to get an instance. If <em>traceback</em>
is provided, it is set on the exception, otherwise any existing
<a class="reference internal" href="../library/exceptions.html#BaseException.__traceback__" title="BaseException.__traceback__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__traceback__</span></code></a> attribute stored in <em>value</em> may
be cleared.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.12 で変更: </span>The second signature (type[, value[, traceback]]) is deprecated and
may be removed in a future version of Python.</p>
</div>
</dd></dl>

<dl class="py method" id="index-33">
<dt class="sig sig-object py" id="generator.close">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.close" title="Link to this definition">¶</a></dt>
<dd><p>Raises a <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> at the point where the generator function was
paused.  If the generator function then exits gracefully, is already closed,
or raises <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> (by not catching the exception), close
returns to its caller.  If the generator yields a value, a
<a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> is raised.  If the generator raises any other exception,
it is propagated to the caller.  <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> does nothing if the generator
has already exited due to an exception or normal exit.</p>
</dd></dl>

</section>
<section id="examples">
<span id="index-34"></span><h4><span class="section-number">6.2.9.2. </span>使用例<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h4>
<p>以下の簡単なサンプルはジェネレータとジェネレータ関数の振る舞いを実際に紹介します:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Execution starts when &#39;next()&#39; is called for the first time.&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="n">e</span>
<span class="gp">... </span>    <span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Don&#39;t forget to clean up when &#39;close()&#39; is called.&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span> <span class="o">=</span> <span class="n">echo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">Execution starts when &#39;next()&#39; is called for the first time.</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">generator</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="s2">&quot;spam&quot;</span><span class="p">)</span>
<span class="go">TypeError(&#39;spam&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">Don&#39;t forget to clean up when &#39;close()&#39; is called.</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> の使用例は、&quot;What's New in Python.&quot; の <a class="reference internal" href="../whatsnew/3.3.html#pep-380"><span class="std std-ref">PEP 380: サブジェネレータへの委譲構文</span></a> を参照してください。</p>
</section>
<section id="asynchronous-generator-functions">
<span id="id3"></span><h4><span class="section-number">6.2.9.3. </span>非同期ジェネレータ関数 (asynchronous generator function)<a class="headerlink" href="#asynchronous-generator-functions" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> を使用して定義された関数やメソッドに yield 式があると、その関数は <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">非同期ジェネレータ</span></a> 関数として定義されます。</p>
<p>非同期ジェネレータ関数が呼び出されると、非同期ジェネレータオブジェクトと呼ばれる非同期イテレータが返されます。
そして、そのオブジェクトはジェネレータ関数の実行を制御します。
通常、非同期ジェネレータオブジェクトは、コルーチン関数内の <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 文で使われ、これはジェネレータオブジェクトが <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 文で使われる様子に類似します。</p>
<p>非同期ジェネレータのメソッドの 1 つを呼び出すと <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> オブジェクトが返され、このオブジェクトが動く番になったときに実行が開始されます。
そのときに実行は最初の yield 式まで進み、そこで再び中断され、 <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> の値を待機中のコルーチンに返します。
ジェネレータと同様に、中断とは、現在のローカル変数束縛、命令ポインタ、内部評価スタック、および例外処理の状態など、すべてのローカルな状態が保たれることを意味します。
非同期ジェネレータのメソッドから次のオブジェクトが返されたことで実行が再開されると、関数はあたかも yield 式が単なる外部呼び出しであるかのように処理を進めていきます。
再開後の yield 式の値は、実行を再開したメソッドによって異なります。
<a class="reference internal" href="#agen.__anext__" title="agen.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> を使った場合は、結果は <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> になります。
そうではなく、 <a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> が使用された場合は、結果はそのメソッドに渡された値になります。</p>
<p>If an asynchronous generator happens to exit early by <a class="reference internal" href="simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a>, the caller
task being cancelled, or other exceptions, the generator's async cleanup code
will run and possibly raise exceptions or access context variables in an
unexpected context--perhaps after the lifetime of tasks it depends, or
during the event loop shutdown when the async-generator garbage collection hook
is called.
To prevent this, the caller must explicitly close the async generator by calling
<a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> method to finalize the generator and ultimately detach it
from the event loop.</p>
<p>非同期ジェネレータ関数では、 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 構造内の任意の場所で yield 式が使用できます。
ただし、非同期ジェネレータが、(参照カウントがゼロに達するか、ガベージコレクションによる) 終了処理より前に再開されない場合、 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code> 構造内の yield 式は失敗となり、実行待ちだった <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 節が実行されます。
このケースでは、非同期ジェネレータが作動しているイベントループやスケジューラの責務は、非同期ジェネレータの <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> メソッドを呼び出し、残りのコルーチンオブジェクトを実行し、それによって実行待ちだった <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 節が実行できるようにします。</p>
<p>To take care of finalization upon event loop termination, an event loop should
define a <em>finalizer</em> function which takes an asynchronous generator-iterator and
presumably calls <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> and executes the coroutine.
This  <em>finalizer</em> may be registered by calling <a class="reference internal" href="../library/sys.html#sys.set_asyncgen_hooks" title="sys.set_asyncgen_hooks"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.set_asyncgen_hooks()</span></code></a>.
When first iterated over, an asynchronous generator-iterator will store the
registered <em>finalizer</em> to be called upon finalization. For a reference example
of a <em>finalizer</em> method see the implementation of
<code class="docutils literal notranslate"><span class="pre">asyncio.Loop.shutdown_asyncgens</span></code> in <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Lib/asyncio/base_events.py">Lib/asyncio/base_events.py</a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> 式は、非同期ジェネレータ関数で使われると文法エラーになります。</p>
</section>
<section id="asynchronous-generator-iterator-methods">
<span id="asynchronous-generator-methods"></span><span id="index-35"></span><h4><span class="section-number">6.2.9.4. </span>非同期ジェネレータイテレータメソッド<a class="headerlink" href="#asynchronous-generator-iterator-methods" title="Link to this heading">¶</a></h4>
<p>この小節では、ジェネレータ関数の実行制御に使われる非同期ジェネレータイテレータのメソッドについて説明します。</p>
<dl class="py method" id="index-36">
<dt class="sig sig-object py" id="agen.__anext__">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">__anext__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.__anext__" title="Link to this definition">¶</a></dt>
<dd><p>Returns an awaitable which when run starts to execute the asynchronous
generator or resumes it at the last executed yield expression.  When an
asynchronous generator function is resumed with an <a class="reference internal" href="#agen.__anext__" title="agen.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a>
method, the current yield expression always evaluates to <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> in the
returned awaitable, which when run will continue to the next yield
expression. The value of the <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> of the
yield expression is the value of the <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception raised by
the completing coroutine.  If the asynchronous generator exits without
yielding another value, the awaitable instead raises a
<a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> exception, signalling that the asynchronous
iteration has completed.</p>
<p>このメソッドは通常、 <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> ループによって暗黙に呼び出されます。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="agen.asend">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">asend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#agen.asend" title="Link to this definition">¶</a></dt>
<dd><p>Returns an awaitable which when run resumes the execution of the
asynchronous generator. As with the <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> method for a
generator, this &quot;sends&quot; a value into the asynchronous generator function,
and the <em>value</em> argument becomes the result of the current yield expression.
The awaitable returned by the <a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> method will return the next
value yielded by the generator as the value of the raised
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, or raises <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> if the
asynchronous generator exits without yielding another value.  When
<a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> is called to start the asynchronous
generator, it must be called with <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> as the argument,
because there is no yield expression that could receive the value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="agen.athrow">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">athrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#agen.athrow" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">athrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Returns an awaitable that raises an exception of type <code class="docutils literal notranslate"><span class="pre">type</span></code> at the point
where the asynchronous generator was paused, and returns the next value
yielded by the generator function as the value of the raised
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception.  If the asynchronous generator exits
without yielding another value, a <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> exception is
raised by the awaitable.
If the generator function does not catch the passed-in exception, or
raises a different exception, then when the awaitable is run that exception
propagates to the caller of the awaitable.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.12 で変更: </span>The second signature (type[, value[, traceback]]) is deprecated and
may be removed in a future version of Python.</p>
</div>
</dd></dl>

<dl class="py method" id="index-37">
<dt class="sig sig-object py" id="agen.aclose">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.aclose" title="Link to this definition">¶</a></dt>
<dd><p>Returns an awaitable that when run will throw a <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> into
the asynchronous generator function at the point where it was paused.
If the asynchronous generator function then exits gracefully, is already
closed, or raises <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> (by not catching the exception),
then the returned awaitable will raise a <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception.
Any further awaitables returned by subsequent calls to the asynchronous
generator will raise a <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> exception.  If the
asynchronous generator yields a value, a <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> is raised
by the awaitable.  If the asynchronous generator raises any other exception,
it is propagated to the caller of the awaitable.  If the asynchronous
generator has already exited due to an exception or normal exit, then
further calls to <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> will return an awaitable that does nothing.</p>
</dd></dl>

</section>
</section>
</section>
<section id="primaries">
<span id="id4"></span><h2><span class="section-number">6.3. </span>プライマリ<a class="headerlink" href="#primaries" title="Link to this heading">¶</a></h2>
<p id="index-38">プライマリは、言語において最も結合の強い操作を表します。文法は以下のようになります:</p>
<pre>
<strong id="grammar-token-python-grammar-primary">primary</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-atom"><code class="xref docutils literal notranslate"><span class="pre">atom</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-attributeref"><code class="xref docutils literal notranslate"><span class="pre">attributeref</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-subscription"><code class="xref docutils literal notranslate"><span class="pre">subscription</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-slicing"><code class="xref docutils literal notranslate"><span class="pre">slicing</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-call"><code class="xref docutils literal notranslate"><span class="pre">call</span></code></a>
</pre>
<section id="attribute-references">
<span id="id5"></span><h3><span class="section-number">6.3.1. </span>属性参照<a class="headerlink" href="#attribute-references" title="Link to this heading">¶</a></h3>
<p id="index-39">属性参照は、プライマリの後ろにピリオドと名前を連ねたものです:</p>
<pre>
<strong id="grammar-token-python-grammar-attributeref">attributeref</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;.&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
</pre>
<p id="index-40">The primary must evaluate to an object of a type that supports attribute
references, which most objects do.  This object is then asked to produce the
attribute whose name is the identifier. The type and value produced is
determined by the object.  Multiple evaluations of the same attribute
reference may yield different objects.</p>
<p>This production can be customized by overriding the
<a class="reference internal" href="datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> method or the <a class="reference internal" href="datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>
method.  The <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code> method is called first and either
returns a value or raises <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> if the attribute is not
available.</p>
<p>If an <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> is raised and the object has a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code>
method, that method is called as a fallback.</p>
</section>
<section id="subscriptions">
<span id="id6"></span><h3><span class="section-number">6.3.2. </span>添字表記 (subscription)<a class="headerlink" href="#subscriptions" title="Link to this heading">¶</a></h3>
<p id="index-42"><span id="index-41"></span>The subscription of an instance of a <a class="reference internal" href="datamodel.html#sequence-types"><span class="std std-ref">container class</span></a>
will generally select an element from the container. The subscription of a
<a class="reference internal" href="../glossary.html#term-generic-type"><span class="xref std std-term">generic class</span></a> will generally return a
<a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias</span></a> object.</p>
<pre>
<strong id="grammar-token-python-grammar-subscription">subscription</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> &quot;]&quot;
</pre>
<p>When an object is subscripted, the interpreter will evaluate the primary and
the expression list.</p>
<p>The primary must evaluate to an object that supports subscription. An object
may support subscription through defining one or both of
<a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> and <a class="reference internal" href="datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>. When the
primary is subscripted, the evaluated result of the expression list will be
passed to one of these methods. For more details on when <code class="docutils literal notranslate"><span class="pre">__class_getitem__</span></code>
is called instead of <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>, see <a class="reference internal" href="datamodel.html#classgetitem-versus-getitem"><span class="std std-ref">__class_getitem__ versus __getitem__</span></a>.</p>
<p>If the expression list contains at least one comma, it will evaluate to a
<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the items of the expression list. Otherwise, the
expression list will evaluate to the value of the list's sole member.</p>
<p>組み込みオブジェクトでは、<a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>　によって添字表記をサポートするオブジェクトには 2 種類あります:</p>
<ol class="arabic simple">
<li><p>マッピング。プライマリが <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">マッピング</span></a> であれば、式リストの値評価結果はマップ内のいずれかのキー値に相当するオブジェクトにならなければなりません。添字表記は、そのキーに対応するマッピング内の値 (value) を選択します。組み込みのマッピングクラスの例は <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> クラスです。</p></li>
<li><p>シーケンス。プライマリが <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">シーケンス</span></a> であれば、式リストの評価結果は <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> または <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> (以下の節で論じます) でなければなりません。組み込みのシーケンスクラスの例には <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>、<a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>、<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> クラスが含まれます。</p></li>
</ol>
<p>The formal syntax makes no special provision for negative indices in
<a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequences</span></a>. However, built-in sequences all provide a <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>
method that interprets negative indices by adding the length of the sequence
to the index so that, for example, <code class="docutils literal notranslate"><span class="pre">x[-1]</span></code> selects the last item of <code class="docutils literal notranslate"><span class="pre">x</span></code>. The
resulting value must be a nonnegative integer less than the number of items in
the sequence, and the subscription selects the item whose index is that value
(counting from zero). Since the support for negative indices and slicing
occurs in the object's <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method, subclasses overriding
this method will need to explicitly add that support.</p>
<p id="index-43"><a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">文字列</span></code></a> は文字 (<em>character</em>) を要素とする特別な種類のシーケンスです。文字は個別の型ではなく、 1 文字だけからなる文字列です。</p>
</section>
<section id="slicings">
<span id="id7"></span><h3><span class="section-number">6.3.3. </span>スライス表記 (slicing)<a class="headerlink" href="#slicings" title="Link to this heading">¶</a></h3>
<p id="index-45"><span id="index-44"></span>スライス表記はシーケンスオブジェクト (文字列、タプルまたはリスト) におけるある範囲の要素を選択します。スライス表記は式として用いたり、代入や <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> 文の対象として用いたりできます。スライス表記の構文は以下のようになります:</p>
<pre>
<strong id="grammar-token-python-grammar-slicing">slicing     </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-python-grammar-slice_list"><code class="xref docutils literal notranslate"><span class="pre">slice_list</span></code></a> &quot;]&quot;
<strong id="grammar-token-python-grammar-slice_list">slice_list  </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-slice_item"><code class="xref docutils literal notranslate"><span class="pre">slice_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-slice_item"><code class="xref docutils literal notranslate"><span class="pre">slice_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-slice_item">slice_item  </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-proper_slice"><code class="xref docutils literal notranslate"><span class="pre">proper_slice</span></code></a>
<strong id="grammar-token-python-grammar-proper_slice">proper_slice</strong> ::=  [<a class="reference internal" href="#grammar-token-python-grammar-lower_bound"><code class="xref docutils literal notranslate"><span class="pre">lower_bound</span></code></a>] &quot;:&quot; [<a class="reference internal" href="#grammar-token-python-grammar-upper_bound"><code class="xref docutils literal notranslate"><span class="pre">upper_bound</span></code></a>] [ &quot;:&quot; [<a class="reference internal" href="#grammar-token-python-grammar-stride"><code class="xref docutils literal notranslate"><span class="pre">stride</span></code></a>] ]
<strong id="grammar-token-python-grammar-lower_bound">lower_bound </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-upper_bound">upper_bound </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-stride">stride      </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>上記の形式的な構文法にはあいまいなところがあります: 式リストに見えるものは、スライスリストにも見えるため、添字表記はスライス表記としても解釈されうるということです。(スライスリストが適切なスライスを含まない場合)、これ以上の構文の複雑化はせず、スライス表記としての解釈よりも添字表記としての解釈が優先されるように定義することで、あいまいさを取り除いています。</p>
<p id="index-46">The semantics for a slicing are as follows.  The primary is indexed (using the
same <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method as
normal subscription) with a key that is constructed from the slice list, as
follows.  If the slice list contains at least one comma, the key is a tuple
containing the conversion of the slice items; otherwise, the conversion of the
lone slice item is the key.  The conversion of a slice item that is an
expression is that expression.  The conversion of a proper slice is a slice
object (see section <a class="reference internal" href="datamodel.html#types"><span class="std std-ref">標準型の階層</span></a>) whose <a class="reference internal" href="../library/functions.html#slice.start" title="slice.start"><code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code></a>,
<a class="reference internal" href="../library/functions.html#slice.stop" title="slice.stop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code></a> and <a class="reference internal" href="../library/functions.html#slice.step" title="slice.step"><code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code></a> attributes are the values of the
expressions given as lower bound, upper bound and stride, respectively,
substituting <code class="docutils literal notranslate"><span class="pre">None</span></code> for missing expressions.</p>
</section>
<section id="calls">
<span id="index-47"></span><span id="id8"></span><h3><span class="section-number">6.3.4. </span>呼び出し (call)<a class="headerlink" href="#calls" title="Link to this heading">¶</a></h3>
<p>呼び出しは、呼び出し可能オブジェクト (例えば <a class="reference internal" href="../glossary.html#term-function"><span class="xref std std-term">function</span></a>) を <a class="reference internal" href="../glossary.html#term-argument"><span class="xref std std-term">arguments</span></a> の系列とともに呼び出します。系列は空の系列であってもかまいません:</p>
<pre>
<strong id="grammar-token-python-grammar-call">call                </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;(&quot; [<a class="reference internal" href="#grammar-token-python-grammar-argument_list"><code class="xref docutils literal notranslate"><span class="pre">argument_list</span></code></a> [&quot;,&quot;] | <a class="reference internal" href="#grammar-token-python-grammar-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>] &quot;)&quot;
<strong id="grammar-token-python-grammar-argument_list">argument_list       </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-positional_arguments"><code class="xref docutils literal notranslate"><span class="pre">positional_arguments</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-starred_and_keywords"><code class="xref docutils literal notranslate"><span class="pre">starred_and_keywords</span></code></a>]
                            [&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>]
                          | <a class="reference internal" href="#grammar-token-python-grammar-starred_and_keywords"><code class="xref docutils literal notranslate"><span class="pre">starred_and_keywords</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>]
                          | <a class="reference internal" href="#grammar-token-python-grammar-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>
<strong id="grammar-token-python-grammar-positional_arguments">positional_arguments</strong> ::=  positional_item (&quot;,&quot; positional_item)*
<strong id="grammar-token-python-grammar-positional_item">positional_item     </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-assignment_expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> | &quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-starred_and_keywords">starred_and_keywords</strong> ::=  (&quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a>)
                          (&quot;,&quot; &quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | &quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a>)*
<strong id="grammar-token-python-grammar-keywords_arguments">keywords_arguments  </strong> ::=  (<a class="reference internal" href="#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a> | &quot;**&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)
                          (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a> | &quot;,&quot; &quot;**&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)*
<strong id="grammar-token-python-grammar-keyword_item">keyword_item        </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> &quot;=&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>最後の位置引数やキーワード引数の後にカンマをつけてもかまいません。構文の意味付けに影響を及ぼすことはありません。</p>
<p id="index-48">The primary must evaluate to a callable object (user-defined functions, built-in
functions, methods of built-in objects, class objects, methods of class
instances, and all objects having a <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> method are callable).  All
argument expressions are evaluated before the call is attempted.  Please refer
to section <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> for the syntax of formal <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameter</span></a> lists.</p>
<p>キーワード引数が存在する場合、以下のようにして最初に位置引数 (positional argument) に変換されます。まず、値の入っていないスロットが仮引数に対して生成されます。N 個の位置引数がある場合、位置引数は先頭の N スロットに配置されます。次に、各キーワード引数について、識別子を使って対応するスロットを決定します (識別子が最初の仮引数名と同じなら、最初のスロットを使う、といった具合です)。スロットがすでにすべて埋まっていたなら <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 例外が送出されます。それ以外の場合、引数をスロットに埋めていきます。 (式が <code class="docutils literal notranslate"><span class="pre">None</span></code> であっても、その式でスロットを埋めます)。全ての引数が処理されたら、まだ埋められていないスロットをそれぞれに対応する関数定義時のデフォルト値で埋めます。(デフォルト値は、関数が定義されたときに一度だけ計算されます; 従って、リストや辞書のような変更可能なオブジェクトがデフォルト値として使われると、対応するスロットに引数を指定しない限り、このオブジェクトが全ての呼び出しから共有されます; このような状況は通常避けるべきです。) デフォルト値が指定されていない、値の埋められていないスロットが残っている場合 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 例外が送出されます。そうでない場合、値の埋められたスロットからなるリストが呼び出しの引数として使われます。</p>
<div class="impl-detail compound">
<p><strong>CPython 実装の詳細:</strong> 実装では、名前を持たない位置引数を受け取る組み込み関数を提供されるかもしれません。そういった引数がドキュメント化のために '名付けられて' いたとしても、実際には名付けられていないのでキーワードでは提供されません。 CPython では、C 言語で実装された関数の、名前を持たない位置引数をパースするために <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> を使用します。</p>
</div>
<p>仮引数スロットの数よりも多くの位置引数がある場合、構文 <code class="docutils literal notranslate"><span class="pre">*identifier</span></code> を使って指定された仮引数がないかぎり、 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 例外が送出されます; 仮引数 <code class="docutils literal notranslate"><span class="pre">*identifier</span></code> がある場合、この仮引数は余分な位置引数が入ったタプル (もしくは、余分な位置引数がない場合には空のタプル) を受け取ります。</p>
<p>キーワード引数のいずれかが仮引数名に対応しない場合、構文 <code class="docutils literal notranslate"><span class="pre">**identifier</span></code> を使って指定された仮引数がない限り、 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 例外が送出されます; 仮引数 <code class="docutils literal notranslate"><span class="pre">**identifier</span></code> がある場合、この仮引数は余分なキーワード引数が入った (キーワードをキーとし、引数値をキーに対応する値とした) 辞書を受け取ります。余分なキーワード引数がない場合には、空の (新たな) 辞書を受け取ります。</p>
<p id="index-49">関数呼び出しに <code class="docutils literal notranslate"><span class="pre">*expression</span></code> という構文が現れる場合は、 <code class="docutils literal notranslate"><span class="pre">expression</span></code> の評価結果は <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">イテラブル</span></a> でなければなりません。
そのイテラブルの要素は、追加の位置引数であるかのように扱われます。
<code class="docutils literal notranslate"><span class="pre">f(x1,</span> <span class="pre">x2,</span> <span class="pre">*y,</span> <span class="pre">x3,</span> <span class="pre">x4)</span></code> という呼び出しにおいて、 <em>y</em> の評価結果がシーケンス <em>y1</em>, ..., <em>yM</em> だった場合は、この呼び出しは M+4 個の位置引数 <em>x1</em>, <em>x2</em>, <em>y1</em>, ..., <em>yM</em>, <em>x3</em>, <em>x4</em> での呼び出しと同じになります。</p>
<p>この結論としては、 <code class="docutils literal notranslate"><span class="pre">*expression</span></code> 構文がキーワード引数の <em>後ろ</em> に来ることもありますが、キーワード引数 (と任意の <code class="docutils literal notranslate"><span class="pre">**expression</span></code> 引数 -- 下を参照) よりも <em>前</em> にあるものとして処理されます。
従って、このような動作になります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">2 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">f() got multiple values for keyword argument &#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">1 2</span>
</pre></div>
</div>
<p>キーワード引数と <code class="docutils literal notranslate"><span class="pre">*expression</span></code> 構文を同じ呼び出しで一緒に使うことはあまりないので、実際に上記のような混乱が頻繁に生じることはありません。</p>
<p id="index-50">関数呼び出しで <code class="docutils literal notranslate"><span class="pre">**expression</span></code> 構文が使われた場合、 <code class="docutils literal notranslate"><span class="pre">expression</span></code> の評価結果は <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">マッピング</span></a> でなければなりません。その内容は追加のキーワード引数として扱われます。
キーにマッチする引数が (明示的なキーワード引数によって、あるいは他のアンパックの中で) 既に値を与えられていたなら、 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 例外が送出されます。</p>
<p>When <code class="docutils literal notranslate"><span class="pre">**expression</span></code> is used, each key in this mapping must be
a string.
Each value from the mapping is assigned to the first formal parameter
eligible for keyword assignment whose name is equal to the key.
A key need not be a Python identifier (e.g. <code class="docutils literal notranslate"><span class="pre">&quot;max-temp</span> <span class="pre">°F&quot;</span></code> is acceptable,
although it will not match any formal parameter that could be declared).
If there is no match to a formal parameter
the key-value pair is collected by the <code class="docutils literal notranslate"><span class="pre">**</span></code> parameter, if there is one,
or if there is not, a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception is raised.</p>
<p><code class="docutils literal notranslate"><span class="pre">*identifier</span></code> や <code class="docutils literal notranslate"><span class="pre">**identifier</span></code> 構文を使った仮引数は、位置引数スロットやキーワード引数名にすることができません。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">バージョン 3.5 で変更: </span>関数呼び出しは任意の数の <code class="docutils literal notranslate"><span class="pre">*</span></code> アンパックと <code class="docutils literal notranslate"><span class="pre">**</span></code> アンパックを受け取り、位置引数はイテラブルアンパック (<code class="docutils literal notranslate"><span class="pre">*</span></code>) の後ろに置け、キーワード引数は辞書アンパック (<code class="docutils literal notranslate"><span class="pre">**</span></code>) の後ろに置けるようになりました。
最初に <span class="target" id="index-118"></span><a class="pep reference external" href="https://peps.python.org/pep-0448/"><strong>PEP 448</strong></a> で提案されました。</p>
</div>
<p>呼び出しを行うと、例外を送出しない限り、常に何らかの値を返します。 <code class="docutils literal notranslate"><span class="pre">None</span></code> を返す場合もあります。戻り値がどのように算出されるかは、呼び出し可能オブジェクトの形態によって異なります。</p>
<p>各形態では---</p>
<dl>
<dt>ユーザ定義関数:</dt><dd><p id="index-52">関数のコードブロックに引数リストが渡され、実行されます。コードブロックは、まず仮引数を実引数に結合 (bind) します; この動作については <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> で記述しています。コードブロックで <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 文が実行される際に、関数呼び出しの戻り値 (return value) が決定されます。</p>
</dd>
<dt>組み込み関数またはメソッド:</dt><dd><p id="index-53">結果はインタプリタに依存します; 組み込み関数やメソッドの詳細は <a class="reference internal" href="../library/functions.html#built-in-funcs"><span class="std std-ref">組み込み関数</span></a> を参照してください。</p>
</dd>
<dt>クラスオブジェクト:</dt><dd><p id="index-54">そのクラスの新しいインスタンスが返されます。</p>
</dd>
<dt>クラスインスタンスメソッド:</dt><dd><p id="index-55">対応するユーザ定義の関数が呼び出されます。このとき、呼び出し時の引数リストより一つ長い引数リストで呼び出されます: インスタンスが引数リストの先頭に追加されます。</p>
</dd>
<dt>クラスインスタンス:</dt><dd><p id="index-56">The class must define a <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> method; the effect is then the same as
if that method was called.</p>
</dd>
</dl>
</section>
</section>
<section id="await-expression">
<span id="await"></span><span id="index-57"></span><h2><span class="section-number">6.4. </span>Await 式<a class="headerlink" href="#await-expression" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> オブジェクトでの <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a> 実行を一時停止します。
<a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">coroutine function</span></a> 内でのみ使用できます。</p>
<pre>
<strong id="grammar-token-python-grammar-await_expr">await_expr</strong> ::=  &quot;await&quot; <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a>
</pre>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</section>
<section id="the-power-operator">
<span id="power"></span><h2><span class="section-number">6.5. </span>べき乗演算 (power operator)<a class="headerlink" href="#the-power-operator" title="Link to this heading">¶</a></h2>
<p id="index-58">べき乗演算は、左側にある単項演算子よりも強い結合優先順位となります。一方、右側にある単項演算子よりは弱い結合優先順位になっています。構文は以下のようになります:</p>
<pre>
<strong id="grammar-token-python-grammar-power">power</strong> ::=  (<a class="reference internal" href="#grammar-token-python-grammar-await_expr"><code class="xref docutils literal notranslate"><span class="pre">await_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a>) [&quot;**&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>]
</pre>
<p>従って、べき乗演算子と単項演算子からなる演算列が丸括弧で囲われていない場合、演算子は右から左へと評価されます (この場合は演算子の評価順序を強制しません。つまり <code class="docutils literal notranslate"><span class="pre">-1**2</span></code> は <code class="docutils literal notranslate"><span class="pre">-1</span></code> になります)。</p>
<p>べき乗演算子の意味は、二つの引数で呼び出される組み込み関数 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> と同じで、左引数を右引数乗して与えます。数値引数はまず共通の型に変換され、結果はその型です。</p>
<p>整数の被演算子では、第二引数が負でない限り、結果は被演算子と同じ型になります; 第二引数が負の場合、全ての引数は浮動小数点型に変換され、浮動小数点型が返されます。例えば <code class="docutils literal notranslate"><span class="pre">10**2</span></code> は <code class="docutils literal notranslate"><span class="pre">100</span></code> を返しますが、<code class="docutils literal notranslate"><span class="pre">10**-2</span></code> は <code class="docutils literal notranslate"><span class="pre">0.01</span></code> を返します。</p>
<p><code class="docutils literal notranslate"><span class="pre">0.0</span></code> を負の数でべき乗すると <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a> を送出します。負の数を小数でべき乗した結果は複素数 (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a> number) になります。 (以前のバージョンでは <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> を送出していました)</p>
<p>This operation can be customized using the special <a class="reference internal" href="datamodel.html#object.__pow__" title="object.__pow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pow__()</span></code></a> method.</p>
</section>
<section id="unary-arithmetic-and-bitwise-operations">
<span id="unary"></span><h2><span class="section-number">6.6. </span>単項算術演算とビット単位演算 (unary arithmetic and bitwise operation)<a class="headerlink" href="#unary-arithmetic-and-bitwise-operations" title="Link to this heading">¶</a></h2>
<p id="index-59">全ての単項算術演算とビット単位演算は、同じ優先順位を持っています:</p>
<pre>
<strong id="grammar-token-python-grammar-u_expr">u_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-power"><code class="xref docutils literal notranslate"><span class="pre">power</span></code></a> | &quot;-&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | &quot;+&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | &quot;~&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>
</pre>
<p id="index-60">The unary <code class="docutils literal notranslate"><span class="pre">-</span></code> (minus) operator yields the negation of its numeric argument; the
operation can be overridden with the <a class="reference internal" href="datamodel.html#object.__neg__" title="object.__neg__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__neg__()</span></code></a> special method.</p>
<p id="index-61">The unary <code class="docutils literal notranslate"><span class="pre">+</span></code> (plus) operator yields its numeric argument unchanged; the
operation can be overridden with the <a class="reference internal" href="datamodel.html#object.__pos__" title="object.__pos__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pos__()</span></code></a> special method.</p>
<p id="index-62">The unary <code class="docutils literal notranslate"><span class="pre">~</span></code> (invert) operator yields the bitwise inversion of its integer
argument.  The bitwise inversion of <code class="docutils literal notranslate"><span class="pre">x</span></code> is defined as <code class="docutils literal notranslate"><span class="pre">-(x+1)</span></code>.  It only
applies to integral numbers or to custom objects that override the
<a class="reference internal" href="datamodel.html#object.__invert__" title="object.__invert__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__invert__()</span></code></a> special method.</p>
<p id="index-63">上記の三つはいずれも、引数が正しい型でない場合には <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 例外が送出されます。</p>
</section>
<section id="binary-arithmetic-operations">
<span id="binary"></span><h2><span class="section-number">6.7. </span>二項算術演算 (binary arithmetic operation)<a class="headerlink" href="#binary-arithmetic-operations" title="Link to this heading">¶</a></h2>
<p id="index-64">二項算術演算は、慣習的な優先順位を踏襲しています。演算子のいずれかは、特定の非数値型にも適用されるので注意してください。べき乗 (power) 演算子を除き、演算子には二つのレベル、すなわち乗算的 (multiplicatie) 演算子と加算的 (additie) 演算子しかありません:</p>
<pre>
<strong id="grammar-token-python-grammar-m_expr">m_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;&#64;&quot; <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> |
            <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;//&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;/&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> |
            <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;%&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>
<strong id="grammar-token-python-grammar-a_expr">a_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> &quot;+&quot; <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> &quot;-&quot; <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a>
</pre>
<p id="index-65"><code class="docutils literal notranslate"><span class="pre">*</span></code> (乗算: multiplication) 演算子は、引数同士の積を与えます。引数は、両方とも数値であるか、片方が整数で他方がシーケンスかのどちらかでなければなりません。前者の場合、数値は共通の型に変換された後乗算されます。後者の場合、シーケンスの繰り返し操作が行われます。繰り返し数を負にすると、空のシーケンスを与えます。</p>
<p>This operation can be customized using the special <a class="reference internal" href="datamodel.html#object.__mul__" title="object.__mul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mul__()</span></code></a> and
<a class="reference internal" href="datamodel.html#object.__rmul__" title="object.__rmul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rmul__()</span></code></a> methods.</p>
<p id="index-66"><code class="docutils literal notranslate"><span class="pre">&#64;</span></code> (at) 演算子は行列の乗算に対し使用されます。
Python の組み込み型はこの演算子を実装していません。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<p id="index-67"><code class="docutils literal notranslate"><span class="pre">/</span></code> (除算: division) および <code class="docutils literal notranslate"><span class="pre">//</span></code> (切り捨て除算: floor division) は、引数同士の商を与えます。数値引数はまず共通の型に変換されます。整数の除算結果は浮動小数点になりますが、整数の切り捨て除算結果は整数になります; この場合、結果は数学的な除算に 'floor' 関数 を適用したものになります。ゼロによる除算を行うと <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a> 例外を送出します。</p>
<p>This operation can be customized using the special <a class="reference internal" href="datamodel.html#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a> and
<a class="reference internal" href="datamodel.html#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code></a> methods.</p>
<p id="index-68"><code class="docutils literal notranslate"><span class="pre">%</span></code> (剰余: modulo) 演算は、第一引数を第二引数で除算したときの剰余になります。数値引数はまず共通の型に変換されます。右引数値がゼロの場合には <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a> 例外が送出されます。引数値は浮動小数点でもよく。例えば <code class="docutils literal notranslate"><span class="pre">3.14%0.7</span></code> は <code class="docutils literal notranslate"><span class="pre">0.34</span></code> になります (<code class="docutils literal notranslate"><span class="pre">3.14</span></code> は <code class="docutils literal notranslate"><span class="pre">4*0.7</span> <span class="pre">+</span> <span class="pre">0.34</span></code> だからです)。剰余演算子は常に第二引数と同じ符号 (またはゼロ) の結果になります; 剰余演算の結果の絶対値は、常に第二引数の絶対値よりも小さくなります。 <a class="footnote-reference brackets" href="#id17" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
<p>切り捨て除算演算と剰余演算は、恒等式: <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x//y)*y</span> <span class="pre">+</span> <span class="pre">(x%y)</span></code> の関係にあります。切り捨て除算や剰余はまた、組み込み関数 <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>: <code class="docutils literal notranslate"><span class="pre">divmod(x,</span> <span class="pre">y)</span> <span class="pre">==</span> <span class="pre">(x//y,</span> <span class="pre">x%y)</span></code> とも関係しています。 <a class="footnote-reference brackets" href="#id18" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">%</span></code> 演算子は、数値に対する剰余演算を行うのに加えて、文字列 (string) オブジェクトにオーバーロードされ、旧式の文字列の書式化 (いわゆる補間) を行います。文字列の書式化の構文は Python ライブラリリファレンス <a class="reference internal" href="../library/stdtypes.html#old-string-formatting"><span class="std std-ref">printf 形式の文字列書式化</span></a> 節を参照してください。</p>
<p>The <em>modulo</em> operation can be customized using the special <a class="reference internal" href="datamodel.html#object.__mod__" title="object.__mod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mod__()</span></code></a> method.</p>
<p>切り捨て除算演算子、剰余演算子、および <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> 関数は、複素数に対しては定義されていません。目的に合うならば、代わりに <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> を使って浮動小数点に変換してください。</p>
<p id="index-69"><code class="docutils literal notranslate"><span class="pre">+</span></code> (加算) 演算は、引数同士の和を与えます。引数は双方とも数値型か、双方とも同じ型のシーケンスでなければなりません。前者の場合、数値は共通の型に変換され、加算されます。後者の場合、シーケンスは結合 (concatenate) されます。</p>
<p>This operation can be customized using the special <a class="reference internal" href="datamodel.html#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> and
<a class="reference internal" href="datamodel.html#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__radd__()</span></code></a> methods.</p>
<p id="index-70"><code class="docutils literal notranslate"><span class="pre">-</span></code> (減算) 演算は、引数間で減算を行った値を返します。数値引数はまず共通の型に変換されます。</p>
<p>This operation can be customized using the special <a class="reference internal" href="datamodel.html#object.__sub__" title="object.__sub__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__sub__()</span></code></a> method.</p>
</section>
<section id="shifting-operations">
<span id="shifting"></span><h2><span class="section-number">6.8. </span>シフト演算 (shifting operation)<a class="headerlink" href="#shifting-operations" title="Link to this heading">¶</a></h2>
<p id="index-71">シフト演算は、算術演算よりも低い優先順位を持っています:</p>
<pre>
<strong id="grammar-token-python-grammar-shift_expr">shift_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a> (&quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot;) <a class="reference internal" href="#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a>
</pre>
<p>これらは整数を引数にとります。引数は共通の型に変換されます。シフト演算は第一引数を、第二引数で与えられたビット数だけ、左または右にビットシフトします。</p>
<p>This operation can be customized using the special <a class="reference internal" href="datamodel.html#object.__lshift__" title="object.__lshift__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lshift__()</span></code></a> and
<a class="reference internal" href="datamodel.html#object.__rshift__" title="object.__rshift__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rshift__()</span></code></a> methods.</p>
<p id="index-72"><em>n</em> ビットの右シフトは <code class="docutils literal notranslate"><span class="pre">pow(2,n)</span></code> による除算として定義されます。<em>n</em> ビットの左シフトは <code class="docutils literal notranslate"><span class="pre">pow(2,n)</span></code> による乗算として定義されます。</p>
</section>
<section id="binary-bitwise-operations">
<span id="bitwise"></span><h2><span class="section-number">6.9. </span>ビット単位演算の二項演算 (binary bitwise operation)<a class="headerlink" href="#binary-bitwise-operations" title="Link to this heading">¶</a></h2>
<p id="index-73">以下の三つのビット単位演算には、それぞれ異なる優先順位レベルがあります:</p>
<pre>
<strong id="grammar-token-python-grammar-and_expr">and_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a> &quot;&amp;&quot; <a class="reference internal" href="#grammar-token-python-grammar-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a>
<strong id="grammar-token-python-grammar-xor_expr">xor_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a> &quot;^&quot; <a class="reference internal" href="#grammar-token-python-grammar-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a>
<strong id="grammar-token-python-grammar-or_expr">or_expr </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a> &quot;|&quot; <a class="reference internal" href="#grammar-token-python-grammar-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a>
</pre>
<p id="index-74">The <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> operator yields the bitwise AND of its arguments, which must be
integers or one of them must be a custom object overriding <a class="reference internal" href="datamodel.html#object.__and__" title="object.__and__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__and__()</span></code></a> or
<a class="reference internal" href="datamodel.html#object.__rand__" title="object.__rand__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rand__()</span></code></a> special methods.</p>
<p id="index-75">The <code class="docutils literal notranslate"><span class="pre">^</span></code> operator yields the bitwise XOR (exclusive OR) of its arguments, which
must be integers or one of them must be a custom object overriding <a class="reference internal" href="datamodel.html#object.__xor__" title="object.__xor__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__xor__()</span></code></a> or
<a class="reference internal" href="datamodel.html#object.__rxor__" title="object.__rxor__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rxor__()</span></code></a> special methods.</p>
<p id="index-76">The <code class="docutils literal notranslate"><span class="pre">|</span></code> operator yields the bitwise (inclusive) OR of its arguments, which
must be integers or one of them must be a custom object overriding <a class="reference internal" href="datamodel.html#object.__or__" title="object.__or__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__or__()</span></code></a> or
<a class="reference internal" href="datamodel.html#object.__ror__" title="object.__ror__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ror__()</span></code></a> special methods.</p>
</section>
<section id="comparisons">
<span id="id11"></span><h2><span class="section-number">6.10. </span>比較<a class="headerlink" href="#comparisons" title="Link to this heading">¶</a></h2>
<p id="index-77">C 言語と違って、Python における比較演算子は同じ優先順位をもっており、全ての算術演算子、シフト演算子、ビット単位演算子よりも低くなっています。また <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">c</span></code> が数学で伝統的に用いられているのと同じ解釈になる点も C 言語と違います:</p>
<pre>
<strong id="grammar-token-python-grammar-comparison">comparison   </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a> (<a class="reference internal" href="#grammar-token-python-grammar-comp_operator"><code class="xref docutils literal notranslate"><span class="pre">comp_operator</span></code></a> <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>)*
<strong id="grammar-token-python-grammar-comp_operator">comp_operator</strong> ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;==&quot; | &quot;&gt;=&quot; | &quot;&lt;=&quot; | &quot;!=&quot;
                   | &quot;is&quot; [&quot;not&quot;] | [&quot;not&quot;] &quot;in&quot;
</pre>
<p>Comparisons yield boolean values: <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>. Custom
<em class="dfn">rich comparison methods</em> may return non-boolean values. In this case
Python will call <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a> on such value in boolean contexts.</p>
<p id="index-78">比較はいくらでも連鎖することができます。例えば <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> は <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> と等価になります。ただしこの場合、前者では <code class="docutils literal notranslate"><span class="pre">y</span></code> はただ一度だけ評価される点が異なります (どちらの場合でも、 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> が偽になると <code class="docutils literal notranslate"><span class="pre">z</span></code> の値はまったく評価されません)。</p>
<p>形式的には、 <em>a</em>, <em>b</em>, <em>c</em>, ..., <em>y</em>, <em>z</em> が式で <em>op1</em>, <em>op2</em>, ..., <em>opN</em> が比較演算子である場合、 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code> は <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">and</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">and</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code> と等価になります。ただし、前者では各式は多くても一度しか評価されません。</p>
<p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span></code> と書いた場合、 <em>a</em> から <em>c</em> までの範囲にあるかどうかのテストを指すのではないことに注意してください。例えば <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> は (きれいな書き方ではありませんが) 完全に正しい文法です。</p>
<section id="value-comparisons">
<span id="expressions-value-comparisons"></span><h3><span class="section-number">6.10.1. </span>値の比較<a class="headerlink" href="#value-comparisons" title="Link to this heading">¶</a></h3>
<p>演算子 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, および <code class="docutils literal notranslate"><span class="pre">!=</span></code> は2つのオブジェクトの値を比較します。
オブジェクトが同じ型を持つ必要はりません。</p>
<p><a class="reference internal" href="datamodel.html#objects"><span class="std std-ref">オブジェクト、値、および型</span></a> の章では、オブジェクトは (型や id に加えて) 値を持つことを述べています。
オブジェクトの値は Python ではやや抽象的な概念です: 例えば、オブジェクトの値にアクセスする正統な方法はありません。
また、その全てのデータ属性から構成されるなどの特定の方法で、オブジェクトの値を構築する必要性もありません。
比較演算子は、オブジェクトの値とは何かについての特定の概念を実装しています。
この比較の実装によって、間接的にオブジェクトの値を定義していると考えることもできます。</p>
<p>Because all types are (direct or indirect) subtypes of <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>, they
inherit the default comparison behavior from <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>.  Types can
customize their comparison behavior by implementing
<em class="dfn">rich comparison methods</em> like <a class="reference internal" href="datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a>, described in
<a class="reference internal" href="datamodel.html#customization"><span class="std std-ref">基本的なカスタマイズ</span></a>.</p>
<p>等価比較 (<code class="docutils literal notranslate"><span class="pre">==</span></code> および <code class="docutils literal notranslate"><span class="pre">!=</span></code>) のデフォルトの振る舞いは、オブジェクトの同一性に基づいています。
従って、同一のインスタンスの等価比較の結果は等しいとなり、同一でないインスタンスの等価比較の結果は等しくないとなります。
デフォルトの振る舞いをこのようにしたのは、全てのオブジェクトを反射的 (reflexive つまり <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> ならば <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code>) なものにしたかったからです。</p>
<p>デフォルトの順序比較 (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>) は提供されません; 比較しようとすると <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> が送出されます。
この振る舞いをデフォルトの振る舞いにした動機は、等価性と同じような不変性が欠けているからです。</p>
<p>同一でないインスタンスは常に等価でないとする等価比較のデフォルトの振る舞いは、型が必要とするオブジェクトの値や値に基づいた等価性の実用的な定義とは対照的に思えるでしょう。
そのような型では比較の振る舞いをカスタマイズする必要が出てきて、実際にたくさんの組み込み型でそれが行われています。</p>
<p>次のリストでは、最重要の組み込み型の比較の振る舞いを解説しています。</p>
<ul>
<li><p>いくつかの組み込みの数値型 (<a class="reference internal" href="../library/stdtypes.html#typesnumeric"><span class="std std-ref">数値型 int, float, complex</span></a>) と標準ライブラリの型 <a class="reference internal" href="../library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a> および <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a> は、これらの型の範囲で異なる型とも比較できますが、複素数では順序比較がサポートされていないという制限があります。
関わる型の制限の範囲内では、精度のロス無しに数学的に (アルゴリズム的に) 正しい比較が行われます。</p>
<p>非数値である <code class="docutils literal notranslate"><span class="pre">float('NaN')</span></code> と <code class="docutils literal notranslate"><span class="pre">decimal.Decimal('NaN')</span></code> は特別です。
数と非数値との任意の順序比較は偽です。
直観に反する帰結として、非数値は自分自身と等価ではないことになります。
例えば <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">float('NaN')</span></code> ならば、 <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">&lt;</span> <span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">3</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">x</span></code> は全て偽で、<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">x</span></code> は真です。
この振る舞いは IEEE 754 に従ったものです。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> and <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> are singletons.  <span class="target" id="index-79"></span><a class="pep reference external" href="https://peps.python.org/pep-0008/"><strong>PEP 8</strong></a> advises that
comparisons for singletons should always be done with <code class="docutils literal notranslate"><span class="pre">is</span></code> or <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code>,
never the equality operators.</p></li>
<li><p>バイナリシーケンス (<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> または <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> のインスタンス) は、これらの型の範囲で異なる型とも比較できます。
比較は要素の数としての値を使った辞書式順序で行われます。</p></li>
<li><p>文字列 (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> のインスタンス) の比較は、文字の Unicode のコードポイントの数としての値 (組み込み関数 <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a> の返り値) を使った辞書式順序で行われます。 <a class="footnote-reference brackets" href="#id19" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p>
<p>文字列とバイナリシーケンスは直接には比較できません。</p>
</li>
<li><p>シーケンス (<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, or <a class="reference internal" href="../library/stdtypes.html#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a> のインスタンス) の比較は、同じ型どうしでしか行えず、 range は順序比較をサポートしていません。
異なる型どうしの等価比較の結果は等価でないとなり、異なる型どうしの順序比較は <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> を送出します。</p>
<p>Sequences compare lexicographically using comparison of corresponding
elements.  The built-in containers typically assume identical objects are
equal to themselves.  That lets them bypass equality tests for identical
objects to improve performance and to maintain their internal invariants.</p>
<p>組み込みのコレクションどうしの辞書式比較は次のように動作します:</p>
<ul class="simple">
<li><p>比較の結果が等価となる2つのコレクションは、同じ型、同じ長さ、対応する要素どうしの比較の結果が等価でなければなりません (例えば、 <code class="docutils literal notranslate"><span class="pre">[1,2]</span> <span class="pre">==</span> <span class="pre">(1,2)</span></code> は型が同じでないので偽です)。</p></li>
<li><p>順序比較をサポートしているコレクションの順序は、最初の等価でない要素の順序と同じになります (例えば、 <code class="docutils literal notranslate"><span class="pre">[1,2,x]</span> <span class="pre">&lt;=</span> <span class="pre">[1,2,y]</span></code> は <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> と同じ値になります)。
対応する要素が存在しない場合、短い方のコレクションの方が先の順序となります (例えば、 <code class="docutils literal notranslate"><span class="pre">[1,2]</span> <span class="pre">&lt;</span> <span class="pre">[1,2,3]</span></code> は真です)。</p></li>
</ul>
</li>
<li><p>マッピング (<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> のインスタンス) の比較の結果が等価となるのは、同じ <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code> を持っているときかつそのときに限ります。
キーと値の等価比較では反射性が強制されます。</p>
<p>順序比較 (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>) は <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> を送出します。</p>
</li>
<li><p>集合 (<a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> または <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> のインスタンス) の比較は、これらの型の範囲で異なる型とも行えます。</p>
<p>集合には、部分集合あるいは上位集合かどうかを基準とする順序比較が定義されています。
この関係は全順序を定義しません (例えば、 <code class="docutils literal notranslate"><span class="pre">{1,2}</span></code> と <code class="docutils literal notranslate"><span class="pre">{2,3}</span></code> という2つの集合は片方がもう一方の部分集合でもなく上位集合でもありません)。
従って、集合は全順序性に依存する関数の引数として適切ではありません (例えば、 <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> は集合のリストを入力として与えると未定義な結果となります)。</p>
<p>集合の比較では、その要素の反射性が強制されます。</p>
</li>
<li><p>他の組み込み型のほとんどは比較メソッドが実装されておらず、デフォルトの比較の振る舞いを継承します。</p></li>
</ul>
<p>比較の振る舞いをカスタマイズしたユーザ定義クラスは、可能なら次の一貫性の規則に従う必要があります:</p>
<ul>
<li><p>等価比較は反射的でなければなりません。
つまり、同一のオブジェクトは等しくなければなりません:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> ならば <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code></p>
</div></blockquote>
</li>
<li><p>比較は対称的でなければなりません。
つまり、以下の式の結果は同じでなければなりません:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">==</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">!=</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&gt;=</span> <span class="pre">x</span></code></p>
</div></blockquote>
</li>
<li><p>比較は推移的でなければなりません。
以下の (包括的でない) 例がその説明です:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> ならば <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">z</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> ならば <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">z</span></code></p>
</div></blockquote>
</li>
<li><p>比較の逆は真偽値の否定でなければなりません。
つまり、以下の式の結果は同じでなければなりません:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> と <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> と <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code> (全順序の場合)</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> と <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> (全順序の場合)</p>
</div></blockquote>
<p>最後の2式は全順序コレクションに当てはまります (たとえばシーケンスには当てはまりますが、集合やマッピングには当てはまりません)。
<a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">total_ordering()</span></code></a> デコレータも参照してください。</p>
</li>
<li><p><a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> の結果は等価性と一貫している必要があります。
等価なオブジェクトどうしは同じハッシュ値を持つか、ハッシュ値が計算できないものとされる必要があります。</p></li>
</ul>
<p>Python はこの一貫性規則を強制しません。
事実、非数値がこの規則に従わない例となります。</p>
</section>
<section id="membership-test-operations">
<span id="membership-test-details"></span><span id="not-in"></span><span id="in"></span><h3><span class="section-number">6.10.2. </span>所属検査演算<a class="headerlink" href="#membership-test-operations" title="Link to this heading">¶</a></h3>
<p>演算子 <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> および <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a> は所属関係を調べます。
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code> の評価は、 <em>x</em> が <em>s</em> の要素であれば <code class="docutils literal notranslate"><span class="pre">True</span></code> となり、そうでなければ <code class="docutils literal notranslate"><span class="pre">False</span></code> となります。
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></code> は <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code> の否定を返します。
すべての組み込みのシーケンス型と集合型に加えて、辞書も <code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code> を辞書が与えられたキーを持っているかを調べる演算子としてサポートしています。
リスト、タプル、集合、凍結集合、辞書、 collections.deque のようなコンテナ型において、式 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> は <code class="docutils literal notranslate"><span class="pre">any(x</span> <span class="pre">is</span> <span class="pre">e</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">e</span> <span class="pre">for</span> <span class="pre">e</span> <span class="pre">in</span> <span class="pre">y)</span></code> と等価です。</p>
<p>文字列やバイト列型については、 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> は <em>x</em> が <em>y</em> の部分文字列であるとき、かつそのときに限り <code class="docutils literal notranslate"><span class="pre">True</span></code> になります。これは <code class="docutils literal notranslate"><span class="pre">y.find(x)</span> <span class="pre">!=</span> <span class="pre">-1</span></code> と等価です。空文字列は、他の任意の文字列の部分文字列とみなされます。従って <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span> <span class="pre">in</span> <span class="pre">&quot;abc&quot;</span></code> は <code class="docutils literal notranslate"><span class="pre">True</span></code> を返すことになります。</p>
<p>For user-defined classes which define the <a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> method, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span>
<span class="pre">y</span></code> returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">y.__contains__(x)</span></code> returns a true value, and
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>For user-defined classes which do not define <a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> but do define
<a class="reference internal" href="datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> if some value <code class="docutils literal notranslate"><span class="pre">z</span></code>, for which the
expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">z</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">z</span></code> is true, is produced while iterating over <code class="docutils literal notranslate"><span class="pre">y</span></code>.
If an exception is raised during the iteration, it is as if <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> raised
that exception.</p>
<p>Lastly, the old-style iteration protocol is tried: if a class defines
<a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> if and only if there is a non-negative
integer index <em>i</em> such that <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y[i]</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">y[i]</span></code>, and no lower integer index
raises the <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> exception.  (If any other exception is raised, it is as
if <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> raised that exception).</p>
<p id="index-80">演算子 <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a> は <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> の真理値を反転した値として定義されています。</p>
</section>
<section id="is-not">
<span id="is"></span><span id="index-81"></span><span id="identity-comparisons"></span><h3><span class="section-number">6.10.3. </span>同一性の比較<a class="headerlink" href="#is-not" title="Link to this heading">¶</a></h3>
<p>演算子 <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> および <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></a> は、オブジェクトの同一性に対するテストを行います: <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> は、 <em>x</em> と <em>y</em> が同じオブジェクトを指すとき、かつそのときに限り真になります。
オブジェクトの同一性は <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id()</span></code></a> 関数を使って判定されます。
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">y</span></code> は <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> の真値を反転したものになります。 <a class="footnote-reference brackets" href="#id20" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p>
</section>
</section>
<section id="boolean-operations">
<span id="not"></span><span id="or"></span><span id="and"></span><span id="booleans"></span><h2><span class="section-number">6.11. </span>ブール演算 (boolean operation)<a class="headerlink" href="#boolean-operations" title="Link to this heading">¶</a></h2>
<pre id="index-82">
<strong id="grammar-token-python-grammar-or_test">or_test </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> &quot;or&quot; <a class="reference internal" href="#grammar-token-python-grammar-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a>
<strong id="grammar-token-python-grammar-and_test">and_test</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a> &quot;and&quot; <a class="reference internal" href="#grammar-token-python-grammar-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a>
<strong id="grammar-token-python-grammar-not_test">not_test</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-comparison"><code class="xref docutils literal notranslate"><span class="pre">comparison</span></code></a> | &quot;not&quot; <a class="reference internal" href="#grammar-token-python-grammar-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a>
</pre>
<p>In the context of Boolean operations, and also when expressions are used by
control flow statements, the following values are interpreted as false:
<code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>, numeric zero of all types, and empty strings and containers
(including strings, tuples, lists, dictionaries, sets and frozensets).  All
other values are interpreted as true.  User-defined objects can customize their
truth value by providing a <a class="reference internal" href="datamodel.html#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> method.</p>
<p id="index-83">演算子 <a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a> は、引数が偽である場合には <code class="docutils literal notranslate"><span class="pre">True</span></code> を、それ以外の場合には <code class="docutils literal notranslate"><span class="pre">False</span></code> になります。</p>
<p id="index-84">式 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></code> は、まず <em>x</em> を評価します; <em>x</em> が偽なら <em>x</em> の値を返します; それ以外の場合には、 <em>y</em> を評価した結果値を返します。</p>
<p id="index-85">式 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></code> は、まず <em>x</em> を評価します; <em>x</em> が真なら <em>x</em> の値を返します; それ以外の場合には、 <em>y</em> を評価した結果値を返します。</p>
<p>なお、 <a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code></a> も <a class="reference internal" href="#or"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code></a> も、返す値を <code class="docutils literal notranslate"><span class="pre">True</span></code> や <code class="docutils literal notranslate"><span class="pre">False</span></code> に制限せず、最後に評価した引数を返します。
この仕様が便利なときもあります。例えば <code class="docutils literal notranslate"><span class="pre">s</span></code> が文字列で、空文字列ならデフォルトの値に置き換えたいとき、式 <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">or</span> <span class="pre">'foo'</span></code> は望んだ値を与えます。
<a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a> は必ず新しい値を作成するので、引数の型に関係なくブール値を返します (例えば、 <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">'foo'</span></code> は <code class="docutils literal notranslate"><span class="pre">''</span></code> ではなく <code class="docutils literal notranslate"><span class="pre">False</span></code> になります)。</p>
</section>
<section id="assignment-expressions">
<span id="index-86"></span><h2><span class="section-number">6.12. </span>代入式<a class="headerlink" href="#assignment-expressions" title="Link to this heading">¶</a></h2>
<pre>
<strong id="grammar-token-python-grammar-assignment_expression">assignment_expression</strong> ::=  [<a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> &quot;:=&quot;] <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>An assignment expression (sometimes also called a &quot;named expression&quot; or
&quot;walrus&quot;) assigns an <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression</span></code></a> to an
<a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref std std-token docutils literal notranslate"><span class="pre">identifier</span></code></a>, while also returning the value of the
<a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression</span></code></a>.</p>
<p>One common use case is when handling matched regular expressions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">matching</span> <span class="o">:=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">(</span><span class="n">matching</span><span class="p">)</span>
</pre></div>
</div>
<p>Or, when processing a file stream in chunks:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">chunk</span> <span class="o">:=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">9000</span><span class="p">):</span>
    <span class="n">process</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
</pre></div>
</div>
<p>Assignment expressions must be surrounded by parentheses when
used as expression statements and when used as sub-expressions in
slicing, conditional, lambda,
keyword-argument, and comprehension-if expressions and
in <code class="docutils literal notranslate"><span class="pre">assert</span></code>, <code class="docutils literal notranslate"><span class="pre">with</span></code>, and <code class="docutils literal notranslate"><span class="pre">assignment</span></code> statements.
In all other places where they can be used, parentheses are not required,
including in <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">while</span></code> statements.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8: </span>代入式に関してより詳しくは <span class="target" id="index-119"></span><a class="pep reference external" href="https://peps.python.org/pep-0572/"><strong>PEP 572</strong></a> を参照してください。</p>
</div>
</section>
<section id="conditional-expressions">
<span id="if-expr"></span><h2><span class="section-number">6.13. </span>条件式 (Conditional Expressions)<a class="headerlink" href="#conditional-expressions" title="Link to this heading">¶</a></h2>
<pre id="index-88">
<strong id="grammar-token-python-grammar-conditional_expression">conditional_expression</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [&quot;if&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> &quot;else&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
<strong id="grammar-token-python-grammar-expression">expression            </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-conditional_expression"><code class="xref docutils literal notranslate"><span class="pre">conditional_expression</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-lambda_expr"><code class="xref docutils literal notranslate"><span class="pre">lambda_expr</span></code></a>
</pre>
<p>条件式 (しばしば &quot;三項演算子&quot; と呼ばれます) は最も優先度が低いPython の演算です。</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">if</span> <span class="pre">C</span> <span class="pre">else</span> <span class="pre">y</span></code> という式は最初に <em>x</em> ではなく条件 <em>C</em> を評価します。 <em>C</em> が true の場合 <em>x</em> が評価され値が返されます。 それ以外の場合には <em>y</em> が評価され返されます。</p>
<p>条件演算に関してより詳しくは <span class="target" id="index-120"></span><a class="pep reference external" href="https://peps.python.org/pep-0308/"><strong>PEP 308</strong></a> を参照してください。</p>
</section>
<section id="lambda">
<span id="lambdas"></span><span id="id14"></span><h2><span class="section-number">6.14. </span>ラムダ (lambda)<a class="headerlink" href="#lambda" title="Link to this heading">¶</a></h2>
<pre id="index-90">
<strong id="grammar-token-python-grammar-lambda_expr">lambda_expr</strong> ::=  &quot;lambda&quot; [<a class="reference internal" href="compound_stmts.html#grammar-token-python-grammar-parameter_list"><code class="xref docutils literal notranslate"><span class="pre">parameter_list</span></code></a>] &quot;:&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>ラムダ式 (ラムダ形式とも呼ばれます) は無名関数を作成するのに使います。
式 <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">parameters:</span> <span class="pre">expression</span></code> は関数オブジェクトになります。
この無名オブジェクトは以下に定義されている関数オブジェクト同様に動作します:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def &lt;lambda&gt;(parameters):
    return expression
</pre></div>
</div>
<p>引数の一覧の構文は <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">関数定義</span></a> を参照してください。ラムダ式で作成された関数は文やアノテーションを含むことができない点に注意してください。</p>
</section>
<section id="expression-lists">
<span id="exprlists"></span><h2><span class="section-number">6.15. </span>式のリスト<a class="headerlink" href="#expression-lists" title="Link to this heading">¶</a></h2>
<pre id="index-91">
<strong id="grammar-token-python-grammar-expression_list">expression_list   </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-starred_list">starred_list      </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-starred_expression">starred_expression</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | (<a class="reference internal" href="#grammar-token-python-grammar-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a> &quot;,&quot;)* [<a class="reference internal" href="#grammar-token-python-grammar-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a>]
<strong id="grammar-token-python-grammar-starred_item">starred_item      </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-assignment_expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> | &quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>
</pre>
<p id="index-92">リスト表示や辞書表示の一部になっているものを除き、少なくとも一つのカンマを含む式のリストはタプルになります。
タプルの長さは、リストにある式の数に等しくなります。
式は左から右へ評価されます。</p>
<p id="index-93">アスタリスク <code class="docutils literal notranslate"><span class="pre">*</span></code> は <em class="dfn">イテラブルのアンパック</em> を意味します。
この被演算子は <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">イテラブル</span></a> でなければなりません。
このイテラブルはアンパックされた位置で要素のシーケンスに展開され、新しいタプル、リスト、集合に入れ込まれます。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5: </span>式リストでのイテラブルのアンパックは最初に <span class="target" id="index-121"></span><a class="pep reference external" href="https://peps.python.org/pep-0448/"><strong>PEP 448</strong></a> で提案されました。</p>
</div>
<p id="index-95">A trailing comma is required only to create a one-item tuple,
such as <code class="docutils literal notranslate"><span class="pre">1,</span></code>; it is optional in all other cases.
A single expression without a
trailing comma doesn't create a tuple, but rather yields the value of that
expression. (To create an empty tuple, use an empty pair of parentheses:
<code class="docutils literal notranslate"><span class="pre">()</span></code>.)</p>
</section>
<section id="evaluation-order">
<span id="evalorder"></span><h2><span class="section-number">6.16. </span>評価順序<a class="headerlink" href="#evaluation-order" title="Link to this heading">¶</a></h2>
<p id="index-96">Python は、式を左から右へと順に評価します。
ただし、代入式を評価するときは、右辺が左辺よりも先に評価されます。</p>
<p>以下に示す実行文の各行での評価順序は、添え字の数字順序と同じになります:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span>
<span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span><span class="p">)</span>
<span class="p">{</span><span class="n">expr1</span><span class="p">:</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">:</span> <span class="n">expr4</span><span class="p">}</span>
<span class="n">expr1</span> <span class="o">+</span> <span class="n">expr2</span> <span class="o">*</span> <span class="p">(</span><span class="n">expr3</span> <span class="o">-</span> <span class="n">expr4</span><span class="p">)</span>
<span class="n">expr1</span><span class="p">(</span><span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="o">*</span><span class="n">expr4</span><span class="p">,</span> <span class="o">**</span><span class="n">expr5</span><span class="p">)</span>
<span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span> <span class="o">=</span> <span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span>
</pre></div>
</div>
</section>
<section id="operator-precedence">
<span id="operator-summary"></span><h2><span class="section-number">6.17. </span>演算子の優先順位<a class="headerlink" href="#operator-precedence" title="Link to this heading">¶</a></h2>
<p id="index-97">以下の表は Python における演算子の優先順位を要約したものです。優先順位の最も高い (結合が最も強い) ものから最も低い (結合が最も弱い) ものに並べてあります。同じボックス内の演算子の優先順位は同じです。構文が明示的に示されていないものは二項演算子です。同じボックス内の演算子は、左から右へとグループ化されます (例外として、べき乗および条件式は右から左にグループ化されます)。</p>
<p><a class="reference internal" href="#comparisons"><span class="std std-ref">比較</span></a> 節で述べられているように、比較、所属、同一性のテストは全てが同じ優先順位を持っていて、左から右に連鎖するという特徴を持っていることに注意してください。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>演算子</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">(expressions...)</span></code>,</p>
<p><code class="docutils literal notranslate"><span class="pre">[expressions...]</span></code>,
<code class="docutils literal notranslate"><span class="pre">{key:</span> <span class="pre">value...}</span></code>,
<code class="docutils literal notranslate"><span class="pre">{expressions...}</span></code></p>
</td>
<td><p>結合式または括弧式、リスト表示、辞書表示、集合表示</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">x[index]</span></code>, <code class="docutils literal notranslate"><span class="pre">x[index:index]</span></code>,
<code class="docutils literal notranslate"><span class="pre">x(arguments...)</span></code>, <code class="docutils literal notranslate"><span class="pre">x.attribute</span></code></p></td>
<td><p>添字指定、スライス操作、呼び出し、属性参照</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span> <span class="pre">x</span></code></a></p></td>
<td><p>Await 式</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">**</span></code></p></td>
<td><p>べき乗 <a class="footnote-reference brackets" href="#id21" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">+x</span></code>, <code class="docutils literal notranslate"><span class="pre">-x</span></code>, <code class="docutils literal notranslate"><span class="pre">~x</span></code></p></td>
<td><p>正数、負数、ビット単位 NOT</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code></p></td>
<td><p>乗算、行列乗算、除算、切り捨て除算、剰余 <a class="footnote-reference brackets" href="#id22" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td><p>加算および減算</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code></p></td>
<td><p>シフト演算</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&amp;</span></code></p></td>
<td><p>ビット単位 AND</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">^</span></code></p></td>
<td><p>ビット単位 XOR</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">|</span></code></p></td>
<td><p>ビット単位 OR</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a>, <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>,
<a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a>, <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></a>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
<td><p>所属や同一性のテストを含む比較</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span></code></a></p></td>
<td><p>ブール演算 NOT</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code></a></p></td>
<td><p>ブール演算 AND</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#or"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code></a></p></td>
<td><p>ブール演算 OR</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#if-expr"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> -- <code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></p></td>
<td><p>条件式</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a></p></td>
<td><p>ラムダ式</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">:=</span></code></p></td>
<td><p>代入式</p></td>
</tr>
</tbody>
</table>
<p class="rubric">脚注</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id17" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">1</a><span class="fn-bracket">]</span></span>
<p><code class="docutils literal notranslate"><span class="pre">abs(x%y)</span> <span class="pre">&lt;</span> <span class="pre">abs(y)</span></code> は数学的には真となりますが、浮動小数点に対する演算の場合には、値丸め (roundoff) のために数値計算的に真にならない場合があります。例えば、Python の浮動小数点型が IEEE754 倍精度数型になっているプラットフォームを仮定すると、 <code class="docutils literal notranslate"><span class="pre">-1e-100</span> <span class="pre">%</span> <span class="pre">1e100</span></code> は <code class="docutils literal notranslate"><span class="pre">1e100</span></code> と同じ符号になるはずなのに、計算結果は <code class="docutils literal notranslate"><span class="pre">-1e-100</span> <span class="pre">+</span> <span class="pre">1e100</span></code> となります。これは数値計算的には厳密に <code class="docutils literal notranslate"><span class="pre">1e100</span></code> と等価です。関数 <a class="reference internal" href="../library/math.html#math.fmod" title="math.fmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.fmod()</span></code></a> は、最初の引数と符号が一致するような値を返すので、上記の場合には <code class="docutils literal notranslate"><span class="pre">-1e-100</span></code> を返します。どちらのアプローチが適切かは、アプリケーションに依存します。</p>
</aside>
<aside class="footnote brackets" id="id18" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">2</a><span class="fn-bracket">]</span></span>
<p>x が y の正確な整数倍に非常に近いと、丸めのために <code class="docutils literal notranslate"><span class="pre">x//y</span></code> が <code class="docutils literal notranslate"><span class="pre">(x-x%y)//y</span></code> よりも 1 だけ大きくなる可能性があります。そのような場合、Python は <code class="docutils literal notranslate"><span class="pre">divmod(x,y)[0]</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code> が <code class="docutils literal notranslate"><span class="pre">x</span></code> に非常に近くなるという関係を保つために、後者の値を返します。</p>
</aside>
<aside class="footnote brackets" id="id19" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">3</a><span class="fn-bracket">]</span></span>
<p>Unicode 標準では、 <em class="dfn">コードポイント (code point)</em> (例えば、U+0041) と <em class="dfn">抽象文字 (abstract character)</em> (例えば、&quot;LATIN CAPITAL LETTER A&quot;) を区別します。
Unicode のほとんどの抽象文字は 1 つのコードポイントだけを使って表現されますが、複数のコードポイントの列を使っても表現できる抽象文字もたくさんあります。
例えば、抽象文字 &quot;LATIN CAPITAL LETTER C WITH CEDILLA&quot; はコード位置 U+00C7 にある <em class="dfn">合成済み文字 (precomposed character)</em> 1 つだけでも表現できますし、コード位置 U+0043 (LATIN CAPITAL LETTER C) にある <em class="dfn">基底文字 (base character)</em> の後ろに、コード位置 U+0327 (COMBINING CEDILLA) にある <em class="dfn">結合文字 (combining character)</em> が続く列としても表現できます。</p>
<p>文字列の比較操作は Unicode のコードポイントのレベルで行われます。
これは人間にとっては直感的ではないかもしれません。
例えば、 <code class="docutils literal notranslate"><span class="pre">&quot;\u00C7&quot;</span> <span class="pre">==</span> <span class="pre">&quot;\u0043\u0327&quot;</span></code> は、どちらの文字も同じ抽象文字 &quot;LATIN CAPITAL LETTER C WITH CEDILLA&quot; を表現しているにもかかわらず、その結果は <code class="docutils literal notranslate"><span class="pre">False</span></code> となります。</p>
<p>抽象文字のレベルで (つまり、人間にとって直感的な方法で) 文字列を比較するには <a class="reference internal" href="../library/unicodedata.html#unicodedata.normalize" title="unicodedata.normalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">unicodedata.normalize()</span></code></a> を使ってください。</p>
</aside>
<aside class="footnote brackets" id="id20" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">4</a><span class="fn-bracket">]</span></span>
<p>自動的なガベージコレクション、フリーリスト、ディスクリプタの動的特性のために、インスタンスメソッドや定数の比較を行うようなときに <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> 演算子の利用は、一見すると普通ではない振る舞いだと気付くかもしれません。詳細はそれぞれのドキュメントを確認してください。</p>
</aside>
<aside class="footnote brackets" id="id21" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">5</a><span class="fn-bracket">]</span></span>
<p>べき乗演算子 <code class="docutils literal notranslate"><span class="pre">**</span></code> は、右側にある単項算術演算子あるいは単項ビット演算子より弱い結合優先順位となります。
つまり <code class="docutils literal notranslate"><span class="pre">2**-1</span></code> は <code class="docutils literal notranslate"><span class="pre">0.5</span></code> になります。</p>
</aside>
<aside class="footnote brackets" id="id22" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id16">6</a><span class="fn-bracket">]</span></span>
<p><code class="docutils literal notranslate"><span class="pre">%</span></code> 演算子は文字列フォーマットにも使われ、同じ優先順位が当てはまります。</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="#">6. 式 (expression)</a><ul>
<li><a class="reference internal" href="#arithmetic-conversions">6.1. 算術変換 (arithmetic conversion)</a></li>
<li><a class="reference internal" href="#atoms">6.2. アトム、原子的要素 (atom)</a><ul>
<li><a class="reference internal" href="#atom-identifiers">6.2.1. 識別子 (identifier、または名前 (name))</a></li>
<li><a class="reference internal" href="#literals">6.2.2. リテラル</a></li>
<li><a class="reference internal" href="#parenthesized-forms">6.2.3. 丸括弧形式 (parenthesized form)</a></li>
<li><a class="reference internal" href="#displays-for-lists-sets-and-dictionaries">6.2.4. リスト、集合、辞書の表示</a></li>
<li><a class="reference internal" href="#list-displays">6.2.5. リスト表示</a></li>
<li><a class="reference internal" href="#set-displays">6.2.6. 集合表示</a></li>
<li><a class="reference internal" href="#dictionary-displays">6.2.7. 辞書表示</a></li>
<li><a class="reference internal" href="#generator-expressions">6.2.8. ジェネレータ式</a></li>
<li><a class="reference internal" href="#yield-expressions">6.2.9. Yield 式</a><ul>
<li><a class="reference internal" href="#generator-iterator-methods">6.2.9.1. ジェネレータ-イテレータメソッド</a></li>
<li><a class="reference internal" href="#examples">6.2.9.2. 使用例</a></li>
<li><a class="reference internal" href="#asynchronous-generator-functions">6.2.9.3. 非同期ジェネレータ関数 (asynchronous generator function)</a></li>
<li><a class="reference internal" href="#asynchronous-generator-iterator-methods">6.2.9.4. 非同期ジェネレータイテレータメソッド</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#primaries">6.3. プライマリ</a><ul>
<li><a class="reference internal" href="#attribute-references">6.3.1. 属性参照</a></li>
<li><a class="reference internal" href="#subscriptions">6.3.2. 添字表記 (subscription)</a></li>
<li><a class="reference internal" href="#slicings">6.3.3. スライス表記 (slicing)</a></li>
<li><a class="reference internal" href="#calls">6.3.4. 呼び出し (call)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#await-expression">6.4. Await 式</a></li>
<li><a class="reference internal" href="#the-power-operator">6.5. べき乗演算 (power operator)</a></li>
<li><a class="reference internal" href="#unary-arithmetic-and-bitwise-operations">6.6. 単項算術演算とビット単位演算 (unary arithmetic and bitwise operation)</a></li>
<li><a class="reference internal" href="#binary-arithmetic-operations">6.7. 二項算術演算 (binary arithmetic operation)</a></li>
<li><a class="reference internal" href="#shifting-operations">6.8. シフト演算 (shifting operation)</a></li>
<li><a class="reference internal" href="#binary-bitwise-operations">6.9. ビット単位演算の二項演算 (binary bitwise operation)</a></li>
<li><a class="reference internal" href="#comparisons">6.10. 比較</a><ul>
<li><a class="reference internal" href="#value-comparisons">6.10.1. 値の比較</a></li>
<li><a class="reference internal" href="#membership-test-operations">6.10.2. 所属検査演算</a></li>
<li><a class="reference internal" href="#is-not">6.10.3. 同一性の比較</a></li>
</ul>
</li>
<li><a class="reference internal" href="#boolean-operations">6.11. ブール演算 (boolean operation)</a></li>
<li><a class="reference internal" href="#assignment-expressions">6.12. 代入式</a></li>
<li><a class="reference internal" href="#conditional-expressions">6.13. 条件式 (Conditional Expressions)</a></li>
<li><a class="reference internal" href="#lambda">6.14. ラムダ (lambda)</a></li>
<li><a class="reference internal" href="#expression-lists">6.15. 式のリスト</a></li>
<li><a class="reference internal" href="#evaluation-order">6.16. 評価順序</a></li>
<li><a class="reference internal" href="#operator-precedence">6.17. 演算子の優先順位</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="import.html"
                          title="前の章へ"><span class="section-number">5. </span>インポートシステム</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="simple_stmts.html"
                          title="次の章へ"><span class="section-number">7. </span>単純文 (simple statement)</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">バグ報告</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/expressions.rst"
            rel="nofollow">ソースの表示
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="サイドバーをたたむ">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. 単純文 (simple statement)"
             >次へ</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. インポートシステム"
             >前へ</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.12.4 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 言語リファレンス</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">6. </span>式 (expression)</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="クイック検索" aria-label="クイック検索" type="search" name="q" id="search-box" />
          <input type="submit" value="検索" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    Copyright
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="/license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最終更新: Jun 11, 2024 (04:44 UTC)
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>

    <script type="text/javascript" src="../_static/switchers.js"></script>
  </body>
</html>